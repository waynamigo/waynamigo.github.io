<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>waynamigo&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://waynamigo.github.io/"/>
  <updated>2023-11-19T12:38:35.680Z</updated>
  <id>http://waynamigo.github.io/</id>
  
  <author>
    <name>waynamigo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务</title>
    <link href="http://waynamigo.github.io/2023/01/24/2023-01-04-%E9%9D%A2%E8%AF%95%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://waynamigo.github.io/2023/01/24/2023-01-04-面试微服务/</id>
    <published>2023-01-23T16:00:00.000Z</published>
    <updated>2023-11-19T12:38:35.680Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新</p><a id="more"></a><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><h2 id="概念性区分"><a href="#概念性区分" class="headerlink" title="概念性区分"></a>概念性区分</h2><p><strong>1.C和C++的区别</strong><br>C面向过程，C++面向对象<br>C的内存管理使用malloc free，C++还可以使用new delete<br>C不支持函数重载，C++支持函数重载<br>C没有引用，C++可以用引用<br><strong>堆和栈的区别</strong><br>stack编译器自动分配和释放，自底向上的数据结构<br>heap需要由程序员手动new delete，会产生外部碎片，是自上到下的数据结构<br><strong>c++中不能被继承的成员函数</strong><br>析构函数和构造函数<br><strong>const</strong><br>定义常量<br>修饰函数参数和函数返回值</p><h2 id="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"><a href="#修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值" class="headerlink" title="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"></a>修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值</h2><p>define给一个立即数，const是常量，放在静态区域，全局变量也在静态区域<br>静态区：static无论是全局变量还是局部变量都存储在全局/静态区域，在编译期就为其分配内存，在程序结束时释放<br>const的全局变量存储在只读数据段，第一次使用时被分配内存，结束时释放；const的局部变量存在栈中，代码块结束释放<br>define定义的常量不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址<br>–const优点<br>const 常量有数据类型，而宏常量没有数据类型。<br>编译器可以对前者进行类型安全检查，<br>后者只进行字符替换，没有类型安全检查，并且在字符替换可能报错。<br>[全局变量放在静态存储区，整个程序开始分配内存，结束释放]<br><strong>static</strong><br>static修饰的变量只能通过其所在文件、模块或函数进行调用，限制变量<br>static修饰的变量一开始就得初始化，并存放于静态内存区<br><strong>volatile</strong><br>本条指令不会因编译器的优化而省略，不会被编译器察觉（隐藏变量），且要求每次重新读取volatile修饰的变量的内容<br><strong>extern</strong></p><p><strong>指针和引用的区别</strong><br>引用本质是只读指针，引用只能在初始化时被赋值,且必须被初始化，之后不能改变，指针是动态的<br>引用不能为NULL，指针可以<br>引用做函数参数时，内部传递的是变量地址<br><strong>进程间通信</strong><br>pipe管道，半双工，用于父子进程通信<br>semaphore信号量，进程同步访问共享资源<br>message que 消息队列，克服了缓冲区限制<br>shared memory共享内存<br>socket<br><strong>线程间通信</strong><br>全局变量   Messages消息机制；<br>CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）</p><p>编译时运算符:sizeof</p><p><strong>写一个函数指针</strong><br><em>( ( void (</em>)() ) 0x100000) ( );<br>void(<em>)()强制转换0x100000<br>typedef void(</em>)() voidFunc;<br>*(  (voidFunc)0x100000 )();</p><p><strong>内存分配方式</strong></p><p>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</p><p>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://waynamigo.github.io/categories/Golang/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="微服务" scheme="http://waynamigo.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>一些算法整理</title>
    <link href="http://waynamigo.github.io/2023/01/24/2023-01-24-%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
    <id>http://waynamigo.github.io/2023/01/24/2023-01-24-面试算法/</id>
    <published>2023-01-23T16:00:00.000Z</published>
    <updated>2023-12-02T08:16:29.257Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新</p><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="三树之和"><a href="#三树之和" class="headerlink" title="三树之和"></a>三树之和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">if</span>(nums.size()&lt;<span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;<span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;nums.size()<span class="number">-2</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;        <span class="comment">//将这个if语句放这里提前终止循环</span></span><br><span class="line">        <span class="keyword">int</span> left = i+<span class="number">1</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 转换为long long避免加法过程中溢出</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> y = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(nums[i]);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> x = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(nums[left]);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> z = <span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(nums[right]);</span><br><span class="line">            <span class="keyword">if</span>(x + y &gt;<span class="number">0</span>-z)</span><br><span class="line">                right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x + y &lt;<span class="number">0</span>-z)</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                <span class="comment">// 相同的left和right不应该再次出现，因此跳过</span></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right] == nums[right<span class="number">-1</span>])</span><br><span class="line">                    right--;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 避免nums[i]作为第一个数重复出现</span></span><br><span class="line">        <span class="comment">// while(i+1&lt;nums.size()&amp;&amp;nums[i] == nums[i+1]) i++;</span></span><br><span class="line">        <span class="comment">// i++;</span></span><br><span class="line">        <span class="keyword">do</span>&#123;i++;&#125;<span class="keyword">while</span>(i+<span class="number">1</span>&lt;nums.size()&amp;&amp;nums[i<span class="number">-1</span>] == nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">int</span> num = nums[mid];</span><br><span class="line">        <span class="keyword">if</span> (num == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; cachelist;<span class="comment">//实际缓存列表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">decltype</span>(cachelist.begin())&gt; cache;</span><br><span class="line">    <span class="comment">//保存的缓存的迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"cend:"&lt;&lt;  -&gt;first;</span></span><br><span class="line">        <span class="comment">// 将缓存中的键值对移动到缓存列表的末尾，表示最近使用</span></span><br><span class="line">        cachelist.splice(cachelist.cend(), cachelist, cache[key]);</span><br><span class="line">        <span class="keyword">return</span> cache[key]-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.count(key))&#123;<span class="comment">//缓存列表里没有出现要进入的k</span></span><br><span class="line">            <span class="comment">//如果满了，就把最前删掉，然后加到链表尾</span></span><br><span class="line">            <span class="keyword">if</span>(cachelist.size()==capacity)&#123;</span><br><span class="line">                <span class="comment">// 移除最久未使用的键值对</span></span><br><span class="line">                cache.erase(cachelist.front().first); <span class="comment">// 从缓存映射中删除对应的键</span></span><br><span class="line">                cachelist.pop_front(); <span class="comment">// 从缓存列表中删除最前面的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            cache[key] = cachelist.emplace(cachelist.cend(),key,value);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//缓存列表里有这个新来的任务</span></span><br><span class="line">            <span class="comment">//根据key更新任务内容</span></span><br><span class="line">            cache[key]-&gt;second = value;</span><br><span class="line">            <span class="comment">//把这个迭代器插入队尾</span></span><br><span class="line">            cachelist.splice(cachelist.cend(),cachelist,cache[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="comment">// for(int i=0; i&lt;q.size() ;i++)&#123;</span></span><br><span class="line">            <span class="comment">//因为q在增加，可以先在外面int n =q.size()</span></span><br><span class="line">            <span class="comment">// 再for(int i=0; i&lt;n ;i++)&#123;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            root = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            tmp.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left) q.push(root-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right) q.push(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root==p || root==q)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* left = lowestCommonAncestor(root-&gt;left,p,q);</span><br><span class="line">    TreeNode* right = lowestCommonAncestor(root-&gt;right,p,q);</span><br><span class="line">    <span class="keyword">if</span>(!left)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!right)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left &amp;&amp; right)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树最大直径-dfs"><a href="#二叉树最大直径-dfs" class="headerlink" title="二叉树最大直径 dfs"></a>二叉树最大直径 dfs</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = depth(root-&gt;left,res);</span><br><span class="line">        <span class="keyword">int</span> r = depth(root-&gt;right,res);</span><br><span class="line">        res = max(res, l+ r );</span><br><span class="line">        <span class="keyword">return</span> max(l,r)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        depth(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归左右子树</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树第k小的元素【没懂，记住了】"><a href="#二叉搜索树第k小的元素【没懂，记住了】" class="headerlink" title="二叉搜索树第k小的元素【没懂，记住了】"></a>二叉搜索树第k小的元素【没懂，记住了】</h2><p>迭代方法，在找到答案后停止，不需要遍历整棵树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode* &gt; nodes;</span><br><span class="line">        <span class="keyword">while</span>(root &amp;&amp; nodes.size() &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root); <span class="comment">//左子树一直进栈</span></span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断树a是否是b的子树"><a href="#判断树a是否是b的子树" class="headerlink" title="判断树a是否是b的子树"></a>判断树a是否是b的子树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) :</span><br><span class="line">        val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1 == <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1-&gt;val != pRoot2-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtree(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; isSubtree(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1-&gt;val == pRoot2-&gt;val) &#123;</span><br><span class="line">            result = isSubtree(pRoot1, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;left, pRoot2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next =pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* newnode=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//必须要</span></span><br><span class="line">        newnode -&gt;next = head;</span><br><span class="line">        ListNode* pre = newnode;</span><br><span class="line">        <span class="comment">//先找需要翻转的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;left<span class="number">-1</span> ;i++)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next =next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哈希表</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;ListNode*,<span class="keyword">int</span>&gt;mp;</span><br><span class="line">        ListNode* cur1=headA;</span><br><span class="line">        <span class="keyword">while</span>(cur1)&#123;</span><br><span class="line">            mp[cur1]++;</span><br><span class="line">            cur1=cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur2=headB;</span><br><span class="line">        <span class="keyword">while</span>(cur2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[cur2]) <span class="keyword">return</span> cur2;</span><br><span class="line">            cur2=cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="无重复的最长子串-无重复字符的最长子串"><a href="#无重复的最长子串-无重复字符的最长子串" class="headerlink" title="无重复的最长子串/无重复字符的最长子串"></a>无重复的最长子串/无重复字符的最长子串</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; appears;<span class="comment">// 判断是否重复</span></span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>,len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left =<span class="number">0</span> ;left &lt;len;left++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left!=<span class="number">0</span>)&#123; <span class="comment">// 只要下面的循环扫描一遍，就会来这里left++</span></span><br><span class="line">            <span class="comment">//说明往右移走了一位，最左边字母删掉</span></span><br><span class="line">                appears.erase(s[left<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; len &amp;&amp; !appears.count(s[pos]))&#123;</span><br><span class="line">                appears.insert(s[pos]);</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res,pos - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断s中是否有字符串st的排列"><a href="#判断s中是否有字符串st的排列" class="headerlink" title="判断s中是否有字符串st的排列"></a>判断s中是否有字符串st的排列</h2><p><a href="https://leetcode.cn/problems/permutation-in-string/" target="_blank" rel="noopener">https://leetcode.cn/problems/permutation-in-string/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s1.length(), m = s2.length();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt[s1[i] - <span class="string">'a'</span>] -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; m; ++right) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = s2[right] - <span class="string">'a'</span>;</span><br><span class="line">        cnt[x]++;</span><br><span class="line">        <span class="keyword">while</span> (cnt[x] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cnt[s2[left] - <span class="string">'a'</span>] --;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="comment">//O(n^2)</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[n];<span class="comment">//dp[i]定义为num数组前i个里面最长的上升子序列长度</span></span><br><span class="line">    <span class="comment">// memset(dp,0,sizeof(dp));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//比较i前所有的数，</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span> &gt; dp[i] ? dp[j]+<span class="number">1</span> :dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans &gt; dp[i]? ans:dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="comment">//O(nlog2n) 抄的评论区</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数.</span></span><br><span class="line"><span class="comment">    由定义知dp数组必然是一个递增数组, 可以用 maxL 来表示最长递增子序列的长度. </span></span><br><span class="line"><span class="comment">    对数组进行迭代, 依次判断每个数num将其插入dp数组相应的位置:</span></span><br><span class="line"><span class="comment">    1. num &gt; dp[maxL], 表示num比所有已知递增序列的尾数都大, 将num添加入dp</span></span><br><span class="line"><span class="comment">        数组尾部, 并将最长递增序列长度maxL加1</span></span><br><span class="line"><span class="comment">    2. dp[i-1] &lt; num &lt;= dp[i], 只更新相应的dp[i]</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> dp[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 二分法查找, 也可以调用库函数如binary_search</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = maxL;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[mid] &lt; num)</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[low] = num;</span><br><span class="line">        <span class="keyword">if</span>(low == maxL)</span><br><span class="line">            maxL++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.size(),n=text2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i]==text2[j])&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=max(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最大子数组-子序和"><a href="#最大子数组-子序和" class="headerlink" title="最大子数组/子序和"></a>最大子数组/子序和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> dp[n];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxn = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        dp[i]=max(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">        maxn = max(maxn,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), m = B.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[i][j] = A[i] == B[j] ? dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                ans = max(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍【有限制的dp】"><a href="#打家劫舍【有限制的dp】" class="headerlink" title="打家劫舍【有限制的dp】"></a>打家劫舍【有限制的dp】</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="comment">//dp[i] =max(dp[i-1]跳过这间，dp[i-2]+nums[i])</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n ;i++)&#123;</span><br><span class="line">            dp[i]=max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>],dp[n<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="第K个最大元素"><a href="#第K个最大元素" class="headerlink" title="第K个最大元素"></a>第K个最大元素</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickselect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        <span class="keyword">int</span> partition = nums[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &lt; partition);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &gt; partition);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= j)<span class="keyword">return</span> quickselect(nums, l, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickselect(nums, j + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">return</span> quickselect(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    merge_sort(nums, left, mid);</span><br><span class="line">    merge_sort(nums, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">//递归调用完成后，[left,mid]和[mid+1,right]两个区间已经有序(升序)</span></span><br><span class="line">    <span class="keyword">int</span> i = left;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//如果 nums[i] &lt;= nums[j]那么就将nums[i]放入temp中，然后i++</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i]&lt;=nums[j])&#123;</span><br><span class="line">            temp[count] = nums[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            temp[count] = nums[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">        temp[count++] = nums[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">        temp[count++] = nums[j++];</span><br><span class="line">    <span class="keyword">int</span> interval_length = right-left+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;interval_length; i++)</span><br><span class="line">        nums[i+left]=temp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快排-快速排序"><a href="#快排-快速排序" class="headerlink" title="快排/快速排序"></a>快排/快速排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> l = startIndex, r = endIndex;</span><br><span class="line">        <span class="keyword">int</span> pivot = rand() % (endIndex - startIndex + <span class="number">1</span>) + startIndex; <span class="comment">// 基于随机的原则</span></span><br><span class="line">        <span class="keyword">int</span> pivotnum = nums[pivot];</span><br><span class="line">        swap(nums[startIndex], nums[pivot]);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 从后往前走，将比第一个小的移到前面</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &gt;= pivotnum) r--;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从前往后走，将比第一个大的移到后面</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &lt;= pivotnum) l++;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                nums[r] = nums[l];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = pivotnum; </span><br><span class="line">        <span class="comment">// 自顶向下</span></span><br><span class="line">        quickSort(nums, startIndex, l - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, l + <span class="number">1</span>, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="归并-1"><a href="#归并-1" class="headerlink" title="归并"></a>归并</h2><h2 id="LRU-1"><a href="#LRU-1" class="headerlink" title="LRU"></a>LRU</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; cachelist;<span class="comment">//实际缓存列表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">decltype</span>(cachelist.begin())&gt; cache;</span><br><span class="line">    <span class="comment">//保存的缓存的迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"cend:"&lt;&lt;  -&gt;first;</span></span><br><span class="line">        <span class="comment">// 将缓存中的键值对移动到缓存列表的末尾，表示最近使用</span></span><br><span class="line">        cachelist.splice(cachelist.cend(), cachelist, cache[key]);</span><br><span class="line">        <span class="keyword">return</span> cache[key]-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.count(key))&#123;<span class="comment">//缓存列表里没有出现要进入的k</span></span><br><span class="line">            <span class="comment">//如果满了，就把最前删掉，然后加到链表尾</span></span><br><span class="line">            <span class="keyword">if</span>(cachelist.size()==capacity)&#123;</span><br><span class="line">                <span class="comment">// 移除最久未使用的键值对</span></span><br><span class="line">                cache.erase(cachelist.front().first); </span><br><span class="line">                <span class="comment">// 从缓存映射中删除对应的键</span></span><br><span class="line">                cachelist.pop_front(); <span class="comment">// 从缓存列表中删除最前面的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            cache[key] = cachelist.emplace(cachelist.cend(),key,value);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//缓存列表里有这个新来的任务</span></span><br><span class="line">            <span class="comment">//根据key更新任务内容</span></span><br><span class="line">            cache[key]-&gt;second = value;</span><br><span class="line">            <span class="comment">//把这个迭代器插入队尾</span></span><br><span class="line">            cachelist.splice(cachelist.cend(),cachelist,cache[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visited(nums.size(),<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;perm;</span><br><span class="line">        dfs(ans,nums,visited,perm);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; perm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==perm.size())&#123;</span><br><span class="line">            ans.push_back(perm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                perm.push_back(nums[i]);</span><br><span class="line">                visited[i]=<span class="literal">true</span>;</span><br><span class="line">                dfs(ans,nums,visited,perm);</span><br><span class="line">                perm.pop_back();</span><br><span class="line">                visited[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="岛屿周长"><a href="#岛屿周长" class="headerlink" title="岛屿周长"></a>岛屿周长</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">islandPerimeter</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="keyword">int</span> </span>&#123;</span><br><span class="line">var land, border <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; len(grid); i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; len(grid[<span class="number">0</span>]); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> grid[i][j] == <span class="number">1</span> &#123;</span><br><span class="line">land++</span><br><span class="line"><span class="keyword">if</span> i &lt; len(grid)<span class="number">-1</span> &amp;&amp; grid[i+<span class="number">1</span>][j] == <span class="number">1</span> &#123;</span><br><span class="line">border++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> j &lt; len(grid[<span class="number">0</span>])<span class="number">-1</span> &amp;&amp; grid[i][j+<span class="number">1</span>] == <span class="number">1</span> &#123;</span><br><span class="line">border++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>*land - <span class="number">2</span>*border</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://waynamigo.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Leetcode" scheme="http://waynamigo.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>生产场景问题</title>
    <link href="http://waynamigo.github.io/2023/01/11/2023-01-11-%E9%9D%A2%E7%BB%8F%E5%9C%BA%E6%99%AF-mysql-redis-%E5%B9%B6%E5%8F%91/"/>
    <id>http://waynamigo.github.io/2023/01/11/2023-01-11-面经场景-mysql-redis-并发/</id>
    <published>2023-01-10T16:00:00.000Z</published>
    <updated>2023-12-01T13:21:38.231Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844904003998842887" target="_blank" rel="noopener">https://juejin.cn/post/6844904003998842887</a></p><a id="more"></a><h2 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a>分布式锁的实现</h2><p><a href="https://juejin.cn/post/7041375517580689439" target="_blank" rel="noopener">https://juejin.cn/post/7041375517580689439</a><br>etcd实现分布式锁</p><h2 id="CICD的区别"><a href="#CICD的区别" class="headerlink" title="CICD的区别"></a>CICD的区别</h2><p><a href="https://zhuanlan.zhihu.com/p/103554905" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/103554905</a></p><ul><li><p><strong>持续集成</strong>是对仓库每次更新完就跟进测试，每次提交远程仓库时，CI工具都会重建分支，并运行所有相关的测试用例，以验证新更改不会破坏现有应用程序的运行。然而要实施持续集成，必须满足一些先决条件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">条件如下</span><br><span class="line">为了使应用程序做好持续集成的准备，需要事先采取一些措施。最显而易见的是如果没有构建系统或测试要运行，则无法构建和测试应用程序。尽管看起来可能要花费额外的精力（特别是在代码没有进行过任何测试的情况下），持续集成可以带来很多好处。例如，自动化单元和集成测试能够在 bug 进入生产环境之前就捕获它们，这样一来更少的 bug 会被交付到生产中。事实上，防止一个潜在 bug 进入生产阶段的有效措施就是用一个测试用例覆盖它们，以确保它们不会导致产品回滚。除此之外，由于持续集成可以在短短几分钟内运行数百个测试用例，花费在手动测试上的时间也将大大减少，这意味着测试人员可以专注于更重要的改进而不是耗费大量精力在反复测试现有功能上。</span><br><span class="line"></span><br><span class="line">为了进一步开发和拓展持续集成机制以实现更高的自动化程度，我们引进了持续交付这一理念。</span><br></pre></td></tr></table></figure></li><li><p><strong>持续交付</strong><br>每次代码更改通过测试时都要对其进行重新部署。把构建和测试，发布三阶段自动化了，运维人员只要点一下按钮就可以部署应用程序。</p></li><li><p><strong>持续部署</strong><br>部署则建立在交付之上。与持续交付相比，持续部署自动将代码更改部署到生产中而无需人工干预。这也意味着为了避免出现回滚和其他问题，您的测试包必须是一流的，因为它决定了您的发布过程。</p></li></ul><p>项目团队将获取更快的部署速度，因为每项更改都可以进行自动处理，代码合并后几分钟就能够在生产环境中看到本地开发的功能；另一方面，代码发布的风险也能够进一步降低，因为您应该尽可能进行小批量部署，所以比较合适的场景是微服务和serverless场景。</p><h2 id="serverless-和微服务的区别"><a href="#serverless-和微服务的区别" class="headerlink" title="serverless 和微服务的区别"></a>serverless 和微服务的区别</h2><ul><li>视频处理的后端系统，常见功能需求如下：视频转码、抽取数据、人脸识别等，这些均为通用计算任务，可由函数计算执行。<br><a href="https://developer.aliyun.com/article/80521" target="_blank" rel="noopener">aliyun serverless的场景</a></li></ul><h2 id="merge-和-rebase-的区别【合并方式和历史记录，冲突解决方式】"><a href="#merge-和-rebase-的区别【合并方式和历史记录，冲突解决方式】" class="headerlink" title="merge 和 rebase 的区别【合并方式和历史记录，冲突解决方式】"></a>merge 和 rebase 的区别【合并方式和历史记录，冲突解决方式】</h2><p><strong>git merge：</strong></p><ul><li>将目标分支的最新提交合并到当前分支，创建一个新的合并提交，保留了分支的历史记录。</li><li>合并后会产生一个新的合并提交，记录了分支的合并操作。</li><li>适合公共分支的合并</li></ul><p><strong>git rebase：</strong></p><ul><li>将当前分支的提交“移动”到目标分支的最新提交之后，使得分支历史看起来更线性。</li><li>实际上是将当前分支的提交重新应用在目标分支的最新提交之后，形成一系列新的提交。</li><li>适合本地工作分支的合并</li><li>然后rebase 合并一些提交记录<br>git merge：<br>保留了分支的整个历史记录，可以清晰地看到分支的合并过程。<br>git rebase：<br>使得分支历史看起来更加线性，但也会丢失了分支的原始历史记录。<h2 id="pull-和fetch的区别"><a href="#pull-和fetch的区别" class="headerlink" title="pull 和fetch的区别"></a>pull 和fetch的区别</h2></li><li>fetch拉取最新代码，本身不会产生冲突，origin/branch1 会覆盖掉本底的暂存branch1</li><li>pull = fetch + merge，会产生冲突</li></ul><h2 id="stash的使用【在merge之前，把本地stash起来，或者当前版本需要临时存到一个分支里】"><a href="#stash的使用【在merge之前，把本地stash起来，或者当前版本需要临时存到一个分支里】" class="headerlink" title="stash的使用【在merge之前，把本地stash起来，或者当前版本需要临时存到一个分支里】"></a>stash的使用【在merge之前，把本地stash起来，或者当前版本需要临时存到一个分支里】</h2><h2 id="git-rm的使用"><a href="#git-rm的使用" class="headerlink" title="git rm的使用"></a>git rm的使用</h2><ol><li>git rm file 删除暂存区和源文件</li><li>git rm –cached file 删除暂存区文件</li><li>git reset file 删除暂存区文件</li><li>git restore –staged file 删除暂存区文件</li></ol><h2 id="强制切换分支，并丢弃当前内容"><a href="#强制切换分支，并丢弃当前内容" class="headerlink" title="强制切换分支，并丢弃当前内容"></a>强制切换分支，并丢弃当前内容</h2><p>checkout -f branchname</p><h2 id="切换到-某个提交-log查看提交hash，checkout过来"><a href="#切换到-某个提交-log查看提交hash，checkout过来" class="headerlink" title="切换到 某个提交 log查看提交hash，checkout过来"></a>切换到 某个提交 log查看提交hash，checkout过来</h2><h2 id="撤销一个commit"><a href="#撤销一个commit" class="headerlink" title="撤销一个commit"></a>撤销一个commit</h2><ol><li>保留历史，丢弃提交<br>git reset HEAD^</li><li>完全丢弃<br>git reset –hard HEAD^<br>git revert <cmmit_sha>,这会创建一个新的提交来撤销特定的提交，保留了提交历史。</cmmit_sha></li></ol><p>如果你已经push，不推荐使用 git reset，因为它会改变历史记录，可能会影响其他开发者。<br>git revert 会创建一个新的提交，用于撤销指定的提交，这样可以保持提交历史的完整性。</p><h2 id="git-checkout-和reset-到指定版本"><a href="#git-checkout-和reset-到指定版本" class="headerlink" title="git checkout 和reset 到指定版本"></a>git checkout 和reset 到指定版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. checkout作用：</span><br><span class="line">主要用于切换分支、切换到某个特定的提交、或者查看历史版本的内容。</span><br><span class="line">影响：</span><br><span class="line">切换分支或切换到特定提交时，会将工作目录和暂存区的状态更新为目标分支或提交的状态。如果是切换到特定提交，会处于“分离头指针”状态。</span><br><span class="line">回滚版本：</span><br><span class="line">不能用 git checkout 直接回滚到以前的版本。如果你只是想查看以前的版本，可以使用 git checkout &lt;commit_sha&gt; 来切换到特定提交。</span><br><span class="line">1.  reset作用：</span><br><span class="line">用于重置当前分支的 HEAD 指针，可以将分支回退到以前的提交。</span><br><span class="line">影响：</span><br><span class="line">可以影响工作目录、暂存区和分支的状态，具体取决于使用的选项：</span><br><span class="line">--soft：保留工作目录和暂存区，只重置 HEAD 指针。</span><br><span class="line">--mixed（默认选项）：重置 HEAD 指针和暂存区，但保留工作目录。</span><br><span class="line">--hard：重置 HEAD 指针、暂存区和工作目录，丢弃所有本地的更改。</span><br><span class="line">回滚版本：</span><br><span class="line">可以用 git reset 回滚到以前的版本。例如，可以使用 git reset HEAD^ 将分支回滚到前一个提交。</span><br><span class="line">总结：</span><br><span class="line">如果你只是想查看以前的版本，可以使用 git checkout。</span><br><span class="line">如果你想回滚到以前的版本，可以使用 git reset，但要注意谨慎使用，因为它会影响工作目录、暂存区和分支的状态，并且在共享分支上可能会影响其他开发者。</span><br></pre></td></tr></table></figure><h2 id="github和gitlab的区别"><a href="#github和gitlab的区别" class="headerlink" title="github和gitlab的区别"></a>github和gitlab的区别</h2><h2 id="持续集成和持续部署的区别是什么，"><a href="#持续集成和持续部署的区别是什么，" class="headerlink" title="持续集成和持续部署的区别是什么，"></a>持续集成和持续部署的区别是什么，</h2><p>持续集成（CI）注重的是团队成员之间的协作与代码的频繁集成。通过自动化的构建和测试流程，保证了每次提交的代码都能够顺利地融入共享代码库，从而快速发现并解决潜在的集成问题，使团队能够保持稳步前进。</p><p>而持续部署（CD）则是在持续集成的基础上，将通过CI验证的代码自动地部署到目标环境，实现了软件交付的高效、可靠，甚至是自动化。这使得开发团队能够以更迅速的速度向生产环境中推送稳定可靠的软件，为项目的成功交付提供了坚实保障。</p><h2 id="慢SQL问题如何排查"><a href="#慢SQL问题如何排查" class="headerlink" title="慢SQL问题如何排查"></a>慢SQL问题如何排查</h2><p>如果你的数据库查询变慢了，可以采取以下步骤来找出问题并解决它：</p><ol><li><strong>找出慢查询</strong>：首先，找出哪些数据库查询很慢。通常，这些查询会花费很长时间才能返回结果。</li><li><strong>检查查询计划</strong>：查看慢查询的执行计划，看看数据库是如何执行这些查询的。这可以帮助你找到性能瓶颈。</li><li><strong>考虑索引</strong>：确保查询使用了适当的索引。有时候，缺少或错误使用索引会导致查询变慢。</li><li><strong>优化SQL</strong>：审查慢查询的SQL语句，看看是否可以通过改写查询或者使用更有效的SQL来提高性能。</li><li><strong>检查数据库服务器</strong>：确保数据库服务器有足够的资源来处理查询。不足的CPU、内存或磁盘IO可能会导致性能问题。</li><li><strong>连接池</strong>：如果你在应用程序中使用了数据库连接池，确保连接池的配置正确。连接池的设置也可能影响性能。</li><li><strong>数据库统计信息</strong>：查看数据库的统计信息，了解表的大小、索引情况和数据分布。这些信息可以指导你哪些地方需要优化。</li><li><strong>查询缓存</strong>：考虑使用查询缓存，将经常执行的查询结果缓存起来，以减轻数据库负担。</li><li><strong>分页查询优化</strong>：如果涉及到分页查询，确保使用了有效的分页查询方式，避免一次性获取大量数据。</li><li><strong>监控和性能测试</strong>：建立监控系统，随时监测数据库性能。进行性能测试，模拟高负载情况，确保数据库在压力下能够正常工作。</li></ol><h2 id="explain的字段有哪些【主要看-type-key-rows-extra】底层是查询优化器实现的，"><a href="#explain的字段有哪些【主要看-type-key-rows-extra】底层是查询优化器实现的，" class="headerlink" title="explain的字段有哪些【主要看 type key rows extra】底层是查询优化器实现的，"></a>explain的字段有哪些【主要看 type key rows extra】底层是查询优化器实现的，</h2><ul><li><p>id    查询序号</p></li><li><p>select_type    查询类型</p></li><li><p>table    表名</p></li><li><p>partitions    匹配的分区</p></li><li><p><strong>type(主要)</strong>    查询使用了什么类型，是index还是全表扫描，同时用了index还会在extra里显示using index</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system --&gt; const --&gt; eq_ref --&gt; ref --&gt; fulltext --&gt; ref_or_null --&gt; index_merge --&gt; unique_subquery --&gt; index_subquery --&gt; range --&gt; index --&gt; ALL</span><br></pre></td></tr></table></figure></li><li><p>prossible_keys    可能会选择的索引</p></li><li><p><strong>key（主要）</strong>    实际选择的索引</p></li><li><p>key_len    索引的长度</p></li><li><p>ref    与索引作比较的列</p></li><li><p><strong>rows（主要）</strong>    要检索的行数(估算值)</p></li><li><p>filtered    查询条件过滤的行数的百分比</p></li><li><p><strong>Extra（主要）</strong>    额外信息，dictinct，using index，using filesort，using temporary，最好是using index，filesort和tmp都可能导致性能下降</p></li></ul><h3 id="select-type有哪些"><a href="#select-type有哪些" class="headerlink" title="select type有哪些"></a>select type有哪些</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE简单SELECT(不使用UNION或子查询)</span><br><span class="line">PRIMARY最外层的SELECT</span><br><span class="line">UNIONUNION中第二个或之后的SELECT语句</span><br><span class="line">DEPENDENT UNIONUNION中第二个或之后的SELECT语句取决于外面的查询</span><br><span class="line">UNION RESULTUNION的结果</span><br><span class="line">SUBQUERY子查询中的第一个SELECT</span><br><span class="line">DEPENDENT SUBQUERY子查询中的第一个SELECT, 取决于外面的查询</span><br><span class="line">DERIVED衍生表(FROM子句中的子查询)</span><br><span class="line">MATERIALIZED物化子查询</span><br><span class="line">UNCACHEABLE SUBQUERY结果集无法缓存的子查询，必须重新评估外部查询的每一行</span><br><span class="line">UNCACHEABLE UNIONUNION中第二个或之后的SELECT，属于无法缓存的子查询</span><br></pre></td></tr></table></figure><p>type的详细内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引。</span><br><span class="line"></span><br><span class="line">1、system</span><br><span class="line"></span><br><span class="line">表中只有一行数据或者是空表，这是const类型的一个特例。且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index</span><br><span class="line"></span><br><span class="line">2、const</span><br><span class="line"></span><br><span class="line">最多只有一行记录匹配。当联合主键或唯一索引的所有字段跟常量值比较时，join类型为const。其他数据库也叫做唯一索引扫描</span><br><span class="line"></span><br><span class="line">3、eq_ref</span><br><span class="line"></span><br><span class="line">多表join时，对于来自前面表的每一行，在当前表中只能找到一行。这可能是除了system和const之外最好的类型。当主键或唯一非NULL索引的所有字段都被用作join联接时会使用此类型。</span><br><span class="line"></span><br><span class="line">eq_ref可用于使用&apos;=&apos;操作符作比较的索引列。比较的值可以是常量，也可以是使用在此表之前读取的表的列的表达式。</span><br><span class="line"></span><br><span class="line">相对于下面的ref区别就是它使用的唯一索引，即主键或唯一索引，而ref使用的是非唯一索引或者普通索引。</span><br><span class="line">eq_ref只能找到一行，而ref能找到多行。</span><br><span class="line">4、ref</span><br><span class="line"></span><br><span class="line">对于来自前面表的每一行，在此表的索引中可以匹配到多行。若联接只用到索引的最左前缀或索引不是主键或唯一索引时，使用ref类型（也就是说，此联接能够匹配多行记录）。</span><br><span class="line"></span><br><span class="line">ref可用于使用&apos;=&apos;或&apos;&lt;=&gt;&apos;操作符作比较的索引列。</span><br><span class="line"></span><br><span class="line">5、 fulltext</span><br><span class="line"></span><br><span class="line">使用全文索引的时候是这个类型。要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引</span><br><span class="line"></span><br><span class="line">6、ref_or_null</span><br><span class="line"></span><br><span class="line">跟ref类型类似，只是增加了null值的比较。实际用的不多。</span><br><span class="line"></span><br><span class="line">eg.</span><br><span class="line">SELECT * FROM ref_table</span><br><span class="line">WHERE key_column=expr OR key_column IS NULL;</span><br><span class="line">7、index_merge</span><br><span class="line"></span><br><span class="line">表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取多个索引，性能可能大部分时间都不如range</span><br><span class="line"></span><br><span class="line">8、unique_subquery</span><br><span class="line"></span><br><span class="line">用于where中的in形式子查询，子查询返回不重复值唯一值，可以完全替换子查询，效率更高。</span><br><span class="line">该类型替换了下面形式的IN子查询的ref：</span><br><span class="line">value IN (SELECT primary_key FROM single_table WHERE some_expr)</span><br><span class="line"></span><br><span class="line">9、index_subquery</span><br><span class="line"></span><br><span class="line">该联接类型类似于unique_subquery。适用于非唯一索引，可以返回重复值。</span><br><span class="line"></span><br><span class="line">10、range</span><br><span class="line"></span><br><span class="line">索引范围查询，常见于使用 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN()或者like等运算符的查询中。</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE key_column BETWEEN 10 and 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tbl_name</span><br><span class="line">  WHERE key_column IN (10,20,30);</span><br><span class="line">11、index</span><br><span class="line"></span><br><span class="line">索引全表扫描，把索引从头到尾扫一遍。这里包含两种情况：</span><br><span class="line">一种是查询使用了覆盖索引，那么它只需要扫描索引就可以获得数据，这个效率要比全表扫描要快，因为索引通常比数据表小，而且还能避免二次查询。在extra中显示Using index，反之，如果在索引上进行全表扫描，没有Using index的提示。</span><br></pre></td></tr></table></figure><h2 id="SQL的优化方式有哪些，优化方式可能根据业务"><a href="#SQL的优化方式有哪些，优化方式可能根据业务" class="headerlink" title="SQL的优化方式有哪些，优化方式可能根据业务"></a>SQL的优化方式有哪些，优化方式可能根据业务</h2><ol><li><strong>索引</strong>，在where或者需要orderby的字段使用索引，来避免扫全表</li><li>Union创建临时表，或者创建view在业务中临时使用</li><li>创建联合索引</li><li>还有网上说的是join代替嵌套子查询，但是分布式，微服务场景下查的时候，可能就有些分库分表场景下的优化方式就不好说了</li><li>常用的方法是用索引单表查完之后在业务里做filter，merge之类的操作</li><li>如果仅用join，有俩原则，一个是小表驱动大表去连接，另外是on的字段要建上个索引；如果还是出现瓶颈的话，就调大join的buffersize</li></ol><h2 id="join-buffer的底层"><a href="#join-buffer的底层" class="headerlink" title="join buffer的底层"></a>join buffer的底层</h2><p>join buffer将参与join操作中的两个或者多个表数据缓存在内存中，以便在下一次进行相同的查询时可以直接从缓存中获取数据，而不必访问磁盘或索引。这样可以大大提高查询速度。</p><h2 id="索引的优化方式有哪些？"><a href="#索引的优化方式有哪些？" class="headerlink" title="索引的优化方式有哪些？"></a>索引的优化方式有哪些？</h2><ol><li>在合适的列上建立索引，1.唯一性2经常用于where或者orderby的 3.可比较的</li></ol><h2 id="为什么有时候使用索引反而会降低性能"><a href="#为什么有时候使用索引反而会降低性能" class="headerlink" title="为什么有时候使用索引反而会降低性能"></a>为什么有时候使用索引反而会降低性能</h2><ol><li>联合索引不满足最左覆盖的时候，索引失效，退化成全表扫描</li><li>索引碎片的东西，比如说如果建在经常修改删除的字段，可能产生不连续的区域，增加IO的压力</li><li>索引就失效了⁴。这时候MySQL就会退化为全表扫描，而不是利用索引进行快速定位</li></ol><h2 id="MYSQL-如果发现CPU，或者IO压力很大，怎么定位问题"><a href="#MYSQL-如果发现CPU，或者IO压力很大，怎么定位问题" class="headerlink" title="MYSQL 如果发现CPU，或者IO压力很大，怎么定位问题"></a>MYSQL 如果发现CPU，或者IO压力很大，怎么定位问题</h2><p>1、首先用htop命令和iostat命令，定位是什么进程在占用cpu和磁盘io<br>2、sql执行show full processlist命令，看现在数据库在执行什么sql语句，是否有语句长时间执行使数据库卡住<br>3、执行show innodb engine status命令，查看数据库是否有锁资源争用<br>4、查看mysql慢查询日志/slow_query.log文件，看是否有慢sql<br>5、找到引起数据库占用资源高的语句，进行优化，该建索引的建索引，索引不合适的删索引，或者根据情况kill掉耗费资源的sql语句等</p><h2 id="大表要如何优化"><a href="#大表要如何优化" class="headerlink" title="大表要如何优化"></a>大表要如何优化</h2><ol><li>分区表：<br>使用分区表将大表拆分为更小的、易管理的分区。根据数据的时间范围、地理位置等因素进行分区，可以提高查询性能和维护效率。</li><li>垂直切分：<br>将大表按列进行垂直切分，将一部分列存储在一个表中，将其他列存储在另一个表中。这可以提高热数据的读取效率。</li><li>水平切分（分库分表），mysql分布式存到不同节点上。<br>将大表数据水平切分成多个小表，每个小表存储部分数据。这样可以提高并发性能，使查询分散在不同的数据节点上。<h2 id="Redis-Lua常用的命令"><a href="#Redis-Lua常用的命令" class="headerlink" title="Redis Lua常用的命令"></a>Redis Lua常用的命令</h2></li></ol><ul><li>EVAL：EVAL script numkeys key [key …] arg [arg …]</li><li>EVALSHA：EVALSHA sha1 numkeys key [key …] arg [arg …]<br>SCRIPT LOAD命令格式：SCRIPT LOAD script<br>EVALSHA命令格式：</li></ul><p>这两个命令放在一起讲的原因是：EVALSHA 命令中的sha1参数，就是SCRIPT LOAD 命令执行的结果。</p><ul><li>SCRIPT LOAD </li><li>SCRIPT EXISTS</li><li>SCRIPT FLUSH</li><li>SCRIPT KILL</li></ul><h2 id="本地缓存如何选型"><a href="#本地缓存如何选型" class="headerlink" title="本地缓存如何选型"></a>本地缓存如何选型</h2><ol><li>ConcurrentHashMap</li><li>golang的话，本地一级缓存和一用</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6844904003998842887&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.cn/post/6844904003998842887&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://waynamigo.github.io/categories/MySQL/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Git" scheme="http://waynamigo.github.io/tags/Git/"/>
    
      <category term="MySQL" scheme="http://waynamigo.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java collection</title>
    <link href="http://waynamigo.github.io/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJavaSpring/"/>
    <id>http://waynamigo.github.io/2023/01/10/2023-01-10-面经JavaSpring/</id>
    <published>2023-01-09T16:00:00.000Z</published>
    <updated>2023-11-19T12:38:36.788Z</updated>
    
    <content type="html"><![CDATA[<p>ok</p><a id="more"></a><h1 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h1><ul><li>Ioc，控制反转，将对象的创建和控制权交给spring，Ioc容器</li><li>AOP的直接体现就是注解</li></ul><h1 id="AOP和IOC的理解"><a href="#AOP和IOC的理解" class="headerlink" title="AOP和IOC的理解"></a>AOP和IOC的理解</h1><ol><li>AOP面向切面编程，起到了解耦的作用，完成一个日志/事务/权限处理等不属于业务里的功能，不需要更改过多业务代码，而是通过一个AOP动态代理（JDK/GClib）完成，调用时将公共逻辑添加到项目中</li><li>IOC，控制反转+依赖注入，通过IOC容器控制对象/对象的依赖 的创建，反转是用IOC容器创建后注入到对象中，由主动创建变成了被动创建<ul><li>IOC底层实现过程：核心原理是反射，使用BeanFactory的工厂模式实现的</li></ul><ol><li><code>createBeanfactory</code>创建bean工厂</li><li>循环创建对象，先通过<code>getBean</code>，<code>doGetBean</code>从容器中查找，没有的话去<code>createBean，doGreateBean</code>，以反射的方法创建对象</li><li>进行对象的属性填充populateBean和进行其他初始化initializingBean<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/img_convert/374544735d0dd4104601ef98749c7f89.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ol></li><li>反射的方式实例化Bean</li><li>对象属性用<code>populateBean</code>填充，循环依赖使用三级缓存</li><li><code>invokeAwareMethod</code>，设置相关依赖：<code>BeanName</code> <code>BeanFactory</code> <code>BeanClassloader</code></li><li>调用<code>BeanPostProcessor()</code>前置处理方法，<code>ApplicationContextPostPostProcessor</code>，设置上下文，环境，resourceloader等对象</li><li>调用<code>invokeInitmethod()</code>，判断是否实现<code>initializingBean</code>，调用了就再调用<code>afterpropertiesSet</code>方法</li><li>调用<code>BeanPostProcessor</code>的后置处理方法，AOP在该过程实现，<code>AbstractAutoProxyCreator()</code>，advice切面切点</li><li>获取完整的对象，可以用getbean获取了</li><li>执行完后，销毁流程，先判断是否实现<code>DisposableBean</code>接口，再判断是否实现<code>DestroyMethod</code>接口</li></ol><h2 id="循环依赖怎么解决？【使用了三级缓存】"><a href="#循环依赖怎么解决？【使用了三级缓存】" class="headerlink" title="循环依赖怎么解决？【使用了三级缓存】"></a>循环依赖怎么解决？【使用了三级缓存】</h2><p>使用了三级缓存，AOP，提前暴露对象</p><ol><li>问题：对象循环依赖产生的问题，A依赖B，B依赖A，提前暴露对象导致的</li><li>Bean创建流程是先实例化，再进行属性填充初始化</li><li>A如果属性里有B，在填充时需要从IOC容器里查找B，找不到的话，就创建B；然后B在属性填充的时候查找A，但是A没有创建完毕，</li><li>一级缓存中放的是完整对象，二级是没有完全创建的对象</li><li>第三级为什么需要？第三级缓存的value类型是ObjectFactory类型的函数接口，保证在整个容器的作用域中只有一个版本的同名Bean对象。</li><li>创建bean对象后，要放到三级缓存中是用于先判断是否需要被代理，选择取的是普通对象还是代理对象。</li></ol><h3 id="如果一个对象需要被代理，需不需要先实例化一个普通对象（要，必须传参数给wrapifnecessary）"><a href="#如果一个对象需要被代理，需不需要先实例化一个普通对象（要，必须传参数给wrapifnecessary）" class="headerlink" title="如果一个对象需要被代理，需不需要先实例化一个普通对象（要，必须传参数给wrapifnecessary）"></a>如果一个对象需要被代理，需不需要先实例化一个普通对象（要，必须传参数给wrapifnecessary）</h3><p>普通对象和代理对象不能同时出现在容器中，当需要被代理时，就需要覆盖普通对象</p><h1 id="SpringAOP的底层原理"><a href="#SpringAOP的底层原理" class="headerlink" title="SpringAOP的底层原理"></a>SpringAOP的底层原理</h1><p>底层原理就是使用的jvm或者gclibs的动态代理功能。AOP的实现阶段是IOC的BeanPostProcessor的后置方法中实现的扩展功能。</p><ol><li>介绍一下jvm gclib的原理，反射</li></ol><h1 id="Spring的设计模式"><a href="#Spring的设计模式" class="headerlink" title="Spring的设计模式"></a>Spring的设计模式</h1><ol><li>Bean都是单例模式</li><li>工厂模式，BeanFactory</li><li>观察者模式，Listener，Event</li><li>适配器模式，Adapter</li><li>装饰者模式：Bean的Wrapper</li><li>责任链模式：使用AOP时，先生成一个拦截器</li><li>代理模式：AOP使用的动态代理<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="Spring事务如何实现的，如何回滚"><a href="#Spring事务如何实现的，如何回滚" class="headerlink" title="Spring事务如何实现的，如何回滚"></a>Spring事务如何实现的，如何回滚</h2>答：事务是AOP实现的声明式事务。也就是首先要生成具体的代理对象，按AOP的流程来执行具体操作逻辑。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation = Propagation.REQUIRED,</span><br><span class="line">                isolation = Isolation.DEFAULT, readOnly = <span class="keyword">false</span>, timeout = -<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ol><p>底层具体到代码里是用jdbc的<code>datasourceTransactionManager</code>实现的，注解声明的事务逻辑是通过一个<code>TransationInterceptor</code>类实现，调用invoke函数体里，最后返回一个invokewithtransaction实现具体逻辑（对传参的方法使用getmethod获取）</p><ul><li>回滚的方式如下：</li></ul><ol><li>执行失败使用<code>completeTransactionAfterthrowing</code></li><li>执行成功用<code>completeTransactionAfterreturning</code></li><li>执行失败的回滚在transactional的doRollback里实现,里面是先获取object.getconn连接，然后conn.rollback回滚，只对于这个特定连接进行，而不是全局的。</li><li>执行成功的提交在transactional里的doCommit，也是获取连接，用jdbc连接的conn.commit()方法提交。</li><li>最后<code>cleanTransactionInfo</code>清除当前事务信息</li></ol><h1 id="SpringBoot的优点"><a href="#SpringBoot的优点" class="headerlink" title="SpringBoot的优点"></a>SpringBoot的优点</h1><ol><li>独立运行<br>Spring Boot 而且内嵌了各种 servlet 容器，Tomcat、Jetty 等，现在不再需要打成war 包部署到容器中，Spring Boot 只要打成一个可执行的 jar 包就能独立运行，所有的依赖包都在一个 jar 包内。</li><li>简化配置<br>spring-boot-starter-web 启动器自动依赖其他组件，简少了 maven 的配置。</li><li>自动配置<br>Spring Boot 能根据当前类路径下的类、jar 包来自动配置 bean，如添加一个 spring<br>boot-starter-web 启动器就能拥有 web 的功能，无需其他配置。</li><li>无代码生成和XML配置<br>Spring Boot 配置过程中无代码生成，也无需 XML 配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是 Spring4.x 的核心功能之一。</li><li>应用监控<br>Spring Boot 提供一系列端点可以监控服务及应用，做健康检测<h1 id="Spring-Bean"><a href="#Spring-Bean" class="headerlink" title="Spring Bean"></a>Spring Bean</h1>被Ioc容器管理的对象，通过xml或者Entity等注解</li></ol><ul><li><p>org.springframework.beans </p></li><li><p>org.springframework.context</p></li><li><p><strong>@Component</strong>：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。</p></li><li><p><strong>@Repository</strong> : 对应持久层即 Dao 层，主要用于数据库相关操作。</p></li><li><p><strong>@Service</strong> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</p></li><li><p><strong>@Controller</strong> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面</p></li></ul><h2 id="1-Bean和-Component的区别"><a href="#1-Bean和-Component的区别" class="headerlink" title="1. @Bean和@Component的区别"></a>1. @Bean和@Component的区别</h2><ol><li>bean用于方法，component用于注解</li><li>@Component通常是通过<strong>类路径扫描</strong>来自动侦测以及自动装配到 Spring 容器中（我们可以<strong>使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配</strong>到 Spring 的 bean 容器中）。</li><li>@Bean注解通常是我们<strong>在标有该注解的方法中定义</strong>产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我<h2 id="2-可以注入Bean的注解有哪些"><a href="#2-可以注入Bean的注解有哪些" class="headerlink" title="2. 可以注入Bean的注解有哪些"></a>2. 可以注入Bean的注解有哪些</h2></li><li>@Autowired</li><li>@Resource</li></ol><h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><p>Spring 管理事务的方式有几种？</p><ul><li>编程式事务：在代码中硬编码(不推荐使用) : 通过 TransactionTemplate或者 TransactionManager 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li>声明式事务：在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于@Transactional 的全注解方式使用最多）</li></ul><h2 id="1-Transactional"><a href="#1-Transactional" class="headerlink" title="1. @Transactional"></a>1. @Transactional</h2><p>使用场景：hibernate的删除事务，更新事务</p><ul><li>使用<code>@Transactional(rollbackFor = Exception.class)</code>：<ul><li>用于保证事务一致性，发生异常时回滚</li><li>不配置for exception的话，只有在runtime err时回滚，为了保证可靠性</li></ul></li></ul><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><ol><li>从常用注解和生命周期，启动，监控，测试等考察</li><li>是@Configuration、@EnableAutoConfiguration、@ComponentScan的集合体</li></ol><h2 id="1-SpringBootApplication"><a href="#1-SpringBootApplication" class="headerlink" title="1. @SpringBootApplication"></a>1. @SpringBootApplication</h2><p>自动装配原理是什么？</p><ol><li>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</li><li>@Configuration：允许在上下文中注册额外的 bean 或导入其他配置类</li><li>@ComponentScan：扫描被@Component (@Service,@Controller)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。</li></ol><h2 id="2-常用注解："><a href="#2-常用注解：" class="headerlink" title="2. 常用注解："></a>2. 常用注解：</h2><ol><li>@RestController和@Controller指定一个类，作为控制器的注解 </li><li>@RequestMapping方法级别的映射注解，这一个用过Spring MVC的小伙伴相信都很熟悉 </li><li>@EnableAutoConfiguration和@SpringBootApplication是类级别的注解，根据maven依赖的jar来自动猜测完成正确的spring的对应配置，只要引入了spring-boot-starter-web的依赖，默认会自动配置Spring MVC和tomcat容器</li><li>@Configuration类级别的注解，一般这个注解，我们用来标识main方法所在的类,完成元数据bean的初始化。</li><li>@ComponentScan类级别的注解，自动扫描加载所有的Spring组件包括Bean注入，一般用在main方法所在的类上 </li><li>@ImportResource类级别注解，当我们必须使用一个xml的配置时，使用@ImportResource和@Configuration来标识这个文件资源的类。 </li><li>@Autowired注解，一般结合@ComponentScan注解，来自动注入一个Service或Dao级别的Bean</li><li>@Component类级别注解，用来标识一个组件，比如我自定了一个filter，则需要此注解标识之后，Spring Boot才会正确识别。</li></ol><h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h2 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1.BeanFactory"></a>1.BeanFactory</h2><h2 id="2-常用注解"><a href="#2-常用注解" class="headerlink" title="2.常用注解"></a>2.常用注解</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ok&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://waynamigo.github.io/categories/Java/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java" scheme="http://waynamigo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java base</title>
    <link href="http://waynamigo.github.io/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E5%9F%BA%E7%A1%80/"/>
    <id>http://waynamigo.github.io/2023/01/10/2023-01-10-面经Java基础/</id>
    <published>2023-01-09T16:00:00.000Z</published>
    <updated>2023-10-30T17:25:40.272Z</updated>
    
    <content type="html"><![CDATA[<p>ok</p><a id="more"></a><h1 id="原则：只能将一个类的实例赋值给它本身或者它的子类，而不能将一个父类的实例赋值给一个子类的引用"><a href="#原则：只能将一个类的实例赋值给它本身或者它的子类，而不能将一个父类的实例赋值给一个子类的引用" class="headerlink" title="原则：只能将一个类的实例赋值给它本身或者它的子类，而不能将一个父类的实例赋值给一个子类的引用"></a>原则：只能将一个类的实例赋值给它本身或者它的子类，而不能将一个父类的实例赋值给一个子类的引用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B extends A;</span><br><span class="line">B b = <span class="keyword">new</span> A(); <span class="comment">//错误</span></span><br><span class="line">A a = <span class="keyword">new</span> B(); <span class="comment">//合法，但是通过 a 只能访问 A 类中定义的方法和属性，除非 B 类重写了这些方法</span></span><br></pre></td></tr></table></figure><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li>boolean 1</li><li>byte 1</li><li>short 2</li><li>char 2</li><li>int 4 </li><li>float 4</li><li>long 4</li><li>double <h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2></li><li>Boolean</li><li>Byte</li><li>Short</li><li>Character</li><li>Integer</li><li>Long</li><li>Float（没有实现缓存机制）</li><li>Double（没有实现缓存机制）</li><li>BigDecimal（浮点精确运算的场景，传统浮点类型计算时，会出现位数不够的时候，计算机会给这个浮点表示进行截断），计算机x86一般用小端存储，高（位）存高（地址），低存低<ul><li>低地址：指的是内存中较小的地址值。在大多数系统中，低地址对应于内存中的起始位置，也就是地址为0的位置。</li><li>高地址：指的是内存中较大的地址值。它是相对于低地址而言的，表示内存的结束位置。</li></ul></li><li>BigInteger（存储超过64 位 long 整型的数字）BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</li></ul><p><a href="https://javaguide.cn/java/basis/bigdecimal.html" target="_blank" rel="noopener">https://javaguide.cn/java/basis/bigdecimal.html</a></p><p><strong>装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="number">40</span>; <span class="comment">//发生装箱，相当于 Integer.valueOf(40);</span></span><br><span class="line">Integer num2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line"><span class="keyword">return</span> num1 == num2; | <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">解释：num1 直接使用的是缓存中的对象: num2 直接创建了新对象</span><br><span class="line"><span class="comment">// 自动装箱函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line">如果把第一句换成 <span class="keyword">int</span> num1 =<span class="number">40</span>;</span><br><span class="line">num1 == num2;| <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//会对num2发生自动拆箱，会实现两个int类型的比较，返回true</span></span><br><span class="line"><span class="comment">// 如果要用num2.equals比较:</span></span><br><span class="line">num2.equals(Integer.valueOf(num1));</span><br></pre></td></tr></table></figure><ul><li>所有<strong>整型包装类对象之间值</strong>的比较，全部使用 equals 方法比较。</li><li>== 操作符会<strong>比较两个对象的引用是否相等</strong>，而不是它们的值。因为 num1 和 num2 都是通过自动装箱得到的，它们实际上是不同的对象，即使它们包装的值相同</li><li>自动拆箱与装箱的例子：<ul><li>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</li><li>int n = i 等价于 int n = i.intValue();</li></ul></li><li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该<strong>尽量避免不必要的拆装箱操作</strong>。<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2></li><li>private</li><li>protected    </li><li>public<h2 id="类，方法，变量修饰符"><a href="#类，方法，变量修饰符" class="headerlink" title="类，方法，变量修饰符"></a>类，方法，变量修饰符</h2></li><li>class</li><li>new</li><li>abstract </li><li>extends</li><li>static:</li><li>final </li><li>implements</li><li>interface</li><li>synchronized</li><li>enum</li><li>native</li><li>volatile</li></ul><ol><li><p>static:static 修饰的变量和方法可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p></li><li><p>静态方法只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p></li><li><p>【为什么不能调用非静态成员】：在类加载的时候就会分配内存，非静态成员需要实例化后才能有效访问</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2></li></ol><ul><li>try</li><li>catch</li><li>throw</li><li>throws</li><li>finally<ul><li>当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li></ul></li></ul><h2 id="重写-override-和-重载-overload"><a href="#重写-override-和-重载-overload" class="headerlink" title="重写 override 和 重载 overload"></a>重写 override 和 重载 overload</h2><ul><li>override是子类重写父类方法，参数需要一样</li><li>overload是在一个类中重载的某个方法</li><li>构造方法可以背重载，不可以重写</li></ul><h2 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h2><p>共同点：都不能被实例化。都可以包含抽象方法。都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</p><p>区别：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。一个类只能继承一个类，但是可以实现多个接口。接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值</p><h2 id="深拷贝与浅拷贝-引用拷贝"><a href="#深拷贝与浅拷贝-引用拷贝" class="headerlink" title="深拷贝与浅拷贝/引用拷贝"></a>深拷贝与浅拷贝/引用拷贝</h2><ul><li>深拷贝：完整复制某个对象，包括这个对象中的内部对象，都是不同的对象</li><li>浅拷贝：在堆上创建一个新对象，这个新对象与原对象使用的是同一个内部对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="comment">//加入这一行，内部的address对象也进行拷贝，本质上是堆上的另外一个对象。</span></span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Object：基类"><a href="#Object：基类" class="headerlink" title="Object：基类"></a>Object：基类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。获取哈希码（int 整数），也称为散列码，也可以比较两个对象是否相等。两个对象的hashCode 值相等并不代表两个对象就相等：可能发生冲突</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">//native 方法，用于创建并返回当前对象的一份拷贝。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="comment">//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String  StringBuffer StringBuilder"></a>String  StringBuffer StringBuilder</h2><ul><li>String类不可变：创建时，采用final的字符数组表示字符串了,final char [],(java9以后用的byte[])</li><li><strong>StringBuilder</strong> 与 <strong>StringBuffer</strong>都继承自 <strong>AbstractStringBuilder</strong> 类，也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</li></ul><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了<strong>避免字符串的重复创建。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line">String aa = <span class="string">"ab"</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line">String bb = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>【面试题】<code>String s1 = new String(&quot;abc&quot;);</code>这句话创建了几个字符串对象？</p><ul><li>一个或两个：</li><li>一个的情况，abc在字符串常量池里，仅需要abc的引用创建s1</li><li>两个的情况，abc不存在常量池里，要先创建abc，再将其引用创建s1</li></ul><p>【面试题】手动将某字符串加入字符串常量池用什么方法</p><ul><li>String.intern()</li><li>将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：<ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line">String s1 = <span class="string">"Java"</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line">String s4 = s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>【面试题】字符串加号操作 str + str</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"str"</span>;<span class="comment">//创建了一个字符串常量 "str"，它会存储在常量池中</span></span><br><span class="line">String str2 = <span class="string">"ing"</span>;</span><br><span class="line">String str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;<span class="comment">//这里的 "str" 和 "ing" 都是字符串字面量，它们会在编译时就被合并成一个新的字符串常量 "string"，然后存储在常量池中。</span></span><br><span class="line">String str4 = str1 + str2;<span class="comment">//这里使用了变量 str1 和 str2 进行字符串拼接，这是在运行时进行的。因此，新的字符串对象 "string" 会在堆内存中创建，而不是常量池</span></span><br><span class="line">String str5 = <span class="string">"string"</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Exception-和-Error（两者继承Thorwable）"><a href="#Exception-和-Error（两者继承Thorwable）" class="headerlink" title="Exception 和 Error（两者继承Thorwable）"></a>Exception 和 Error（两者继承Thorwable）</h2><ul><li><strong>Exception</strong> ：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong>Error</strong>：Error 属于程序无法处理的错误 ，jvm一般会选择线程终止。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="Checkable-Exception-受检查异常，必须用catch或者throw捕获"><a href="#Checkable-Exception-受检查异常，必须用catch或者throw捕获" class="headerlink" title="Checkable Exception 受检查异常，必须用catch或者throw捕获"></a>Checkable Exception 受检查异常，必须用catch或者throw捕获</h3><p>除了RuntimeException及其子类以外（下列），其他的Exception类及其子类都属于受检查异常</p><ul><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误比如方法入参类型错误)</li><li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>ArithmeticException（算术错误）</li><li>SecurityException （安全错误比如权限不够）</li><li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用throws关键字声明可能抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法内部发现异常情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* some condition */</span>) &#123;</span><br><span class="line">            <span class="comment">// 抛出自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"Something went wrong"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line">          e.printStackTrace(); <span class="comment">//在控制台上打印 Throwable 对象封装的异常信息</span></span><br><span class="line">          e.getMessage();<span class="comment">// 返回异常发生时的简要描述</span></span><br><span class="line">          e.toString();<span class="comment">// 返回异常发生时的详细信息</span></span><br><span class="line">          e.getLocalizedMessage();<span class="comment">//返回异常对象的本地化信息。</span></span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型-Generics-对比CPP的template"><a href="#泛型-Generics-对比CPP的template" class="headerlink" title="泛型 Generics //对比CPP的template"></a>泛型 Generics //对比CPP的template</h2><p>相同点：</p><ul><li><strong>参数化类型</strong>：两者都允许你定义可以接受不特定类型的数据结构或算法，从而提高代码的复用性和灵活性。</li><li><strong>类型安全</strong>：Java 的泛型和 C++ 的模板都<strong>在编译时进行类型检查</strong>，确保类型的一致性。</li><li><strong>支持容器类</strong>：在两者中，可以创建可以容纳任何类型的容器类（例如，List、Set、Map 等）。</li></ul><p>不同点：</p><ul><li><strong>实现方式</strong>：<ul><li>Java 泛型是通过擦除（type erasure）来实现的。在编译时，泛型类型信息会被擦除，编译器会将泛型代码转化成非泛型的代码。这意味着在运行时，不会保留关于泛型类型的信息。这也是为什么在 Java 中不能直接创建泛型数组的原因。</li><li>C++ 模板是通过编译器在编译时进行代码生成，每次使用模板时，都会根据模板参数生成对应的代码。这使得 C++ 模板可以实现更为复杂和灵活的类型推断。</li></ul></li><li><strong>语法</strong>：<br>Java 泛型使用<t>来表示泛型类型，可以在类、接口、方法等级别使用泛型。<br>C++ 模板使用<typename t>或者<class t>来声明模板参数，可以在类、函数等级别使用模板。</class></typename></t></li><li><strong>泛型的通配符</strong>：<br>Java 的泛型可以使用通配符（wildcards）来表示不确定的类型。例如：List&lt;?&gt;表示一个不确定类型的 List。<br>C++ 模板可以通过模板特化来处理特定的类型。</li><li><strong>模板元编程</strong>：<br>C++ 的模板系统支持模板元编程，这意味着可以在编译时进行计算和逻辑操作，从而实现更为复杂的类型处理。</li><li><strong>依赖</strong>：<br>Java 的泛型不依赖于运行时类型信息（RTTI）。<br>C++ 的模板依赖于编译时类型信息（CTTI）。</li></ul><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><ul><li>代理机制</li></ul><p><strong>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><ul><li>动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。</li><li>静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li>JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class; <span class="comment">//知道目的类名为TargetObject，直接获取</span></span><br><span class="line">Class alunbarClass1 = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);<span class="comment">//通过类的全路径获取</span></span><br><span class="line">TargetObject instance = <span class="keyword">new</span> TargetObject();<span class="comment">//通过实例获取</span></span><br><span class="line">Class alunbarClass2 = instance.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类加载器进行全路径的loadclass</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>静态代理<br>可以在代理类中增加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br></pre></td></tr></table></figure></li><li><p>动态代理：JDK 动态代理、CGLIB 动态代理</p><ul><li>InvocationHandler 接口和 Proxy 类</li><li>还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>数据从外部存储和内存之间进出的过程就是IO。</p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时</p><h2 id="序列化-Protobuf，Hessian，Kyro"><a href="#序列化-Protobuf，Hessian，Kyro" class="headerlink" title="序列化 Protobuf，Hessian，Kyro"></a>序列化 Protobuf，Hessian，Kyro</h2><ul><li>transient 阻止实例中那些用此关键字修饰的的变量序列化；</li><li>当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</li><li>transient 只能修饰变量，不能修饰类和方法。</li><li>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li></ul><h2 id="sun-misc-Unsafe类-并发工具类的组件，一个直接操作内存空间的类。"><a href="#sun-misc-Unsafe类-并发工具类的组件，一个直接操作内存空间的类。" class="headerlink" title="sun.misc.Unsafe类:并发工具类的组件，一个直接操作内存空间的类。"></a>sun.misc.Unsafe类:并发工具类的组件，一个直接操作内存空间的类。</h2><p>主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。</p><ul><li>Unsafe中提供的方法需要依赖native方法，Java 代码中只是声明方法头，具体的实现则交给本地代码</li></ul><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object srcBase, <span class="keyword">long</span> srcOffset,Object destBase, <span class="keyword">long</span> destOffset,<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br></pre></td></tr></table></figure><p>这种方式分配<strong>堆外内存</strong>，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用freeMemory方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在try中执行对内存的操作，最终在finally块中进行内存释放。</p><h3 id="【面试题】为什么要用堆外内存"><a href="#【面试题】为什么要用堆外内存" class="headerlink" title="【面试题】为什么要用堆外内存"></a>【面试题】为什么要用堆外内存</h3><ul><li>对GC停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li><li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式的应用：</span></span><br><span class="line"><span class="comment">// 利用反射获得 Unsafe 类中已经实例化完成的单例对象 theUnsafe.</span></span><br><span class="line">Unsafe unsafe = Unsafe.reflectGetUnsafe();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">long</span> maddr = unsafe.allocateMemory(<span class="number">1024</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(OutOfMemoryError e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  <span class="keyword">throw</span> e;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  unsafe.freeMomory(maddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><ul><li>实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，在NIO中使用广泛。</li><li>对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现</li></ul><h3 id="内存屏障-Memory-Barrier-组织指令重排序"><a href="#内存屏障-Memory-Barrier-组织指令重排序" class="headerlink" title="内存屏障 Memory Barrier:组织指令重排序"></a>内存屏障 Memory Barrier:组织指令重排序</h3><p>阻止屏障两边的<strong>指令重排序</strong>从而避免编译器和硬件的不正确优化情况</p><ul><li>屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ok&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://waynamigo.github.io/categories/Java/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java" scheme="http://waynamigo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java concur</title>
    <link href="http://waynamigo.github.io/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E5%B9%B6%E5%8F%91/"/>
    <id>http://waynamigo.github.io/2023/01/10/2023-01-10-面经Java并发/</id>
    <published>2023-01-09T16:00:00.000Z</published>
    <updated>2023-10-30T17:25:39.556Z</updated>
    
    <content type="html"><![CDATA[<p>ok</p><a id="more"></a><h2 id="java线程和linux的C-线程有何区别"><a href="#java线程和linux的C-线程有何区别" class="headerlink" title="java线程和linux的C++线程有何区别"></a>java线程和linux的C++线程有何区别</h2><p>Java线程：Java中的异常处理机制可以捕获和处理线程中的异常。</p><p>C++线程：C++线程中的异常会导致程序终止，除非显式地进行了异常处理。</p><h2 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h2><p>多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的<strong>程序计数器、虚拟机栈 和 本地方法栈。</strong></p><ul><li>程序计数器PC，需要按顺序实行机器指令；多线程情况下，相当于一个指针指向执行位置，恢复上下文</li><li>如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li></ul><p>虚拟机栈和本地方法栈为什么私有</p><ul><li>每个方法的栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程</li><li>本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<h2 id="java线程的生命周期"><a href="#java线程的生命周期" class="headerlink" title="java线程的生命周期"></a>java线程的生命周期</h2>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</li><li>NEW: 初始状态，线程被创建出来但没有被调用 start() 。</li><li>RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><h3 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h3><ol><li>wait释放了锁，sleep没释放锁，所以wait会被用于线程间的同步，sleep常用于暂停程序</li><li>wait的线程不自动苏醒，需要同一对象的其他线程使用notify去唤醒，sleep的时间过完会自动往下执行</li></ol><ul><li>wait执行完释放了锁</li><li>sleep没有释放锁，可能导致死锁</li><li>wait() 通常被用于线程间交互/通信</li><li>sleep()通常被用于暂停执行。</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。</li><li>sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。</li><li>sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。</li></ul><h3 id="为什么-wait-方法不定义在-Thread-中"><a href="#为什么-wait-方法不定义在-Thread-中" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中"></a>为什么 wait() 方法不定义在 Thread 中</h3><ul><li>wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。</li><li>每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（Object）而非当前的线程（Thread）。<h3 id="为什么sleep方法定义在Thread中"><a href="#为什么sleep方法定义在Thread中" class="headerlink" title="为什么sleep方法定义在Thread中"></a>为什么sleep方法定义在Thread中</h3></li><li>sleep() 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</li></ul><h3 id="【面试题】可以直接调用-Thread-类的-run-方法吗"><a href="#【面试题】可以直接调用-Thread-类的-run-方法吗" class="headerlink" title="【面试题】可以直接调用 Thread 类的 run 方法吗"></a>【面试题】可以直接调用 Thread 类的 run 方法吗</h3><p>【回答】可以直接调用，但是直接执行 run() 方法，不经过start()时，jvm会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它</p><ul><li>调用 start() 方法方可启动线程并使线程进入就绪状态</li><li>直接执行 run() 方法的话不会以多线程的方式执行</li></ul><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="共享内存：volatile声明变量共享，防止jvm指令重排"><a href="#共享内存：volatile声明变量共享，防止jvm指令重排" class="headerlink" title="共享内存：volatile声明变量共享，防止jvm指令重排"></a>共享内存：volatile声明变量共享，防止jvm指令重排</h3><ul><li>该变量可能会被多个线程同时访问</li><li>每次读区都从内存读，不会被本地线程缓存</li><li>可确保可见性和有序性，但<strong>不能保证原子性</strong></li></ul><p><strong>这个变量在堆上还是在栈上</strong>？</p><ul><li>至于变量在哪里存储，volatile 关键字主要影响了变量的可见性，在堆还是栈上取决于它是成员变量还是局部变量<h3 id="禁止指令重排序：volatile"><a href="#禁止指令重排序：volatile" class="headerlink" title="禁止指令重排序：volatile"></a>禁止指令重排序：volatile</h3>一个jvm调优的办法，jvm会自动重排，有可能导致性能下降。unsafe类提供了直接操作内存的方法，volatile的变量在读写时，插入读写屏障来禁止指令重排<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="乐观锁悲观锁"><a href="#乐观锁悲观锁" class="headerlink" title="乐观锁悲观锁"></a>乐观锁悲观锁</h2><ul><li>乐观锁是线程无需等待，只在提交修改的时候验证资源是否被修改</li><li>悲观锁是显式的synchronized或者reentrantlock独占锁</li></ul><p><strong>CAS算法</strong>，<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 CAS Compare And Swap（比较与交换）实现的。</p><h3 id="区别：高并发场景下，乐观锁不会造成死锁或阻塞问题。"><a href="#区别：高并发场景下，乐观锁不会造成死锁或阻塞问题。" class="headerlink" title="区别：高并发场景下，乐观锁不会造成死锁或阻塞问题。"></a>区别：高并发场景下，乐观锁不会造成死锁或阻塞问题。</h3><ul><li><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</p></li><li><p>但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><h3 id="两者使用方式"><a href="#两者使用方式" class="headerlink" title="两者使用方式"></a>两者使用方式</h3></li><li><p>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</p></li><li><p>不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</p></li></ul><h3 id="CAS算法流程"><a href="#CAS算法流程" class="headerlink" title="CAS算法流程"></a>CAS算法流程</h3><ul><li>是一个原子操作</li><li>涉及到 var变量，expected预期值，new预期写入的新值</li><li>当v = e时，通过new更新v，如果v != e,就说明其他进程要写，当前线程放弃更新</li><li>当多个线程同时使用 CAS 操作一个变量时，只有一个会成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</li></ul><ol><li>java语言中的cas类是通过<code>unsafe</code>类里的<code>compareAndSwapObject</code>实现的</li><li>它是C++内联汇编的产物</li></ol><h2 id="乐观锁的ABA问题"><a href="#乐观锁的ABA问题" class="headerlink" title="乐观锁的ABA问题"></a>乐观锁的ABA问题</h2><p><strong>检查变量的时候，原值为A，要赋值为B时检测为A，但是不能保证这之前没有被其他线程修改过</strong></p><p>解决思路：在变量前追加版本号/时间戳：<code>AtomicStampedReference</code></p><h2 id="乐观锁的循环时间长的问题"><a href="#乐观锁的循环时间长的问题" class="headerlink" title="乐观锁的循环时间长的问题"></a>乐观锁的循环时间长的问题</h2><p>CAS使用自旋锁来进行重试，降低消耗使用pause指令</p><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><ul><li>修饰实例方法：锁当前对象实例</li><li>修饰静态方法：锁当前类</li><li>修饰代码块：对括号里指定的对象/类加锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 。</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。</span></span><br><span class="line"><span class="comment">// synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>synchronized(A.class) 和修饰static方法都是要锁的class</li><li>synchronized+方法是给实例对象加锁</li></ol><h3 id="问题-静态-synchronized-方法和非静态-synchronized-方法之间的调用互斥么？"><a href="#问题-静态-synchronized-方法和非静态-synchronized-方法之间的调用互斥么？" class="headerlink" title="[问题]静态 synchronized 方法和非静态 synchronized 方法之间的调用互斥么？"></a>[问题]静态 synchronized 方法和非静态 synchronized 方法之间的调用互斥么？</h3><p>不互斥！锁的是两种不同的方法，静态用的是当前类的锁，非静态锁的是单个实例对象</p><h2 id="构造方法能不能使用-synchronized-关键字修饰【不能】"><a href="#构造方法能不能使用-synchronized-关键字修饰【不能】" class="headerlink" title="构造方法能不能使用 synchronized 关键字修饰【不能】"></a>构造方法能不能使用 synchronized 关键字修饰【不能】</h2><ul><li>因为构造方法本身属于线程安全，构造一个对象是原子操作<br>多线程可能有些特殊情况造成不安全。</li><li>比如说逃逸问题：<br>如果在构造方法中将未完全初始化的对象引用传递给其他线程，其他线程可能会在对象完全初始化之前访问它，这也可能导致线程不安全<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapingExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SomeObject sharedObject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EscapingExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sharedObject = <span class="keyword">new</span> SomeObject(); <span class="comment">// 逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>构造时，可以使用静态工厂方法构造对象</p><h2 id="底层原理了解吗，很了解，通过对象监视器和访问标识来实现"><a href="#底层原理了解吗，很了解，通过对象监视器和访问标识来实现" class="headerlink" title="底层原理了解吗，很了解，通过对象监视器和访问标识来实现"></a>底层原理了解吗，很了解，通过对象监视器和访问标识来实现</h2><ul><li>synchronized 同步语句块：使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</li><li>修饰方法：JVM通过一个访问标识<code>ACC_SYNCHRONIZED</code> 指明这一个同步方法</li></ul><h2 id="synchronized-和-volatile关键字，互补"><a href="#synchronized-和-volatile关键字，互补" class="headerlink" title="synchronized 和 volatile关键字，互补"></a>synchronized 和 volatile关键字，互补</h2><ul><li>volatile 修饰变量，synchronized修饰方法和代码块</li><li>volatile 保证顺序性可见性，synchronized保证可见性和原子性</li><li>volatile 解决变量在多个线程之间的可见性，synchronized解决多线程访问资源的同步性</li></ul><h2 id="ReentrantLock是一个可重入的独占锁"><a href="#ReentrantLock是一个可重入的独占锁" class="headerlink" title="ReentrantLock是一个可重入的独占锁"></a>ReentrantLock是一个可重入的独占锁</h2><ul><li>底层用<code>AbstractQueuedSynchronizer</code> 实现,内部的Sync类继承了AQS类，</li><li>实现公平锁和非公平锁 <code>UnFairSync和FairSync</code>，都是继承的内部类Sync实现的，默认使用公平锁</li></ul><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><h2 id="synchronized-和-reentrantlock"><a href="#synchronized-和-reentrantlock" class="headerlink" title="synchronized 和 reentrantlock"></a>synchronized 和 reentrantlock</h2><ul><li>sychronized 依赖于 jvm的对象监视器monitor、访问标识，reentrantlock依赖于jdk层面</li><li>reentrantlock需要配合trycatch，抛出的异常是InterruptedException</li></ul><h1 id="threadLocal（变量）"><a href="#threadLocal（变量）" class="headerlink" title="threadLocal（变量）"></a>threadLocal（变量）</h1><p>可以让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本withInitial(obj)作为本地线程的一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">""</span>+i);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" default Formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="threadLocal原理"><a href="#threadLocal原理" class="headerlink" title="threadLocal原理"></a>threadLocal原理</h2><ul><li>通过维护threadlocalmap类型的两个变量<code>threadLocals</code>,<code>inheritableThreadLocals</code>可继承threadlocals</li><li>初始化为null，当当前线程调用set get时，进行创建<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="threadlocal内存泄漏问题"><a href="#threadlocal内存泄漏问题" class="headerlink" title="threadlocal内存泄漏问题"></a>threadlocal内存泄漏问题</h2><ul><li><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。</p></li><li><p>所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉，导致了内存泄漏</p></li><li><p>ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p></li><li><p>ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后最好手动调用remove()方法</p></li><li><p>弱引用WeakReference</p></li><li><p>强引用指可以直接访问对象的引用，一般不会被gc，弱引用的话，弱引用不会阻止被引用对象的垃圾回收，也就是说，当只有弱引用引用一个对象时，垃圾回收器可以随时回收该对象，而不考虑当前内存是否足够。这使得弱引用非常适合用于缓存等场景，当内存资源不足时，缓存中的对象可以被及时释放。</p></li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>使用ThreadPoolExecutor构造方法去创建</p><ul><li><strong>FixedThreadPool</strong>：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor</strong>： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool</strong>： 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li><li><strong>ScheduledThreadPool</strong>：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h3 id="内置线程池Executor是什么，为什么不建议使用【容易导致内存泄漏】"><a href="#内置线程池Executor是什么，为什么不建议使用【容易导致内存泄漏】" class="headerlink" title="内置线程池Executor是什么，为什么不建议使用【容易导致内存泄漏】"></a>内置线程池Executor是什么，为什么不建议使用【容易导致内存泄漏】</h3><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p><p><strong>使用executors返回的线程池可能导致的问题如下：</strong></p><ol><li>FixedThreadPool 和 SingleThreadExecutor：使用的是无界的 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM</li><li>CachedThreadPool：使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM</li><li>ScheduledThreadPool 和 SingleThreadScheduledExecutor : 使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM</li></ol><h2 id="实现一个根据任务的优先级来执行的线程池【使用阻塞队列】"><a href="#实现一个根据任务的优先级来执行的线程池【使用阻塞队列】" class="headerlink" title="实现一个根据任务的优先级来执行的线程池【使用阻塞队列】"></a>实现一个根据任务的优先级来执行的线程池【使用阻塞队列】</h2><p>通过构造函数，传入一个<code>ProorityBlockingQueue&lt;Runnable&gt;</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ok&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://waynamigo.github.io/categories/Java/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java" scheme="http://waynamigo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java random</title>
    <link href="http://waynamigo.github.io/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E9%97%AE%E9%A2%98/"/>
    <id>http://waynamigo.github.io/2023/01/10/2023-01-10-面经Java问题/</id>
    <published>2023-01-09T16:00:00.000Z</published>
    <updated>2023-10-30T17:25:43.475Z</updated>
    
    <content type="html"><![CDATA[<p>ook</p><a id="more"></a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-重载和重写的区别"><a href="#1-重载和重写的区别" class="headerlink" title="1. 重载和重写的区别"></a>1. 重载和重写的区别</h2><ul><li><p>重载 overload：方法名相同，返回值和形参，访问修饰符可能不同，发生在一个类中；编译时发生</p></li><li><p>重写 override：发生在继承中，（覆盖），方法名和形参都相同，修饰符大于等于父类，子类不能重写父类的private方法，</p><h2 id="2-string-stringbuffer-stringbuilder"><a href="#2-string-stringbuffer-stringbuilder" class="headerlink" title="2. string stringbuffer stringbuilder"></a>2. string stringbuffer stringbuilder</h2></li></ul><ol><li>string用final修饰，底层用byte[]，java9之前用的char[]，节省字符串占用的内存</li><li>stringbuffer对原对象操作，线程安全，用了sychronized修饰？</li><li>stringbuilder线程不安全，单线程使用这个<h2 id="3-接口interface和抽象类abstract-class的区别"><a href="#3-接口interface和抽象类abstract-class的区别" class="headerlink" title="3. 接口interface和抽象类abstract class的区别"></a>3. 接口interface和抽象类abstract class的区别</h2></li><li>抽象类只能继承一个，接口可以有多个实现</li><li>抽象类中可以有普通成员函数（及实现），包括构造方法，接口只能有public的abstract方法</li><li>抽象类中可以有普通成员变量，            接口只能有public static final类型成员<br>abstract class：只能继承一个<br>interface</li><li>抽象类用于代码复用，比如抽象工厂，接口用于对类的行为进行约束，关注某些操作时用接口</li></ol><h2 id="4-hashcode和equals"><a href="#4-hashcode和equals" class="headerlink" title="4. hashcode和equals"></a>4. hashcode和equals</h2><ul><li>hashcode是获取对象的hash码，作用是确定在哈希表的位置，java任何类都有hashcode()函数，在Object父类里<h2 id="5-ArrayList和LinkedList"><a href="#5-ArrayList和LinkedList" class="headerlink" title="5. ArrayList和LinkedList"></a>5. ArrayList和LinkedList</h2></li><li>ArrayList基于动态数组，连续内存存储，动态用扩容实现，类似于C++的vector和Java、python的slice</li><li>LinkedList基于链表实现，存储分散的内存，适合插入删除，不适合查询，根据下标get(i)需要遍历<h2 id="6-HashMap和HashTable"><a href="#6-HashMap和HashTable" class="headerlink" title="6. HashMap和HashTable"></a>6. HashMap和HashTable</h2></li><li>HashMap并发不安全，HashTable用sychronized修饰，并发安全</li><li>数组+链表实现的，<h2 id="7-jdk7-concurrentHashMap原理"><a href="#7-jdk7-concurrentHashMap原理" class="headerlink" title="7. jdk7.concurrentHashMap原理"></a>7. jdk7.concurrentHashMap原理</h2></li></ul><ol><li>数据结构使用ReentrantLock + Segment + HashEntry  ，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表</li><li>元素查询：使用二次hash，第一次找到segment，第二次定位到元素所在的头部</li><li>锁使用了Segment分段锁，Segment继承ReentrantLock，其他Segment不受影响，数组扩容不影响其他Segment<h2 id="8-jdk8-concurrentHashMap原理"><a href="#8-jdk8-concurrentHashMap原理" class="headerlink" title="8. jdk8.concurrentHashMap原理"></a>8. jdk8.concurrentHashMap原理</h2></li><li>数据结构使用sychronized + CAS +红黑树，Node的next和val都用volatile修饰，查找替换赋值使用CAS</li><li>元素查询：使用CAS查找【】</li><li>锁：锁了head结点，其他元素的读写不受影响，<strong>读操作无锁</strong><h3 id="9-IOC容器和AOP是什么"><a href="#9-IOC容器和AOP是什么" class="headerlink" title="9. IOC容器和AOP是什么"></a>9. IOC容器和AOP是什么</h3></li><li>Inversion of Control 控制反转，就是把对象的创建管理的权利反转给外部的环境</li><li>Aspect Oriented Programming 面向切片编程，将日志、权限、接口等关注点从核心业务分离出来，通过<strong>动态代理</strong>等技术。<strong>各种注解就是以AOP的思想和机制实现的</strong><h2 id="10-Spring的AOP如何实现的【动态代理】"><a href="#10-Spring的AOP如何实现的【动态代理】" class="headerlink" title="10. Spring的AOP如何实现的【动态代理】"></a>10. Spring的AOP如何实现的【动态代理】</h2></li><li>Spring AOP：如果需要代理的对象实现了某个<strong>接口</strong>，SpringAOP使用JDKProxy创建代理对象，如果存在没有实现接口的对象，使用<strong>cglib</strong>生成一个被代理对象的子类作为代理</li><li>Aspect J：切面多的情况下使用，性能有优势<h2 id="11-java程序运行的流程"><a href="#11-java程序运行的流程" class="headerlink" title="11.java程序运行的流程"></a>11.java程序运行的流程</h2></li><li>源码 .java</li><li>编译器</li><li>字节码 .class</li><li>jvm解释器</li><li>机器的二进制码</li><li>运行<h2 id="12-equals-和-的区别"><a href="#12-equals-和-的区别" class="headerlink" title="12. equals 和 == 的区别"></a>12. equals 和 == 的区别</h2></li><li>==比较基础类型，和引用类型的地址是否相同</li><li>equals比较两个对象是否相同</li><li>Integer 与int的比较，<strong>以右边为基础</strong>，使用 Integer == int 发生拆箱；使用int == Integer发生装箱</li><li>Integer.equals(int)发生装箱，再比较内容<h2 id="13-final-finally-finalize的区别"><a href="#13-final-finally-finalize的区别" class="headerlink" title="13. final finally finalize的区别"></a>13. final finally finalize的区别</h2></li><li>final修饰类（不可继承）、方法（不可重写）、变量（不可修改）</li><li>finally修饰代码块，常用于释放资源、关闭连接等</li><li>finalize用于垃圾回收，已经被废弃<h2 id="14-BIO-NIO-AIO"><a href="#14-BIO-NIO-AIO" class="headerlink" title="14. BIO NIO AIO"></a>14. BIO NIO AIO</h2></li><li>阻塞与非阻塞：<ul><li>BIO是阻塞式I/O模型，线程会一直被阻塞等待操作完成。</li><li>NIO是非阻塞式I/O模型，线程可以去做其他任务，当I/O操作完成时得到通知。</li><li>AIO也是非阻塞式I/O模型，不需要用户线程关注I/O事件，由操作系统通过回调机制处理。</li></ul></li><li>缓冲区：<ul><li>BIO使用传统的字节流和字符流，需要为输入输出流分别创建缓冲区。</li><li>NIO引入了基于通道和缓冲区的I/O方式，使用一个缓冲区完成数据读写操作。</li><li>AIO则不需要缓冲区，使用异步回调方式进行操作。</li></ul></li><li>线程模型：<ul><li>BIO采用一个线程处理一个请求方式，面对高并发时线程数量急剧增加，容易导致系统崩溃。</li><li>NIO采用多路复用器来监听多个客户端请求，使用一个线程处理，减少线程数量，提高系统性能。</li><li>AIO依靠操作系统完成I/O操作，不需要额外的线程池或多路复用器。<h4 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h4></li></ul></li></ol><h5 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h5><p><strong>BIO 属于同步阻塞 IO 模型 。</strong></p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。</p><p> <img src="/images/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8C%97.assets/1624285967500-eb053522-effc-475a-a1dc-eb410d76f572.png" alt="img"></p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h5 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h5><p>Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>跟着我的思路往下看看，相信你会得到答案！</p><p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="F:\面试指北\面试指北.assets\1624285967455-d13860a6-06cb-4397-ac09-ca3789187e1a.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的</strong>。</p><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="F:\面试指北\面试指北.assets\1624285967508-983b174a-58dd-4327-b345-8027a3f42a21.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持</p><ul><li>select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li>epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/javajob.assets/1624285967445-1152e468-bef7-4d9a-924b-4ef3dad343e0.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h5><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/javajob.assets/1624285967551-d3b2369c-21de-4c90-9777-928091acb617.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/面试指北.assets/1624285968982-79ae67ec-fef4-4dc9-8b65-80d1830a78c4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="15-反射用途和实现原理"><a href="#15-反射用途和实现原理" class="headerlink" title="15. 反射用途和实现原理"></a>15. 反射用途和实现原理</h2><p>反射是通过<strong>运行时</strong>检查类信息完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls = ClassName.class;</span><br><span class="line">Class&lt;?&gt; cls = obj.getClass();</span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">"ClassName"</span>);</span><br></pre></td></tr></table></figure><p>原理：反射API实现，Class，Method，Field，Constructor</p><h3 id="Class-forName和ClassLoader的区别"><a href="#Class-forName和ClassLoader的区别" class="headerlink" title="Class.forName和ClassLoader的区别"></a>Class.forName和ClassLoader的区别</h3><ul><li>Class.forName是一个<strong>静态</strong>方法，通过提供类的完全限定名，在运行时加载类。此方法还会执行类的静态初始化块。如果类名不存在或无法访问，将抛出ClassNotFoundException异常。</li><li>ClassLoader<strong>是一个抽象类，类加载器</strong>，负责将类文件加载到Java虚拟机中。ClassLoader可以<strong>动态加载类</strong>，从不同来源加载类文件，如本地文件系统、网络等。</li></ul><h2 id="16-可重入锁是什么？解释ReentrantLock和sychronized的区别"><a href="#16-可重入锁是什么？解释ReentrantLock和sychronized的区别" class="headerlink" title="16. 可重入锁是什么？解释ReentrantLock和sychronized的区别"></a>16. 可重入锁是什么？解释ReentrantLock和sychronized的区别</h2><p>可重入锁是允许重新获取机制的锁。就像拿钥匙开锁一样，你可以反复用同一把钥匙开锁。这种锁在同一线程内是安全的，因为它可以被同一线程多次获取，而不会产生不一致的状态。<br>举个例子，假设有一个线程A在执行一个方法，同时这个方法内部又调用另一个方法，那么线程A可以重复获取同一个锁，而不会出现死锁的情况。因为同一线程可以多次获取同一个锁，所以这种锁机制避免了死锁的发生。<br>但是需要注意，在使用可重入锁时，必须保证在释放锁之前已经获取了该锁，否则会导致死锁。同时还需要保证在获取锁的时候没有嵌套地获取其他锁，否则也会导致死锁。另外，还必须保证在获取锁的时候没有阻塞其他线程，否则同样会导致死锁。<br>总之，可重入锁是一种安全的锁机制，可以避免死锁的发生。但是在使用时需要注意以上几点，以确保程序的正确性和安全性。</p><ul><li><strong>实现上</strong>：synchronized 是一个关键字，是在JVM层面通过监视器实现的，而 ReentrantLock 是基于AQS（AbstractQueuedSynchronizer）实现的。</li><li><strong>用法上</strong>：reentrantlock修饰代码块，synchronized修饰方法，静态方法和代码块</li><li><strong>显隐式</strong>：Synchronized 是隐式锁，进入synchronized代码块之后自动加锁，离开后自动释放锁；ReentrantLock显示定义，然后手动用lockunlock</li><li><strong>中断响应</strong>：sync不能直接响应终端，reentrantlock可以响应中断，避免死锁<h2 id="17-java序列化讲一下"><a href="#17-java序列化讲一下" class="headerlink" title="17. java序列化讲一下"></a>17. java序列化讲一下</h2>指将Java对象转换为字节流的过程，可以将这些字节流保存到文件中或通过网络传输。使用implements Serializable接口<h2 id="18-notify-和-notifyall-的区别"><a href="#18-notify-和-notifyall-的区别" class="headerlink" title="18. notify()和 notifyall()的区别"></a>18. notify()和 notifyall()的区别</h2></li><li>notify方法用于唤醒在当前对象上等待的单个线程,具体是哪个线程被唤醒是不确定的，取决于线程调度器的实现</li><li>notifyall 用于唤醒在当前对象上等待的所有线程。<ul><li>如果有多个线程在某个对象上等待，调用notifyAll()方法后，所有等待的线程都会被唤醒并竞争该对象的锁。其中一个线程获得锁后继续执行，其他线程则继续等待。<h2 id="19-静态内部类和非静态内部类"><a href="#19-静态内部类和非静态内部类" class="headerlink" title="19. 静态内部类和非静态内部类"></a>19. 静态内部类和非静态内部类</h2></li></ul></li></ul><ol><li>实例化方式：静态内部类可以直接通过外部类名来实例化，而非静态内部类必须要通过外部类的实例来实例化。</li><li>对外部类的引用：静态内部类不持有对外部类实例的引用，而非静态内部类则会持有对外部类实例的引用。这意味着在静态内部类中不能直接访问外部类的非静态成员（方法或字段），而非静态内部类可以。</li><li>生命周期：静态内部类的生命周期与外部类相互独立，即使外部类实例被销毁，静态内部类仍然存在。非静态内部类的生命周期与外部类实例绑定，只有在外部类实例存在时才能创建非静态内部类的实例。</li><li>访问权限：静态内部类对外部类的访问权限与其他类一样，根据访问修饰符而定。非静态内部类可以访问外部类的所有成员，包括私有成员<h2 id="20-自定义注解的场景和实现"><a href="#20-自定义注解的场景和实现" class="headerlink" title="20. 自定义注解的场景和实现"></a>20. 自定义注解的场景和实现</h2></li><li>扩展框架</li><li>运行时检查，单元测试，配和写Log等</li><li>规范约束<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h3></li><li>使用@interface关键字定义注解。</li><li>可在注解中定义属性，并指定默认值。</li><li>根据需求，可添加元注解来控制注解的使用方式。</li><li>在代码中使用自定义注解。</li><li>使用反射机制解析注解信息。<h2 id="21-java的构造器能否被重写-override【不可以，只能在子类super父类进行增量更改】"><a href="#21-java的构造器能否被重写-override【不可以，只能在子类super父类进行增量更改】" class="headerlink" title="21. java的构造器能否被重写 override【不可以，只能在子类super父类进行增量更改】"></a>21. java的构造器能否被重写 override【不可以，只能在子类super父类进行增量更改】</h2></li></ol><h2 id="22-java实现对象克隆【深拷贝浅拷贝】"><a href="#22-java实现对象克隆【深拷贝浅拷贝】" class="headerlink" title="22. java实现对象克隆【深拷贝浅拷贝】"></a>22. java实现对象克隆【深拷贝浅拷贝】</h2><ol><li>浅拷贝：通过创建一个新对象，并将原对象的非静态字段值复制给新对象实现。新对象和原对象共享引用数据。在Java中，可以使用clone()方法实现浅拷贝。要实现一个类的克隆操作，需要满足以下条件<ul><li>实现Cloneable接口。</li><li>重写Object类的clone()方法，声明为public访问权限。</li><li>在clone()方法中调用super.clone()，并处理引用类型字段。</li></ul></li><li>深拷贝：通过创建一个新对象，并将原对象的所有字段值复制给新对象，包括引用类型数据。新对象和原对象拥有独立的引用数据。实现深拷贝有以下方式：<ul><li>使用序列化和反序列化实现深拷贝，要求对象及其引用类型字段实现Serializable接口。</li><li>自定义拷贝方法，递归拷贝引用类型字段。<h2 id="23-java中常见的运行时异常"><a href="#23-java中常见的运行时异常" class="headerlink" title="23. java中常见的运行时异常"></a>23. java中常见的运行时异常</h2></li></ul></li><li>空指针异常：当应用程序尝试使用 null 对象时抛出。</li><li>数组越界异常：当应用程序尝试访问数组元素的时候，数组下标超出了数组的范围。</li><li>类转换异常：当应用程序尝试将一个对象强制转换为不是其实例的子类时抛出。</li><li>非法参数异）：当应用程序传递了一个无效或不合法的参数时抛出。</li><li>非法状态异常：当应用程序调用了一个不合适的方法或处于不正确的状态时抛出<h2 id="24-synchronized的实现原理是什么"><a href="#24-synchronized的实现原理是什么" class="headerlink" title="24. synchronized的实现原理是什么"></a>24. synchronized的实现原理是什么</h2>通过互斥锁来控制线程对共享变量的访问。</li><li>synchronized的实现基础是对象内部的锁（也称为监视器锁或管程），每个锁关联着一个对象实例。</li><li>当synchronized作用于某个对象时，它就会尝试获取这个对象的锁，如果锁没有被其他线程占用，则当前线程获取到锁，并可以执行同步代码块；如果锁已经被其他线程占用，那么当前线程就会阻塞在同步块之外，直到获取到锁才能进入同步块。</li><li>synchronized还支持作用于类上，此时它锁住的是整个类，而不是类的某个实例。在这种情况下，由于只有一个锁存在，所以所有使用该类的线程都需要等待锁的释放。</li><li>在JVM内部，每个Java对象都有头信息，其中包含了对象的一些元信息和状态标志。synchronized通过修改头信息的状态标志来实现锁的获取和释放。</li><li>synchronized还支持<strong>可重入性，即在同一个线程中可以多次获取同一个锁，这样可以避免死锁问题</strong>。</li><li>Java虚拟机会通过锁升级的方式来提升synchronized的效率，比如偏向锁、轻量级锁和重量级锁等机制，使得在竞争不激烈的情况下，synchronized的性能可以达到与非同步代码相当的水平。<h2 id="25-ThreadLocal和场景和原理"><a href="#25-ThreadLocal和场景和原理" class="headerlink" title="25. ThreadLocal和场景和原理"></a>25. ThreadLocal和场景和原理</h2></li><li>为每个线程创建独立的变量副本，避免竞争状态，代码层面的体验是一定程度上简化了多线程设计</li><li>原理是每个线程都有自己的threadlocalmap，<strong>ThreadLocal 对象充当键，线程的变量副本作为对应键的值</strong>，set get进行资源设置和获取<h3 id="注意避坑【内存泄漏，线程安全性，数据隔离】"><a href="#注意避坑【内存泄漏，线程安全性，数据隔离】" class="headerlink" title="注意避坑【内存泄漏，线程安全性，数据隔离】"></a>注意避坑【内存泄漏，线程安全性，数据隔离】</h3><h3 id="应用场景【线程池，数据库连接管理，传递上下文信息】"><a href="#应用场景【线程池，数据库连接管理，传递上下文信息】" class="headerlink" title="应用场景【线程池，数据库连接管理，传递上下文信息】"></a>应用场景【线程池，数据库连接管理，传递上下文信息】</h3><h3 id="如何防止内存泄漏"><a href="#如何防止内存泄漏" class="headerlink" title="如何防止内存泄漏"></a>如何防止内存泄漏</h3></li></ol><ul><li>内存泄漏是由于 ThreadLocalMap 中的 Entry 没有被及时清理导致的</li></ul><ol><li>使用完 ThreadLocal 后及时调用 remove() 方法</li><li>使用 try-with-resources 或 try-finally 块，在finally释放资源</li><li>使用InheritableThreadLocal<h2 id="26-BigDecimal避坑"><a href="#26-BigDecimal避坑" class="headerlink" title="26. BigDecimal避坑"></a>26. BigDecimal避坑</h2></li><li>使用浮点数初始化时，使用valueOf()，而不是使用new Bigdecimal()：valueof()内部先转换string再初始化</li><li>使用equals时，精度（scale）不同也返回false；使用compareTo方法，-1小于，0等于，1大于</li><li>divide时，指定一个结果精度，避免无限循环抛出arith异常；使用RoundingMode类选四舍五入等<h2 id="27-阻塞队列BQ，类似于channel"><a href="#27-阻塞队列BQ，类似于channel" class="headerlink" title="27. 阻塞队列BQ，类似于channel"></a>27. 阻塞队列BQ，类似于channel</h2></li></ol><ul><li>特点1:队列为空，读进程阻塞</li><li>特点2:队列为满，写进程阻塞</li></ul><ol><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>PriorityBlockingQueue<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3></li><li>生产消费者模型</li><li>线程池任务队列</li><li>线程同步问题：goroutine，多个线程可以共享一个阻塞队列<h2 id="28-守护线程和普通线程的区别"><a href="#28-守护线程和普通线程的区别" class="headerlink" title="28. 守护线程和普通线程的区别"></a>28. 守护线程和普通线程的区别</h2><h2 id="29-启动线程使用start，而不是用run"><a href="#29-启动线程使用start，而不是用run" class="headerlink" title="29. 启动线程使用start，而不是用run"></a>29. 启动线程使用start，而不是用run</h2></li><li>start方法告诉jvm新建了一个线程，并在新线程中执行与run方法相关联的代码块</li><li>run方法仅是一个方法调用，没有新线程创建<h2 id="30-java的线程如何通信"><a href="#30-java的线程如何通信" class="headerlink" title="30. java的线程如何通信"></a>30. java的线程如何通信</h2></li><li>共享内存：使用volatile保证共享变量的可见性</li><li>消息传递：消息队列/管道/信号量<h2 id="31-线程调度算法【抢占式算法】"><a href="#31-线程调度算法【抢占式算法】" class="headerlink" title="31. 线程调度算法【抢占式算法】"></a>31. 线程调度算法【抢占式算法】</h2>线程优先级是如何设定的？<h2 id="32-死锁与活锁，饥饿是什么"><a href="#32-死锁与活锁，饥饿是什么" class="headerlink" title="32. 死锁与活锁，饥饿是什么"></a>32. 死锁与活锁，饥饿是什么</h2></li><li><strong>死锁</strong>是进程间互斥且一直等待对方释放资源，都无法继续执行的情况</li><li><strong>活锁</strong>是运行状态下，多个线程不断地改变自己的状态以回应对方，但最终无法取得进展，导致线程不断重试相同的操作，却无法成功</li><li><strong>饥饿</strong>,一个比较宽泛的概念，指一个或多个线程或进程由于某种原因无法获得所需的资源或执行机会</li></ol><h2 id="33-什么时候进入waiting状态"><a href="#33-什么时候进入waiting状态" class="headerlink" title="33. 什么时候进入waiting状态"></a>33. 什么时候进入waiting状态</h2><ol><li>等待获取锁的时候</li><li>等待IO时</li><li>使用Object.wait()方法，等待其他线程调用同对象的notify和notifyall方法唤醒</li><li>使用Thread.join()，使当前线程等待目标线程的结束，目标线程结束后，当前线程被唤醒</li><li>使用LockSupport.park()，使当前线程等待，直到获取LockSupport指定的许可或者线程被中断、调度。<h3 id="为什么wait和notify要在同步块中调用"><a href="#为什么wait和notify要在同步块中调用" class="headerlink" title="为什么wait和notify要在同步块中调用"></a>为什么wait和notify要在同步块中调用</h3></li></ol><p><strong>同步块提供了互斥性</strong></p><ul><li>希望同一时刻只有一个线程能执行wait/notify，避免并发修改问题，不在互斥时进行wait/notify会导致错误的上下文，还有导致竞争状态<h2 id="36-自动拆箱导致的-空指针-问题"><a href="#36-自动拆箱导致的-空指针-问题" class="headerlink" title="36. 自动拆箱导致的 空指针 问题"></a>36. 自动拆箱导致的 空指针 问题</h2>数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险.<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/javajob.assets/51eb094e11b71dfeff75f93e99dc7856.png" alt title>                </div>                <div class="image-caption"></div>            </figure>减少自动拆箱问题<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/javajob.assets/10f950d32f14aa81d0677156837572c5.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="35-线程安全如何实现【加锁，原子操作，ThreadLocal减少共享资源，线程安全的设计模式】"><a href="#35-线程安全如何实现【加锁，原子操作，ThreadLocal减少共享资源，线程安全的设计模式】" class="headerlink" title="35. 线程安全如何实现【加锁，原子操作，ThreadLocal减少共享资源，线程安全的设计模式】"></a>35. 线程安全如何实现【加锁，原子操作，ThreadLocal减少共享资源，线程安全的设计模式】</h2><ul><li>线程安全的设计模式：使用单例模式中的双重检查锁定<br>实现，其实就是线程安全的singleton<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="34-三个线程如何顺序执行"><a href="#34-三个线程如何顺序执行" class="headerlink" title="34. 三个线程如何顺序执行"></a>34. 三个线程如何顺序执行</h2><ol><li>思路是2等1的锁，3等2的锁，1等3的锁。实现用join和LockSupport的park和unpark方法。</li><li>CountDownLatch。设置初始计数为 2，分别在 T1 和 T2 的线程内等待计数器减少到 0，然后释放 T3 线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Thread T1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 线程 T1 的任务</span></span><br><span class="line">&#125;);</span><br><span class="line">Thread T2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T1.join(); <span class="comment">// 等待 T1 执行完成</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程 T2 的任务</span></span><br><span class="line">&#125;);</span><br><span class="line">Thread T3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T2.join(); <span class="comment">// 等待 T2 执行完成</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程 T3 的任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>LockSupport</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Thread t2;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Thread t3;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"T1 is running."</span>);</span><br><span class="line">        LockSupport.unpark(t2); <span class="comment">// 唤醒线程T2</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LockSupport.park(); <span class="comment">// 阻塞线程T2</span></span><br><span class="line">        System.out.println(<span class="string">"T2 is running."</span>);</span><br><span class="line">        LockSupport.unpark(t3); <span class="comment">// 唤醒线程T3</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LockSupport.park(); <span class="comment">// 阻塞线程T3</span></span><br><span class="line">        System.out.println(<span class="string">"T3 is running."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch latch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">CountDownLatch latch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"T1 running."</span>);</span><br><span class="line">    latch1.countDown(); <span class="comment">// T1 执行完后释放 latch1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch1.await(); <span class="comment">// 等待 latch1 的释放</span></span><br><span class="line">      System.out.println(<span class="string">"T2 running."</span>);</span><br><span class="line">        latch2.countDown(); <span class="comment">// T2 执行完后释放 latch2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch2.await(); <span class="comment">// 等待 latch2 的释放</span></span><br><span class="line">      System.out.println(<span class="string">"T3 running."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ook&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://waynamigo.github.io/categories/Java/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java" scheme="http://waynamigo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java collection</title>
    <link href="http://waynamigo.github.io/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E9%9B%86%E5%90%88/"/>
    <id>http://waynamigo.github.io/2023/01/10/2023-01-10-面经Java集合/</id>
    <published>2023-01-09T16:00:00.000Z</published>
    <updated>2023-10-30T17:25:46.682Z</updated>
    
    <content type="html"><![CDATA[<p>ok</p><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li>List<ul><li>ArrayList: Object[]</li><li>Vector: Object[]</li><li>LinkedList: 双向链表</li></ul></li><li>Set<ul><li>HashSet(无序，唯一): 底层采用 HashMap 来保存元素-</li><li>LinkedHashSet: HashSet 的子类，通过 LinkedHashMap 来实现的</li><li>TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul></li><li>Queue<ul><li>PriorityQueue: Object[] 数组实现二叉堆</li><li>ArrayQueue: Object[] 数组+双指针<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2></li></ul></li><li>HashMap<ul><li>开始是链表，链表长度大于阈值8，进行扩容，当容量大于64时，变成红黑树</li></ul></li><li>LinkedHashMap<ul><li>在HashMap的基础上，增加了一条双向链表，保持KV的插入顺序</li></ul></li><li>Hashtable<ul><li>数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的</li></ul></li><li>TreeMap：红黑树<h2 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h2></li></ul><ol><li>保证线程安全的手段？Concurrent修饰的Map等</li><li>持续更新</li></ol><h2 id="List实现"><a href="#List实现" class="headerlink" title="List实现"></a>List实现</h2><h3 id="ArrayList-和-Array-的区别"><a href="#ArrayList-和-Array-的区别" class="headerlink" title="ArrayList 和 Array 的区别"></a>ArrayList 和 Array 的区别</h3><ul><li>一个动态数组和静态数组</li><li>区别类似于go语言和python的slice实现</li></ul><ol><li>声明时不需要指定大小，动态扩容</li><li>支持泛型</li><li>支持插入、更改、删除<br>【面试题】说说ArrayList的扩容机制</li></ol><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h3><ul><li>ArrayList线程不安全</li><li>Vector使用了synchronized关键字保证线程安全<h3 id="Vector-和-Stack-的区别"><a href="#Vector-和-Stack-的区别" class="headerlink" title="Vector 和 Stack 的区别"></a>Vector 和 Stack 的区别</h3>Vector 和 Stack 已经被淘汰，推荐使用并发集合类</li></ul><ol><li>ConcurrentHashMap、CopyOnWriteArrayList等，</li><li>或者手动实现线程安全的方法来提供安全的多线程操作支持。</li></ol><h3 id="ArrayList-可以添加-null-值吗？"><a href="#ArrayList-可以添加-null-值吗？" class="headerlink" title="ArrayList 可以添加 null 值吗？"></a>ArrayList 可以添加 null 值吗？</h3><p>ArrayList 中可以存储任何类型的对象，包括 null 值。不过，不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p><h2 id="Set实现"><a href="#Set实现" class="headerlink" title="Set实现"></a>Set实现</h2><h3 id="Comparable-和-Comparator-的区别：都是用于排序"><a href="#Comparable-和-Comparator-的区别：都是用于排序" class="headerlink" title="Comparable 和 Comparator 的区别：都是用于排序"></a>Comparable 和 Comparator 的区别：都是用于排序</h3><ul><li>Comparable 接口实际上是出自 java.lang 包 它有一个 compareTo(Object obj)方法用来排序</li><li>Comparator 接口实际上是出自 java.util 包 它有一个 compare(Object obj1, Object obj2)方法用来排序</li><li>需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法</li></ul><h2 id="Queue实现"><a href="#Queue实现" class="headerlink" title="Queue实现"></a>Queue实现</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><ul><li>Queue是单端队列，遵循先进先出（FIFO）规则</li><li>Deque 是双端队列，在队列的两端均可以插入或删除元素</li></ul><h3 id="PriorityQueue实现：默认最小二叉堆"><a href="#PriorityQueue实现：默认最小二叉堆" class="headerlink" title="PriorityQueue实现：默认最小二叉堆"></a>PriorityQueue实现：默认最小二叉堆</h3><ul><li>P利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。</li><li>PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</li><li>PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</li></ul><p>手撕一个priorityqueue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><ul><li>支持当队列没有元素时一直阻塞，用于生产者消费者模型</li><li>生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理</li></ul><p><strong>ArrayBlockingQueue</strong> 和 <strong>LinkedBlockingQueue</strong> 是 Java 并发包中常用的两种阻塞队列实现</p><ul><li>都线程安全，Array底层用的固定数组，Linked底层用的链表，也是扩容机制</li><li>ArrayBlockingQueue 生产和消费用的是同一个锁</li><li>LinkedBlockingQueue 生产用putLock，消费用的takelock，防止生产者和消费者线程之间的锁争夺</li></ul><h2 id="Map实现"><a href="#Map实现" class="headerlink" title="Map实现"></a>Map实现</h2><h3 id="HashMap-和-Hashtable-淘汰-的区别"><a href="#HashMap-和-Hashtable-淘汰-的区别" class="headerlink" title="HashMap 和 Hashtable(淘汰) 的区别"></a>HashMap 和 Hashtable(淘汰) 的区别</h3><ul><li><p>HashMap 是线程不安全的，线程安全版ConcurrentHashMap</p></li><li><p>Hashtable 是线程安全的</p></li><li><p>HashMap 可以存储 null 的 kv，但 null 作为键只能有一个，null 作为值可以多个</p></li><li><p>Hashtable 不允许有 null 键和 null 值，否则会抛NullPointerException<br>HashMap的构造函数以及扩容函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul><li>HashSet如何检查重复的： 底层使用HashMap<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h3><ul><li>hash()函数,拉链法解决冲突<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h3><ul><li>jdk1.7前，HashMap 扩容时会造成死循环和数据丢失的问题</li><li>jdk1.8后，多个kv可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 HashMap 的 put 操作会导致线程不安全，具体来说会有数据覆盖的风险。<h3 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h3><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw</a></li><li>结论，尽量使用 entrySet 来实现 Map 集合的遍历</li><li>不能再在遍历中使用集合 map.remove() 来删除数据，这是非安全的操作方式</li><li>但可以使用迭代器的 iterator.remove() 的方法来删除数据，这是安全的删除集合的方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">"Java"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">"JDK"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"Spring Framework"</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">"MyBatis framework"</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">"Java中文社群"</span>);</span><br><span class="line">        <span class="comment">// 迭代器 entrySet 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator =</span><br><span class="line">            map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器 keySet 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Integer key = iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for-each  遍历 entrySet()</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for-each  遍历 keySet()</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Lambda表达式</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Streams API 单线程</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Streams API 多线程</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ok&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://waynamigo.github.io/categories/Java/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Java" scheme="http://waynamigo.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>分布式理论</title>
    <link href="http://waynamigo.github.io/2023/01/06/2023-01-06-%E9%9D%A2%E7%BB%8F%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    <id>http://waynamigo.github.io/2023/01/06/2023-01-06-面经分布式/</id>
    <published>2023-01-05T16:00:00.000Z</published>
    <updated>2023-12-07T18:08:08.771Z</updated>
    
    <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h2 id="如何设计一个高并发系统"><a href="#如何设计一个高并发系统" class="headerlink" title="如何设计一个高并发系统"></a>如何设计一个高并发系统</h2><ol><li>高并发系统的目的是处理网络请求和数据的关系，瓶颈主要在内存，网络IO </li><li></li></ol><h2 id="如何解决10万非结构化数据查询请求"><a href="#如何解决10万非结构化数据查询请求" class="headerlink" title="如何解决10万非结构化数据查询请求"></a>如何解决10万非结构化数据查询请求</h2><p>这个问题要解决的主要是网络IO和非结构化存储的瓶颈问题。</p><ol><li>首先数据库要支持非结构化的存储比如使用MongoDB的文档存储使用gridFS进行分布式存储</li><li>然后对于每秒的十万的网络请求，最常见的方法，以及目前的主流方法是拆分微服务，使用负载均衡策略将请求有效分发到不同</li><li>对于数据的存储和查询，现在主流也是分布式数据库，比如ES和MongoDB，PG的集群都可以创建非结构化数据的索引，在业务逻辑中优化sql查询语句等</li><li>使用redis做缓存，对于某些大型的非结构化数据，可以使用cdn去存储静态资源</li></ol><h2 id="如果是百台以内的机器"><a href="#如果是百台以内的机器" class="headerlink" title="如果是百台以内的机器"></a>如果是百台以内的机器</h2><ol><li>常用的有两种方便的方法，一个是fabric多个ssh同步文件，这也是阿里云和百度云针对个人用户提供的一种解决方案</li><li>配置集群以后，rsync同步一个文件夹下的某个文件。<h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1></li></ol><p><strong>Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性）</strong></p><h1 id="raft理论"><a href="#raft理论" class="headerlink" title="raft理论"></a>raft理论</h1><h2 id="leader选举、日志复制、日志压缩、成员变更"><a href="#leader选举、日志复制、日志压缩、成员变更" class="headerlink" title="leader选举、日志复制、日志压缩、成员变更"></a>leader选举、日志复制、日志压缩、成员变更</h2><ol><li>Leader Selection</li></ol><p>Raft使用 (心跳机制)来触发选举。当server节点启动时，初始状态都是 follower。每一个server都有一个定时器，超时时间为 (时间长 度一般为150ms~300ms)，如果某server没有超时的情况下收到来自leader或者 candidate的任何RPC，则定时器重启，如果超时，它就开始一次选举。leader给 followers发RPC要么复制日志，要么就是用来告诉followers自己是leader，不用选举的 心跳(告诉followers对状态机应用日志的消息夹杂在心跳中)。如果某个candidate获 得了超过半数节点的选票(自己投了自己)，就称为新leader</p><h3 id="如果leader节点出现了故障"><a href="#如果leader节点出现了故障" class="headerlink" title="如果leader节点出现了故障"></a>如果leader节点出现了故障</h3><p>用raft共识算法来做的</p><ol start="2"><li>Log Relocation</li></ol><p>leader 在每个 heartbeat 向 follower 发送AppendEntries RPC同步日志，follower如果发现没问题，复制成功后会 给leader一个表示成功的ACK，leader收到超过半数的ACK后应用该日志，返回客户 端执行结果。若 follower 节点宕机、运行缓慢或者丢包，则 leader 节点会不断重试 AppendEntries RPC，直到所有 follower 节点最终都复制所有日志条目。</p><p>乐观锁：<br>每个对象有一个版本号或者时间戳，当对象被修改时，版本号会更新。在提交更新时，检查版本号是否匹配，如果不匹配则说明有冲突发生，需要进行相应的处理。<br>悲观锁：<br>在操作对象时，先锁定该对象，其他用户无法修改该对象直到锁被释放。这种方法可以保证同时只有一个用户能够修改对象，但可能会导致并发性能下降。</p><ol><li>服务注册与发现 consul</li><li>负载均衡，consul，用wrr算法实现的</li><li>APi网关 gateway</li><li>熔断器 circuitbreaker<h2 id="raft算法流程"><a href="#raft算法流程" class="headerlink" title="raft算法流程"></a>raft算法流程</h2>Raft算法分为两个阶段，首先是选举过程，然后在选举出来的领导人带领进行正常操作，主要用于管理复制日志的一致性算法。<br>Raft算法三模块：领导人选举、日志复制、安全性。<br>领导人Leader选举<br>Raft通过选举一个领导人，然后给予他全部的管理复制日志的责任来实现一致性。<br>三个角色(任何服务器都可以当三个角色之一)：<br>领导者(leader)：处理客户端交互，日志复制等动作，一般一次只有一个领导者<br>候选者(candidate)：候选者就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者<br>跟随者(follower)：类似选民，完全被动的角色，这样的服务器等待被通知投票<br>理解：当服务启动的时候，所有服务器follower都是初始状态，每个服务器都有一个定时器，超时时间为election timeout（一般为150-300ms），当某个服务器达到超时时间，他就成为了候选者，先给自己投上一票，然后发送消息给其他服务器，当其他服务器超过半数收到了他的消息，相当于获取到了选票，他就成了领导者，而其他服务器全部成了跟随者，这时候领导者就开始根据间隔时间向跟随者发送心跳检测包，证明我还活在，也就是心跳机制，而跟随者每次接受到消息，就初始化自己内部的定时器，当某个服务器定时器达到超时时间，没有收到领导者的消息，那么跟随者会觉得领导者挂了，他就摇身一变称为候选者，开始篡位，重复之前的过程，成为领导者，当他成为领导者之后，当前任领导者就算回来了，也只能变成跟随者。<br>特殊情况：四个服务器，当其中两个服务器同时达到超时成为候选者，并且每个服务器拿到自己一票，另外一个服务器一票，这时候的机制就是这两个服务器重新定时，先达到超时的服务器成为候选者，并发送通知进一步成为选举者。</li></ol><p>日志复制（保证数据一致性）<br>Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条 日志应用到它的状态机并向客户端返回执行结果。<br>1）客户端的每一个请求都包含被复制状态机执行的指令。<br>2）leader把这个指令作为一条新的日志条目添加到日志中，然后并行发起 RPC 给其他的服务器，让他们复制这条 信息。<br>3）跟随者响应ACK,如果 follower 宕机或者运行缓慢或者丢包，leader会不断的重试，直到所有的 follower 最终都 复制了所有的日志条目。<br>4）通知所有的Follower提交日志，同时领导人提交这条日志到自己的状态机中，并返回给客户端。</p><h2 id="分布式session怎么做的，常用的"><a href="#分布式session怎么做的，常用的" class="headerlink" title="分布式session怎么做的，常用的"></a>分布式session怎么做的，常用的</h2><p>java有apach shiro这两个中间件有session管理器，它是配置redis共享缓存的服务器中的，使用的是RedisSessionDAO层。</p><p>golang有casbin+redis的共享缓存来实现分布式session管理</p><h2 id="身份认证和权限管理"><a href="#身份认证和权限管理" class="headerlink" title="身份认证和权限管理"></a>身份认证和权限管理</h2><p><a href="https://zhuanlan.zhihu.com/p/150644469" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/150644469</a></p><p><a href="https://www.cnblogs.com/alisapine/p/15080359.html" target="_blank" rel="noopener">https://www.cnblogs.com/alisapine/p/15080359.html</a></p><h2 id="分布式事务和分布式锁"><a href="#分布式事务和分布式锁" class="headerlink" title="分布式事务和分布式锁"></a>分布式事务和分布式锁</h2><ul><li><p>分布式锁<br>通常用于控制多个节点或进程之间对共享资源的并发访问，以避免竞态条件和数据损坏。</p></li><li><p>分布式事务<br>通常涉及多个事务性操作后的一致性，如数据库更新、消息发布等，需要确保这些操作在分布式系统中以事务的方式执行。 </p></li></ul><h2 id="场景问题集合"><a href="#场景问题集合" class="headerlink" title="场景问题集合"></a>场景问题集合</h2><p>一个外卖平台上有一个外卖单子，现在有多名骑手想接这一单，如何保证只有一个骑手可以接到单子？<br>如何把一个文件快速下发到100w个服务器？<br>给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的?<br>典型TOPk系列的问题：10亿个数，找出最大的10个。等(10万个数，输出从小到大？有十万个单词，找出重复次数最高十个？)<br>让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。<br>分布式多个机器生成id，如何保证不重复?<br>扫码登录是如何实现的？<br>分布式集群中如何保证线程安全？<br>某网站/app首页每天会从10000个商家里面推荐50个商家置顶，每个商家有一个权值，你如何来推荐？第二天怎么更新推荐的商家？<br>如何设计一个本地缓存？需要考虑哪些方面？</p><h2 id="项目开放性问题"><a href="#项目开放性问题" class="headerlink" title="项目开放性问题"></a>项目开放性问题</h2><p>1、找个印象最深的项目说说？(简历中不止一个项目)<br>2、你项目中遇到的最大的问题是什么？你是怎么解决的？<br>3、你项目中用到的技术栈是如何学习的？<br>4、为什么做这个项目，技术选型为什么是这样的？<br>5、登录怎么做的？单点登录说说你的理解？<br>6、项目遇到的最大挑战是什么？(类似问题2)<br>7、说说项目中的闪光点和亮点？<br>8、项目怎么没有尝试部署上线呢？<br>9、介绍项目具体做了什么？(项目背景)<br>10、如果让你对这个项目优化，你会从哪几个点来优化呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; questions&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://waynamigo.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="分布式" scheme="http://waynamigo.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Project</title>
    <link href="http://waynamigo.github.io/2023/01/06/2023-01-06-%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE/"/>
    <id>http://waynamigo.github.io/2023/01/06/2023-01-06-面试项目/</id>
    <published>2023-01-05T16:00:00.000Z</published>
    <updated>2023-11-19T01:08:49.566Z</updated>
    
    <content type="html"><![CDATA[<p>嘴太笨了</p><a id="more"></a><h2 id="Go数字孪生"><a href="#Go数字孪生" class="headerlink" title="Go数字孪生"></a>Go数字孪生</h2><p>项目背景：企业合作项目。负责设计开发数据采集与指令下发模块，实现车间物理设备与Unity模拟软件的实时状态映射。</p><p>这个项目是老师和<strong>科大讯飞与农科信创</strong>这个公司合作的一个数字化管理系统，这个项目虽然叫数字孪生但是您可以把它当作一个游戏前端+共享文档来看，客户端程序我们用的unity开发的，农科信创提供的了数字资产和传感器，科大讯飞提供了一部分深度学习模型，做的事包括产量预估、病虫害表型鉴定、采摘车的三维图像定位（通过ROS控制）、异常人员检测，这个项目我做的事就基于go做的后端，一个是监听、收集和预处理数据发送到模型端，一个是提供给unity接口支持多个用户去操作边缘设备（调整温度光照，要更改采摘车的采摘顺序），将模型处理后的统计数据、实体状态呈现给前端。</p><p>项目难点：根据传感器文档构建指令，指令是通过状态写入协议来进行的；处理多个用户操作同一个对象的冲突问题。</p><!-- ： 传感器数据发送到预测模型，处理的结果上传数据库，用户在unity客户端的指令，我要发送到边缘设备上更改前端unity可视化的作用。 --><ul><li>后端主要基于Gin和Zinx开发，连接Unity端收发实时数据，提供用户控制端Web服务接口</li><li>使用gRPC对序列化后的对象消息进行流式传输，保证服务器端与Unity端的高效同步</li><li>使用MongoDB存储服务器端的统计数据、历史设备指令与数字工厂状态的日志文件提供历史状态查询与回滚操作</li></ul><ol><li>gin做的是登陆认证、资产文件上分片上传/拉取功能，存储在mongodb，资产文件用gridFS。以及获取grpc通信的结构体解析成XML的功能，unity前端有一个功能是鼠标移动到实例上就有一个悬浮框显示所有属性</li><li>数据接收模块：传感器都是基于UDP的协议进行上传，频率有高有低，所以对一个传感器go了一个routine，在这个routine里接收解析所需的数据进行解析完，处理成结构体之后，用grpc的stream消息发到GPU服务器上部署的模型来处理。</li><li>用户在unity端的操作和指令下发是用zinx实现的，它是一个TCP长连接框架，然后服务器端去实现温度、土壤、种植区、采摘车这些实体对象与现实状态的同步，（比如控制土壤ph、二氧化碳浓度、控温、光谱开关、采摘车路线修正）包括位置、惯导的方位角，角速度线速度等（用MSO格式封装的报文），在用户端封装的控制指令以bytes的形式用zinx的DataPack封装，封装的控制指令转发到终端设备的service</li><li>如果有多个用户并发要对这个对象操作，在这个处理的goroutine中可能会造成冲突，我们维护了一个对象map，对这个map加锁处理，对于采摘车的话，是单独维护了一个处于三维坐标系下的对象。</li><li>用到channel的场景：一个预测服务中，对发送数据的goroutine是配套的，</li><li>历史状态查询的话，是根据mongo中存储各对象的历史状态，根据时间戳向前端的拉取。</li><li>是做用户在本地对传感器做操作后，连接的控制终端，比如采摘车的路径校准、和毫米波雷达的控制，主要包括DIFOP设备信息输出协议，用户配置写入协议UCWP</li><li>在服务器端连接mongodb，服务器数据收集、统计计算、上传数据库</li></ol><h2 id="Go-轻量聊天APP（Go-Kratos-GPT2）"><a href="#Go-轻量聊天APP（Go-Kratos-GPT2）" class="headerlink" title="Go 轻量聊天APP（Go/Kratos/GPT2）"></a>Go 轻量聊天APP（Go/Kratos/GPT2）</h2><p>项目角色：唯一贡献者<br>项目背景：该软件作为当时学习Go语言微服务框架与组件的个人练手项目。聊天以群组的形式进行，将基于GPT2的bot与聊天室服务拆分成微服务，主要包括用户信息服务、群组管理服务、消息传输服务、GPT会话存储服务四个。</p><ul><li>使用的微服务框架为Kratos，开发组件和工具主要包括Redis/Go-kit/Swagger</li><li>遵循微服务部署流程，微服务使用k8s部署，dlv调试工具，godoc自动化生成文档等</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户表</span><br><span class="line">用户id，密码，密码哈希值，salt</span><br><span class="line">群组表</span><br><span class="line">群组id, 用户id, 权限值</span><br><span class="line">聊天记录表</span><br><span class="line">key：userid, groupid,timestamp做的索引</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h2 id="用户信息服务"><a href="#用户信息服务" class="headerlink" title="用户信息服务"></a>用户信息服务</h2><ul><li>查看个人/他人信息功能</li><li>更改字段功能</li><li>增加删除(注销)功能<!-- - 登陆模块1：初始是获取MAC地址进行的，机器码和id作为key --></li><li>登陆模块：用户输入用户名、密码<ul><li>注册时提供密码，系统为用户生成唯一salt</li><li>将密码的字符串salt与原字符串拼接，得到hash</li><li>数据库存储 hash 和 salt</li><li>登陆时将字符串与salt连接后的到hash’，判断hash’ == hash</li><li>验证正确后，服务端使用jwt机制，进行API调用（库使用的jwt-go</li></ul></li><li>jwt优点<ul><li>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料</li><li>Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</li><li>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</li><li>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</li></ul></li></ul><h2 id="群组管理服务"><a href="#群组管理服务" class="headerlink" title="群组管理服务"></a>群组管理服务</h2><ul><li>邀请加入用户byID</li><li>踢出用户byID<h2 id="消息传输服务"><a href="#消息传输服务" class="headerlink" title="消息传输服务"></a>消息传输服务</h2></li><li>群组以聊天室为单位进行，一个聊天室对应一个Pod</li><li>主要包括ChatRoomClient和ChatRoomServer</li><li>ChatRoomClient 主要负责与前端通信和处理与当前用户相关的信息</li><li>ChatRoomServer 则负责维护所有在线用户信息以及处理消息的分发<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChatRoomClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    roomId <span class="keyword">int</span></span><br><span class="line">    user User </span><br><span class="line">    conn net.Conn <span class="comment">//与前端维持的通信连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ChatRoomServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    clients <span class="keyword">map</span>[<span class="keyword">string</span>]*ChatRoomClient <span class="comment">// 维护一个连接池</span></span><br><span class="line">    rooms   <span class="keyword">map</span>[<span class="keyword">string</span>][]*ChatRoomClient <span class="comment">// 用于维护聊天室与客户端的关系</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SendMessage 方法用于发送消息给聊天室</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChatRoomClient)</span> <span class="title">SendMessage</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    c.server.BroadcastMessage(c.RoomID, c.UserID, c.UserName, message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Disconnect 方法处理客户端断开连接的情况</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChatRoomClient)</span> <span class="title">Disconnect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.server.RemoveClient(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NewChatRoomServer 方法用于创建一个新的ChatRoomServer对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChatRoomServer</span><span class="params">()</span> *<span class="title">ChatRoomServer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ChatRoomServer&#123;</span><br><span class="line">        clients: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*ChatRoomClient),</span><br><span class="line">        rooms:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]*ChatRoomClient),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AddClient 方法将一个客户端添加到服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">AddClient</span><span class="params">(client *ChatRoomClient)</span></span> &#123;</span><br><span class="line">    s.clients[client.ConnectionID] = client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveClient 方法将一个客户端从服务器移除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">RemoveClient</span><span class="params">(client *ChatRoomClient)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s.clients, client.ConnectionID)</span><br><span class="line">    <span class="comment">// 在此处也可以将客户端从对应的聊天室中移除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JoinRoom 方法将一个客户端加入到指定聊天室中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">JoinRoom</span><span class="params">(client *ChatRoomClient, roomID <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.rooms[roomID] = <span class="built_in">append</span>(s.rooms[roomID], client)</span><br><span class="line">    client.RoomID = roomID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeaveRoom 方法将一个客户端从指定聊天室中移除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">LeaveRoom</span><span class="params">(client *ChatRoomClient, roomID <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    clients := s.rooms[roomID]</span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> clients &#123;</span><br><span class="line">        <span class="keyword">if</span> c.ConnectionID == client.ConnectionID &#123;</span><br><span class="line">            <span class="comment">// 从聊天室中移除客户端</span></span><br><span class="line">            s.rooms[roomID] = <span class="built_in">append</span>(clients[:i], clients[i+<span class="number">1</span>:]...)</span><br><span class="line">            client.RoomID = <span class="string">""</span> <span class="comment">// 将客户端的聊天室ID清空</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BroadcastMessage 方法向指定聊天室内的所有客户端广播消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">BroadcastMessage</span><span class="params">(roomID, userID, userName, message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    clients := s.rooms[roomID]</span><br><span class="line">    <span class="keyword">for</span> _, client := <span class="keyword">range</span> clients &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(client *ChatRoomClient)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 在协程中处理消息发送</span></span><br><span class="line">            client.SendMessage(userID, userName, message)</span><br><span class="line">        &#125;(client)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="消息传输的并发处理和消息分发问题是怎么解决的"><a href="#消息传输的并发处理和消息分发问题是怎么解决的" class="headerlink" title="消息传输的并发处理和消息分发问题是怎么解决的"></a>消息传输的并发处理和消息分发问题是怎么解决的</h3><p>消息发送时，一个客户端的sendmessage用一个goroutine进行</p><ul><li>可能出现的并发安全问题<ol><li>map互斥锁 在 ChatRoomServer 中的 rooms 和 clients 字典是共享的数据结构，多个goroutine可能会同时访问或修改这些数据结构，可能导致竞态条件（race condition）或数据不一致的问题。</li></ol></li></ul><h2 id="kratos进行微服务间的通信"><a href="#kratos进行微服务间的通信" class="headerlink" title="kratos进行微服务间的通信"></a>kratos进行微服务间的通信</h2><p>这些服务的通信都是一些很轻量的元数据，kratos的用protobuf定义的middleware</p><p>gRPC API 进行接口交互，服务架构需要使用统一的元信息（Metadata）传输进行微服务间的传递。 目前 gRPC 中可以携带元信息传递，原理是将元信息放入 HTTP Header 中，这样上游即可收到对应的元信息 信息。 因此在Kratos的设计上，也是通过 HTTP Header 进行传递。在框架中先将元信息包封装成key/value结构，然后携带到 Transport Header 中。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>创建一个 Registrar（以 consul 为例），将 Registrar 注入进 Kratos 应用实例中，Kratos 会自动完成实例注册和反注册</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    consul <span class="string">"github.com/go-kratos/kratos/contrib/registry/consul/v2"</span></span><br><span class="line">    <span class="string">"github.com/hashicorp/consul/api"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// new consul client</span></span><br><span class="line">client, err := api.NewClient(api.DefaultConfig())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new reg with consul client</span></span><br><span class="line">reg := consul.New(client)</span><br><span class="line"></span><br><span class="line">app := kratos.New(</span><br><span class="line">    <span class="comment">// service-name</span></span><br><span class="line">    kratos.Name(Name),</span><br><span class="line">    kratos.Version(Version),</span><br><span class="line">    kratos.Metadata(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;),</span><br><span class="line">    kratos.Logger(logger),</span><br><span class="line">    kratos.Server(</span><br><span class="line">        hs,</span><br><span class="line">        gs,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">// with registrar</span></span><br><span class="line">    kratos.Registrar(reg),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="用的是kratos的负载均衡器"><a href="#用的是kratos的负载均衡器" class="headerlink" title="用的是kratos的负载均衡器"></a>用的是kratos的负载均衡器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Selector <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// Selector 内部维护的服务节点列表通过 Rebalancer 接口来更新</span></span><br><span class="line">  Rebalancer</span><br><span class="line">  <span class="comment">// Select nodes</span></span><br><span class="line">  <span class="comment">// if err == nil, selected and done must not be empty.</span></span><br><span class="line">  Select(ctx context.Context, opts ...SelectOption) </span><br><span class="line">        (selected Node, done DoneFunc, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Rebalancer 实现服务节点变更感知</span></span><br><span class="line"><span class="keyword">type</span> Rebalancer <span class="keyword">interface</span> &#123;</span><br><span class="line">  Apply(nodes []Node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的默认的wrr算法 Weighted round robin</p><h2 id="rpc是什么-远程过程调用-和rmi的区别【RMI相当于RPC的一种实现】"><a href="#rpc是什么-远程过程调用-和rmi的区别【RMI相当于RPC的一种实现】" class="headerlink" title="rpc是什么 远程过程调用 和rmi的区别【RMI相当于RPC的一种实现】"></a>rpc是什么 远程过程调用 和rmi的区别【RMI相当于RPC的一种实现】</h2><ul><li><p>RPC (Remote Procedure Call) 采用客户端/服务器方式 (请求/响应)，发送请求到服务器端，服务端执行方法后返回结果。 优点是跨语言跨平台，缺点是编译期无法排错。返回的对象由外部数据表示</p></li><li><p>RMI (Remote Method Invocation) 客户端jvm调用服务端jvm的方法，直接获取远端方法的签名，进行调用。优点是强类型、编译期可检查错误；缺点是只限于java语言。返回的对象可以是java支持的所有对象名。</p></li></ul><p>RPC的代理类stub，将消息序列化为RPCrequest/RPCresponse</p><h2 id="RMI流程原理"><a href="#RMI流程原理" class="headerlink" title="RMI流程原理"></a>RMI流程原理</h2><ul><li><p>定义远程接口<code>interface Rmiiface extends Remote</code></p></li><li><p>实现一个远程接口类<code>MyRemoteObject implements Rmiiface</code></p></li><li><p>服务器端注册和查找远程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Rmiiface remoteObject = <span class="keyword">new</span> MyRemoteObject();</span><br><span class="line">            Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>); <span class="comment">// 默认 RMI 注册表端口号为 1099</span></span><br><span class="line">            registry.bind(<span class="string">"MyRemoteObject"</span>, remoteObject);</span><br><span class="line">            System.out.println(<span class="string">"Server is ready."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端查找注册表来获取远程方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>, <span class="number">1099</span>);</span><br><span class="line">            MyRemoteInterface remoteObject = (MyRemoteInterface) registry.lookup(<span class="string">"MyRemoteObject"</span>);</span><br><span class="line">            String response = remoteObject.sayHello();</span><br><span class="line">            System.out.println(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过JRMP协议来通信</p><h3 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h3><p>基于protobuf序列化协议的通讯协议</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嘴太笨了&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://waynamigo.github.io/categories/Golang/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="DigitalTwins" scheme="http://waynamigo.github.io/tags/DigitalTwins/"/>
    
  </entry>
  
  <entry>
    <title>Operating System</title>
    <link href="http://waynamigo.github.io/2023/01/05/2023-01-05-%E9%9D%A2%E7%BB%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://waynamigo.github.io/2023/01/05/2023-01-05-面经操作系统/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-12-02T07:39:15.516Z</updated>
    
    <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>线程安全（Thread Safety）：</li></ul><p>当多个线程访问某个类或者对象时，如果不需要额外的同步机制或者用户干预，这个类或者对象依然能够表现出正确的行为，那么它就被认为是线程安全的。<br>简而言之，线程安全意味着在多线程环境下，对象的状态不会发生不一致或者不正确的情况。</p><ul><li>线程不安全（Thread Unsafe）：</li></ul><p>相反，当多个线程访问某个类或者对象时，如果没有适当的同步措施，就可能导致对象的状态变得不可预测或者不正确，那么这个类或者对象就是线程不安全的。<br>在线程不安全的情况下，多个线程可能会在同一时间访问、修改相同的数据，这可能导致数据损坏或者不一致。</p><h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><p>用户态(User Mode) : 用户态运行的进程可以直接读取用户程序的数据<br>内核态(Kernel Mode)：内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等</p><h2 id="如何切换用户态和内核态"><a href="#如何切换用户态和内核态" class="headerlink" title="如何切换用户态和内核态"></a>如何切换用户态和内核态</h2><ul><li>系统调用：比如open close write read，还有一堆IO函数</li><li>中断：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号</li><li>异常：缺页异常等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 系统调用：是一种软中断处理程序，用于让程序从用户态陷入内核态，以执行相应的操作</span><br><span class="line">流程：中断，保存现场，陷入内核态，执行完恢复现场（上下文），从保存的地址开始继续执行（产生中断的那一句）</span><br><span class="line"></span><br><span class="line">2. 中断分软和硬中断，由中断向量表（中断号-中断程序入口地址）和中断处理程序完成。</span><br></pre></td></tr></table></figure></li></ul><h2 id="进程上下文包括哪些"><a href="#进程上下文包括哪些" class="headerlink" title="进程上下文包括哪些"></a>进程上下文包括哪些</h2><ul><li>进程控制块 PCB</li><li>CPU寄存器状态</li><li>程序计数器</li></ul><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul><li><p>进程是系统资源分配的基本单位，一个程序对应一个进程。每个进程都有自己独立的内存空间，相互之间不会共享。它包括了程序代码、内存空间、资源和文件等。</p></li><li><p>线程是进程中的<strong>执行单元</strong>，一个进程可以包含多个线程。线程共享了进程的内存空间和资源，可以同时执行不同的任务。</p></li></ul><h3 id="共享资源指的是哪些资源"><a href="#共享资源指的是哪些资源" class="headerlink" title="共享资源指的是哪些资源"></a>共享资源指的是哪些资源</h3><p>内存、全局变量、对象、文件等</p><h2 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h2><p>协程（goroutine）可以理解为轻量化的用户态线程的实现，区别是<br><strong>协程由goruntime进行调度，线程由操作系统内核调度</strong></p><h2 id="进程切换："><a href="#进程切换：" class="headerlink" title="进程切换："></a>进程切换：</h2><ul><li>保存当前进程上下文：当操作系统决定要切换到另一个进程时，首先会保存当前进程的上下文信息，包括寄存器的值、程序计数器（PC）等。</li><li>加载目标进程的上下文：接下来，操作系统会从进程调度队列中选择一个新的进程，将其保存的上下文信息加载到 CPU 寄存器中，以便开始执行该进程。</li><li>切换页表：在多进程的环境下，<strong>每个进程都有自己独立的地址空间</strong>（虚拟内存），因此在切换进程时，需要将当前进程的页表（用于地址映射）切换为目标进程的页表。</li><li>恢复执行：一旦目标进程的上下文信息被加载，CPU 会从目标进程的上次停止的位置继续执行。</li></ul><h2 id="与线程切换的区别："><a href="#与线程切换的区别：" class="headerlink" title="与线程切换的区别："></a>与线程切换的区别：</h2><ul><li>线程切换发生在用户态，进程切换发生在内核态。</li><li>线程切换相对于进程切换来说更加轻量级，因为线程共享了同一地址空间和其他资源，上下文切换的开销较小。</li></ul><h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><ul><li><strong>共享内存</strong> </li><li><strong>管道</strong> 半双工</li><li><strong>信号</strong> signal ，用于处理异步事件，如外部中断、错误、异常等情况</li><li><strong>信号量</strong> semaphore（mutex）实现进程间的互斥与同步，int计数器</li><li><strong>消息队列</strong> 保存在内核中的消息链表</li><li><strong>socket</strong><h1 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h1></li><li><strong>互斥锁</strong></li><li><strong>读写锁</strong></li><li><strong>自旋锁</strong> 适用于锁被持有时间较短的情况：线程尝试获得锁时，如果锁已被占用，线程会一直忙等待直到锁被释放</li><li><strong>信号量</strong></li><li><strong>条件变量</strong></li><li><strong>原子操作</strong><h1 id="fork子进程与父进程的区别"><a href="#fork子进程与父进程的区别" class="headerlink" title="fork子进程与父进程的区别"></a>fork子进程与父进程的区别</h1>在调用 fork() 函数时，操作系统会创建一个新的进程，这个新的进程称为子进程。子进程是父进程的一个复制，它将继承父进程的内存空间、文件描述符等资源。<br>fork之后，子进程和父进程之间是完全独立进行，互不干扰。</li></ul><h1 id="死锁定义-amp-产生条件"><a href="#死锁定义-amp-产生条件" class="headerlink" title="死锁定义&amp; 产生条件"></a>死锁定义&amp; 产生条件</h1><p>定义：<br>死锁（Deadlock）是指在多个进程或线程之间，每个进程或线程都在等待一个事件，而这个事件只能由其他等待的进程或线程触发，从而导致所有进程或线程都无法继续执行的一种状态。</p><p>产生条件</p><ul><li>互斥（Mutual Exclusion）：资源只能被一个进程或线程占用，如果资源被占用，其他进程或线程必须等待。</li><li>持有和等待（Hold and Wait）：一个进程或线程可以在持有某个资源的同时等待其他资源，这时如果其他资源被占用，就会导致死锁。</li><li>不可剥夺（No Preemption）：资源不能被强制从一个进程或线程中抢占，只能由占用它的进程或线程显式释放。</li><li>循环等待（Circular Wait）：多个进程或线程之间形成一个环路。</li></ul><h1 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h1><ul><li>先来先服务</li><li>短进程优先</li><li>时间片轮转</li><li>优先级队列</li><li>多级反馈队列<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1></li><li>先进先出</li><li>最近最久未使用（手撕）</li></ul><h1 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h1><ul><li>先来先服务</li><li>最短寻道优先</li><li>扫描算法<h1 id="分页是什么，内存页面"><a href="#分页是什么，内存页面" class="headerlink" title="分页是什么，内存页面"></a>分页是什么，内存页面</h1>分页是操作系统中一种内存管理技术。</li></ul><p>优势 </p><ul><li>虚拟内存的实现：允许程序使用比实际物理内存更大的地址空间。</li><li>分页策略：可以实现页面置换算法，将不常用的页置换到磁盘上。</li><li>内存保护：可以将页设置为只读或只执行，从而保护程序的关键部分不被修改。</li><li>内存共享：多个进程可以共享相同的物理页，减少了内存的占用。</li></ul><h1 id="分段是什么，存在碎片问题"><a href="#分段是什么，存在碎片问题" class="headerlink" title="分段是什么，存在碎片问题"></a>分段是什么，存在碎片问题</h1><p>与分页不同，分段不将内存划分为固定大小的块，而是将其划分为逻辑上相关联的段，每个段的长度可以不同。</p><p>优势</p><ul><li>更灵活的内存管理：可以根据程序的需要分配不同大小的段，更好地利用内存。</li><li>更好的地址空间划分：可以将程序的不同部分（如代码、数据、堆栈等）放置在不同的段中，提高了程序的可读性和可维护性。</li><li>内存保护：可以通过设置段的权限（如只读、读写等）来保护程序的关键部分，防止非法访问。</li><li>共享和动态加载：不同程序可以共享相同的段，也可以在运行时动态加载和卸载段。</li></ul><p>使用场景</p><ul><li>动态链接库（DLL）：在操作系统中，动态链接库通常会以独立的段来存放，这样可以在运行时被加载和卸载。</li><li>程序的逻辑结构：将程序的不同部分（如代码段、数据段、堆栈段等）放置在不同的段中，可以使程序的逻辑结构更清晰，提高可读性和可维护性。</li><li>内存保护：可以通过设置段的权限来保护程序的关键部分，防止非法访问。例如，将代码段设置为只读，防止在运行时修改代码</li></ul><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>通过将程序的逻辑地址空间映射到物理内存或磁盘上的存储空间来实现。<br>实现技术：分页和分段技术</p><ul><li>隔离进程：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。每个进程都认为自己拥有了整个物理内存，进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li><li>提升物理内存利用率：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li><li>简化内存管理：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。</li><li>多个进程共享物理内存：进程在运行过程中，会加载许多操作系统的动态库。这些库对于每个进程而言都是公用的，它们在内存中实际只会加载一份，这部分称为共享内存。</li><li>提高内存使用安全性：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li><li>提供更大的可使用内存空间：可以让程序拥有超过系统物理内存大小的可用内存空间。这是因为当物理内存不够用时，可以利用磁盘充当，将物理内存页（通常大小为 4 KB）保存到磁盘文件（会影响读写速度），数据或代码页会根据需要在物理内存与磁盘之间移动。</li></ul><h2 id="如果没有虚拟内存的话"><a href="#如果没有虚拟内存的话" class="headerlink" title="如果没有虚拟内存的话"></a>如果没有虚拟内存的话</h2><ol><li>容易爆内存，内存不够用</li><li>浪费内存，内存崩溃等，根据局部性原理</li></ol><h1 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h1><p>时间局部性：如果一个数据项被访问，那么在不久的将来它很可能再次被访问。这意味着程序往往会重复使用相同的数据。<br>空间局部性：如果一个数据项被访问，那么在它附近的数据也很可能会被访问。这意味着程序往往会以块或连续区域的方式访问数据。</p><h1 id="TLB是什么快表，或者叫cache"><a href="#TLB是什么快表，或者叫cache" class="headerlink" title="TLB是什么快表，或者叫cache"></a>TLB是什么快表，或者叫cache</h1><p>缓存了虚拟页号到物理页号的映射关系，你可以将其简单看作是存储着键（虚拟页号）值（物理页号）对的哈希表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用 TLB 之后的地址翻译流程是这样的：</span><br><span class="line"></span><br><span class="line">1. 用虚拟地址中的虚拟页号作为 key 去 TLB 中查询；</span><br><span class="line">2. 如果能查到对应的物理页的话，就不用再查询页表了，这种情况称为 TLB 命中（TLB hit)。</span><br><span class="line">3. 如果不能查到对应的物理页的话，还是需要去查询主存中的页表，同时将页表中的该映射表项添加到 TLB 中，这种情况称为 TLB 未命中（TLB miss)。</span><br><span class="line">4. 当 TLB 填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一</span><br></pre></td></tr></table></figure><h1 id="交换空间（Swap分区）"><a href="#交换空间（Swap分区）" class="headerlink" title="交换空间（Swap分区）"></a>交换空间（Swap分区）</h1><p>当物理内存不足时，操作系统会将一部分不常用的数据（可能是程序的代码、数据等）从物理内存移动到磁盘上的交换文件（Swap File）或者交换分区（Swap Partition）中。这样，物理内存就会腾出空间来运行当前活动的程序。当需要访问被移到交换空间的数据时，操作系统会将其再次加载到物理内存中。</p><h1 id="缓冲区泄漏"><a href="#缓冲区泄漏" class="headerlink" title="缓冲区泄漏"></a>缓冲区泄漏</h1><p>当程序向缓冲区写入超过其容量的数据时，会覆盖相邻内存区域的数据或者控制程序的执行流程，从而可能导致程序崩溃或者执行意外的行为。</p><ul><li>程序崩溃：如果溢出的数据覆盖了程序关键的数据或者控制信息，可能会导致程序崩溃或异常终止。</li><li>提权漏洞：如果一个程序以特权用户或系统管理员的身份运行，并且存在缓冲区溢出漏洞，攻击者可以利用这个漏洞来提升自己的权限，获取对系统的控制权。</li><li>执行恶意代码：攻击者可以通过精心构造的输入数据来覆盖程序的返回地址或者函数指针，从而强行将程序执行流程转移到恶意代码所在的地址，实现远程代码执行攻击。</li><li>信息泄露：攻击者可以利用缓冲区溢出漏洞来读取程序内部的数据，可能包括敏感信息、密码等。</li></ul><h1 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h1><h2 id="僵尸进程：子进程结束，父进程不知道，导致子进程的资源没被释放"><a href="#僵尸进程：子进程结束，父进程不知道，导致子进程的资源没被释放" class="headerlink" title="僵尸进程：子进程结束，父进程不知道，导致子进程的资源没被释放"></a>僵尸进程：子进程结束，父进程不知道，导致子进程的资源没被释放</h2><p>定义：僵尸进程是已经结束执行的子进程，但其父进程尚未调用wait()或waitpid()系统调用来获取子进程的退出状态，因此子进程的资源（如进程表项、文件描述符等）尚未被完全释放。</p><p>状态：僵尸进程处于”Z”状态（在ps命令中以”Z”标识），找到Z状态kill掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep Z</span><br><span class="line">kill -s SIGCHLD &lt;PID&gt; </span><br><span class="line">#SIGCHLD信号是一个用于通知父进程子进程状态变化的信号。通过向僵尸进程发送这个信号</span><br></pre></td></tr></table></figure><p>危害：僵尸进程占用了系统资源（如进程表项），如果大量的僵尸进程积累，可能会导致系统资源不足。</p><h2 id="孤儿进程：父进程结束，子进程还在执行，会被init进程接管"><a href="#孤儿进程：父进程结束，子进程还在执行，会被init进程接管" class="headerlink" title="孤儿进程：父进程结束，子进程还在执行，会被init进程接管"></a>孤儿进程：父进程结束，子进程还在执行，会被init进程接管</h2><p>定义：孤儿进程是指一个子进程的父进程提前结束了，而子进程还在继续运行。此时，子进程会被init进程（PID为1）接管，成为init的子进程。<br>状态：孤儿进程的状态正常，不会变成僵尸进程，因为init进程会负责回收孤儿进程的资源。<br>危害：一般情况下，孤儿进程并不会造成严重问题。但如果大量的孤儿进程在系统中运行，可能会占用系统资源，因此最好的做法是在父进程退出前，确保它的子进程已经正确地结束。</p><h1 id="重点：IO多路复用"><a href="#重点：IO多路复用" class="headerlink" title="重点：IO多路复用"></a>重点：IO多路复用</h1><p>IO Multiplexing是指通过一种机制<strong>同时监听多个文件描述符（sockets、文件、设备等）</strong>，当其中任意一个文件描述符就绪（可读、可写或异常）时，就可以对其进行相应的处理，从而提高了系统的性能和响应速度。</p><ul><li>select 轮训，在一个数组中注册多个文件描述符，数据量少时效果好</li><li>数据结构：数组</li><li>poll 轮训，数据量多时效果好</li><li>数据结构：链表</li><li>epoll 使用了事件驱动的方式来管理文件描述符，只有当文件描述符真正就绪时才会通知应用程序</li><li>数据结构：红黑树</li></ul><p>优点：相对于select和poll，epoll的性能更高，因为它采用了红黑树的数据结构来管理文件描述符，可以处理大量的文件描述符，并且在文件描述符就绪时会立即得到通知。</p><h1 id="硬连接-软连接"><a href="#硬连接-软连接" class="headerlink" title="硬连接 软连接"></a>硬连接 软连接</h1><p>硬连接</p><ul><li>硬链接与原文件共享同一个索引节点，具有相同的 Inode 号。</li><li>不能连接目录，防止形成环<br>软连接</li><li>软链接是一个单独的文件，其中包含了指向目标文件的路径信息。</li><li>能连接目录</li><li>删除源文件，软连接失效，硬连接还嫩用，因为原来的Inode还在用</li></ul><h1 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h1><ol><li>中断触发，事件可能包括定时器结束，系统调用，异常等</li><li>中断请求，向CPU发送通知，我要处理一个终端</li><li>中断控制器（Interrupt Controller）将中断请求映射到一个中断向量，对应了中断处理程序的入口地址，是映射关系，类似于函数指针。</li><li>根据中断向量表将中断向量映射到实际的中断处理程序的入口地址。</li><li>保存上下文</li><li>执行中断服务程序</li><li>关中断</li><li>恢复现场后，<strong>重新执行产生中断的那一句指令</strong></li></ol><h1 id="中断和轮训"><a href="#中断和轮训" class="headerlink" title="中断和轮训"></a>中断和轮训</h1><ol><li>触发条件不同，中断是被动条件触发（定时器结束、产生异常），轮训是主动查询资源状体啊</li><li>响应能力不同，中断实时发生，论文有延迟</li><li>轮训同步，中断异步</li></ol><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>零拷贝是一种优化数据传输的技术，它通过<strong>减少或消除数据在内存之间的复制过程</strong>来提高传输效率，从而在高性能的数据传输场景中发挥重要作用。</p><ol><li>传递文件描述符</li><li>允许内核缓冲区直接访问</li><li>DMA</li><li>sendfile() 将一个文件描述符的内容发给另一个</li><li>mmap()文件映射到内存</li></ol><p><strong>Redis：</strong><br>Redis 通过使用 sendfile 系统调用，实现了零拷贝技术，可以在文件传输时避免数据在用户空间和内核空间之间的多次拷贝。</p><p><strong>Kafka：</strong><br>Kafka 在数据的生产者和消费者之间使用了零拷贝技术。生产者将数据<strong>直接写入内核缓冲区</strong>，消费者从内核缓冲区直接读取数据，避免了中间的数据拷贝过程。</p><h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p><strong>分配管理</strong></p><ul><li>栈由编译器管理，自动分配和释放内存，函数调用时分配，并在函数返回时自动释放。</li><li>堆通常用于存储动态分配的数据，由程序员手动管理内存的分配和释放。<code>malloc()、calloc()、realloc()</code></li></ul><p><strong>存储内容</strong><br>栈用于存储函数的局部变量和控制信息<br>堆用于存储动态分配的数据，如动态数组、对象等。<br><strong>大小和位置</strong></p><ul><li>栈的大小是固定有限的，由系统在程序启动时分配，每个函数调用时，都会创建一个称为帧（Frame）的区域来存储这些信息</li><li>堆大小不固定，位置不固定</li></ul><h2 id="CPU占用率-使用率-负载"><a href="#CPU占用率-使用率-负载" class="headerlink" title="CPU占用率 使用率 负载"></a>CPU占用率 使用率 负载</h2><p>CPU占用率、使用率和负载是监控和评估计算机系统性能的三个不同方面。</p><p><strong>CPU占用率（CPU Usage）：</strong><br>CPU占用率是指计算机CPU处理任务的效率和利用率。它通常以百分比的形式表示，表示CPU正在执行任务的时间占总时间的比例。例如，一个CPU占用率为50%的系统表示CPU一半的时间用于处理任务，一半的时间处于空闲状态。</p><p><strong>CPU使用率（CPU Utilization）：</strong><br>CPU使用率是指实际用于处理计算任务的CPU时间与总时间的比例。它反映了CPU的工作效率，是一个反映计算机性能的重要指标。CPU使用率可以分为用户态使用率、内核态使用率等不同类型。</p><p><strong>负载（Load Average）：</strong><br>负载是一个相对于一段时间内系统CPU运算负荷的指标。通常以三个数值表示，分别表示系统在过去1分钟、5分钟和15分钟内的负载情况。例如，一个负载为1.0的系统表示在平均1分钟内，有一个任务在运行。</p><p><strong>区别总结：</strong></p><p>CPU占用率关注的是CPU执行任务的效率，以百分比表示。<br>CPU使用率关注的是实际用于处理任务的CPU时间占总时间的比例，也以百分比表示，但更偏向于反映CPU的工作效率。<br>负载关注的是系统的整体负担情况，包括CPU、内存、磁盘等资源的占用情况，以及等待队列中的任务数。</p><h2 id="Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）"><a href="#Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）" class="headerlink" title="Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）"></a>Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）</h2><h2 id="Linus线程间通信：互斥量、信号量、条件变量"><a href="#Linus线程间通信：互斥量、信号量、条件变量" class="headerlink" title="Linus线程间通信：互斥量、信号量、条件变量"></a>Linus线程间通信：互斥量、信号量、条件变量</h2><h2 id="linux启动"><a href="#linux启动" class="headerlink" title="linux启动"></a>linux启动</h2><p>主板加电BIOS，加电自检<br>引导系统的Boot Loader<br>grub配置文件读取，加载内核<br>用户层init进程执行rc.syninit<br>初始化内核模块<br>初始化用户空间的init</p><p>执行/etc/rc.d/rc.local(本地运行服务)<br>执行/bin/login,就可以登录了。</p><h2 id="linux删除命令rm，发生了什么"><a href="#linux删除命令rm，发生了什么" class="headerlink" title="linux删除命令rm，发生了什么"></a>linux删除命令rm，发生了什么</h2><p>linux文件系统里，用inode保存文件的数据结构，rm本质上是删除了这个inode和文件名的关联，然后文件的引用计数减少，当一个文件引用计数减少到0时，系统释放空间</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; questions&lt;/p&gt;
    
    </summary>
    
      <category term="OS" scheme="http://waynamigo.github.io/categories/OS/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="OS" scheme="http://waynamigo.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://waynamigo.github.io/2023/01/05/2023-01-05-%E9%9D%A2%E7%BB%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://waynamigo.github.io/2023/01/05/2023-01-05-面经设计模式/</id>
    <published>2023-01-04T16:00:00.000Z</published>
    <updated>2023-11-19T12:42:22.481Z</updated>
    
    <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><p>开闭原则：软件实体（类、函数、模块）对扩展开放，对修改封闭</p><p>单一职责：每个类只做它负责的事情（一个类应该只有一个引起它修改的原因）<br>里氏替换：子类可以完全代替父类</p><p>依赖倒置：细节依赖于抽象，抽象不依赖于细节，程序细节由底层完成</p><p>最少知道：迪米特法则，尽量降低类与类之间的耦合。一个类不应该知道自己操作的类的细节</p><p>接口隔离：一个接口实现时，如果有冗余，就应该把接口拆分，让实现的类只依赖自己需要的接口，客户端不应依赖于它不知道的接口</p><h1 id="创造型模式"><a href="#创造型模式" class="headerlink" title="创造型模式"></a>创造型模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">工厂方法模式：为每一类对象建立工厂，将对象交由工厂创建，客户端只和工厂打交道。</span><br><span class="line">抽象工厂模式：为每一类工厂提取出抽象接口，使得新增工厂、替换工厂变得非常容易。</span><br><span class="line">建造者模式：用于创建构造过程稳定的对象，不同的 Builder 可以定义不同的配置。</span><br><span class="line">单例模式：全局使用同一个对象，分为饿汉式和懒汉式。懒汉式有双检锁和内部类两种实现方式。</span><br><span class="line">原型模式：为一个类定义 clone 方法，使得创建相同的对象更方便。</span><br></pre></td></tr></table></figure><p>饿汉：变量在声明时便初始化，但饿汉式有一个弊端，那就是即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。<br>懒汉：先声明一个空变量，需要用时才初始化。懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。<br>    - 但是懒汉不是线程安全的，要实现线程安全的懒汉，需要加同步锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span><span class="comment">// 同步包</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//饿汉</span></span><br><span class="line"><span class="keyword">var</span> instance *Singleton = &amp;Singleton&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒汉线程安全</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span>&#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instance := &amp;Singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工厂模式</strong><br><strong>抽象工厂模式</strong><br><strong>单例模式</strong><br><strong>建造者模式</strong><br><strong>原型模式</strong></p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">适配器模式：用于有相关性但不兼容的接口</span><br><span class="line">桥接模式：用于同等级的接口互相组合</span><br><span class="line">组合模式：用于整体与部分的结构</span><br><span class="line">外观模式：体现封装的思想</span><br><span class="line">享元模式：体现面向对象的可复用性</span><br><span class="line">代理模式：主要用于对某个对象加以控制</span><br></pre></td></tr></table></figure><p><strong>适配器模式</strong><br><strong>装饰器模式</strong><br><strong>代理模式</strong><br><strong>享元模式</strong>：享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p><p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。<br>一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p><p><strong>外观模式</strong><br><strong>桥接模式</strong><br><strong>组合模式</strong></p><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">行为型模式重点关注类与类之间的交互与协作。如同在工作中，每个人的行为都可能影响到其他同事，同时每个人也会受到别人的影响。我们一边接收上级的指令，一边派发任务给下级，在这样的协作中完成一项项伟大的工作。程序在运行时，每个对象都不是孤立的，他们可以通过通信与协作完成种种复杂的功能。</span><br><span class="line"></span><br><span class="line">责任链模式：处理职责相同，程度不同的对象，使其在一条链上传递</span><br><span class="line">命令模式：封装“方法调用”，将行为请求者和行为实现者解耦</span><br><span class="line">解释器模式：定义自己的语法规则</span><br><span class="line">迭代器模式：定义 next() 方法和 hasNext() 方法，让外部类使用这两个方法来遍历列表，以达到隐藏列表内部细节的目的</span><br><span class="line">中介者模式：通过引入中介者，将网状耦合结构变成星型结构</span><br><span class="line">备忘录模式：存储对象的状态，以便恢复</span><br><span class="line">观察者模式：处理一对多的依赖关系，被观察的对象改变时，多个观察者都能收到通知</span><br><span class="line">状态模式：关于多态的设计模式，每个状态类处理对象的一种状态</span><br><span class="line">策略模式：殊途同归，用多种方法做同一件事</span><br><span class="line">模板方法模式：关于继承的设计模式，父类是子类的模板</span><br><span class="line">访问者模式：将数据的结构和对数据的操作分离</span><br></pre></td></tr></table></figure><p><strong>责任链模式</strong>：责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止<br><strong>观察者模式</strong><br><strong>中介者模式</strong><br><strong>访问者模式</strong><br><strong>解释器模式</strong><br><strong>迭代器模式</strong><br><strong>命令模式</strong><br><strong>备忘录模式</strong></p><h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><ol><li>面向对象的特点是什么？</li></ol><p>可维护、可复用、可扩展、灵活性好。</p><ol><li>让面向对象保持结构良好的秘诀是什么？</li></ol><p>让面向对象保持结构良好的秘诀就是设计模式，面向对象结合设计模式，才能真正体会到程序变得可维护、可复用、可扩展、灵活性好。</p><ol><li>六大设计原则是什么？</li></ol><p>开闭原则、单一职责原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则。</p><ol><li>什么是里氏替换原则？</li></ol><p>子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</p><ol><li>工厂模式是用于达到什么目的的设计模式？</li></ol><p>封装对象。</p><ol><li>工厂模式有哪三种？</li></ol><p>简单工厂模式、工厂方法模式、抽象工厂模式。</p><ol><li>工厂方法模式解决了简单工厂模式的哪两个弊端？</li></ol><p>当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。<br>当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。</p><ol><li>抽象工厂模式是什么样的？</li></ol><p>在创建时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。这种经过抽象的工厂方法模式被称作抽象工厂模式。</p><ol><li>抽象工厂模式很好的发挥了哪些原则？</li></ol><p>开闭原则、依赖倒置原则。</p><ol><li>抽象工厂模式的缺点是什么？</li></ol><p>缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。</p><ol><li>抽象工厂模式适用于和不适用于哪些情况？</li></ol><p>适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。</p><ol><li>什么时候可以使用单例模式？</li></ol><p>某个对象全局只需要一个实例时即可。</p><ol><li>单例模式的优点是什么？</li></ol><p>• 它能够避免对象重复创建，节约空间并提升效率<br>• 避免由于操作不同实例导致的逻辑错误</p><ol><li>单例模式有哪两种实现方式？请分别简单解释。</li></ol><p>饿汉式和懒汉式。饿汉式指变量在声明时便初始化。懒汉式指先声明一个空变量，需要用时才初始化。</p><ol><li>饿汉式的弊端是什么？</li></ol><p>即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。</p><ol><li>静态内部类方式是怎么保证线程安全的？</li></ol><p>Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。</p><ol><li>建造者模式用于什么时候？</li></ol><p>创建过程稳定，但配置多变的对象。</p><ol><li>建造者模式是什么意思？</li></ol><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><ol><li>现在建造者模式主要用来做什么？</li></ol><p>通过链式调用生成不同的配置。</p><ol><li>使用建造者模式的好处是什么？</li></ol><p>不用担心忘了指定某个配置，保证了构建过程是稳定的。</p><ol><li>原型模式是什么？</li></ol><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><ol><li>适配器模式适用于什么结构？</li></ol><p>有相关性但不兼容的结构。</p><ol><li>什么是适配？什么是适配器？</li></ol><p>源接口通过一个中间件转换后才可以适用于目标接口，这个转换过程就是适配，这个中间件就称之为适配器。</p><ol><li>需要绘制矩形、圆形、三角形这三种图案，按照桥接模式的思想会怎么做？</li></ol><p>将形状和颜色分离，根据需要对形状和颜色进行组合。</p><ol><li>什么是桥接模式？</li></ol><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。</p><ol><li>组合模式适用于什么结构？</li></ol><p>组合模式用于整体与部分的结构，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。</p><ol><li>组合模式最主要的功能是什么？</li></ol><p>组合模式最主要的功能是让用户可以一致对待整体和部分结构，将两者都作为一个相同的组件。</p><ol><li>什么是组合模式中的透明方式？</li></ol><p>违背了接口隔离原则的组合模式。</p><ol><li>什么是安全方式？</li></ol><p>在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。</p><ol><li>什么是透明装饰模式？</li></ol><p>装饰器仅用于增强功能，并不会改变 Me 原有的功能，这种装饰模式称之为透明装饰模式。</p><ol><li>装饰模式的缺点是什么？</li></ol><p>容易造成程序中有大量相似的类。</p><ol><li>动态代理相对于静态代理的优势是什么？</li></ol><p>节省代码量。</p><ol><li>简述责任链模式的有优点有哪些？</li></ol><p>• 降低了对象之间的耦合度。<br>• 扩展性强，满足开闭原则。可以根据需要增加新的请求处理类。<br>• 灵活性强。可以动态地改变链内的成员或者改变链的次序来适应流程的变化。<br>• 简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用。</p><ol><li>什么是宏命令？</li></ol><p>宏命令是将多个命令合并起来组成的命令。</p><ol><li>请写出解释器模式的一个常见应用。</li></ol><p>在我们平时匹配字符串时，用到的正则表达式就是一个解释器。</p><ol><li>怎样使得外部类只能读取此列表中的数据，无法修改其中的任何数据，保证其安全性？</li></ol><p>• 提供一个 String next() 方法，使得外部类可以按照次序，一条一条的读取数据；<br>• 提供一个 boolean hasNext() 方法，告知外部类是否还有下一条数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; questions&lt;/p&gt;
    
    </summary>
    
      <category term="软件工程" scheme="http://waynamigo.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="设计模式" scheme="http://waynamigo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UML" scheme="http://waynamigo.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>Redis questions</title>
    <link href="http://waynamigo.github.io/2023/01/04/2023-01-04-%E9%9D%A2%E7%BB%8FRedis%E9%97%AE%E9%A2%98/"/>
    <id>http://waynamigo.github.io/2023/01/04/2023-01-04-面经Redis问题/</id>
    <published>2023-01-03T16:00:00.000Z</published>
    <updated>2023-11-25T10:19:46.331Z</updated>
    
    <content type="html"><![CDATA[<p> questions<br> <a href="https://github.com/redisson/redisson/wiki/目录" target="_blank" rel="noopener">https://github.com/redisson/redisson/wiki/目录</a></p><a id="more"></a><h2 id="1-memcached和redis区别有哪些，优势劣势？"><a href="#1-memcached和redis区别有哪些，优势劣势？" class="headerlink" title="1.memcached和redis区别有哪些，优势劣势？"></a>1.memcached和redis区别有哪些，优势劣势？</h2><p>redis支持多种数据类型，并且支持持久化策略，</p><h2 id="2-实现本地缓存，有哪些方案？go本地，redis"><a href="#2-实现本地缓存，有哪些方案？go本地，redis" class="headerlink" title="2.实现本地缓存，有哪些方案？go本地，redis"></a>2.实现本地缓存，有哪些方案？go本地，redis</h2><h2 id="3-redis通讯协议？特点是什么【TCP】"><a href="#3-redis通讯协议？特点是什么【TCP】" class="headerlink" title="3.redis通讯协议？特点是什么【TCP】"></a>3.redis通讯协议？特点是什么【TCP】</h2><h2 id="4-字符串最大长度是多少？512MB"><a href="#4-字符串最大长度是多少？512MB" class="headerlink" title="4.字符串最大长度是多少？512MB"></a>4.字符串最大长度是多少？512MB</h2><h2 id="5-介绍一下zset及底层实现机制"><a href="#5-介绍一下zset及底层实现机制" class="headerlink" title="5.介绍一下zset及底层实现机制"></a>5.介绍一下zset及底层实现机制</h2><h2 id="6-redis事务？原理是什么"><a href="#6-redis事务？原理是什么" class="headerlink" title="6.redis事务？原理是什么"></a>6.redis事务？原理是什么</h2><h2 id="7-事务相关命令？支持回滚吗"><a href="#7-事务相关命令？支持回滚吗" class="headerlink" title="7.事务相关命令？支持回滚吗"></a>7.事务相关命令？支持回滚吗</h2><h2 id="8-介绍一下pipeline和使用场景：批量读取写入"><a href="#8-介绍一下pipeline和使用场景：批量读取写入" class="headerlink" title="8.介绍一下pipeline和使用场景：批量读取写入"></a>8.介绍一下pipeline和使用场景：批量读取写入</h2><p>批量执行Redis命令的机制，它可以在客户端发送多个命令后，一次性将它们发送到服务器，然后一次性接收服务器的响应</p><h3 id="和批量命令有什么不同"><a href="#和批量命令有什么不同" class="headerlink" title="和批量命令有什么不同"></a>和批量命令有什么不同</h3><ol><li>pipeline是同时发送/执行不同命令的机制，批量是都需要执行相似的</li><li>pipeline是顺序执行所有命令，执行一个一个状态，而批量需要等待所有的返回<h2 id="9-设置生存时间和过期时间用什么命令"><a href="#9-设置生存时间和过期时间用什么命令" class="headerlink" title="9.设置生存时间和过期时间用什么命令"></a>9.设置生存时间和过期时间用什么命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key n_seconds</span><br><span class="line">PEXPIRE mykey n_milseconds</span><br></pre></td></tr></table></figure></li></ol><h2 id="10-介绍下redis的发布订阅功能"><a href="#10-介绍下redis的发布订阅功能" class="headerlink" title="10.介绍下redis的发布订阅功能"></a>10.介绍下redis的发布订阅功能</h2><ul><li>允许多个客户端之间通过消息中间件来发送和接收消息。在这种模式下，消息的发送者称为发布者（Publisher），而消息的接收者称为订阅者（Subscriber）</li><li>Redis的发布订阅功能是异步的，消息的发送和接收是非阻塞的，因此在订阅者接收消息时需要特别注意处理并发和同步的问题。<h2 id="11-redis单线程为什么那么快"><a href="#11-redis单线程为什么那么快" class="headerlink" title="11.redis单线程为什么那么快"></a>11.redis单线程为什么那么快</h2>单线程没有锁，主线程异步处理IO，避免多线程上下文切换<h2 id="12-分布式缓存要注意哪些问题"><a href="#12-分布式缓存要注意哪些问题" class="headerlink" title="12. 分布式缓存要注意哪些问题"></a>12. 分布式缓存要注意哪些问题</h2></li></ul><ol><li>缓存一致性 </li><li>缓存击穿 </li><li>缓存雪崩</li></ol><h2 id="13-redis的key删除策略【redis同时使用了惰性删除和定期删除】"><a href="#13-redis的key删除策略【redis同时使用了惰性删除和定期删除】" class="headerlink" title="13. redis的key删除策略【redis同时使用了惰性删除和定期删除】"></a>13. redis的key删除策略【redis同时使用了惰性删除和定期删除】</h2><ol><li>定期删除，每 100 毫秒检查 20 个随机选择的过期 key，这个过期的key存储在expire字典中，如果发现有过期的 key，就会将其删除。</li><li>惰性删除，访问时检查key有没有过期，然后删除。</li></ol><p>设置过期时间+一个随机的时间，防止缓存雪崩</p><h1 id="lua"><a href="#lua" class="headerlink" title="lua"></a>lua</h1><p><a href="https://zhuanlan.zhihu.com/p/383994942?utm_oi=757371723308879872" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/383994942?utm_oi=757371723308879872</a></p><h2 id="lua的基本数据类型"><a href="#lua的基本数据类型" class="headerlink" title="lua的基本数据类型"></a>lua的基本数据类型</h2><ul><li>nil    这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</li><li>boolean    包含两个值：false和true。</li><li>number    表示双精度类型的实浮点数</li><li>string    字符串由一对双引号或单引号来表示</li><li>function    由 C 或 Lua 编写的函数</li><li>userdata    表示任意存储在变量中的C数据结构</li><li>thread    表示执行的独立线路，用于执行协同程序</li><li>table    Lua 中的表（table）其实是一个”关联数组”（associative  arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</li></ul><h2 id="1-pairs-和ipairs"><a href="#1-pairs-和ipairs" class="headerlink" title="1. pairs 和ipairs"></a>1. pairs 和ipairs</h2><ol><li><p>ipairs遇到nil会停止，pairs会输出nil值然后继续下去</p></li><li><p>ipairs并不会输出table中存储的键值对,会跳过键值对，然后顺序输出table中的值。而pairs会输出table的键值对，先顺序输出值，再乱序(键的哈希值)输出键值对。</p></li></ol><h1 id="高频问题"><a href="#高频问题" class="headerlink" title="高频问题"></a>高频问题</h1><h2 id="1-Redis为什么那么快"><a href="#1-Redis为什么那么快" class="headerlink" title="1. Redis为什么那么快"></a>1. Redis为什么那么快</h2><ol><li>redis存储是基于内存的</li><li>命令的读写过程单线程执行，6.0之后引入了IO多线程，使用IO多路复用，提升网络IO的利用率和提速</li><li>底层数据存储结构使用的是全局hash，也就是kv存储，还有几种数据类型用了高效的压缩列表，哈希表跳表等等<ul><li>String 简单动态字符串，线程安全，使用incr也线程安全，一个是incr原子操作，一个是string根据len去判断</li><li>Zset 有序集合，使用的跳表：有序链表的优化，<h2 id="2-Redis对于过期key的处理"><a href="#2-Redis对于过期key的处理" class="headerlink" title="2. Redis对于过期key的处理"></a>2. Redis对于过期key的处理</h2></li></ul></li><li>惰性删除，一个key发生读写时，去判断是否过期，过期了直接删</li><li>定时删除，默认每100ms主动淘汰一批过期的key</li><li>定期删除，server.hz配置每秒钟执行serverCron()的次数，周期性轮询redis库中的时效性数据，采用随机抽取的策略</li></ol><h2 id="3-key没设置过期时间为什么还被删除了【在内存使用超阈值之后，会自动清一波没有使用的内存】"><a href="#3-key没设置过期时间为什么还被删除了【在内存使用超阈值之后，会自动清一波没有使用的内存】" class="headerlink" title="3. key没设置过期时间为什么还被删除了【在内存使用超阈值之后，会自动清一波没有使用的内存】"></a>3. key没设置过期时间为什么还被删除了【在内存使用超阈值之后，会自动清一波没有使用的内存】</h2><p>对于没有过期时间的key，使用allkeys-lru/allkeys-lfu/allkeys-random三种策略去淘汰</p><h2 id="4-删除key的命令会阻塞redis吗？【会发生阻塞】"><a href="#4-删除key的命令会阻塞redis吗？【会发生阻塞】" class="headerlink" title="4. 删除key的命令会阻塞redis吗？【会发生阻塞】"></a>4. 删除key的命令会阻塞redis吗？【会发生阻塞】</h2><p>因为在数据结构中删除存在一个，时间复杂度O(k)，n为存在的数量，是个常数，返回值是删除的数量</p><h2 id="5-主从-哨兵-集群-优缺点"><a href="#5-主从-哨兵-集群-优缺点" class="headerlink" title="5. 主从 哨兵 集群 优缺点"></a>5. 主从 哨兵 集群 优缺点</h2><ol><li>主从，主负责写，从负责读，主要作用相当于一个备份</li><li>哨兵三个sentinel去监控节点，master发生故障进行切换，提供服务的还是只有一个主节点，无法支持特别高的并发</li><li>集群，<strong>复制，高可用，分片</strong>，配置简单，</li></ol><h2 id="6-集群模式，数据的hash分片算法"><a href="#6-集群模式，数据的hash分片算法" class="headerlink" title="6. 集群模式，数据的hash分片算法"></a>6. 集群模式，数据的hash分片算法</h2><ol><li>redis集群时，有数据分片存储，找kv分在了哪个节点上</li><li>分片算法首先对key做CRC16得到一个中间值，然后mod 16384，根据分片规则，就能算到请求要到哪个master上<h2 id="7-主从切换为什么会导致缓存雪崩【从节点所在系统时间戳不同】"><a href="#7-主从切换为什么会导致缓存雪崩【从节点所在系统时间戳不同】" class="headerlink" title="7. 主从切换为什么会导致缓存雪崩【从节点所在系统时间戳不同】"></a>7. 主从切换为什么会导致缓存雪崩【从节点所在系统时间戳不同】</h2></li></ol><h2 id="8-RDB快照和AOF问题"><a href="#8-RDB快照和AOF问题" class="headerlink" title="8. RDB快照和AOF问题"></a>8. RDB快照和AOF问题</h2><p>主从复制只用RDB</p><h2 id="9-线上数据如何备份"><a href="#9-线上数据如何备份" class="headerlink" title="9. 线上数据如何备份"></a>9. 线上数据如何备份</h2><ol><li>定时把rdb或者aof持久化文件存到备份硬盘或者机器上，可以用crontab 分时日月周</li></ol><h2 id="10-主从复制风暴是什么【发生在从节点特别多的情况】"><a href="#10-主从复制风暴是什么【发生在从节点特别多的情况】" class="headerlink" title="10. 主从复制风暴是什么【发生在从节点特别多的情况】"></a>10. 主从复制风暴是什么【发生在从节点特别多的情况】</h2><p>节点重起的多，要求主节点发rdb文件，如果从节点只连接主节点，压力就特别大<br>如果要减轻压力，rdb复制的路线就采用树形结构，从节点发到下一级的从节点</p><h2 id="11-网络抖动导致频繁主从切换，怎么处理【redis-timeout超过一定阈值，才认定故障，发生主从切换】"><a href="#11-网络抖动导致频繁主从切换，怎么处理【redis-timeout超过一定阈值，才认定故障，发生主从切换】" class="headerlink" title="11. 网络抖动导致频繁主从切换，怎么处理【redis timeout超过一定阈值，才认定故障，发生主从切换】"></a>11. 网络抖动导致频繁主从切换，怎么处理【redis timeout超过一定阈值，才认定故障，发生主从切换】</h2><h2 id="12-为什么redis至少需要三个master"><a href="#12-为什么redis至少需要三个master" class="headerlink" title="12. 为什么redis至少需要三个master"></a>12. 为什么redis至少需要三个master</h2><p>选举主节点时，要求半数以上的节点去选一个新主节点</p><h2 id="13-mset-mget批量指令支持redis集群吗【支持】"><a href="#13-mset-mget批量指令支持redis集群吗【支持】" class="headerlink" title="13. mset mget批量指令支持redis集群吗【支持】"></a>13. mset mget批量指令支持redis集群吗【支持】</h2><p>要借助hashtag，保证每次批量执行的key落在明确的节点上，要用大括号括一个值，在hash分片的时候查找</p><h2 id="14-lua可以在集群执行吗【可以，但是有要求，同13问】"><a href="#14-lua可以在集群执行吗【可以，但是有要求，同13问】" class="headerlink" title="14. lua可以在集群执行吗【可以，但是有要求，同13问】"></a>14. lua可以在集群执行吗【可以，但是有要求，同13问】</h2><p>操作的key必须落在明确的节点上，hash分片</p><h2 id="15-主从切换导致分布式锁丢失"><a href="#15-主从切换导致分布式锁丢失" class="headerlink" title="15. 主从切换导致分布式锁丢失"></a>15. 主从切换导致分布式锁丢失</h2><p>主节点把分布式锁的key发给slave是，因为是异步的，可能中间master挂了，导致丢失了</p><ul><li>有一种redlock的方法，要搞半数以上的独立redis节点，服务端才认定加锁成功。类似于zookeeper，但是</li></ul><h2 id="16-大公司使用旁路写回的情况，是建立在设置好超时时间的前提下的"><a href="#16-大公司使用旁路写回的情况，是建立在设置好超时时间的前提下的" class="headerlink" title="16. 大公司使用旁路写回的情况，是建立在设置好超时时间的前提下的"></a>16. 大公司使用旁路写回的情况，是建立在设置好超时时间的前提下的</h2><h2 id="【redis集群一致性】：主从复制，分片算法"><a href="#【redis集群一致性】：主从复制，分片算法" class="headerlink" title="【redis集群一致性】：主从复制，分片算法"></a>【redis集群一致性】：主从复制，分片算法</h2><ol><li><p>主从复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1）从节点连接主节点，并发送SYNC命令请求同步数据。</span><br><span class="line">2）主节点在接收到SYNC命令后，开始执行BGSAVE命令，将数据持久化到磁盘中，并将生成的RDB文件发送给从节点。</span><br><span class="line">3）从节点在接收到RDB文件后，通过LOAD命令将其加载到内存中，从而与主节点的数据保持一致。</span><br><span class="line">4）从节点开始接收主节点的增量数据，并将其应用到自己的数据集中，保持与主节点的同步。</span><br></pre></td></tr></table></figure></li><li><p>分片算法，每次对key的CRC16值mod 16384 ，判定放置的slot号，然后落在哪个实例上</p></li><li><p>更改、增加、删除实例时，就更改slot和实例的分配，不会影响集群总体的一致性，但是不是强一致性。</p><h2 id="17-解决缓存数据库双写不一致情况【双写指两个-多个写操作，其中有一个在查db和更新缓存之间顿了一下导致】"><a href="#17-解决缓存数据库双写不一致情况【双写指两个-多个写操作，其中有一个在查db和更新缓存之间顿了一下导致】" class="headerlink" title="17. 解决缓存数据库双写不一致情况【双写指两个/多个写操作，其中有一个在查db和更新缓存之间顿了一下导致】"></a>17. 解决缓存数据库双写不一致情况【双写指两个/多个写操作，其中有一个在查db和更新缓存之间顿了一下导致】</h2></li><li><p>加个分布式锁，在查db和更缓存这两个过程绑一起，更新完再delete这把锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RLock wlock = redission.createReadWriteLock(lockname);<span class="comment">//在一个上锁的事务,两边都要</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    Rlock wlock = redission.getReadWriteLock(lockname + id);</span><br><span class="line">    wlock.lock();</span><br><span class="line">    <span class="comment">//transaction code</span></span><br><span class="line">    <span class="comment">//1. update db</span></span><br><span class="line">    <span class="comment">//2. set redis key</span></span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    wlock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="18-分布式锁在遇到高并发时，出现串行征用问题"><a href="#18-分布式锁在遇到高并发时，出现串行征用问题" class="headerlink" title="18. 分布式锁在遇到高并发时，出现串行征用问题"></a>18. 分布式锁在遇到高并发时，出现串行征用问题</h2><p>解决方法：读写锁<br>读写锁底层如何实现的？1.为什么写写互斥，写读互斥，读读不互斥？</p><h2 id="19-一个创建某个cache的操作进行上锁，几万个请求来搞这个请求，如何优化【使用redission的trylock】"><a href="#19-一个创建某个cache的操作进行上锁，几万个请求来搞这个请求，如何优化【使用redission的trylock】" class="headerlink" title="19. 一个创建某个cache的操作进行上锁，几万个请求来搞这个请求，如何优化【使用redission的trylock】"></a>19. 一个创建某个cache的操作进行上锁，几万个请求来搞这个请求，如何优化【使用redission的trylock】</h2><p>就是所有线程都在自旋等待unlock锁，默认是非公平抢占锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rlock lock = redission.getlock()</span><br><span class="line">lock.lock() <span class="comment">// 改成lock.trylock()</span></span><br></pre></td></tr></table></figure><h2 id="Redis和MongoDB的区别"><a href="#Redis和MongoDB的区别" class="headerlink" title="Redis和MongoDB的区别"></a>Redis和MongoDB的区别</h2><p>Redis和MongoDB都是流行的开源NoSQL数据库，但它们的设计理念和使用场景有所不同。本文将重点介绍Redis和MongoDB的区别和使用场景。</p><p>Redis是一个高性能的数据存储系统，常被用作缓存和消息中间件。<br>Redis以内存为主要存储介质，但它也支持将数据持久化到磁盘上。Redis是一款键值数据库，它支持多种数据结构（例如字符串、列表、哈希表、有序集合等），并提供了丰富的命令和API供开发者使用。</p><ol><li>MongoDB是一个面向文档的数据库，它以JSON格式存储数据。MongoDB是一款NoSQL数据库，它支持复杂的查询和数据聚合操作。MongoDB的数据模型和关系型数据库有所不同，它不需要事先定义表结构和字段，可以动态地添加或删除数据字段。MongoDB也支持数据的分片和复制，以实现数据的高可用和横向扩展。</li></ol><p>Redis和MongoDB的区别<br>（1）数据模型</p><p>Redis是一个键值数据库，数据结构简单，适用于存储缓存数据和消息队列等场景。Redis支持字符串、列表、哈希表、有序集合等基本数据结构，同时还支持订阅与发布机制、Lua脚本等高级特性。Redis的数据操作速度非常快，可以达到单机每秒数百万次读写的性能。</p><p>MongoDB是一个面向文档的数据库，数据结构相对复杂，适用于存储各种应用数据。MongoDB的数据以BSON格式存储，类似于JSON，但支持更多的数据类型和地理位置信息等特性。MongoDB支持文档级别的事务和复杂的数据聚合操作。</p><p>（2）持久化机制</p><p>Redis最初是一个基于内存的缓存系统，但它提供了多种持久化机制来保证数据安全。Redis的持久化是异步的，默认情况下，Redis将数据写入内存，然后将数据异步地写入磁盘上的RDB文件或AOF文件。RDB文件是一个快照文件，可以定期保存数据库的状态，而AOF是一个日志文件，可以记录每个写操作的命令序列。</p><p>MongoDB支持多种持久化机制，包括基于写前日志（Write Ahead Log，WAL）和基于快照的持久化机制。MongoDB将每个写操作写入WAL，然后异步地将WAL中的操作应用到数据集中。MongoDB还可以定期创建数据集的快照，并将快照写入磁盘中的文件。WAL和数据集的快照可以用于数据的恢复和复制。</p><p>（3）查询特性</p><p>Redis的查询特性相对简单，主要支持基于键值的查询和基本的条件查询。Redis的查询速度非常快，因为它的数据都在内存中，可以直接访问。Redis还支持数据交集、并集和差集等高级查询特性。</p><p>MongoDB的查询特性非常强大，支持复杂的查询和数据聚合操作。MongoDB支持索引、分片、复制和副本集等技术，以提高查询的速度和可靠性。MongoDB还支持地理位置查询、全文搜索和图形查询等特性，可以满足不同应用场景的需求。</p><p>Redis和MongoDB的使用场景<br>（1）Redis的使用场景</p><p>Redis的内存存储特性和高性能的数据读写能力，使它非常适合作为缓存系统和消息队列。Redis也可以用于会话管理、分布式锁和实时计数器等场景。Redis的数据结构和高级特性（例如Lua脚本和发布订阅机制）可以实现智能匹配、排行榜和广告推广等应用。</p><p>（2）MongoDB的使用场景</p><p>MongoDB的文档存储特性和丰富的查询特性，使它非常适合作为Web应用和移动应用的后端数据库。MongoDB可以处理复杂的数据结构和数据关系，支持动态增加和删除数据字段，可以快速地适应应用的变化。MongoDB还可以用于数据分析、数据挖掘和机器学习等领域，以支持大规模数据的处理和分析。</p><p>总结<br>Redis和MongoDB都是优秀的NoSQL数据库，在不同的应用场景中有着不同的表现。Redis的内存存储和高性能的数据读写能力，使它适用于缓存和消息队列等场景。MongoDB的文档存储和强大的查询特性，使它适用于Web应用和移动应用的后端数据库。在选择Redis或MongoDB作为数据存储系统时，需要考虑应用的性能需求、数据模型和查询特性等因素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; questions&lt;br&gt; &lt;a href=&quot;https://github.com/redisson/redisson/wiki/目录&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/redisson/redisson/wiki/目录&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://waynamigo.github.io/categories/Redis/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Redis" scheme="http://waynamigo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://waynamigo.github.io/2023/01/04/2023-01-04-%E9%9D%A2%E7%BB%8FRedis/"/>
    <id>http://waynamigo.github.io/2023/01/04/2023-01-04-面经Redis/</id>
    <published>2023-01-03T16:00:00.000Z</published>
    <updated>2023-11-21T05:34:13.571Z</updated>
    
    <content type="html"><![CDATA[<p>questions</p><p>使用go-redis连接，因为redigo无法连接redis集群<br>redis集群可以用kratos的或者go-zero的分布式锁实现<br><a href="https://juejin.cn/post/7041375517580689439" target="_blank" rel="noopener">https://juejin.cn/post/7041375517580689439</a></p><a id="more"></a><h2 id="go-redis-连接集群"><a href="#go-redis-连接集群" class="headerlink" title="go-redis 连接集群"></a>go-redis 连接集群</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initClient</span><span class="params">()</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line">rdb := redis.NewClusterClient(&amp;redis.ClusterOptions&#123;</span><br><span class="line">Addrs: []<span class="keyword">string</span>&#123;<span class="string">":7000"</span>, <span class="string">":7001"</span>, <span class="string">":7002"</span>, <span class="string">":7003"</span>, <span class="string">":7004"</span>, <span class="string">":7005"</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">_, err = rdb.Ping().Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="go-redis-连接哨兵"><a href="#go-redis-连接哨兵" class="headerlink" title="go-redis 连接哨兵"></a>go-redis 连接哨兵</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initClient</span><span class="params">()</span><span class="params">(err error)</span></span>&#123;</span><br><span class="line">rdb := redis.NewFailoverClient(&amp;redis.FailoverOptions&#123;</span><br><span class="line">MasterName:    <span class="string">"master"</span>,</span><br><span class="line">SentinelAddrs: []<span class="keyword">string</span>&#123;<span class="string">"x.x.x.x:26379"</span>, <span class="string">"xx.xx.xx.xx:26379"</span>, <span class="string">"xxx.xxx.xxx.xxx:26379"</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line">_, err = rdb.Ping().Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/八股文/五种数据类型.png" alt title>                </div>                <div class="image-caption"></div>            </figure><table><thead><tr><th>String</th><th>List</th><th>Hash</th><th>Set</th><th>Zset</th></tr></thead><tbody><tr><td>SDS</td><td>QuickList</td><td>Dict、ZipList</td><td>Dict、Intset</td><td>SkipList</td></tr><tr><td># redis内存模型？</td><td></td><td></td><td></td><td></td></tr><tr><td>hashtable</td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h1><ul><li>BitMap：签到、行为统计（点赞）</li><li>hyperloglog：不太了解</li><li>Geospatial：基于sort set，GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。</li></ul><h2 id="【重点】一致性问题：Redis和数据库的一致性"><a href="#【重点】一致性问题：Redis和数据库的一致性" class="headerlink" title="【重点】一致性问题：Redis和数据库的一致性"></a>【重点】一致性问题：Redis和数据库的一致性</h2><p><a href="https://juejin.cn/post/7287026079066800168#heading-1" target="_blank" rel="noopener">https://juejin.cn/post/7287026079066800168#heading-1</a></p><h2 id="【重点】redis主从的一致性【配置redis-conf】"><a href="#【重点】redis主从的一致性【配置redis-conf】" class="headerlink" title="【重点】redis主从的一致性【配置redis.conf】"></a>【重点】redis主从的一致性【配置redis.conf】</h2><ol><li>全量复制，master-&gt;slave1-&gt;slave2的级联方式</li></ol><ul><li>全量<ul><li>salve 发送sync请求到master，开始第一次同步</li><li>第一次同步时使用bgsave做rdb快照，同时将后续修改记录加到内存缓冲区，完成后将rdb文件同步到从节点，复制完后由从节点加载到内存</li><li>加载完成后通知master，master将缓冲区的写操作记录发给slave，slave再执行剩余的这些写操作，与master保持一致</li></ul></li><li>部分复制<ul><li>slave发送psync请求到master，开始第一次同步</li><li>slave再发一个偏移量，master从这个偏移量开始同步数据</li></ul></li></ul><h1 id="三种缓存读写策略"><a href="#三种缓存读写策略" class="headerlink" title="三种缓存读写策略"></a>三种缓存读写策略</h1><h2 id="1-Cache-Aside-Pattern（旁路缓存模式）"><a href="#1-Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="1. Cache Aside Pattern（旁路缓存模式）"></a>1. <strong>Cache Aside Pattern（旁路缓存模式）</strong></h2><ul><li>写：先更新DB，再删除cache，先dao.create/update/delete，再更新缓存，用redis实例去set更新key</li><li>读：先从cache读，读到就返回；读不到就读db，将数据写到cache ，先从redis.get，如果非空，用dao查找</li></ul><ol><li>为什么要删缓存而不是更新？删除轻量一些，更新比较耗时，数据重新回缓存由更多的读操作实现</li><li>【问题】可以先删cache，再更新db吗？<br>不能，因为写的时间远大于读，出现数据不一致的可能性更高，因为在更新db前，cache可能已经被读操作覆盖了<h3 id="缺陷有哪些"><a href="#缺陷有哪些" class="headerlink" title="缺陷有哪些"></a>缺陷有哪些</h3></li><li>不能避免个别的不一致性问题，就是脏读问题</li><li>写操作多的情况影响性能，因为每次都要更新db</li><li>在高并发的情况下，不管是先写数据库，再删缓存；还是先删缓存，再写数据库，都有可能出现数据不一致的情况，比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果删除了缓存redis，还没来得及写库mysql,另一个线程就读取，发现缓存为空，则去数据库读取数据写入缓存，此时缓存中的数据为脏数据。</span><br><span class="line">如果写了库，在删除缓存前，写库的线程故障了，也会出现数据不一致的情况。</span><br><span class="line">解决办法：</span><br><span class="line">延迟双删策略</span><br><span class="line">1、先删除缓存</span><br><span class="line">2、再写数据库</span><br><span class="line">3、休眠时间（根据统计线程读取数据和写缓存的时间）</span><br><span class="line">（休眠的作用是当前线程等其他线程读完了数据后写入缓存后，删除缓存）</span><br><span class="line">4、再删除缓存</span><br></pre></td></tr></table></figure></li></ol><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>解决办法：</p><ul><li>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小</li><li>还有一个阿里的canal组件，是监控mysql的binlog，更改了就自动去写redis<h2 id="2-Read-Write-Through-Pattern（读写穿透）"><a href="#2-Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="2. Read/Write Through Pattern（读写穿透）"></a>2. <strong>Read/Write Through Pattern（读写穿透）</strong></h2><ul><li>写：先查cache，没有就直接更新db；有的话， 先更新cache，cache服务自己更新db</li><li>读：先从cache读，读到就返回；读不到就读db，写入到cache<h2 id="3-Write-Behind-Pattern（异步缓存写入）"><a href="#3-Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="3. Write Behind Pattern（异步缓存写入）"></a>3. <strong>Write Behind Pattern（异步缓存写入）</strong></h2></li><li>写：先查cache，没有直接更新db；有的话，只更新缓存，异步批量写db</li><li>读：先从cache读，读到就返回；读不到就读db，写入到cache</li></ul></li></ul><p><strong>与读写穿透的区别：</strong>：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="Redis持久化的方式"><a href="#Redis持久化的方式" class="headerlink" title="Redis持久化的方式"></a>Redis持久化的方式</h2><p>Redis 共有三种数据持久化的方式：</p><ul><li>AOF（Append Only File）日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li>RDB（Redis Database Backup file） 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li>混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点<h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3>提供两个命令实现快照</li><li>save：在主线程实现，可能会导致阻塞</li><li>bgsave：background save，在后台的子进程生成RDB快照</li></ul><p><strong>RDB 在执行快照的时候，数据能修改吗？</strong></p><p>执行 bgsave 过程中，Redis 依然可以继续处理操作命令的，也就是数据是能被修改的，关键的技术就在于【写时复制技术】（Copy-On-Write, COW）。</p><p>技术原理：bgsave会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p><h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。<br><strong>它们的区别是什么</strong><br>AOF：三种写回方式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/redisAOF.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>所以，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p><p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><p><strong>AOF 日志过大，会触发什么机制</strong></p><p>【AOF 重写机制】，压缩AOF文件：<br>【压缩方式】：在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。但是对KV的记录就保持最新的那一条</p><h1 id="redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】"><a href="#redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】" class="headerlink" title="redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】"></a>redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】</h1><p><strong>不支持回滚</strong></p><ol><li>ULTI/EXEC 命令：<br>在 Redis 中，事务的开始由 MULTI 命令表示，结束由 EXEC 命令表示。在 MULTI 和 EXEC 之间的所有命令会被添加到事务队列中，但不会立即执行。</li><li>WATCH 命令：<br>Redis 提供了 WATCH 命令，可以用于在事务执行之前监视一个或多个键。如果在事务执行过程中，被监视的键被其他客户端修改了，事务将会被打断。</li></ol><h1 id="数据类型实现"><a href="#数据类型实现" class="headerlink" title="数据类型实现"></a>数据类型实现</h1><h3 id="String-字符串-应用场景-缓存对象、常规计数、分布式锁、共享-session-信息等。"><a href="#String-字符串-应用场景-缓存对象、常规计数、分布式锁、共享-session-信息等。" class="headerlink" title="String(字符串) 应用场景:缓存对象、常规计数、分布式锁、共享 session 信息等。"></a>String(字符串) 应用场景:缓存对象、常规计数、分布式锁、共享 session 信息等。</h3><ul><li><strong>底层数据结构是SDS（Simple Dynamic String）简单动态字符串</strong>，保存文本数据，还可以保存二进制数据 。因为 SDS 使用 len 属性 的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li><li>Redis 的 SDS API 是安全的，<strong>拼接字符串不会造成缓冲区溢出</strong> ：因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果<strong>空间不够会自动扩容</strong>，所以不会导致缓冲区溢出的问题。</li></ul><p><strong>使用 String 来缓存对象有两种方式</strong>：</p><p>直接缓存整个对象的 JSON，命令例子： <figure class="highlight plain"><figcaption><span>user:1 '&#123;"name":"xiaolin", "age":18&#125;'```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20**</span><br><span class="line">### List(列表)</span><br><span class="line">- **数据结构**：quicklist（双向链表+压缩列表）</span><br><span class="line">- **类型的应用场景**:消息队列(但是有两个问题:1. 生产者需要自行实现全局唯一ID;2. 不能以消费组形式消费数据)等</span><br><span class="line"></span><br><span class="line">**List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。**</span><br><span class="line"></span><br><span class="line">- 生产者使用 LPUSH key value[value...] 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</span><br><span class="line"></span><br><span class="line">- 消费者使用 RPOP key 依次读取队列的消息，先进先出。</span><br><span class="line"></span><br><span class="line">### Set(集合) 类型:聚合计算(并集、交集、差集)场景，比如点赞、共同关注、抽奖活动等。</span><br><span class="line">- **数据结构**：是由哈希表或整数集合实现的</span><br><span class="line">- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构；</span><br><span class="line">- 如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。</span><br><span class="line">### Zset(有序集合) 类型:排序场景，比如排行榜、电话和姓名排序等</span><br><span class="line">- **数据结构** ：使用 跳表 实现的</span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">#### redis队列和延时队列</span><br><span class="line">- 队列使用list，当队列为空，rpush生产消息，使用blpop消费消息。</span><br><span class="line">- 延时队列使用zset，每个消息对应的时间戳作为score，消息内容当key，**zadd生产消息**，消费者用 **zrangebyscore 指令获取 N 秒之前的数据轮询进行处理**</span><br><span class="line">### Hash(哈希) 类型:缓存对象、购物车等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### BitMap(2.2 版新增):二值状态统计的场景，比如签到、判断用户登陆状态、 连续签到用户总数等;</span><br><span class="line">### HyperLogLog(2.8 版新增):海量数据基数统计的场景，比如百万级网页 UV 计数等;</span><br><span class="line">### GEO</span><br><span class="line">### Stream</span><br><span class="line"># Redis 的线程模型</span><br><span class="line"></span><br><span class="line">**首先**，是单线程模型，它指的是```「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」```这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。</span><br><span class="line"></span><br><span class="line">但是，Redis 程序并不是单线程的，Redis 在启动的时候，是会启动后台线程（BIO）</span><br><span class="line"></span><br><span class="line">### Redis 6.0 之后为什么引入了多线程？</span><br><span class="line">回答：网络IO出现瓶颈，对网络IO引入了多线程处理，命令执行仍然是主线程完成。</span><br><span class="line"></span><br><span class="line">虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，这是因为```随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上```。</span><br><span class="line"></span><br><span class="line">所以为了提高网络 I/O 的并行度，Redis 6.0 **对于网络 I/O 采用多线程来处理**。但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解 Redis 有多线程同时执行命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Redis的零拷贝技术是什么</span><br><span class="line">能省下拷贝开销的地方，一般直接传文件描述符的地址去操作，Linux的sendfile，还有实现内存映射</span><br><span class="line"></span><br><span class="line"># Redis集群</span><br><span class="line"></span><br><span class="line">主从复制，主节点故障时要手动恢复</span><br><span class="line">### 主从模式</span><br><span class="line">读写分离，主节点负责写，从节点负责读。</span><br><span class="line">### 哨兵模式</span><br><span class="line">多个哨兵监控主节点服务器，提供故障转移功能：</span><br><span class="line">【故障转移】：主节点挂了之后，在从节点中选取一个作为主节点</span><br><span class="line"></span><br><span class="line">### 切片集群模式</span><br><span class="line">缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群。</span><br><span class="line">将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</span><br><span class="line">- 切片就是一个redis实例分成多个hash slot，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</span><br><span class="line">- 默认部署的slot个数有16384个，平均分配到各节点上，如果有n个redis实例，那么每个节点有16384/n个slot。</span><br><span class="line"></span><br><span class="line">### 可能出现的问题：</span><br><span class="line">**集群脑裂是什么**：</span><br><span class="line"></span><br><span class="line">由于网络问题，导致主节点与哨兵失联后，哨兵多选举出来一个主节点，当旧节点恢复正常时，降级从节点后，向新master请求同步复制时，清空了自己的缓冲区，产生了之前客户端写入的数据丢失的问题。</span><br><span class="line"></span><br><span class="line">- 如果旧节点又好了，就把旧主节点降级为普通节点，作为从节点向新master进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</span><br><span class="line"></span><br><span class="line">【解决方案】</span><br><span class="line">当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</span><br><span class="line"></span><br><span class="line">【配置文件】</span><br><span class="line">- min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</span><br><span class="line">- min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</span><br><span class="line">### Redis过期删除与内存淘汰</span><br><span class="line"></span><br><span class="line">【过期删除：惰性删除+定期删除】当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个过期字典（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</span><br><span class="line"></span><br><span class="line">- 惰性删除：惰性删除策略的做法是，不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</span><br><span class="line">- 每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</span><br><span class="line">【内存淘汰：不进行数据淘汰的策略/进行数据淘汰的策略】</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 集群与哨兵模式的区别</span><br><span class="line">- 主从集群模式适合对读写性能要求高，且可以容忍一定程度的数据同步延迟的场景</span><br><span class="line">- 哨兵模式适用于对高可用性要求较高的场景，能够实现自动故障切换</span><br><span class="line">## Redis的lua支持</span><br><span class="line">如果你想在 Redis 中定时执行 Lua 脚本，可以考虑使用 Redis 的定时任务功能，例如使用 Redis 的BGSAVE和MONITOR命令配合实现。</span><br><span class="line"></span><br><span class="line">1. 编写 Lua 脚本</span><br><span class="line">首先，你需要编写一个 Lua 脚本，命名为 a.lua 或其他你喜欢的名字。在该脚本中编写你想要定时执行的逻辑。</span><br><span class="line">2. 使用 BGSAVE</span><br><span class="line">Redis 的 BGSAVE 命令用于在后台执行持久化操作（将数据写入磁盘），这会创建一个快照文件。你可以利用这个特性来触发 Lua 脚本的执行。</span><br><span class="line">客户端执行```BGSAVE</span><br></pre></td></tr></table></figure></p><p>请注意，BGSAVE 不会阻塞 Redis 的主线程，因此可以在 Redis 运行时执行。</p><ol start="3"><li>使用 MONITOR<br>Redis 的 MONITOR 命令可以用于实时监控 Redis 的命令执行情况。你可以通过监控 Redis 的命令来捕捉 BGSAVE 命令的执行，一旦发现 BGSAVE 命令执行完毕，就可以在 Lua 脚本中调用 EVAL 来执行你的逻辑。</li></ol><h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><h2 id="介绍缓存雪崩，缓存击穿，缓存穿透"><a href="#介绍缓存雪崩，缓存击穿，缓存穿透" class="headerlink" title="介绍缓存雪崩，缓存击穿，缓存穿透"></a>介绍缓存雪崩，缓存击穿，缓存穿透</h2><ul><li><strong>缓存雪崩</strong> 指大量缓存数据在同一时间过期时，大量的用户请求全部直接访问数据库，从而导致数据库崩溃的问题，从而形成一系列连锁反应，造成整个系统崩溃。</li><li><strong>缓存击穿</strong> 指某个数据过期时，大量用户请求直接访问该数据，导致高并发的数据库请求</li><li><strong>缓存穿透</strong> 当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。</li></ul><p>【缓存雪崩解决方法】</p><ol><li>设置缓存失效时间随机打乱</li><li>设置多级缓存</li><li>设置缓存不过期，使用后台接口进行操作redis，不推荐，人工要考虑的太麻烦</li><li></li></ol><p>【缓存击穿解决方法】</p><ol><li>互斥锁方案（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ol><p>【缓存穿透解决方法】</p><ol><li><p><strong>布隆过滤器</strong>：快速判断数据是否存在，避免通过查询数据库来判断数据是否存在：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p></li><li><p>设置空值或者默认值</p></li><li><p>在API入口处判断请求参数有没有非法值/是否存在</p></li></ol><h2 id="热点数据缓存策略"><a href="#热点数据缓存策略" class="headerlink" title="热点数据缓存策略"></a>热点数据缓存策略</h2><p>热点数据动态缓存的策略总体思路：通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。</p><h2 id="【面试题】缓存更新策略"><a href="#【面试题】缓存更新策略" class="headerlink" title="【面试题】缓存更新策略"></a>【面试题】缓存更新策略</h2><ul><li>Cache Aside（旁路缓存）策略；</li><li>Read/Write Through（读穿 / 写穿）策略；</li><li>Write Back（写回）策略；</li></ul><h2 id="【面试题】数据库和缓存如何保证一致性"><a href="#【面试题】数据库和缓存如何保证一致性" class="headerlink" title="【面试题】数据库和缓存如何保证一致性"></a>【面试题】数据库和缓存如何保证一致性</h2><h2 id="【面试题】常见性能问题和解决方案"><a href="#【面试题】常见性能问题和解决方案" class="headerlink" title="【面试题】常见性能问题和解决方案"></a>【面试题】常见性能问题和解决方案</h2><ol><li>Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大 的，会间断性暂停服务</li><li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</li><li>为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局 域网</li><li>尽量避免在压力很大的主库上增加从</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即:Master &lt;- Slave1&lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启 用 Slave1 做 Master，其他不变。</li></ol><h2 id="过期key的删除策略"><a href="#过期key的删除策略" class="headerlink" title="过期key的删除策略"></a>过期key的删除策略</h2><ul><li>定时删除单key：一个是添加的key的时候， expire指定时间</li><li>惰性删除：每次查找key时，都会判断是否过期</li><li>定期批量删除：每隔一段时间扫库，删除过期key<h2 id="Redis回收-淘汰策略"><a href="#Redis回收-淘汰策略" class="headerlink" title="Redis回收/淘汰策略"></a>Redis回收/淘汰策略</h2></li></ul><ol><li>volatile-lru:从已设置过期时间的数据集(server.db[i].expires)中挑选 最近最少使用的数据淘汰</li><li>volatile-ttl:从已设置过期时间的数据集(server.db[i].expires)中挑选 将要过期的数据淘汰</li><li>volatile-random:从已设置过期时间的数据集(server.db[i].expires)中任 意选择数据淘汰</li><li>allkeys-lru:从数据集(server.db[i].dict)中挑选最近最少使用的数据淘 汰</li><li>allkeys-random:从数据集(server.db[i].dict)中任意选择数据淘汰</li><li>no-enviction(驱逐):禁止驱逐数据 注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置 过期时间的数 据集淘汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是 三种不同 的淘汰策略，再加上一种no-enviction 永不回收的策略。<h2 id="如何选取上述策略？"><a href="#如何选取上述策略？" class="headerlink" title="如何选取上述策略？"></a>如何选取上述策略？</h2></li><li>如果数据分布的差不多，使用allkeys random</li><li>如果数据分布差别大，使用allkeys lru</li></ol><h2 id="redis集群的原理"><a href="#redis集群的原理" class="headerlink" title="redis集群的原理"></a>redis集群的原理</h2><ol><li><p>哨兵模式，高可用性，在master宕机时自动将slave提升为master</p></li><li><p>集群模式，扩展性，单个redis内存不足时，使用cluster进行分片存储</p><ul><li>集群没用一致性hash，而是用了hash槽，有16384个hash槽，每个节点负责一部分槽</li><li>主从复制模型，每个节点都是其他节点的副本<h2 id="集群会有写操作丢失吗【会】为什么？"><a href="#集群会有写操作丢失吗【会】为什么？" class="headerlink" title="集群会有写操作丢失吗【会】为什么？"></a>集群会有写操作丢失吗【会】为什么？</h2></li></ul></li><li><p>当发生故障转移（failover）时，在连接丢失的情况下，部分写操作无法完成</p></li><li><p>另外如果用了RDB，主节点写操作存在buffer里，转移主节点时，这部分不进行复制，导致写操作丢失，所以可以使用混合方式，写操作使用AOF持久化一下，转移主节点后重放AOF日志</p><h2 id="redis事务了解吗"><a href="#redis事务了解吗" class="headerlink" title="redis事务了解吗"></a>redis事务了解吗</h2><p>multi exec discard watch</p><h2 id="如何优化redis内存占用和性能【内存优化】"><a href="#如何优化redis内存占用和性能【内存优化】" class="headerlink" title="如何优化redis内存占用和性能【内存优化】"></a>如何优化redis内存占用和性能【内存优化】</h2></li><li><p>对小数据合并到一个对象中，用hash存储</p></li><li><p>设置合理的过期策略，和内存淘汰策略等</p></li><li><p>使用持久化保证高可用性</p></li><li><p>使用布隆过滤器，防止缓存穿透和击穿问题，查看一个元素是否存在于一个集合中</p></li><li><p>删除key后的碎片整理：Redis 会在删除键值对后，释放内存并且尝试整理内存碎片。可以通过配置文件中的 activerehashing 参数来控制内存碎片整理的行为。</p><h2 id="假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某-个固定的已知的前缀开头的，如果将它们全部找出来"><a href="#假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某-个固定的已知的前缀开头的，如果将它们全部找出来" class="headerlink" title="假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某 个固定的已知的前缀开头的，如果将它们全部找出来?"></a>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某 个固定的已知的前缀开头的，如果将它们全部找出来?</h2></li></ol><ul><li>使用scan无阻塞地去提取正则字符串，然后在客户端用一个set去重</li><li>keys也可以扫，但是会导致阻塞，线上服务会停</li></ul><h2 id="redis内存回收进程"><a href="#redis内存回收进程" class="headerlink" title="redis内存回收进程"></a>redis内存回收进程</h2><p><a href="https://cloud.tencent.com/developer/article/2315748" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/2315748</a><br>Redis回收进程指对那些已过期但是尚未被删除的 keys 进行标记，这样它们就可以在之后被立即释放并回收所占用的内存</p><ol><li>基本原理是周期性地扫描存储数据库中所有的键<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Redis 提供了三个与内存回收相关的命令：</span><br><span class="line"></span><br><span class="line">MEMORY USAGE key：</span><br><span class="line">用于返回指定键所占用的内存字节数。可以通过传递键的名称作为参数来获取相应键的内存使用情况。</span><br><span class="line">MEMORY PURGE：</span><br><span class="line">该命令用于在 Redis Enterprise 中手动触发内存回收。</span><br><span class="line">MEMORY DOCTOR：</span><br><span class="line">该命令用于诊断 Redis 内存分配和使用情况，帮助识别内存泄漏或者不正常的内存使用情况。</span><br><span class="line">需要注意的是，MEMORY PURGE 和 MEMORY DOCTOR 是 Redis Enterprise 特有的命令，而 MEMORY USAGE 是 Redis 通用的命令。</span><br></pre></td></tr></table></figure></li></ol><h2 id="如何使用redis实现一个分布式锁"><a href="#如何使用redis实现一个分布式锁" class="headerlink" title="如何使用redis实现一个分布式锁"></a>如何使用redis实现一个分布式锁</h2><ul><li>set if not exist拿锁，拿到之后expire给锁加一个过期时间，</li></ul><h2 id="Redis内存耗尽会怎样"><a href="#Redis内存耗尽会怎样" class="headerlink" title="Redis内存耗尽会怎样"></a>Redis内存耗尽会怎样</h2><p>崩溃，可能导致缓存失效，命中率下降，虚拟内存<br><a href="https://juejin.cn/post/6932711444404256781" target="_blank" rel="noopener">https://juejin.cn/post/6932711444404256781</a></p><ol><li>会使用LRU和LFU的内存淘汰策略</li></ol><h2 id="LRU-最近最长时间未被使用"><a href="#LRU-最近最长时间未被使用" class="headerlink" title="LRU 最近最长时间未被使用"></a>LRU 最近最长时间未被使用</h2><h2 id="LFU-最近最少频率使用"><a href="#LFU-最近最少频率使用" class="headerlink" title="LFU 最近最少频率使用"></a>LFU 最近最少频率使用</h2><h2 id="stream数据结构"><a href="#stream数据结构" class="headerlink" title="stream数据结构"></a>stream数据结构</h2><ol><li>基于基数树</li></ol><h2 id="缓存穿透miss-和击穿breakdown-怎么解决"><a href="#缓存穿透miss-和击穿breakdown-怎么解决" class="headerlink" title="缓存穿透miss 和击穿breakdown 怎么解决"></a>缓存穿透miss 和击穿breakdown 怎么解决</h2><ul><li>击穿是breakdown，要查找的热点缓存突然过期，导致大量请求向mysql涌入，导致崩溃等问题</li><li>穿透是缓存中没有这些key，没有方法满足这些请求<h2 id="穿透的解决方式"><a href="#穿透的解决方式" class="headerlink" title="穿透的解决方式"></a>穿透的解决方式</h2></li></ul><ol><li>在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回</li><li>简单处理，存无效key，value设为null</li></ol><h2 id="如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题"><a href="#如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题" class="headerlink" title="如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题"></a>如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题</h2><ul><li>设置过期时间时加上随机值，使得缓存失效的时间点尽量均匀分布。</li><li>使用 Redis 集群，将缓存数据分散到多个节点上，避免单点故障。</li><li>在缓存失效后采用加锁或者队列来控制<strong>读数据库写缓存</strong>的线程数量，避免大量线程同时读数据库。</li><li>针对热点数据可以设置永不过期，或者使用手动过期的方式来控制缓存的使用时间</li><li>高并发时，使用限流和熔断机制控制请求访问量</li><li>本地和分布式缓存结合，服务器本地当二级缓存</li></ul><h2 id="热key问题怎么解决"><a href="#热key问题怎么解决" class="headerlink" title="热key问题怎么解决"></a>热key问题怎么解决</h2><p>热key问题是由于某部分热点key分布在不同的节点上，导致负载不均衡</p><ul><li>解决方法，1使用分布式缓存，读写分离架构 2 数据分片策略 3 缓存失效策略避免一直是热key</li><li>如果热Key的产生<strong>来自于读请求</strong>使用读写分离架构<br>您可以将实例改造成读写分离架构来降低每个数据分片的读请求压力，甚至可以不断地增加从节点。但是读写分离架构在增加业务代码复杂度的同时，也会增加Redis集群架构复杂度。不仅要为多个从节点提供转发层（如Proxy，LVS等）来实现负载均衡，还要考虑从节点数量显著增加后带来故障率增加的问题。<h2 id="单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】"><a href="#单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】" class="headerlink" title="单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】"></a>单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】</h2></li></ul><h2 id="redis-6-0-前后不支持与支持多线程的理由"><a href="#redis-6-0-前后不支持与支持多线程的理由" class="headerlink" title="redis 6.0 前后不支持与支持多线程的理由"></a>redis 6.0 前后不支持与支持多线程的理由</h2><ol><li>6.0前，避免竞态条件，上下文切换的开销，充分利用CPU</li><li>6.0后的多线程主要引入的是IO和AOF和RDB备份</li></ol><h2 id="提高命中率的方式"><a href="#提高命中率的方式" class="headerlink" title="提高命中率的方式"></a>提高命中率的方式</h2><ol><li>缓存过期时间</li><li>缓存预热</li><li>LRU LFU分别基于访问时间和频率来确定缓存中的数据</li><li>使用分布式缓存，将缓存数据分布到多节点上<!-- 5. 使用分布式锁，布隆过滤器等手段去提高可用性，提供维护时间长 --></li></ol><h2 id="redis-如何解决key冲突"><a href="#redis-如何解决key冲突" class="headerlink" title="redis 如何解决key冲突"></a>redis 如何解决key冲突</h2><ol><li><p>命名时注意不冲突，比如加前缀后缀</p></li><li><p>不同数据存合适的数据结构</p></li><li><p>分布式锁来保证并发冲突</p></li><li><p>单线程下使用mutex方法<br>内存模型是hashtable，解决key冲突可能就链地址 开地址哪些吧</p></li></ol><h2 id="redis-如何解决大key问题【key的value过大】"><a href="#redis-如何解决大key问题【key的value过大】" class="headerlink" title="redis 如何解决大key问题【key的value过大】"></a>redis 如何解决大key问题【key的value过大】</h2><p><a href="https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys" target="_blank" rel="noopener">bigkey solution</a></p><h3 id="大key产生的问题"><a href="#大key产生的问题" class="headerlink" title="大key产生的问题"></a>大key产生的问题</h3><ol><li>执行变慢，删除时产生阻塞，内存溢出</li></ol><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><ol><li>如果已经发现了一个大key，就遍历把它插成大key1 key2 key3，限制长度</li><li>不要这个大key时，使用UNLINK删除</li><li><strong>使用redis分片技术</strong>：</li></ol><ul><li><p>一致性hash:<br>将哈希值映射到一个固定大小的环形空间中。客户端根据键的哈希值定位到环上的某个位置，然后找到离该位置最近的节点，将数据存储在该节点上。</p><ul><li><strong>优点</strong>：在节点的增减时，只有少量的数据需要重新映射，保持了相对的稳定性。</li><li><strong>缺点</strong>：可能会出现不均匀的数据分布，导致节点负载不均</li></ul></li><li><p>CRC16:<br>循环冗余校验来生成哈希值</p><ul><li><strong>优点</strong>：计算速度快，适用于一些简单的分布式场景。</li><li><strong>缺点</strong>：可能会导致节点负载不均衡。</li></ul></li><li><p>RedisCluster<br>它将数据分片到多个节点上，同时提供了节点间的数据复制和故障恢复机制</p><ul><li><strong>优点</strong>自动进行数据分片和复制，实现了高可用性。</li><li><strong>缺点</strong>好用但是复杂 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key本身的数据量过大：一个String类型的Key，它的值为5 MB。</span><br><span class="line">Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。</span><br><span class="line">Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="redis慢查询如何排查"><a href="#redis慢查询如何排查" class="headerlink" title="redis慢查询如何排查"></a>redis慢查询如何排查</h2><p>命令：</p><ol><li>慢查询日志：SHOWLOG GET</li><li>redis-cli的INFO</li><li>redis有一个时延监控命令，–latency查询命令</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;questions&lt;/p&gt;
&lt;p&gt;使用go-redis连接，因为redigo无法连接redis集群&lt;br&gt;redis集群可以用kratos的或者go-zero的分布式锁实现&lt;br&gt;&lt;a href=&quot;https://juejin.cn/post/7041375517580689439&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.cn/post/7041375517580689439&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://waynamigo.github.io/categories/Redis/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Redis" scheme="http://waynamigo.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>NetWorking</title>
    <link href="http://waynamigo.github.io/2023/01/04/2023-01-04-%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://waynamigo.github.io/2023/01/04/2023-01-04-面经计算机网络/</id>
    <published>2023-01-03T16:00:00.000Z</published>
    <updated>2023-12-02T02:12:51.648Z</updated>
    
    <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><p>MAC头部：6<br>IP头部：20<br>TCP头部：20到60字节<br>UDP头部：8<br>TCP最大长度 65535 - 头部<br>UDP最大长度 65535 - 头部</p><h2 id="RPC和HTTP（RESTFul）的区别"><a href="#RPC和HTTP（RESTFul）的区别" class="headerlink" title="RPC和HTTP（RESTFul）的区别"></a>RPC和HTTP（RESTFul）的区别</h2><p><a href="https://zhuanlan.zhihu.com/p/200656764" target="_blank" rel="noopener">rpc</a></p><ol><li>支持的协议：RPC支持多种协议，包括上层实现，比如grpc基于http2.0实现的，HTTP底层是TCP</li><li>消息的序列化：RPC，支持多种消息，protobuf/json等，HTTP底层是用json，xml封装的request的文本协议，进行序列化反序列化的</li><li>http的请求头部很长，rpc的话一般可以压缩一些<h2 id="为什么微服务用grpc而不是http"><a href="#为什么微服务用grpc而不是http" class="headerlink" title="为什么微服务用grpc而不是http"></a>为什么微服务用grpc而不是http</h2>grpc 基于HTTP/2 提供了诸如多路复用、头部压缩等特性，可以显著提升通信效率<h2 id="get-post-put-delete的区别【幂等性：操作多次，导致服务器到达的结果是想等的】"><a href="#get-post-put-delete的区别【幂等性：操作多次，导致服务器到达的结果是想等的】" class="headerlink" title="get post put delete的区别【幂等性：操作多次，导致服务器到达的结果是想等的】"></a>get post put delete的区别【幂等性：操作多次，导致服务器到达的结果是想等的】</h2></li><li>get，一个具有幂等性的请求，参数在url后作为参数，只有get的请求数据会被缓存</li><li>post，不具有幂等性，参数封装在请求体中，数据不会被缓存</li><li>put一般放文件，delete用来删除文件，也都是幂等的</li></ol><h2 id="三次握手变成两次会发生什么"><a href="#三次握手变成两次会发生什么" class="headerlink" title="三次握手变成两次会发生什么"></a>三次握手变成两次会发生什么</h2><p><a href="https://zhuanlan.zhihu.com/p/347519096" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/347519096</a><br><a href="https://blog.csdn.net/lengxiao1993/article/details/82771768" target="_blank" rel="noopener">https://blog.csdn.net/lengxiao1993/article/details/82771768</a></p><ol><li>第三次握手报文没有的话，二次握手维护的序列号没有第三次的确认号确认，服务端就无法确认客户端准备ok，触发超时重传，就无法协商它们的滑动窗口和拥塞窗口了<h2 id="四次握手第四次没确认的话会发生什么"><a href="#四次握手第四次没确认的话会发生什么" class="headerlink" title="四次握手第四次没确认的话会发生什么"></a>四次握手第四次没确认的话会发生什么</h2>四次没确认就是<h2 id="四次握手最后一次time-wait状态为什么要等待两个MSL"><a href="#四次握手最后一次time-wait状态为什么要等待两个MSL" class="headerlink" title="四次握手最后一次time-wait状态为什么要等待两个MSL"></a>四次握手最后一次time-wait状态为什么要等待两个MSL</h2>两个最大生存时间</li><li>为了保证A对第三次FIN挥手的确认报文到达B，如果没收到第四次的握手确认，B重传第三次挥手信号<h3 id="为什么不是一个MSL"><a href="#为什么不是一个MSL" class="headerlink" title="为什么不是一个MSL"></a>为什么不是一个MSL</h3>如果检测丢包所用的时间用了一个MSL，就根本没有接收到三次握手重传报文的机会了<h2 id="TCP的字节序是大端还是小端【大端】为什么？"><a href="#TCP的字节序是大端还是小端【大端】为什么？" class="headerlink" title="TCP的字节序是大端还是小端【大端】为什么？"></a>TCP的字节序是大端还是小端【大端】为什么？</h2>小端字节序是将最低有效字节存储在内存的最低地址处，而大端字节序则是将最高有效字节存储在最低地址处。</li><li>网络字节序是大端，arm64和x86主机采用主机字节序，是小端</li><li>如果两台主机的CPU架构或者字节序不同（比如一台是小端序，另一台是大端序），TCP协议会在传输过程中自动进行字节序的转换，以保证接收方能够正确地解析数据。</li></ol><ul><li>创建socket或bind时，要用htonl、htons等函数来将端口或ip地址从主机字节序转换成网络字节序</li><li>send，recv等函数传输的只是字节流，不关心大小端序<h2 id="TCP如何保证可靠的"><a href="#TCP如何保证可靠的" class="headerlink" title="TCP如何保证可靠的"></a>TCP如何保证可靠的</h2></li></ul><ol><li>头部维护的校验和字段（CRC）</li><li>三次握手和四次挥手</li><li>超时重传（TTS字段）</li><li>流量控制（滑动窗口）</li><li>拥塞控制（拥塞窗口 + 慢启动）<h2 id="TCP半连接队列和全连接队列"><a href="#TCP半连接队列和全连接队列" class="headerlink" title="TCP半连接队列和全连接队列"></a>TCP半连接队列和全连接队列</h2>在TCP连接的建立过程中，会涉及到半连接队列（SYN队列）和全连接队列（ESTABLISHED队列）。</li></ol><ul><li>半连接队列中存放的是三次握手中的第一步（即SYN）发送的连接请求，还没有得到完全建立连接的确认</li><li>当TCP连接成功建立后，会被移动到全连接队列<h2 id="粘包和拆包"><a href="#粘包和拆包" class="headerlink" title="粘包和拆包"></a>粘包和拆包</h2>由于网络传输中的数据分片、路由器缓冲区大小限制、接收端缓冲区大小设置等因素造成的</li><li><strong>粘包</strong>：多个数据包被合并成一个大的数据块</li><li><strong>拆包</strong>：只收到了一个大包，被拆成了多个小块</li><li>TCP选项字段可以设置MTU，指网络通信中能够通过的最大数据包的大小。通过设置MTU，可以控制单个数据包的大小，但并不能解决粘包和拆包的问题。</li><li>粘包和拆包问题主要是因为TCP协议是流协议，它并没有记录消息的边界信息。因此，在数据传输过程中，可能会出现多个消息被合并成一个包（粘包）或一个消息被拆分成多个包（拆包）的情况。</li></ul><h2 id="TCP为什么要等待2MSL【为了保证最后一次握手成功】"><a href="#TCP为什么要等待2MSL【为了保证最后一次握手成功】" class="headerlink" title="TCP为什么要等待2MSL【为了保证最后一次握手成功】"></a>TCP为什么要等待2MSL【为了保证最后一次握手成功】</h2><p>因为服务端发送FIN以后，客户端发送第四次的挥手确认后，服务端可能接收不到，触发了重传，一个四次挥手的ACK和重传的FIN各占一个MSL</p><h1 id="TCP最大长度为2的32次方-头部字段"><a href="#TCP最大长度为2的32次方-头部字段" class="headerlink" title="TCP最大长度为2的32次方-头部字段"></a>TCP最大长度为2的32次方-头部字段</h1><h3 id="解决办法【固定长度，消息边界，定时器，缓冲区】"><a href="#解决办法【固定长度，消息边界，定时器，缓冲区】" class="headerlink" title="解决办法【固定长度，消息边界，定时器，缓冲区】"></a>解决办法【固定长度，消息边界，定时器，缓冲区】</h3><ol><li>头部字段，固定消息长度</li><li>帧数据字段加入边界信息，比如某个特定字符</li><li>使用定时器来等待足够长的时间以接收完整的消息，</li><li>可以通过合理设置缓冲区大小来保证完整接收消息<h2 id="TCP的TIMEWAIT状态过多会发生什么"><a href="#TCP的TIMEWAIT状态过多会发生什么" class="headerlink" title="TCP的TIMEWAIT状态过多会发生什么"></a>TCP的TIMEWAIT状态过多会发生什么</h2>TCP的TIME_WAIT状态发生在第四次挥手，是为了确保在网络中所有的数据包都被正确地接收和处理，以避免出现数据包混淆或丢失的情况</li><li>内存资源、端口资源大量被占用，新连接无法建立，被网络攻击，导致程序崩溃等情况</li><li>拒绝服务（DOS）攻击，端口扫描攻击<h3 id="【如何解决】"><a href="#【如何解决】" class="headerlink" title="【如何解决】"></a>【如何解决】</h3></li><li>在程序里设置一个等待参数，超时退出</li><li>使用连接池复用连接<h2 id="传输内容"><a href="#传输内容" class="headerlink" title="传输内容"></a>传输内容</h2>应用层 报文<br>传输层 报文段<br>网络层 数据包<br>链路层 数据帧<br>物理层 比特流<h2 id="网络层实现转发"><a href="#网络层实现转发" class="headerlink" title="网络层实现转发"></a>网络层实现转发</h2><h2 id="路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？"><a href="#路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？" class="headerlink" title="路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？"></a>路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？</h2>路由表通常使用前缀树（Trie）存储路由表项，存的是一个<strong>IP地址与下一跳路由器，即路由器的IP地址</strong>，的映射<br>没有要查找的IP，则跳到默认的下一跳，如果一直转发默认下一跳，则丢弃或者不可达信号</li></ol><h2 id="简述TCP的拥塞控制"><a href="#简述TCP的拥塞控制" class="headerlink" title="简述TCP的拥塞控制"></a>简述TCP的拥塞控制</h2><p>首先，通过<strong>慢启动</strong>机制，当建立新的TCP连接时，发送方会谨慎地开始发送数据，逐步增大发送量以避免过快发送引起网络拥塞，每次x2。其次，一旦拥塞窗口达到设定阈值，TCP进入<strong>拥塞避免</strong>状态，发送方将<strong>以线性方式增大拥塞窗口</strong>，以保持合理的数据传输速率。</p><ol><li>发现数据丢失时，用<strong>快速重传和快速恢复机制</strong>：1.计时器检测没有确认，超时重传发生，TCP会将拥塞窗口减半，再线性增加。<h2 id="简述TCP的流量控制【确保接收方能以自己的接收速度来处理】"><a href="#简述TCP的流量控制【确保接收方能以自己的接收速度来处理】" class="headerlink" title="简述TCP的流量控制【确保接收方能以自己的接收速度来处理】"></a>简述TCP的流量控制【确保接收方能以自己的接收速度来处理】</h2>通过接收方维护接收的窗口实现的。<br>发送方<h1 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h1><h2 id="HTTP的无状态、明文传输特性"><a href="#HTTP的无状态、明文传输特性" class="headerlink" title="HTTP的无状态、明文传输特性"></a>HTTP的无状态、明文传输特性</h2></li></ol><ul><li>无状态：在处理每个请求时都不会记住之前的请求，每个请求都是独立的，不依赖于之前的请求</li><li>状态码：状态码用来指示<strong>服务器对请求</strong>的处理状态<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2></li><li>强制缓存：浏览器判断缓存没有过期，则直接使用浏览器的本地缓存</li><li>协商缓存：通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存，响应状态码为304。</li><li>【TIP】只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</li></ul><h2 id="HTTP-和HTTPs-的区别"><a href="#HTTP-和HTTPs-的区别" class="headerlink" title="HTTP 和HTTPs 的区别"></a>HTTP 和HTTPs 的区别</h2><ol><li>HTTP是明文传输，HTTPS使用了SSL证书来建立加密传输过程，HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li><li>HTTP是直接运行在TCP协议基础上的，HTTPS是运行在SSL协议上，其中SSL协议建立在TCP之上，使用加密和身份验证保证安全性</li><li>HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>CA证书放在服务器上，证书内容包含服务器的公钥、持有者信息、颁发者信息、有效期等等</li><li>CA证书验证：服务器向客户端发送证书时，客户端会使用相应的CA的公钥来验证证书的合法性。包括检查证书的数字签名是否正确、证书是否在有效期内等。</li><li>CA信任链验证：如果客户端信任该CA（通常是因为<strong>CA的根证书</strong>预装在操作系统或浏览器中），那么客户端将信任由该CA签发的证书。</li></ol><h2 id="cookie和session-token的区别"><a href="#cookie和session-token的区别" class="headerlink" title="cookie和session,token的区别"></a>cookie和session,token的区别</h2><p><a href="https://zhuanlan.zhihu.com/p/625995458" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/625995458</a><br><a href="https://zhuanlan.zhihu.com/p/164696755" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/164696755</a></p><h3 id="1-区别"><a href="#1-区别" class="headerlink" title="1.区别"></a>1.区别</h3><ol><li>cookie存在本地，session存在服务器上，cookie不安全，用户本地向服务器请求的申请，session用于会话控制，在服务端记录用户状态</li><li>cookie存的字段都是字符串，session的话，跟随服务端数据类型</li><li>cookie存的数据较少，最多4kb；session可以存的多，生命周期比短</li><li>cookie主要字段如下：name expires domain path<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://pic2.zhimg.com/80/v2-e3e9981e1aa6818285f1981ba92eeb15_1440w.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">session存的具体字段取决于你在应用程序中选择存储的信息。这些字段可以是任何你认为在会话期间需要跟踪和使用的数据。以下是一些可能存储在Session中的字段的例子：</span><br><span class="line"></span><br><span class="line">用户ID：用于标识当前会话所属的用户。</span><br><span class="line">示例：user_id: 12345</span><br><span class="line">用户名：用于显示在界面上或者用于显示欢迎消息等。</span><br><span class="line">示例：username: johndoe</span><br><span class="line">角色或权限信息：用于确定用户具有的权限级别或角色。</span><br><span class="line">示例：role: admin</span><br><span class="line">购物车内容：存储用户在购物网站中选择的商品信息。</span><br><span class="line">示例：cart: [item1, item2, item3]</span><br><span class="line">用户首选语言：用于提供多语言支持。</span><br><span class="line">示例：preferred_language: en</span><br><span class="line">上次访问时间：用于跟踪用户的活动情况。</span><br><span class="line">示例：last_visit: 2023-11-05 10:30:00</span><br><span class="line">登录状态：用于标识用户是否已登录。</span><br><span class="line">示例：logged_in: true</span><br><span class="line">安全令牌：用于防止CSRF等安全攻击。</span><br><span class="line">示例：csrf_token: abcdef123456</span><br><span class="line">用户设置：例如主题偏好、通知偏好等。</span><br><span class="line">示例：theme: dark</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-作用机制"><a href="#2-作用机制" class="headerlink" title="2.作用机制"></a>2.作用机制</h3><p>cookie存了一个session ID，用户发请求时，cookie随请求body一起提交，然后session根据ID解析用户名密码，如果没找到，说明用户没登录或者失效</p><h3 id="3-token是什么"><a href="#3-token是什么" class="headerlink" title="3. token是什么"></a>3. token是什么</h3><p>token的生命周期： token的验证：再次请求时，携带此token，则服务端再次根据用户标识，生成token，根据两个token是否一致且未过期来判定用户是否已授权。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端使用用户名跟密码请求登录</span><br><span class="line">2. 服务端收到请求，去验证用户名与密码</span><br><span class="line">3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</span><br><span class="line">4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</span><br><span class="line">5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token</span><br><span class="line">6. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</span><br></pre></td></tr></table></figure><ol><li>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</li><li>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</li><li>token 完全由应用管理，所以它可以避开同源策略</li><li>token由服务器生成并返回给客户端，是一种no-session的方式（当然也不需要cookie）。在Web应用程序中，Token通常是包含用户身份信息的加密字符串，JWT的工具类<h3 id="4-token和session-cookie"><a href="#4-token和session-cookie" class="headerlink" title="4. token和session-cookie"></a>4. token和session-cookie</h3></li><li>token使每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</li><li>Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。</li><li>Token 使服务端无状态化，不会存储会话信息。</li></ol><ul><li>安全做法：将accessToken存在内存中，refreshToken由backend通过set-cookie的方式存在http-only的cookie中<h3 id="5-jwt和session的优劣"><a href="#5-jwt和session的优劣" class="headerlink" title="5. jwt和session的优劣"></a>5. jwt和session的优劣</h3></li></ul><ol><li>jwt是时间换空间，大量并发请求会导致压力比session方式压力大，然后在服务端生成jwt，每次请求都有新的jwt，如果用https请求发送，安全性也高一些</li><li>jwt一旦创建就得等待过期，session适合用于大型项目<h3 id="6-分布式session"><a href="#6-分布式session" class="headerlink" title="6. 分布式session"></a>6. 分布式session</h3></li><li>共享session<br>首先保证一个可用的redis集群，可以加redis服务器水平扩展，服务器重启session不会丢失</li><li>session复制，在各服务器里复制，会造成网络负荷压力</li><li>粘性session，将请求重定向到某个有session的服务器上，负载均衡去转发，缺乏容错措施</li></ol><h2 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h2><p><a href="https://juejin.cn/post/7121237647829237768" target="_blank" rel="noopener">https://juejin.cn/post/7121237647829237768</a><br><a href="https://juejin.cn/post/7288961029936578560" target="_blank" rel="noopener">https://juejin.cn/post/7288961029936578560</a></p><ol><li>JWY包括头部(Header)载荷(Payload)签名(Signature)三个部分<h2 id="rpc完整的调用过程"><a href="#rpc完整的调用过程" class="headerlink" title="rpc完整的调用过程"></a>rpc完整的调用过程</h2></li><li>调用方持续把请求参数对象序列化成二进制数据，经过 TCP 传输到服务提供方；</li><li>服务提供方从 TCP 通道里面接收到二进制数据；</li><li>根据 RPC 协议，服务提供方将二进制数据分割出不同的请求数据，经过反序列化将二进制数据逆向</li><li>还原出请求对象，找到对应的实现类，完成真正的方法调用；</li><li>然后服务提供方再把执行结果序列化后，回写到对应的 TCP 通道里面；</li><li>调用方获取到应答的数据包后，再反序列化成应答对象。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/2021021617062398.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="RPC的关键技术"><a href="#RPC的关键技术" class="headerlink" title="RPC的关键技术"></a>RPC的关键技术</h2></li></ol><h2 id="HTTP状态码目录"><a href="#HTTP状态码目录" class="headerlink" title="HTTP状态码目录"></a>HTTP状态码目录</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></p><ul><li>200：成功返回响应</li><li>301：永久重定向，客户端第一次访问此 url 时，告知客户端以后直接访问新的 url，该状态保存在浏览器缓存中。</li><li>302；临时重定向，客户端每次访问此 url 时，告知客户端重定向到新的 url ，后续访问依然访问当前的 url。</li><li>304：使用协商缓存</li><li>400：发送的请求错误，请求格式错误，或者没有服务器要求的数据。</li><li>401：没有权限访问，当前用户没有权限访问此资源。</li><li>403：请求被服务器禁止。</li><li>404：请求的 url 不存在，一般是 url 出错。</li><li>500：服务器处理请求出现错误。</li><li>501：服务器超出能力之外的方法，例如：请求的方法服务器不支持。</li><li>504：来自网关或者代理服务器，请求资源服务器时超时。</li></ul><h2 id="HTTP2：解决HTTP延迟高的问题"><a href="#HTTP2：解决HTTP延迟高的问题" class="headerlink" title="HTTP2：解决HTTP延迟高的问题"></a>HTTP2：解决HTTP延迟高的问题</h2><ul><li>延迟高的原因：请求-响应模型、头部巨大且重复、并发连接耗时、服务器不能主动推送等<h3 id="解决方法与针对的问题"><a href="#解决方法与针对的问题" class="headerlink" title="解决方法与针对的问题"></a>解决方法与针对的问题</h3></li><li>头部压缩：Cookie、User Agent、Accept 头部字段内容太大</li><li>二进制帧：字段传输速度，便于位运算</li><li>并发传输：缓解了队头阻塞问题（没有解决）</li><li>服务端主动推送资源<h3 id="方法细节"><a href="#方法细节" class="headerlink" title="方法细节"></a>方法细节</h3></li><li>头部压缩：使用Hpack算法，静态字典/动态字典/哈夫曼编码。客户端和服务器两端都会建立和维护「字典」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，可达到 50%~90% 的高压缩率。</li><li>二进制帧：响应报文划分成了两类帧，包括 首部 和 DATA（负载），也就是说一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码。</li><li>并发传输：使用 Stream 设计，多个 Stream 复用一条 TCP 连接，达到并发的效果</li></ul><p><img src="/images/http2stream.webp" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；</span><br><span class="line">- Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；</span><br><span class="line">- Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；</span><br><span class="line">- 一个 Frame 可以由多个 TCP 报文构成</span><br><span class="line">- 不同stream的帧可以乱序，帧头部可以带stream ID，接收端可以重组</span><br></pre></td></tr></table></figure><ul><li>服务端推送资源：客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 PUSH_PROMISE 帧传输 HTTP 头部，并通过帧中的 Promised Stream ID 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。<h2 id="HTTP3-quic协议，使用HTTP2-TLS-UDP"><a href="#HTTP3-quic协议，使用HTTP2-TLS-UDP" class="headerlink" title="HTTP3: quic协议，使用HTTP2 + TLS + UDP"></a>HTTP3: quic协议，使用HTTP2 + TLS + UDP</h2>HTTP2存在问题：</li></ul><ol><li>TCP层的队头阻塞问题：HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。<ul><li><strong>TCP 是字节流协议</strong>。TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。</li></ul></li><li>TCP 与 TLS 的握手时延迟：TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生“减速”效果</li><li>网络迁移需要重新连接：<h3 id="quic协议"><a href="#quic协议" class="headerlink" title="quic协议"></a>quic协议</h3></li><li>无队头阻塞：传输层协议换成UDP，根本上避免了TCP的队头阻塞。<ul><li>quic协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。</li><li>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li></ul></li><li>更快的连接建立：quic协议握手的方式：<ul><li>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li></ul></li><li>连接迁移：没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感。</li></ol><h2 id="网页解析HTTP请求："><a href="#网页解析HTTP请求：" class="headerlink" title="网页解析HTTP请求："></a>网页解析HTTP请求：</h2><ol><li><p>输入url</p></li><li><p>DNS解析，就近原则，如果本地DNS服务器的缓存中没有，就发到DNS根服务器，</p><ul><li>根DNS服务器返回的报文，告诉本地DNS，这个域名由哪个顶级DNS服务器负责，本地去这个顶级（比如.com）服务器去查询</li><li>顶级返回次级地址，次级返回次次级，最后返回目标IP，本地DNS缓存更新这个IP</li><li>其中用户使用的DNS服务器默认是运营商提供的本地域名解析器，检查自己的缓存</li></ul></li><li><p><strong>建立TCP连接，经过三次握手 <em>1.C-&gt;S发送握手请求，附带一个SEQ=x，2.S-&gt;C发送收到，福袋一个ACK=x+1，和另一个SEQ=y ，3. C-&gt;S发送一个ACK=y+1 ,SEQ =x+1，上一个ACK</em>，结束SYN-RECV阶段，并进入establish阶段/</strong></p></li><li><p>释放连接，<strong>经过四次挥手</strong> <em>1.</em></p><h2 id="网页解析HTTPS请求：先建立TCP，再建立SSL加密"><a href="#网页解析HTTPS请求：先建立TCP，再建立SSL加密" class="headerlink" title="网页解析HTTPS请求：先建立TCP，再建立SSL加密"></a>网页解析HTTPS请求：先建立TCP，再建立SSL加密</h2></li><li><p>输入url，三次握手完成TCP通信建立</p></li><li><p>客户端发送https请求到服务端</p></li><li><p>服务端发回SSL证书和公钥到客户端</p></li><li><p>客户端验证证书安全性，如果安全，生成对称密钥，把这个密钥用公钥发回服务端</p></li><li><p>服务端用自己的私钥解密，这样两者都有了session key，后面的传输都是通过这个对称加密进行的</p></li></ol><h2 id="HTTP1-1的长连接是怎样建立的"><a href="#HTTP1-1的长连接是怎样建立的" class="headerlink" title="HTTP1.1的长连接是怎样建立的"></a>HTTP1.1的长连接是怎样建立的</h2><p>响应头中包含了 Connection: keep-alive 字段，那么它表示愿意保持连接开启，后续的请求都会通过上一个连接发送</p><h2 id="HTTP方法：POST-GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有"><a href="#HTTP方法：POST-GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有" class="headerlink" title="HTTP方法：POST GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有"></a>HTTP方法：POST GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有</h2><p>GET 方法具有<strong>幂等性</strong>，指同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。<br>POST不具有幂等性。</p><ol><li><p>get 提交的数据会放在 url 之后，post 提交的数据放在 body 上。<br>get请求参数会以 url 的形式完整的保留在浏览器的记录里，会存在安全问题。而 post 数据放在请求主体中，且数据不会被浏览器记录，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</p><ul><li><p>post 可以进行复杂的加密，get 则不可以</p></li><li><p>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</p></li><li><p>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据理论上没限制</p></li></ul></li><li><p>get 方法具有幂等性，post 方法不具有。<br>幂等性，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p></li><li><p>post方法有时会发送两个 tcp 数据包，与浏览器有关</p></li></ol><ul><li>使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送<br>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</li></ul><h2 id="长连接：减少-TCP-连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。"><a href="#长连接：减少-TCP-连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。" class="headerlink" title="长连接：减少 TCP 连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。"></a>长连接：减少 TCP 连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。</h2><ul><li>管道传输【一般不使用】：在同一个 TCP 连接里面，客户端可以发起多个请求：只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</li><li>队头阻塞问题：当顺序发送的请求序列中的某个请求阻塞时，后面的请求也会一直被阻塞。<h1 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h1><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2>UDP头部包含8个字节64位</li></ul><p>UDP头部的格式如下：</p><p><strong>源端口 (16位)</strong>：用于标识发送方的端口号。<br><strong>目标端口 (16位)</strong>：用于标识接收方的端口号。<br><strong>长度 (16位)</strong>：指示UDP报文头部和数据的总长度，以字节为单位，最小值为8（只有头部）。<br><strong>校验和 (16位)</strong>：用于检测UDP报文是否在传输过程中发生了错误。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP头部包含20个字节。握手挥手时，数据字段为空</p><h3 id="为什么要进行三次握手-？"><a href="#为什么要进行三次握手-？" class="headerlink" title="*为什么要进行三次握手 ？"></a>*为什么要进行三次握手 ？</h3><p>确认客户端和服务端都可以正常发送接收数据。</p><ul><li>第一次握手：确认客户端可以正常发送数据。</li><li>第二次握手：确认客户端可以正常发送数据，确认服务端可以正常接收数据。</li><li>第三次握手：确认客户端可以正常发送数据，确认服务端可以正常接收数据，确认服务端可以正常发送数据，客户端可以正常接收数据。<h3 id="三次握手过程中网络断开，会出现什么情况"><a href="#三次握手过程中网络断开，会出现什么情况" class="headerlink" title="三次握手过程中网络断开，会出现什么情况"></a>三次握手过程中网络断开，会出现什么情况</h3></li></ul><p>第一次握手丢失：客户端没收到第二次握手，触发超时重传机制，发送第一次握手<br>第二次握手丢失：客户端依然没收到第二次握手，触发超时重传，发送第一次握手；服务端没有收到第三次握手，超时重传，发送第二次握手<br>第三次握手丢失：客户端establish状态，服务端没有收到第三次握手，超时重传，仍然发送第二次握手</p><p>超时重传的限度：发送一定次数N，这个次数由内核限制，linux为5次。</p><h3 id="为什么要进行四次挥手-？"><a href="#为什么要进行四次挥手-？" class="headerlink" title="为什么要进行四次挥手 ？"></a>为什么要进行四次挥手 ？</h3><p>第一次挥手：客户端向服务端请求关闭连接。</p><ul><li>客户端：客户端无数据传输。</li><li>服务端：无感知。</li></ul><p>第二次挥手：服务端收到客户端的请求，并且告知客户端等我处理完毕数据。</p><ul><li>客户端：客户端无数据传输。</li><li>服务端：客户端无数据传输。</li></ul><p>第三次挥手：服务端处理完毕数据，告知客户端，服务端数据处理完毕。</p><ul><li>客户端：客户端无数据传输，服务端无数据传输。</li><li>服务端：客户端无数据传输，服务端无数据传输。</li></ul><p>第四次挥手：客户端得知服务端数据处理完毕，双方数据都处理完毕，可断开连接。</p><ul><li>客户端：客户端无数据传输，服务端无数据传输。</li><li>服务端：客户端无数据传输，服务端无数据传输，得知客户端知道服务端无数据传输。</li></ul><h3 id="TCP是如何保证可靠传输的"><a href="#TCP是如何保证可靠传输的" class="headerlink" title="*TCP是如何保证可靠传输的"></a>*TCP是如何保证可靠传输的</h3><p>1 数据分块<br>​ 应用数据被分割成 TCP 认为最适合发送的数据块。并且给每一个数据块进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，如果发送过程中，存在数据块丢失或者发送重复，接收方根据序列号整理数据块，删除重复的数据块，要求发送方重新发送丢失的数据块。</p><p>2 校验和<br>与UDP 校验和相同，监测数据传输过程中可能出现的差错。</p><p>3 流量控制<br>让发送方的发送速率不要太快，让接收方来得及接收，TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</p><p>4 ARQ协议<br>ARQ(Automatic Repeat-reQuest)自动重传协议：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p><p>5 超时重传<br>当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</p><p>6 拥塞控制<br>在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p><p>慢开始：当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况。慢开始的慢指的是初始发送报文段的数量为 1，如果收到确认，则发送两个报文段，之后每收到一个确认报文，发送报文端的数量就翻倍，直到到达慢开始门限，当发送报文段的数据大于门限数量时，使用拥塞避免算法。<br>拥塞避免：当网络拥塞发生时，慢开始门限值减半，发送的报文段数量改变为 1 ,然后再次重复两种算法（慢开始和拥塞避免）。<br>快重传：接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。</p><p>快恢复</p><p>快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：</p><p>① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限值减半；</p><p>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，发送报文段的数量减半，然后执行拥塞避免算法，线性增加发送报文段的数量。</p><h2 id="quic协议-1"><a href="#quic协议-1" class="headerlink" title="quic协议"></a>quic协议</h2><p>QUIC(Quick UDP Internet Connections)，是一种基于 UDP 的传输层协议。QUIC = HTTP/2 + TLS + UDP.</p><h1 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>A 类地址：10.0.0.0～10.255.255.255<br>B 类地址：172.16.0.0～172.31.255.255<br>C 类地址：192.168.0.0～192.168.255.255<br>解决IPv4不够用的两种技术：</p><ul><li>nat(network address translation)网络地址转换协议：将内网地址转为公网ip的协议，实现多层网络地址转换。</li><li>IPv6 128位，比IPv4的32位多了四倍<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2>arp(address resolution protocol) 地址解析协议：根据主机的ip 地址获取主机的mac 地址。每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</li></ul><p>A要发送B一个数据包，首先他有B的IP地址，为了发送成功还需要B的MAC地址。</p><ul><li>首先A查找本地ARP缓存，<strong>IP：MAC的映射</strong></li><li>如果找到MAC 地址，就可以发送消息。</li><li>如果没有，A就会发送一个局域网广播的ARP请求B的MAC的数据包，这个消息被局域网内所有的计算机接受，B返回一个包含自身MAC和IP地址的ARP响应消息。作为响应请求的一部分，B 可以将 A 的一个条目插入到它的 ARP 表中，以备将来使用。</li></ul><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><ul><li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。<br>互联网中主机之间相互传递数据的逻辑是，先通过 ip 地址找到对应的局域网，然后再找到对应的主机。</li><li>如果只采用 ip 地址，不用mac 地址：不安全， 同一个ip 地址可能绑定多个主机，而无论何时mac 地址和主机是一一对应的。<br>  <strong>找不到主机号，IP本质上相当于逻辑地址，两个主机可能有一个IP</strong></li><li>如果只采用mac 地址，不用ip 地址：没有办法使用ip 通过网段寻找目标主机，需要在全网段内没有规律的找一个主机，效率太慢。<br>  <strong>一个是不够用，二是没有IP网段，全网查找，没有规律</strong></li></ul><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><ul><li>使用最广泛的HTTP/1.1，也是基于TCP协议的，同一时间里，客户端和服务器只能有一方主动发数据，这就是所谓的半双工。</li></ul><h2 id="1-正向代理和反向代理"><a href="#1-正向代理和反向代理" class="headerlink" title="1. 正向代理和反向代理"></a>1. 正向代理和反向代理</h2><ol><li>正向代理是为了隐藏客户端信息例如ip，反向代理是为了隐藏服务器信息，例如ip。</li><li>正向代理是有感知的（就是说你需要用vpn你需要自己去配置），反向代理是无感知的（只需要输入<a href="http://www.baidu.com就可以访问到百度不同服务器上的资源，配置过程不是用户去做的）。" target="_blank" rel="noopener">www.baidu.com就可以访问到百度不同服务器上的资源，配置过程不是用户去做的）。</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; questions&lt;/p&gt;
    
    </summary>
    
      <category term="Network" scheme="http://waynamigo.github.io/categories/Network/"/>
    
    
      <category term="network" scheme="http://waynamigo.github.io/tags/network/"/>
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL questions</title>
    <link href="http://waynamigo.github.io/2023/01/03/2023-01-03-%E9%9D%A2%E7%BB%8FMySQL%E9%97%AE%E9%A2%98/"/>
    <id>http://waynamigo.github.io/2023/01/03/2023-01-03-面经MySQL问题/</id>
    <published>2023-01-02T16:00:00.000Z</published>
    <updated>2023-12-02T09:46:21.665Z</updated>
    
    <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h2 id="mysql货币使用什么类型"><a href="#mysql货币使用什么类型" class="headerlink" title="mysql货币使用什么类型"></a>mysql货币使用什么类型</h2><p>Numeric和Decimal</p><h2 id="explain使用-查询优化器-对语句进行分析，找出最优的查询方案，并显示对应的信息。"><a href="#explain使用-查询优化器-对语句进行分析，找出最优的查询方案，并显示对应的信息。" class="headerlink" title="explain使用 查询优化器 对语句进行分析，找出最优的查询方案，并显示对应的信息。"></a>explain使用 查询优化器 对语句进行分析，找出最优的查询方案，并显示对应的信息。</h2><h2 id="explain的字段有哪些【主要看-type-key-rows-extra】"><a href="#explain的字段有哪些【主要看-type-key-rows-extra】" class="headerlink" title="explain的字段有哪些【主要看 type key rows extra】"></a>explain的字段有哪些【主要看 type key rows extra】</h2><ul><li><p>id    查询序号</p></li><li><p>select_type    查询类型</p></li><li><p>table    表名</p></li><li><p>partitions    匹配的分区</p></li><li><p><strong>type(主要)</strong>    查询使用了什么类型，是index还是全表扫描，同时用了index还会在extra里显示using index</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system --&gt; const --&gt; eq_ref --&gt; ref --&gt; fulltext --&gt; ref_or_null --&gt; index_merge --&gt; unique_subquery --&gt; index_subquery --&gt; range --&gt; index --&gt; ALL</span><br></pre></td></tr></table></figure></li><li><p>prossible_keys    可能会选择的索引</p></li><li><p><strong>key（主要）</strong>    实际选择的索引</p></li><li><p>key_len    索引的长度</p></li><li><p>ref    与索引作比较的列</p></li><li><p><strong>rows（主要）</strong>    要检索的行数(估算值)</p></li><li><p>filtered    查询条件过滤的行数的百分比</p></li><li><p><strong>Extra（主要）</strong>    额外信息，dictinct，using index，using filesort，using temporary，最好是using index，filesort和tmp都可能导致性能下降</p></li></ul><h3 id="select-type有哪些"><a href="#select-type有哪些" class="headerlink" title="select type有哪些"></a>select type有哪些</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SIMPLE简单SELECT(不使用UNION或子查询)</span><br><span class="line">PRIMARY最外层的SELECT</span><br><span class="line">UNIONUNION中第二个或之后的SELECT语句</span><br><span class="line">DEPENDENT UNIONUNION中第二个或之后的SELECT语句取决于外面的查询</span><br><span class="line">UNION RESULTUNION的结果</span><br><span class="line">SUBQUERY子查询中的第一个SELECT</span><br><span class="line">DEPENDENT SUBQUERY子查询中的第一个SELECT, 取决于外面的查询</span><br><span class="line">DERIVED衍生表(FROM子句中的子查询)</span><br><span class="line">MATERIALIZED物化子查询</span><br><span class="line">UNCACHEABLE SUBQUERY结果集无法缓存的子查询，必须重新评估外部查询的每一行</span><br><span class="line">UNCACHEABLE UNIONUNION中第二个或之后的SELECT，属于无法缓存的子查询</span><br></pre></td></tr></table></figure><h1 id="2-慢查询怎么排查"><a href="#2-慢查询怎么排查" class="headerlink" title="2. 慢查询怎么排查"></a>2. 慢查询怎么排查</h1><ol><li>看慢查询日志，cat slow_query.log</li><li>找到的话用explain，查看他的type，是否using index，最差可能时all（扫全表），keys用了哪些索引，rows的估计值</li></ol><h2 id="其他数据库"><a href="#其他数据库" class="headerlink" title="其他数据库"></a>其他数据库</h2><p>mongodb(<a href="https://www.chaojimake.cn/question_8_88.html" target="_blank" rel="noopener">https://www.chaojimake.cn/question_8_88.html</a>)<br>mongodb索引使用了B树，<a href="https://mp.weixin.qq.com/s/mMWdpbYRiT6LQcdaj4hgXQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mMWdpbYRiT6LQcdaj4hgXQ</a><br>hbase(<a href="https://www.chaojimake.cn/question_8_349.html" target="_blank" rel="noopener">https://www.chaojimake.cn/question_8_349.html</a>)</p><h2 id="为什么要分库"><a href="#为什么要分库" class="headerlink" title="为什么要分库"></a>为什么要分库</h2><p>如果业务量剧增，数据库可能会出现性能瓶颈，这时候我们就需要考虑拆分数据库。</p><ul><li><strong>磁盘存储</strong><br>业务量剧增，MySQL单机磁盘容量会撑爆，拆成多个数据库，磁盘使用率大大降低。</li><li><strong>并发连接支撑</strong><br>知道数据库连接数是有限的（150个？）。在高并发的场景下，大量请求访问数据库，MySQL单机是扛不住的！高并发场景下，会出现too many connections报错。</li></ul><p>当前非常火的微服务架构出现，就是为了应对高并发。它把订单、用户、商品等不同模块，拆分成多个应用，并且把单个数据库也拆分成多个不同功能模块的数据库（订单库、用户库、商品库），以分担读写压力。</p><h2 id="为什么要分表"><a href="#为什么要分表" class="headerlink" title="为什么要分表"></a>为什么要分表</h2><p>假如你的单表数据量非常大，存储和查询的性能就会遇到瓶颈了，如果你做了很多优化之后还是无法提升效率的时候，就需要考虑做分表了。一般千万级别数据量，就需要分表。<br>这是因为即使SQL命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是B+树结构，数据千万级别的话，B+树的高度会增高，查询就变慢啦</p><h2 id="考虑分库分表的时机"><a href="#考虑分库分表的时机" class="headerlink" title="考虑分库分表的时机"></a>考虑分库分表的时机</h2><p>一般数据量千万级别，B+树索引高度就会到3层以上了，查询的时候会多查磁盘的次数，SQL就会变慢。</p><p>阿里巴巴的《Java开发手册》提出：<br><strong>单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表</strong><br>那我们是不是等到数据量到达五百万，才开始分库分表呢？<br>不是这样的，我们应该提前规划分库分表，如果估算3年后，你的表都不会到达这个五百万，则不需要分库分表。<br>MySQL服务器如果配置更好，是不是可以超过这个500万这个量级，才考虑分库分表？<br>虽然配置更好，可能数据量大之后，性能还是不错，但是如果持续发展的话，还是要考虑分库分表<br>一般什么类型业务表需要才分库分表？<br>通用是一些流水表、用户表等才考虑分库分表，如果是一些配置类的表，则完全不用考虑，因为不太可能到达这个量级。</p><h2 id="如何分库分表？原则有哪些"><a href="#如何分库分表？原则有哪些" class="headerlink" title="如何分库分表？原则有哪些"></a>如何分库分表？原则有哪些</h2><h2 id="数据库垂直切分"><a href="#数据库垂直切分" class="headerlink" title="数据库垂直切分"></a>数据库垂直切分</h2><h2 id="数据库水平切分"><a href="#数据库水平切分" class="headerlink" title="数据库水平切分"></a>数据库水平切分</h2><h2 id="一定规则"><a href="#一定规则" class="headerlink" title="一定规则"></a>一定规则</h2><h2 id="分库分表的取模算法"><a href="#分库分表的取模算法" class="headerlink" title="分库分表的取模算法"></a>分库分表的取模算法</h2><h2 id="分库分表的范围限定算法"><a href="#分库分表的范围限定算法" class="headerlink" title="分库分表的范围限定算法"></a>分库分表的范围限定算法</h2><h2 id="分库后，事务问题如何解决"><a href="#分库后，事务问题如何解决" class="headerlink" title="分库后，事务问题如何解决"></a>分库后，事务问题如何解决</h2><h2 id="分表后，跨节点的join和union问题"><a href="#分表后，跨节点的join和union问题" class="headerlink" title="分表后，跨节点的join和union问题"></a>分表后，跨节点的join和union问题</h2><h2 id="分库分表后，orderby-groupby等聚合函数如何处理"><a href="#分库分表后，orderby-groupby等聚合函数如何处理" class="headerlink" title="分库分表后，orderby groupby等聚合函数如何处理"></a>分库分表后，orderby groupby等聚合函数如何处理</h2><h2 id="分库分表后，分页的处理方案"><a href="#分库分表后，分页的处理方案" class="headerlink" title="分库分表后，分页的处理方案"></a>分库分表后，分页的处理方案</h2><h2 id="如何生成全局唯一的分布式ID"><a href="#如何生成全局唯一的分布式ID" class="headerlink" title="如何生成全局唯一的分布式ID"></a>如何生成全局唯一的分布式ID</h2><h2 id="主流分库分表中间件"><a href="#主流分库分表中间件" class="headerlink" title="主流分库分表中间件"></a>主流分库分表中间件</h2><h2 id="分表要停服吗，不停服怎么做"><a href="#分表要停服吗，不停服怎么做" class="headerlink" title="分表要停服吗，不停服怎么做"></a>分表要停服吗，不停服怎么做</h2><h2 id="为了避免数据热点问题如何选择分表策略"><a href="#为了避免数据热点问题如何选择分表策略" class="headerlink" title="为了避免数据热点问题如何选择分表策略"></a>为了避免数据热点问题如何选择分表策略</h2><h2 id="阐述常用的数据库中间件"><a href="#阐述常用的数据库中间件" class="headerlink" title="阐述常用的数据库中间件"></a>阐述常用的数据库中间件</h2><h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><ul><li>int：tinyint(1byte) smallint(2byte)  mediumint(3byte)  int(4byte)  bigint(8byte) </li><li>float,double</li><li>decimal</li></ul><p><strong>字符串类型：varchar,char,text,blob</strong> </p><ul><li>varchar(n):n代表字符个数，不是字节个数</li><li>char与varchar的区别<ul><li>char定长，var不定长，存储效率较高</li><li>varchar在开头两个字节存长度</li></ul></li><li>text 和blob会使用临时表，开销损失大</li></ul><p>【Tips】经常变更的数据使用char，char不容易产生碎片<br><strong>时间类型</strong></p><ul><li>date</li><li>timestamp（优先使用，空间开销小）</li></ul><h2 id="3-数据库三大范式-，范式和反范式是什么【】"><a href="#3-数据库三大范式-，范式和反范式是什么【】" class="headerlink" title="3. 数据库三大范式 ，范式和反范式是什么【】"></a>3. 数据库三大范式 ，范式和反范式是什么【】</h2><ul><li><p>第一范式（1NF）：每个列都不可以再拆分，强调的是列的原子性。第一范式要求数据库中的表都是二维表。</p></li><li><p>第二范式（2NF）：在第一范式的基础上，一个表必须有一个主键，非主键列 完全依赖 于主键，而不能是依赖于主键的一部分。</p></li><li><p>第三范式（3NF）：在第二范式的基础上，非主键列只依赖（直接依赖）于主键，不依赖于其他非主键。</p></li><li><p><strong>范式</strong>：范式化的表减少了数据冗余，数据表更新操作快、占用存储空间少。    </p></li><li><p>但是查询时通常需要多表关联查询，更难进行索引优化</p></li><li><p><strong>反范式</strong>：反范式的过程就是通过冗余数据来提高查询性能，可以减少表关联和更好进行索引优化</p></li><li><p>存在大量冗余数据，并且数据的维护成本更高</p></li></ul><h1 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h1><h2 id="1-索引的分类"><a href="#1-索引的分类" class="headerlink" title="1.索引的分类"></a>1.索引的分类</h2><h2 id="2-索引优缺点"><a href="#2-索引优缺点" class="headerlink" title="2.索引优缺点"></a>2.索引优缺点</h2><h2 id="3-索引设计原则"><a href="#3-索引设计原则" class="headerlink" title="3.索引设计原则"></a>3.索引设计原则</h2><ol><li>唯一性</li><li>经常与其他表链接的表，在链接字段应创建索引 on 两边的字段，都要建立索引</li><li>经常出现在where子句中的字段，尤其是大表，应创建索引</li><li>索引应创建在选择性高，重复度低的字段上，如员工表，姓名和性别都作为查询条件，姓名更适合建立索引。如果两个同时建立了索引，MySQL也会自动选择以姓名作为索引查询</li><li>索引应该建立在小字段上，对于大的文本甚至超长字段，尽量不建立索引</li><li>复合索引<br>① 正确选择复合索引中的主列字段，一般是选择性较好的字段<br>② 复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？ 如果是，则可以建立复合索引；否则考虑单字段索引<br>③ 如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引<br>④ 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引</li></ol><h2 id="选哪些列建立索引的原则是什么"><a href="#选哪些列建立索引的原则是什么" class="headerlink" title="选哪些列建立索引的原则是什么"></a>选哪些列建立索引的原则是什么</h2><ol><li>字段不为null，唯一性，不频繁更新的，需要经常作为where orderby join的条件的字段做索引</li><li>不应该给频繁更新的字段维护索引</li><li>尽量考虑建立联合索引，并避免冗余</li><li>字符串的索引用前缀表示</li><li>单张表索引不超过 5 个<h2 id="4-索引的b-树"><a href="#4-索引的b-树" class="headerlink" title="4.索引的b+树"></a>4.索引的b+树</h2><h2 id="5-hash索引和b-索引的区别"><a href="#5-hash索引和b-索引的区别" class="headerlink" title="5.hash索引和b+索引的区别"></a>5.hash索引和b+索引的区别</h2><h2 id="6-为什么b-树打败了二叉查找树和b树"><a href="#6-为什么b-树打败了二叉查找树和b树" class="headerlink" title="6.为什么b+树打败了二叉查找树和b树"></a>6.为什么b+树打败了二叉查找树和b树</h2><h2 id="7-最左匹配原则"><a href="#7-最左匹配原则" class="headerlink" title="7.最左匹配原则"></a>7.最左匹配原则</h2><h2 id="8-覆盖索引"><a href="#8-覆盖索引" class="headerlink" title="8.覆盖索引"></a>8.覆盖索引</h2><h2 id="9-索引下推"><a href="#9-索引下推" class="headerlink" title="9.索引下推"></a>9.索引下推</h2><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1>InnoDB 适用于？<br>MyISAM 适用以插入为主的程序，比如博客系统、新闻门户</li></ol><h2 id="1-存储引擎InnoDB的四大特性"><a href="#1-存储引擎InnoDB的四大特性" class="headerlink" title="1.存储引擎InnoDB的四大特性"></a>1.存储引擎InnoDB的四大特性</h2><p>插入缓冲（insert buffer)<br>二次写(double write)<br>自适应哈希索引(ahi)<br>预读(read ahead)</p><h2 id="2-MyISAM和InnoDB的区别"><a href="#2-MyISAM和InnoDB的区别" class="headerlink" title="2.MyISAM和InnoDB的区别"></a>2.MyISAM和InnoDB的区别</h2><ul><li><p>InnoDB 支持事务，而 MyISAM 不支持。</p></li><li><p>InnoDB 支持外键，而 MyISAM 不支持。因此将一个含有外键的 InnoDB 表 转为 MyISAM 表会失败。</p></li><li><p>InnoDB 和 MyISAM 均支持 B+ Tree 数据结构的索引。但 InnoDB 是聚集索引，而 MyISAM 是非聚集索引。</p></li><li><p>InnoDB 不保存表中数据行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量记录了整个表的行数，速度相当快（注意不能有 WHERE 子句）。</p></li></ul><p><strong>那为什么 InnoDB 没有使用这样的变量呢</strong> 因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的。</p><ul><li><p>InnoDB 支持表、行（默认）级锁，而 MyISAM 支持表级锁。<br>InnoDB 的行锁是基于索引实现的，而不是物理行记录上。即访问如果没有命中索引，则也无法使用行锁，将要退化为表锁。</p></li><li><p>InnoDB 必须有唯一索引（如主键），如果没有指定，就会自动寻找或生产一个隐藏列 Row_id 来充当默认主键，而 Myisam 可以没有主键。</p><h2 id="3-为何推荐使用自增主键"><a href="#3-为何推荐使用自增主键" class="headerlink" title="3.为何推荐使用自增主键"></a>3.为何推荐使用自增主键</h2><p>自增 ID 可以保证每次插入时 B+ 树索引是从右边扩展的，因此相比自定义 ID （如 UUID）可以避免 B+ 树的频繁合并和分裂。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="1-页Page，区Extend，段Segment"><a href="#1-页Page，区Extend，段Segment" class="headerlink" title="1.页Page，区Extend，段Segment"></a>1.页Page，区Extend，段Segment</h2></li></ul><p><strong>页（数据页）：InnoDB中每个页16KB，Myisam是1KB</strong></p><h3 id="一行数据大于16kb，会发生什么，怎么解决【行溢出问题】"><a href="#一行数据大于16kb，会发生什么，怎么解决【行溢出问题】" class="headerlink" title="一行数据大于16kb，会发生什么，怎么解决【行溢出问题】"></a>一行数据大于16kb，会发生什么，怎么解决【行溢出问题】</h3><p>内置的解决方式：将溢出的数据存到新页里，然后原始页里存放一个指针，需要额外一次IO去读取</p><p>聚簇索引情况：</p><ul><li>如果表使用了聚簇索引（InnoDB的主键索引就是一个聚簇索引），那么数据行实际上是存储在聚簇索引的叶子节点中的。如果一行数据超出了页的大小，那么会发生行溢出，溢出部分会存储在一个溢出页中，而叶子节点中仍然包含原始行的数据和指向溢出页的指针。</li></ul><p>非聚簇索引情况：</p><ul><li>如果表使用了非聚簇索引（如普通索引），那么数据行是单独存储在聚簇索引的叶子节点之外的，这种情况下，如果一行数据超出了页的大小，会直接发生行溢出，溢出部分会存储在溢出页中，同时非聚簇索引中也会保留指向溢出页的指针。</li></ul><p><strong>区Extent：一个区默认是 64 个连续的页组成的，也就是 1MB</strong></p><p><strong>段Segment：一段相邻的区的集合，逻辑上的组织，存放b+树</strong></p><h2 id="2-页由哪些数据组成"><a href="#2-页由哪些数据组成" class="headerlink" title="2.页由哪些数据组成"></a>2.页由哪些数据组成</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/mysqlpagestructure.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>file header:用于描述数据页的外部信息，比如属于哪一个表空间、前后页的页号等</li><li>page header:用来描述数据页中的具体信息，比如存在多少条纪录，第一条纪录的位置等。</li><li>infimum 和 supremum 纪录:是系统生成的纪录，分别为最小和最大纪录值，infimum 的下一条是用户纪录中键值最小的纪录，supremum 的上一条是用户纪录中键值最大的纪录，通过 next_record 字段来相连。</li><li>user records:据库表中对应的数据(Compact行格式)</li><li>free space 可插入的空闲区域</li><li>page dictionary：类似于字典的目录结构，根据主键大小，每隔 4-8 个纪录设置一个槽，用来纪录其位置，当根据主键查找数据时，首先一步到位找到数据所在的槽，然后在槽中线性搜素。这种方法比从前到后遍历页的链表的效率更快。</li><li>File Header：存储刷盘前内存的校验和，Page Tailer储存刷盘后的校验和。当刷盘的时候，出现异常，Page Tailer和File Header中的校验和不一致，则说明出现刷盘错误。</li></ul><h2 id="3-页插入记录的过程"><a href="#3-页插入记录的过程" class="headerlink" title="3.页插入记录的过程"></a>3.页插入记录的过程</h2><p>1）如果 Free Space 的空间足够的话，直接分配空间来添加纪录，并将插入前最后一条纪录的 next_record 指向当前插入的纪录，将当前插入纪录的 next_record 指向 supremum 纪录。</p><p>2）如果 Free Space的 空间不够的话，则首先将之前删除造成的碎片重新整理之后，按照上述步骤插入纪录。</p><p>3）如果当前页空间整理碎片之后仍然不足的话，则重新申请一个页，将页初始化之后，按照上述步骤插入纪录</p><h2 id="4-bufferPool"><a href="#4-bufferPool" class="headerlink" title="4.bufferPool"></a>4.bufferPool</h2><p>Buffer Pool 是 InnoDB 存储引擎层的缓冲池，不属于 MySQL 的 Server 层，注意跟 8.0 删掉的“查询缓存”功能区分。</p><p>内存中以页（page）为单位缓存磁盘数据，减少磁盘IO，提升访问速度。缓冲池大小默认 128M，独立的 MySQL 服务器推荐设置缓冲池大小为总内存的 80%。主要存储数据页、索引页更新缓冲（change buffer）等。</p><h2 id="5-change-buffer"><a href="#5-change-buffer" class="headerlink" title="5.change buffer"></a>5.change buffer</h2><p>​如果每次写操作，数据库都直接更新磁盘中的数据，会很占磁盘IO。为了减少磁盘IO，InnoDB在Buffer Pool中开辟了一块内存，用来存储变更记录，为了防止异常宕机丢失缓存，当事务提交时会将变更记录持久化到磁盘（redo log），等待时机更新磁盘的数据文件（刷脏），用来缓存写操作的内存，就是Change Buffer</p><p>Change Buffer默认占Buffer Pool的25%，最大设置占用50%。</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h2 id="1-架构设计【内存、线程】"><a href="#1-架构设计【内存、线程】" class="headerlink" title="1.架构设计【内存、线程】"></a>1.架构设计【内存、线程】</h2><ul><li>内存数据区域划分<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Innodbmem.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>四大线程<ul><li>Master thread</li><li>IO thread</li><li>Purge thread</li><li>Page Cleaner Thread</li></ul></li></ul><p>1）负责刷新内存池中的数据，保证缓冲池的内存缓冲的是最近的数据</p><p>2）已修改的数据文件刷新到磁盘文件</p><p>3）保证数据库发生异常的情况下InnoDB能恢复到正常状态</p><h2 id="2-InnoDB有哪些线程"><a href="#2-InnoDB有哪些线程" class="headerlink" title="2.InnoDB有哪些线程"></a>2.InnoDB有哪些线程</h2><ul><li>Master Thread</li></ul><p>负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲（INSERT BUFFER），UNDO页的回收等。</p><ul><li>IO Thread</li></ul><p>负责 AIO 请求的回调处理。</p><ul><li>Purge Thread</li></ul><p>事务提交后，undo log 可能不再需要，由 Purge Thread 负责回收并重新分配的这些已经使用的 undo 页。</p><ul><li>Page Cleaner Thread</li></ul><p>将Master Threader中刷新脏页的工作移至该线程，如上面说的FLUSH LRU LIST Checkpoint以及Async/Sync Flush Checkpoint。</p><h2 id="3-double-writer是什么"><a href="#3-double-writer是什么" class="headerlink" title="3.double writer是什么"></a>3.double writer是什么</h2><h2 id="4-自适应hash是什么"><a href="#4-自适应hash是什么" class="headerlink" title="4. 自适应hash是什么"></a>4. 自适应hash是什么</h2><p>InnoDB 会监控对表上各索引页的查询执行情况，如发现建立哈希索引可以提升速度，则建立哈希索引，这是过程不需要用户干预。（默认开启）</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1.什么是事务"></a>1.什么是事务</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p><h2 id="2-什么是事务的四大特性ACID"><a href="#2-什么是事务的四大特性ACID" class="headerlink" title="2.什么是事务的四大特性ACID"></a>2.什么是事务的四大特性ACID</h2><h2 id="3-事务的并发问题【带来脏读、不可重复度、幻读问题】"><a href="#3-事务的并发问题【带来脏读、不可重复度、幻读问题】" class="headerlink" title="3.事务的并发问题【带来脏读、不可重复度、幻读问题】"></a>3.事务的并发问题【带来脏读、不可重复度、幻读问题】</h2><h2 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5.事务的隔离级别"></a>5.事务的隔离级别</h2><p>串行化<br>可重复度（Innodb默认）<br>读已提交<br>读未提交</p><h2 id="6-ACID的特性如何实现"><a href="#6-ACID的特性如何实现" class="headerlink" title="6.ACID的特性如何实现"></a>6.ACID的特性如何实现</h2><p>原子性是 undo 日志<br>持久性是 redo 日志</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="1-数据库锁的特性，有哪些锁"><a href="#1-数据库锁的特性，有哪些锁" class="headerlink" title="1.数据库锁的特性，有哪些锁"></a>1.数据库锁的特性，有哪些锁</h2><ul><li>行锁，表锁，页锁，</li><li>共享锁=读锁S，排他锁=写锁X，更新锁U锁</li><li>乐观锁，悲观锁<h2 id="2-隔离级别和锁的关系"><a href="#2-隔离级别和锁的关系" class="headerlink" title="2.隔离级别和锁的关系"></a>2.隔离级别和锁的关系</h2></li><li>InnoDB 的行锁是基于索引实现的，而不是物理行记录上。即访问如果没有命中索引，则也无法使用行锁，将要退化为表锁。<h2 id="3-InnoDB的锁算法"><a href="#3-InnoDB的锁算法" class="headerlink" title="3.InnoDB的锁算法"></a>3.InnoDB的锁算法</h2><h2 id="4-快照读和当前读"><a href="#4-快照读和当前读" class="headerlink" title="4.快照读和当前读"></a>4.快照读和当前读</h2><h2 id="5-innodb的可重复度如何实现"><a href="#5-innodb的可重复度如何实现" class="headerlink" title="5.innodb的可重复度如何实现"></a>5.innodb的可重复度如何实现</h2>通过MVCC实现，为每个事务维护一个独立版本视图，执行期间保持一致性。<h2 id="6-MVCC以及实现（乐观锁）"><a href="#6-MVCC以及实现（乐观锁）" class="headerlink" title="6.MVCC以及实现（乐观锁）"></a>6.MVCC以及实现（乐观锁）</h2>MVCC 的基本思想是为每个事务创建一个独立的版本视图，以便在事务执行期间保持数据的一致性。它通过在修改数据时不覆盖原有的数据，而是为每个事务创建一个新的版本来实现。</li></ul><ol><li>每行数据保存一个版本号/时间戳</li><li>当一个事务对某行数据进行修改时，不会直接修改原始数据，而是会在数据库中创建一个新的版本，并将原始版本的数据保留下来</li><li>查询时，根据版本号<h2 id="7-mysql优化手段有哪些"><a href="#7-mysql优化手段有哪些" class="headerlink" title="7. mysql优化手段有哪些"></a>7. mysql优化手段有哪些</h2></li><li>给常用字段索引，使用覆盖索引的时候，最左原则，避免全表扫描</li><li>避免not in ，范围查询使用between</li><li>分表分区，拆分子表，规模大的时候拆一下insert和update等</li><li>使用覆盖索引：索引覆盖是指查询的列都包含在索引中，而无需再去访问表本身，可以减少IO和提高查询性能。<strong>不适合频繁变更的表和列</strong></li><li>redis缓存分担压力</li><li>连接池等</li></ol><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="1-mysql的常见日志"><a href="#1-mysql的常见日志" class="headerlink" title="1.mysql的常见日志"></a>1.mysql的常见日志</h2><ul><li><p>binlog 记录mysql的写入信息和操作，追加的方式写入，用于主从复制和数据恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">主从复制：在Master端开启binlog，然后将binlog发送到各个Slave端，Slave端重放binlog从而达到主从数据一致。</span><br><span class="line">数据恢复：通过使用mysqlbinlog工具来恢复数据。</span><br><span class="line">刷盘时机：sync_binlog参数控制biglog的刷盘时机，取值范围是0-N：</span><br><span class="line">    0：不去强制要求，由系统自行判断何时写入磁盘；</span><br><span class="line">    1：每次commit的时候都要将binlog写入磁盘；</span><br><span class="line">    N：每N个事务，才会将binlog写入磁盘。</span><br><span class="line"></span><br><span class="line">有三种格式，分别为STATMENT、ROW和MIXED</span><br></pre></td></tr></table></figure></li><li><p>undolog实现回滚，保证原子性的，实现的MVCC多版本并发控制。是在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">刷盘时机 有三种：每秒刷盘，每次事务提交的时候刷盘</span><br><span class="line">延迟写，每秒刷盘</span><br><span class="line">实时写，实时刷 每次事务提交刷盘</span><br><span class="line">实时写，延迟刷 每秒刷盘</span><br></pre></td></tr></table></figure></li><li><p>redolog用于持久化新数据的备份，用于恢复数据库用的。<br>引入redolog的原因是undolog缺点：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。</p><h2 id="2-主从复制的方法，-4-主从复制的原理，5-主从复制的异步复制和半同步"><a href="#2-主从复制的方法，-4-主从复制的原理，5-主从复制的异步复制和半同步" class="headerlink" title="2.主从复制的方法，  4.主从复制的原理，5.主从复制的异步复制和半同步"></a>2.主从复制的方法，  4.主从复制的原理，5.主从复制的异步复制和半同步</h2><p>1 同步复制:<br>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p></li></ul><p>2 异步复制:结构一般是链式或者树形的结构去发binlog进行复制，至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。</p><p>3 半同步复制:<br>master只保证slaves中的一个操作成功，就返回，其他slave不管。这个功能，是由google为MySQL引入的</p><p>存在一个主从延迟的问题，产生的原因是需要复制的节点IO线程跟不上binlog的内容，解决方法一般是多个worker并行复制去做relaylog，</p><h2 id="【重点】项目是怎么知道哪个mysql节点有哪些表的，如何控制请求向哪个节点查询"><a href="#【重点】项目是怎么知道哪个mysql节点有哪些表的，如何控制请求向哪个节点查询" class="headerlink" title="【重点】项目是怎么知道哪个mysql节点有哪些表的，如何控制请求向哪个节点查询"></a>【重点】项目是怎么知道哪个mysql节点有哪些表的，如何控制请求向哪个节点查询</h2><ol><li>mysql主节点提供一个系统表，jdbc直接连的话，可以通过查询主节点的系统表获取集群的表信息</li><li>微服务常用一些组件来做服务发现，进行请求的分发和负载均衡，比如可以接入consul管理mysql集群信息，etcd也可以维护mysql节点的信息。应用程序可以查询服务注册中心，获取数据库节点的地址和表信息。这样，可以动态地发现数据库节点，并知道每个节点上有哪些表<h2 id="3-主从复制的架构【并行复制】"><a href="#3-主从复制的架构【并行复制】" class="headerlink" title="3.主从复制的架构【并行复制】"></a>3.主从复制的架构【并行复制】</h2><a href="https://developer.aliyun.com/article/990898#:~:text=常用的主从同步延迟解决方案：%20🥖强制读主库%20🥖延迟读,🥖降低并发%20🥖并行复制%20%28推荐%29" target="_blank" rel="noopener">https://developer.aliyun.com/article/990898#:~:text=常用的主从同步延迟解决方案：%20🥖强制读主库%20🥖延迟读,🥖降低并发%20🥖并行复制%20%28推荐%29</a></li><li>主库将数据库中数据的变化写入到 binlog</li><li>从库创建一个 I/O 线程向主库请求更新的 binlog</li><li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收</li><li>从库的 I/O 线程将接收的 binlog 写入到 relay log 中。</li><li>从库读取 relay log 同步数据本地</li></ol><p>现在常用一种并行复制的方式去做，是在从节点用多worker去relaylog，解决主从延迟的问题</p><h2 id="6-主从的常见问题和解决方式"><a href="#6-主从的常见问题和解决方式" class="headerlink" title="6.主从的常见问题和解决方式"></a>6.主从的常见问题和解决方式</h2><p>主从延迟问题，不一致性问题<br><a href="https://zhuanlan.zhihu.com/p/642614348" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/642614348</a></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="1-Where和Having的区别"><a href="#1-Where和Having的区别" class="headerlink" title="1.Where和Having的区别"></a>1.Where和Having的区别</h2><ol><li>WHERE 用于过滤行，出现在 FROM 子句之后。</li><li>HAVING 用于过滤分组后的结果，出现在 GROUP BY 子句之后。</li></ol><p>在没有分组的情况下，WHERE 和 HAVING 的作用相似，但在存在 GROUP BY 子句时，HAVING 是唯一能够过滤聚合结果的地方。</p><h2 id="2-In-和-Exists的区别"><a href="#2-In-和-Exists的区别" class="headerlink" title="2.In 和 Exists的区别"></a>2.In 和 Exists的区别</h2><ol><li>IN 用于匹配值是否在给定的值列表中，而 EXISTS 用于检查是否存在满足条件的子查询结果。</li><li>IN 通常用于对列的直接比较，而 EXISTS 通常用于与子查询结合，检查子查询是否有结果。</li><li>相对来说经常用exist去子查询，优化器执行是会使用索引去匹配，而in会扫描全表<h2 id="3-Union和Union-ALL的区别"><a href="#3-Union和Union-ALL的区别" class="headerlink" title="3. Union和Union ALL的区别"></a>3. Union和Union ALL的区别</h2></li><li>Union自己去重，union all会包含重复的列，一般是unionall之后在业务里去重</li></ol><h2 id="4-Drop-Delete-Truncate的区别"><a href="#4-Drop-Delete-Truncate的区别" class="headerlink" title="4. Drop Delete Truncate的区别"></a>4. Drop Delete Truncate的区别</h2><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="1-如何判断是否走了索引"><a href="#1-如何判断是否走了索引" class="headerlink" title="1. 如何判断是否走了索引"></a>1. 如何判断是否走了索引</h2><h2 id="2-索引失效的几种情况"><a href="#2-索引失效的几种情况" class="headerlink" title="2. 索引失效的几种情况"></a>2. 索引失效的几种情况</h2><h2 id="3-where子句如何优化"><a href="#3-where子句如何优化" class="headerlink" title="3. where子句如何优化"></a>3. where子句如何优化</h2><h2 id="4-超大分页和深度分页"><a href="#4-超大分页和深度分页" class="headerlink" title="4. 超大分页和深度分页"></a>4. 超大分页和深度分页</h2><h2 id="5-大表查询如何优化"><a href="#5-大表查询如何优化" class="headerlink" title="5. 大表查询如何优化"></a>5. 大表查询如何优化</h2><ol><li>使用覆盖索引：索引覆盖是指查询的列都包含在索引中，而无需再去访问表本身，可以减少IO和提高查询性能。<strong>不适合频繁变更的表和列</strong></li><li>按照列进行垂直分割，将冷热数据分开存储，以降低查询的数据量</li><li>对大表进行分区，将数据划分为更小的物理单元，以减少查询时需要扫描的数据量。</li><li>根据查询的条件，选择合适的分区键。</li></ol><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-存储过程（procedure）和函数的区别"><a href="#1-存储过程（procedure）和函数的区别" class="headerlink" title="1.存储过程（procedure）和函数的区别"></a>1.存储过程（procedure）和函数的区别</h2><h2 id="2-视图是什么"><a href="#2-视图是什么" class="headerlink" title="2.视图是什么"></a>2.视图是什么</h2><h2 id="3-Trigger是什么"><a href="#3-Trigger是什么" class="headerlink" title="3.Trigger是什么"></a>3.Trigger是什么</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; questions&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://waynamigo.github.io/categories/Mysql/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Mysql" scheme="http://waynamigo.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://waynamigo.github.io/2023/01/03/2023-01-03-%E9%9D%A2%E7%BB%8FMySQL/"/>
    <id>http://waynamigo.github.io/2023/01/03/2023-01-03-面经MySQL/</id>
    <published>2023-01-02T16:00:00.000Z</published>
    <updated>2023-12-02T04:43:08.364Z</updated>
    
    <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h1 id="mysql分为哪些层，各用来干嘛的"><a href="#mysql分为哪些层，各用来干嘛的" class="headerlink" title="mysql分为哪些层，各用来干嘛的"></a>mysql分为哪些层，各用来干嘛的</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/mysql查询流程.png.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>mysql架构共分为两层：Server 层和存储引擎层</li><li>Server 层负责建立连接、分析和执行 SQL</li><li>存储引擎层负责数据的存储和提取<h2 id="为什么mysql用b-树而不是用b树：查询性能和顺序遍历的效率高"><a href="#为什么mysql用b-树而不是用b树：查询性能和顺序遍历的效率高" class="headerlink" title="为什么mysql用b+树而不是用b树：查询性能和顺序遍历的效率高"></a>为什么mysql用b+树而不是用b树：查询性能和顺序遍历的效率高</h2>主要的原因可能就是b+数据存在叶子节点上，并且用指针连着，如果要遍历直接去扫一遍，而b树的话，需要遍历整棵树才能读完；<br>并且查找时，b+树高度一般很稳定，b树高度一般来说会更高，因为两者的<h2 id="mysql基于什么协议传输"><a href="#mysql基于什么协议传输" class="headerlink" title="mysql基于什么协议传输"></a>mysql基于什么协议传输</h2>TCP。<br>三次握手建立后，连接器验证用户名和密码。</li></ul><p><strong>连接器作用</strong></p><ul><li>TCP三次握手</li><li>校检用户名密码，返回用户权限</li></ul><p><strong>查询缓存作用</strong></p><ul><li>select语句输入，执行，先去查询缓存中找，查询缓存中存的是之前执行过的sql语句，以key-value保存的，底层数据结构为哈希表。</li><li>8.0.3后移除了这一层，在一些问题，包括性能问题、锁的竞争问题以及难以扩展。</li></ul><p><strong>解析器作用</strong></p><ul><li><code>词法分析-语法分析-语法树</code>结构</li><li>词法分析（Lexical Analysis）</li><li>语法分析（Syntax Analysis）语法分析器会将其转化为一个抽象语法树（<strong>AST</strong>）</li><li><strong>AST</strong>的作用：编译器或解释器用来理解代码含义的数据结构，它可以被后续的步骤用来进行语义分析、优化和生成目标代码等。</li><li>【查询优化】：对AST进行查询优化，选择合适的索引和决定连接顺序</li></ul><h2 id="【面试题】执行一条-SQL-查询语句，期间发生了什么？"><a href="#【面试题】执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="【面试题】执行一条 SQL 查询语句，期间发生了什么？"></a>【面试题】执行一条 SQL 查询语句，期间发生了什么？</h2><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：</li><li>prepare 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li><li>optimize 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>execute 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul><h2 id="如何查看我的sql被几个客户端链接了"><a href="#如何查看我的sql被几个客户端链接了" class="headerlink" title="如何查看我的sql被几个客户端链接了"></a>如何查看我的sql被几个客户端链接了</h2><p>show processlist;会有ID user host等字段</p><h2 id="mysql推荐使用长链接，但会产生的问题："><a href="#mysql推荐使用长链接，但会产生的问题：" class="headerlink" title="mysql推荐使用长链接，但会产生的问题："></a>mysql推荐使用长链接，但会产生的问题：</h2><p>随着长连接一直不释放，内存占用大。【解决方式】定期释放，主动重置连接mysql_reset_connection()</p><h2 id="MYSQL的数据存储方式"><a href="#MYSQL的数据存储方式" class="headerlink" title="MYSQL的数据存储方式"></a>MYSQL的数据存储方式</h2><ol><li>show variable like ‘datadir’; 可以查找mysql的文件在哪<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.opt  用来存储当前数据库的默认字符集和字符校验规则。</span><br><span class="line">t_order.frm  存放表结构，在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</span><br><span class="line">t_order.ibd  存放表数据。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。</span><br></pre></td></tr></table></figure></li></ol><h3 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h3><p>表空间由段（segment）、区（extent）、页（page）、行（row）组成</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/mysqltablestructure.drawio.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>表中的数据在Page里，数据是按「页」为单位来读写的，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</li><li>默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间</li></ul><p><strong>按区分配空间的情况</strong></p><ul><li>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。</li></ul><p><strong>段一般分为数据段、索引段和回滚段等。</strong></p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合，之前讲事务隔离 (opens new window)的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li></ul><h2 id="Innodb的行格式"><a href="#Innodb的行格式" class="headerlink" title="Innodb的行格式"></a>Innodb的行格式</h2><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p><p><strong>COMPACT 行格式</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/COMPACT.drawio.png.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>数据类型：char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p></li><li><p>row_id：<br>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p></li><li><p>trx_id：<br>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p></li><li><p>roll_pointer：<br>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节</p></li><li><p>NULL值列表：用位图存储的。压缩行存储通过一种称为”Dynamic Prefix”的技术，动态地存储每一行的前缀信息和 NULL 列的位图。这使得它可以更加高效地存储具有大量 NULL 列的行。</p><h1 id="mysql读取时的几个情况"><a href="#mysql读取时的几个情况" class="headerlink" title="mysql读取时的几个情况"></a>mysql读取时的几个情况</h1></li><li><p>脏读：读到其他事务未提交的数据；</p></li><li><p>不可重复读：前后读取的数据不一致；</p></li><li><p>幻读：前后读取的记录数量不一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不可重复读的重点是修改，幻读的重点在于新增或者删除。</span><br><span class="line"></span><br><span class="line">例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导致A再读自己的工资时工资变为 2000；这就是不可重复读。</span><br><span class="line"></span><br><span class="line">例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记 录就变为了5条，这样就导致了幻读。</span><br></pre></td></tr></table></figure></li></ul><p><strong>脏读</strong>: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚. </p><p><strong>不可重复读</strong>: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作. </p><p><strong>幻读</strong>: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成”幻觉”. </p><h1 id="mysql四种隔离级别"><a href="#mysql四种隔离级别" class="headerlink" title="mysql四种隔离级别"></a>mysql四种隔离级别</h1><ol><li>Serializable (串行化) :可避免脏读、不可重复读、幻读的发生。 </li><li>Repeatable read (可重复读) :可避免脏读、不可重复读的发生。 </li><li>Read committed (读已提交) :可避免脏读的发生。</li><li>Read uncommitted (读未提交) :最低级别，任何情况都无法保证。 </li></ol><p>SQL查看隔离级别：</p><figure class="highlight plain"><figcaption><span>@@transaction_isolation;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">设置隔离级别：</span><br><span class="line">```set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><h2 id="生产环境数据库一般用的什么隔离级别呢？"><a href="#生产环境数据库一般用的什么隔离级别呢？" class="headerlink" title="生产环境数据库一般用的什么隔离级别呢？"></a>生产环境数据库一般用的什么隔离级别呢？</h2><p>生产环境大多使用RC(读已提交)，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缘由一：在可重复读RR隔离级别下，存在**间隙锁**，导致出现死锁的几率比RC大的多！ </span><br><span class="line">缘由二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行!</span><br></pre></td></tr></table></figure><p>InnoDB的默认隔离级别：可重复读，不能避免幻读<br>多版本并发控制协议MVCC(Multi- Version Concurrency Control) </p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p><a href="https://zhuanlan.zhihu.com/p/340593296" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/340593296</a></p><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是存储引擎用于提高数据库表的访问速度的一种数据结构。它可以比作一本字典的目录，可以帮你快速找到对应的记录。<br>索引一般存储在磁盘的文件中，它是占用物理空间的。</p><h2 id="索引的分类（按字段特性）"><a href="#索引的分类（按字段特性）" class="headerlink" title="索引的分类（按字段特性）"></a>索引的分类（按字段特性）</h2><ol><li>主键索引：primary key，在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A(</span><br><span class="line">    x <span class="built_in">int</span> primary <span class="keyword">key</span>, </span><br><span class="line">    //或</span><br><span class="line">    x <span class="built_in">int</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(x) <span class="keyword">using</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><p>建表后，创建主键索引<br><code>CREATE INDEX a ON tableA(a);</code><br>再将其添加主键约束<br><code>ALTER TABLE tableA ADD CONTRAINT id PRIMARY KEY</code></p><p>如果仅改一个主键<code>ALTER TABLE tableA ADD PRIMARY KEY(a)</code></p><ol start="2"><li>唯一索引：unique key建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，<strong>索引列的值必须唯一，但是允许有空值</strong>。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A&#123;</span><br><span class="line">    x <span class="built_in">int</span> <span class="keyword">unique</span> <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">key</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>建表后，创建唯一索引<code>create UNIQUE INDEX index_nameON table_name(index_column_1,index_column_2,...);</code></li></ul><ol start="3"><li><p>普通索引/二级索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx <span class="keyword">on</span> tableA(a,b,x,y);</span><br></pre></td></tr></table></figure></li><li><p>前缀索引: 对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tableA(</span><br><span class="line">    a <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">INDEX</span>(a(<span class="number">10</span>))//字符串前<span class="number">10</span>个字符匹配。</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h3 id="【面试考点】联合索引如何使用的"><a href="#【面试考点】联合索引如何使用的" class="headerlink" title="【面试考点】联合索引如何使用的"></a>【面试考点】联合索引如何使用的</h3><p>指按sql里从左到右的顺序去匹配，查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成</p><h3 id="失效的情况"><a href="#失效的情况" class="headerlink" title="失效的情况"></a>失效的情况</h3><p>如果有abc索引，可以支持查找时的 a/b/c/ac/cba(打乱)，不支持bc</p><ol><li>联合索引范围查询</li></ol><p>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。</p><p>【例子】</p><figure class="highlight plain"><figcaption><span>* from  tableA where a> 10 and b</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">```select * from  tableA where a&gt;= 10 and b=2;```的区别：</span><br><span class="line">a都用了索引，一个没用，一个用了。因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序</span><br><span class="line">   </span><br><span class="line">## 索引的优缺点？</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">- 加快数据查找的速度</span><br><span class="line">- 为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度</span><br><span class="line">- 加快表与表之间的连接</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">- 建立索引需要占用物理空间</span><br><span class="line">- 会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引，导致增删改时间变长</span><br><span class="line">## 什么情况下需要建索引？</span><br><span class="line"></span><br><span class="line">- 经常**用于查询**的字段</span><br><span class="line">- 经常**用于连接**的字段建立索引，可以加快连接的速度</span><br><span class="line">- 经常**需要排序**的字段建立索引，因为索引已经排好序，可以加快排序查询速度</span><br><span class="line"></span><br><span class="line">## 什么情况下不建索引？</span><br><span class="line"></span><br><span class="line">- where条件中用不到的字段不适合建立索引</span><br><span class="line">- 表记录较少。比如只有几百条数据，没必要加索引。</span><br><span class="line">- 需要经常增删改。需要评估是否适合加索引</span><br><span class="line">- 参与列计算的列不适合建索引</span><br><span class="line">- 区分度不高的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。</span><br><span class="line"></span><br><span class="line">## 哈希索引</span><br><span class="line">哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</span><br><span class="line"></span><br><span class="line">## 【面试题】InnoDB为什么用B+树做索引</span><br><span class="line">innodb用的聚簇索引，把索引和数据一起存放，数据在叶子节点有序存放，非叶子存放索引（key和页号）；一个是有序存放适合范围查找，不需要遍历整棵树，一个是达到减少磁盘IO次数的作用。</span><br><span class="line"></span><br><span class="line">![](/images/innodbb%2Btree.webp)</span><br><span class="line">因为B+树可以实现**有序存放**和**减少磁盘IO**</span><br><span class="line">知识点：</span><br><span class="line">1. 适合范围查找：普通二分查找树</span><br><span class="line">   由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（假设一个节点的大小「小于」操作系统的最小读写单位块的大小），也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。</span><br><span class="line">2.  在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</span><br><span class="line"></span><br><span class="line">## 为什么 B+ 和 B树</span><br><span class="line">- 从存储情况来说，B+只有叶子有数据，B树所有节点都有数据，这样就增加了磁盘IO次数</span><br><span class="line">- B+ 的非叶子结点仅有关键字，适合搜索</span><br><span class="line"></span><br><span class="line">B 树的内部节点既包含关键字也包含指向实际数据的指针，而 B+ 树的内部节点仅包含关键字，实际数据只存储在叶子节点中。这使得 B+ 树在磁盘存储和范围查询等方面具有优势，适合作为数据库索引的数据结构</span><br><span class="line"></span><br><span class="line">### 【再问】为什么不用B树</span><br><span class="line">B树和B+的时间复杂度查找都是O(logN)，但是B 树可能会因为树的分支过多，导致需要进行多次磁盘访问。并且B+支持多级索引，很容易扩展。</span><br><span class="line">- 更适合磁盘存储：</span><br></pre></td></tr></table></figure><p>B+ 树的叶子节点形成了一个有序链表，这使得范围查询的效率非常高，因为相邻的元素会被存储在相邻的位置，可以在一个或者很少几个相邻的节点中找到所有需要的数据。<br>B+ 树的叶子节点包含了所有的数据记录，这意味着每次查找都可以直接定位到具体的数据行，而不需要额外的中间层节点来获取实际数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 支持多级索引</span><br><span class="line"></span><br><span class="line">B+ 树可以很容易地扩展为多级索引。在多级索引中，每一层都是一个独立的 B+ 树，它们之间通过指针进行连接。这样的设计使得在大量数据的情况下也可以保持高效的检索速度。</span><br></pre></td></tr></table></figure><p>举例来说，假设我们有一个三级索引 (a, b, c)，那么：<br>第一级索引以 a 为键构建一颗 B+ 树，每个节点中存储 b 的值以及指向第二级索引的指针。<br>第二级索引以 b 为键构建一颗 B+ 树，每个节点中存储 c 的值以及指向第三级索引的指针。<br>第三级索引以 c 为键构建一颗 B+ 树，叶子节点中存储了对应的数据记录。<br>这样的设计使得在多级索引中，每一层都能帮助缩小搜索范围，从而提高查询效</p><p>其中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">## 【面试】 索引失效的情况</span><br><span class="line">https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg</span><br><span class="line"></span><br><span class="line">- 左/左右模糊匹配`like %a`</span><br><span class="line">- 使用函数，但是8.0之后出现了函数索引</span><br><span class="line">- 表达式计算</span><br><span class="line">- 隐式类型转换，比如name是varchar，查询时使用`select 8 from A where name=11111;`</span><br><span class="line">- 联合索引的非**最左匹配**：</span><br><span class="line">- WHERE 里面的 OR操作，导致全表扫描：OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，解决办法将其都加上索引。</span><br><span class="line"></span><br><span class="line">## MySQL什么情况下索引会失效</span><br><span class="line">1. 组合索引时，如果查询条件没有使用最左边的字段，就不会使用索引</span><br><span class="line">2. like进行匹配时，如果字符串前面含有%百分号，就会全表扫描时，不使用索引，</span><br><span class="line">3. 还有一种情况，是如果查询条件中类型是字符串，没有引号，发生了隐式转换就不会使用索引</span><br><span class="line">4. 对索引列进行运算</span><br><span class="line">5. 判断索引列是否不等于某个值时</span><br><span class="line">6. 查询条件使用or连接，也会导致索引失效</span><br><span class="line"></span><br><span class="line">## 【面试题】索引下推是什么，回表是什么</span><br><span class="line">- **explain会显示Extra字段为using index condition，表示使用了索引下推**</span><br><span class="line">- 查询的时候截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 (a, b, c) 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</span><br><span class="line">- 回表也叫二次查询，指在数据库中执行一个查询，如果查询的字段不在查询的索引中，数据库可能需要通过索引定位到相应的行，然后再去实际的数据页中获取所需的字段值，这个过程就被称为回表。</span><br><span class="line">以索引举例，查了两个索引，那么就是先根据第一个索引找到符合要求的值，然后在这些行里用第二个索引进行过滤。</span><br><span class="line"></span><br><span class="line">## 【面试】最左匹配的一个问题：当where a=1 and c=3时，符合最左匹配吗</span><br><span class="line">答案：符合最左，只有a用了索引，c字段没使用</span><br><span class="line">严格意义上来说是属于索引截断。</span><br><span class="line"></span><br><span class="line">- MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</span><br><span class="line">- 从 MySQL 5.6 之后，有一个索引下推功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</span><br><span class="line">## 【面试】讲一下回表和索引下推的区别</span><br><span class="line">- **回表是先通过索引查询行，再访问数据行涉及到两次磁盘访问**</span><br><span class="line">- **索引下推是先在索引上执行一部分或全部的查询条件，大大减少磁盘访问次数**</span><br><span class="line"></span><br><span class="line">**回表（Lookup）：**</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">回表是指在使用索引定位到符合查询条件的行后，再次访问实际的数据行，从中获取所需的字段值的过程。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">使用索引定位到符合查询条件的行的位置。</span><br><span class="line">从定位到的位置中读取行的指针或主键。</span><br><span class="line">使用指针或主键再次访问实际的数据行，从中获取所需的字段值。</span><br><span class="line"></span><br><span class="line">代价：</span><br><span class="line">回表的代价相对较高，因为它涉及了两次磁盘/内存访问。</span><br><span class="line"></span><br><span class="line">**索引下推（Index Pushdown）：**</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">索引下推是指在查询执行过程中，数据库管理系统会尝试在索引上执行部分或全部的查询条件，从而减少需要访问实际数据行的次数。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">当查询中的条件可以在索引中找到匹配项时，数据库会尝试在索引上执行这部分查询条件，以过滤掉不符合条件的行。 只有符合索引条件的行才会被返回给用户。</span><br><span class="line"></span><br><span class="line">优势：</span><br><span class="line">减少了回表的次数，降低了查询的代价，提高了查询的性能。</span><br><span class="line">减少了磁盘/内存访问次数，尤其在大型数据集中，效果显著。</span><br><span class="line"></span><br><span class="line">适用情况：</span><br><span class="line">索引下推通常在涉及到范围查询、排序、聚合等操作时可以发挥较大的优化作用。</span><br><span class="line"></span><br><span class="line">## Hash索引和B+树索引的区别？</span><br><span class="line"></span><br><span class="line">哈希索引**不支持排序**，因为哈希表是无序的。</span><br><span class="line">哈希索引**不支持范围查找**。</span><br><span class="line">哈希索引**不支持模糊查询**及组合索引的最左前缀匹配。</span><br><span class="line">因为哈希表中会存在哈希冲突，所以哈希索引的性能是**不稳定**的，</span><br><span class="line">而B+树索引的性能是**相对稳定的**，每次查询都是从根节点到叶子节点。</span><br><span class="line"></span><br><span class="line">## 为什么B+树比B树更适合实现数据库索引？【】</span><br><span class="line"></span><br><span class="line">- 由于B+树的数据都存储在叶子结点中，**叶子结点均为数据，方便扫库**，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</span><br><span class="line"></span><br><span class="line">B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。</span><br><span class="line"></span><br><span class="line">B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</span><br><span class="line"></span><br><span class="line">## 什么是覆盖索引？</span><br><span class="line"></span><br><span class="line">select的数据列只用从索引中就能够取得，不需要回表进行二次查询，也就是说查询列要被所使用的索引覆盖。对于innodb表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。</span><br><span class="line"></span><br><span class="line">不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。</span><br><span class="line"></span><br><span class="line">对于使用了覆盖索引的查询，在查询前面使用explain，输出的extra列会显示为using index。</span><br><span class="line"></span><br><span class="line">比如user_like 用户点赞表，组合索引为(user_id, blog_id)，user_id和blog_id都不为null。</span><br><span class="line"></span><br><span class="line">```explain select blog_id from user_like where user_id = 13;</span><br></pre></td></tr></table></figure><p>explain结果的Extra列为Using index，查询的列被索引覆盖，并且where筛选条件符合最左前缀原则，通过索引查找就能直接找到符合条件的数据，不需要回表查询数据。</p><figure class="highlight plain"><figcaption><span>select user_id from user_like where blog_id </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain结果的Extra列为Using where; Using index， 查询的列被索引覆盖，where筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过索引扫描找到符合条件的数据，也不需要回表查询数据。</span><br><span class="line"></span><br><span class="line"># 数据库引擎</span><br><span class="line">## InnoDB存储引擎</span><br><span class="line"></span><br><span class="line">InnoDB是MySQL默认的事务型存储引擎，使用最广泛，基于**聚簇索引**建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。</span><br><span class="line"></span><br><span class="line">**优点**：支持事务和崩溃修复能力；引入了行级锁和外键约束。</span><br><span class="line"></span><br><span class="line">**缺点**：占用的数据空间相对较大。</span><br><span class="line"></span><br><span class="line">**适用场景**：需要事务支持，并且有较高的并发读写频率。</span><br><span class="line"></span><br><span class="line">### 什么是聚簇索引？【索引结构和数据一起存放的索引，根据主键创建的索引，用B+树创建】</span><br><span class="line"></span><br><span class="line">InnoDB使用**表的主键构造主键索引树**，同时叶子节点中存放的即为整张表的记录数据。聚集索引叶子节点的存储是逻辑上连续的，使用双向链表连接，叶子节点按照主键的顺序排序，因此对于主键的排序查找和范围查找速度比较快。</span><br><span class="line"></span><br><span class="line">聚集索引的叶子节点就是整张表的行记录。InnoDB 主键使用的是聚簇索引。聚集索引要比非聚集索引查询效率高很多。</span><br><span class="line"></span><br><span class="line">对于InnoDB来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引。如果没有主键也没有合适的唯一索引，那么InnoDB内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为6个字节，它的值会随着数据的插入自增。</span><br><span class="line">### 聚簇和非聚簇索引</span><br><span class="line">- 聚簇索引叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据；而非聚簇索引叶子节点存储的是主键信息，所以使用非聚簇索引，一般情况还需要回表查询，如果查询的字段命中索引就不需要回表了，比如select age where age = 10.</span><br><span class="line">- or：聚簇索引的叶子节点存放的是主键值和数据行，支持覆盖索引</span><br><span class="line">      非聚簇索引的叶子节点存放的是主键值或数据记录的地址（InnoDB辅助索引的data域存储相应记录主键的值，MyISAM辅助索引的data域保存数据记录的地址）</span><br><span class="line"></span><br><span class="line">## MyISAM存储引擎</span><br><span class="line"></span><br><span class="line">数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件.MYD和索引文件.MYI。</span><br><span class="line"></span><br><span class="line">**优点**：访问速度快</span><br><span class="line"></span><br><span class="line">**缺点**：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。</span><br><span class="line"></span><br><span class="line">**适用场景**：对事务完整性没有要求；表的数据都会只读的。</span><br><span class="line"></span><br><span class="line">## InnoDB和MyISAM的区别</span><br><span class="line">1. myisam支持到表锁，Innodb支持表锁，进一步支持到行锁，粒度更细，解决脏读和不可重复度。使用场景myisam适合读场景多，crud场景少的场景，比如博客这些；innodb适合事务支持，高并发等情况</span><br><span class="line">2. myisam不支持事务，innodb有binlog可以恢复数据库</span><br><span class="line">3. myisam数据存储是直接查到内存地址，innodb是有数据缓存</span><br><span class="line">4. myisam索引是非聚簇索引，索引里只有innodb是聚簇索引</span><br><span class="line">## 两者索引的区别【非聚簇索引myisam，看3.】</span><br><span class="line">1. myisam使用非聚簇索引，也是b+树，innodb使用聚簇索引，B+树</span><br><span class="line">2. myisam的索引和数据存储是分开的，聚簇索引是将数据和索引存储在一起</span><br><span class="line">3. 将数据存储于索引分开结构，索引结构的叶子节点指向了数 据的对应行，myisam 通 过 key_buffer 把索引先缓存到内存中，当需要访问 数据时(通过索引访问数据)，在内存中直接 搜索索引，然后通过索引找 到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢 的 原因。</span><br><span class="line"></span><br><span class="line">## 【重点】为什么innodb比myisam慢了点</span><br><span class="line">- myisam是非聚簇，索引和数据是分开的，在查询时，可以直接访问到索引文件，而不需要额外的查找操作。</span><br><span class="line">- 而在 InnoDB 中，由于使用了聚簇索引，查询时可能需要在索引中定位到主键，再根据主键访问数据行</span><br><span class="line"># 事务Transaction</span><br><span class="line">## InnoDB 引擎通过什么技术来保证事务的这ACID特性的？</span><br><span class="line"></span><br><span class="line">- 持久性Durability是通过 redo log（重做日志）来保证的；</span><br><span class="line">- 原子性Atomicity 是通过 undo log（回滚日志）来保证的；</span><br><span class="line">- 隔离性Isolation是通过 MVCC（多版本并发控制） 或锁机制来保证的；</span><br><span class="line">- 一致性Consistency则是通过持久性+原子性+隔离性来保证；</span><br><span class="line"></span><br><span class="line">*MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能*</span><br><span class="line">https://xiaolincoding.com/mysql/transaction/phantom.html#什么是幻读</span><br><span class="line">## 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。</span><br><span class="line"></span><br><span class="line">## 【面试题】为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题。</span><br><span class="line">数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</span><br><span class="line"></span><br><span class="line">## 多事务的并发进行一般会造成以下几个问题: </span><br><span class="line"></span><br><span class="line">锁：共享锁和排他锁（读写锁）</span><br><span class="line"></span><br><span class="line"># 【面试重点】锁</span><br><span class="line">锁分为全局锁，表锁，行锁，下面介绍各锁的使用和场景</span><br><span class="line"></span><br><span class="line">## 全局锁</span><br><span class="line">**应用场景**：全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</span><br><span class="line">* 如果在主库备份，在备份期间不能更新，业务停止，所以更新业务会处于等待状态</span><br><span class="line">* 如果在从库备份，在备份期间不能执行主库同步的binlog，导致主从延迟</span><br><span class="line">**缺点**：意味着整个数据库都是只读状态，备份花时间长，无法执行其他操作。</span><br><span class="line">但是MYSQL解决了这个问题，通过**可重复度**，使用ReadView，事务操作时用ReadView，MVCC支持备份与事务同时进行。</span><br><span class="line"></span><br><span class="line">- 上锁1`flush tables with READ lock;`锁定所有的表，防止其他会话对这些表进行写操作，但允许读操作</span><br><span class="line">- 上锁2`lock tables [tablename] READ/WRITE`</span><br><span class="line">- `unlock tables;`</span><br><span class="line"></span><br><span class="line">## 表级锁</span><br><span class="line">### 表锁</span><br><span class="line">**应用场景**:表级别的共享锁=读锁,独占锁=写锁</span><br><span class="line">- 尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能</span><br><span class="line">- `lock tables [tablename] read/write;` </span><br><span class="line">### 元数据锁</span><br><span class="line">**应用场景**不需要显式使用，在CRUD/alter中自动创建，select执行完才可以执行其他操作，</span><br><span class="line">- MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。</span><br><span class="line">  </span><br><span class="line">【引申问题】</span><br><span class="line">那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），</span><br><span class="line">首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</span><br><span class="line"></span><br><span class="line">然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</span><br><span class="line"></span><br><span class="line">接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</span><br><span class="line"></span><br><span class="line">那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</span><br><span class="line"></span><br><span class="line">**那么为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？**</span><br><span class="line"></span><br><span class="line">因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</span><br><span class="line"></span><br><span class="line">### 意向锁</span><br><span class="line">**用于快速判断表是否加了锁**。因为：</span><br><span class="line"></span><br><span class="line">如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</span><br><span class="line"></span><br><span class="line">### 自增锁</span><br><span class="line">```java</span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy = GenerationType.IDENTITY) // 指定自动生成主键的策略</span><br><span class="line">@Column(name = &quot;id&quot;)</span><br><span class="line">private int id;</span><br></pre></td></tr></table></figure><p>在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</p><p><strong>应用场景</strong></p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p><strong>记录锁 Record Lock</strong>，仅仅把一条记录锁上；</p><p><strong>间隙锁 Gap Lock</strong>，锁定一个范围，但是不包含记录本身；间隙锁的意义只在于阻止区间被插入</p><p><strong>临键锁 Next-Key Lock</strong>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><ul><li>【普通的select没有行锁】普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。<h3 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁 Record Lock"></a>记录锁 Record Lock</h3>记录锁分为S锁和X锁。</li><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。<h3 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 Gap Lock"></a>间隙锁 Gap Lock</h3>只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</li><li>对间隙加锁是为了防止插入/删除的时候出现幻读</li><li>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。<h3 id="临键锁-Next-key-Lock"><a href="#临键锁-Next-key-Lock" class="headerlink" title="临键锁 Next-key Lock"></a>临键锁 Next-key Lock</h3>理解为一个范围的间隙锁</li></ul><h2 id="【面试题】MYSQL怎么加锁"><a href="#【面试题】MYSQL怎么加锁" class="headerlink" title="【面试题】MYSQL怎么加锁"></a>【面试题】MYSQL怎么加锁</h2><ol><li>【加行锁】在查询时对记录加行级锁，这两种查询会加锁的语句称为锁定读。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//对读取的记录加共享锁(S型锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line">//对读取的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">//对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> .... <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">//对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><p>上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。</p><h3 id="普通查询，没有使用索引的话，会导致什么情况？"><a href="#普通查询，没有使用索引的话，会导致什么情况？" class="headerlink" title="普通查询，没有使用索引的话，会导致什么情况？"></a>普通查询，没有使用索引的话，会导致什么情况？</h3><p>没有使用索引字段作查询条件的话，导致扫描是全表扫描。那么，每一条记录的索引上都会加 临键（NK）锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.xiaolincoding.com//mysql/other/3c3af16e7a948833ccb6409e8b51daf8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>如果在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.xiaolincoding.com//mysql/other/1aa886fe95e7bc791c296e2d342fa435.png" alt title>                </div>                <div class="image-caption"></div>            </figure>这条 update 语句产生了 4 个记录锁（有几条记录就有几个Record锁）和 5 个间隙锁（范围+1），相当于锁住了全表。</li></ul><h3 id="那-update-语句的-where-带上索引就能避免全表记录加锁了吗？"><a href="#那-update-语句的-where-带上索引就能避免全表记录加锁了吗？" class="headerlink" title="那 update 语句的 where 带上索引就能避免全表记录加锁了吗？"></a>那 update 语句的 where 带上索引就能避免全表记录加锁了吗？</h3><p>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了。</p><h3 id="update-没加索引，加的是表锁还是行锁"><a href="#update-没加索引，加的是表锁还是行锁" class="headerlink" title="update 没加索引，加的是表锁还是行锁"></a>update 没加索引，加的是表锁还是行锁</h3><p>对每一行都加了NK锁，就锁了整张表。</p><h3 id="避免全表锁定"><a href="#避免全表锁定" class="headerlink" title="避免全表锁定"></a>避免全表锁定</h3><p>将 MySQL 里的 <strong>sql_safe_updates 参数设置为 1</strong>，开启安全更新模式。</p><ul><li><p>update 语句必须满足如下条件之一才能执行成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 where，并且 where 条件中必须有索引列；</span><br><span class="line">使用 limit；</span><br><span class="line">同时使用 where 和 limit，此时 where 条件中可以没有索引列；</span><br></pre></td></tr></table></figure></li><li><p>delete 语句必须满足以下条件能执行成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同时使用 where 和 limit，此时 where 条件中可以没有索引列；</span><br><span class="line"></span><br><span class="line">另外：如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 FORCE INDEX([index_name]) 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</span><br></pre></td></tr></table></figure></li></ul><h2 id="MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？【可以】"><a href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？【可以】" class="headerlink" title="MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？【可以】"></a>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？【可以】</h2><h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁的生成时机：</p><p>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁），现象就是 Insert 语句会被阻塞。</p><h1 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h1><h2 id="binlog，归档日志，逻辑日志，属于Server层，与引擎无关"><a href="#binlog，归档日志，逻辑日志，属于Server层，与引擎无关" class="headerlink" title="binlog，归档日志，逻辑日志，属于Server层，与引擎无关"></a>binlog，归档日志，逻辑日志，属于Server层，与引擎无关</h2><p>保证一致性C；用于数据库的数据备份、主备、主主、主从复制</p><ol><li>事务执行过程中，先把日志写到binlog cache，事务提交的时候，再把binlog cache写到binlog文件中，事务一次性写入，后台给一个线程去写</li></ol><p>三种模式：statement、row和mixed.</p><ul><li>statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.</li><li>row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.</li><li>mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.</li></ul><h3 id="show-master-status"><a href="#show-master-status" class="headerlink" title="show master status"></a>show master status</h3><p>在my.ini文件中 查看bin_log文件位置</p><h2 id="redolog：宕机恢复数据，物理日志"><a href="#redolog：宕机恢复数据，物理日志" class="headerlink" title="redolog：宕机恢复数据，物理日志"></a>redolog：宕机恢复数据，物理日志</h2><p>Redo Log记录的是新数据的备份。</p><p>保证持久性D</p><ol><li>查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中</li><li>后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能</li><li><strong>更新表数据的时候</strong>，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新，然后会<strong>把修改内容记录到redologbuffer</strong>里，接着刷盘到 redo log 文件里</li></ol><h2 id="undolog：回滚，缺点-写操作较多"><a href="#undolog：回滚，缺点-写操作较多" class="headerlink" title="undolog：回滚，缺点-写操作较多"></a>undolog：回滚，缺点-写操作较多</h2><p>在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p><p>保证原子性A</p><ul><li>所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作</li><li>MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改</li></ul><h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><ul><li>每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</li></ul><h2 id="https-gitee-com-mydb-interview"><a href="#https-gitee-com-mydb-interview" class="headerlink" title="https://gitee.com/mydb/interview"></a><a href="https://gitee.com/mydb/interview" target="_blank" rel="noopener">https://gitee.com/mydb/interview</a></h2><h2 id="如何做增量备份"><a href="#如何做增量备份" class="headerlink" title="如何做增量备份"></a>如何做增量备份</h2><ol><li>mysqldump   做一个全备</li><li>mysqlbinlog 做一个增量备份</li></ol><h2 id="innodb使用自增ID当主键【顺序添加，uuid插入值会造成页面的碎片和不紧凑的索引结构】"><a href="#innodb使用自增ID当主键【顺序添加，uuid插入值会造成页面的碎片和不紧凑的索引结构】" class="headerlink" title="innodb使用自增ID当主键【顺序添加，uuid插入值会造成页面的碎片和不紧凑的索引结构】"></a>innodb使用自增ID当主键【顺序添加，uuid插入值会造成页面的碎片和不紧凑的索引结构】</h2><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面</p><h2 id="MyISAM和InnoDB使用B-树做索引，区别是什么【innodb使用聚簇，myisam使用非聚簇】"><a href="#MyISAM和InnoDB使用B-树做索引，区别是什么【innodb使用聚簇，myisam使用非聚簇】" class="headerlink" title="MyISAM和InnoDB使用B+树做索引，区别是什么【innodb使用聚簇，myisam使用非聚簇】"></a>MyISAM和InnoDB使用B+树做索引，区别是什么【innodb使用聚簇，myisam使用非聚簇】</h2><ol><li>Innodb的聚簇：数据在叶子节点有序存放，非叶子存放key和页号，也就是一棵B+树的索引文件本身就可以是数据文件，找到了索引就找到了对应的行数据。</li><li>叶节点存key和data。data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”<h2 id="mysql自增主键不连续的情况原因有三个"><a href="#mysql自增主键不连续的情况原因有三个" class="headerlink" title="mysql自增主键不连续的情况原因有三个:"></a>mysql自增主键不连续的情况原因有三个:</h2>1) 唯一键冲突<br>2) 事务回滚<br>3) insert…select的时候会出现主键id每次双倍分配导致主键id跳过的问题</li></ol><h2 id="高并发场景下，如何安全修改同一行数据"><a href="#高并发场景下，如何安全修改同一行数据" class="headerlink" title="高并发场景下，如何安全修改同一行数据"></a>高并发场景下，如何安全修改同一行数据</h2><ol><li>悲观锁，innodb的事务支持加行锁</li><li>乐观锁，每次修改时先判断版本号是否一直，如果更改了就返回失败/重试，使用版本号机制，或者CAS算法实现</li><li>CAS算法</li></ol><h2 id="select-…for-update语句是我们经常使用手工加锁语句。"><a href="#select-…for-update语句是我们经常使用手工加锁语句。" class="headerlink" title="select …for update语句是我们经常使用手工加锁语句。"></a>select …for update语句是我们经常使用手工加锁语句。</h2><p>用来锁定特定的行（如果有where子句，就是满足where条件的那些行）。当这些行被锁定后，其他会话可以选择这些行，但不能更改或删除这些行，直到该语句的事务被commit语句或rollback语句结束为止</p><h1 id="超大数据"><a href="#超大数据" class="headerlink" title="超大数据"></a>超大数据</h1><h2 id="如果mysql-limit加载超多10000，如何解决"><a href="#如果mysql-limit加载超多10000，如何解决" class="headerlink" title="如果mysql limit加载超多10000，如何解决"></a>如果mysql limit加载超多10000，如何解决</h2><ol><li>如果id连续，分离出来几个范围查找</li><li>利用子查询优化超多分页场景。（先快速定位需要获取的id段，然后再关联）</li><li>order by id 10000，10</li><li>更改业务，一般不需要那么多数量</li></ol><h2 id="千万数据，可以用分库分表优化表结构"><a href="#千万数据，可以用分库分表优化表结构" class="headerlink" title="千万数据，可以用分库分表优化表结构"></a>千万数据，可以用分库分表优化表结构</h2><ol><li>分表方案（水平分表，垂直分表，切分规则hash等）</li><li>分库分表一些问题（事务问题？跨节点Join的问题）</li><li>分库分表中间件（Mycat，sharding-jdbc等）</li><li>解决方案（分布式事务等如何做）</li></ol><h2 id="【思格】简述count-1-、count-与count-列名-的执行区别"><a href="#【思格】简述count-1-、count-与count-列名-的执行区别" class="headerlink" title="【思格】简述count(1)、count(*)与count(列名)的执行区别 ?"></a>【思格】简述count(1)、count(*)与count(列名)的执行区别 ?</h2><p>count(*)：包括了所有的列，相当于行数，在统计结果的时候， 不会忽略列值为NULL<br>count(1)：包括了忽略所有列，用1代表代码行，在统计结果的时候， 不会忽略列值为NULL<br>count(列名)：只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数， 即某个字段值为NULL时，不统计。<br>执行效率上：</p><p>列名为主键，count(列名)会比count(1)快<br>列名不为主键，count(1)会比count(列名)快<br>如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（<em>）<br>如果有主键，则 select count（主键）的执行效率是最优的<br>如果表只有一个字段，则 select count（</em>）最优。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; questions&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://waynamigo.github.io/categories/Mysql/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Mysql" scheme="http://waynamigo.github.io/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Golang questions</title>
    <link href="http://waynamigo.github.io/2023/01/02/2023-01-02-%E9%9D%A2%E7%BB%8FGo%E9%97%AE%E9%A2%98/"/>
    <id>http://waynamigo.github.io/2023/01/02/2023-01-02-面经Go问题/</id>
    <published>2023-01-01T16:00:00.000Z</published>
    <updated>2023-12-02T03:49:16.797Z</updated>
    
    <content type="html"><![CDATA[<p>Golang questions</p><a id="more"></a><p>利用通信，也就是封装内部实现，提供接口的方式来进行相应的操作</p><h2 id="make-和new的区别"><a href="#make-和new的区别" class="headerlink" title="make 和new的区别"></a>make 和new的区别</h2><p>分配内存的类型，返回值来回答<br>make专门给引用类型分配内存+初始化，返回的是一个对象的引用<br>new用来为其他类型分配内存，返回的是对象的指针（也可以new一个map，返回的指针指向全是0值的map对象</p><h2 id="map数据结构是什么，底层是基于哈希表实现的，碰撞冲突用的是开链法"><a href="#map数据结构是什么，底层是基于哈希表实现的，碰撞冲突用的是开链法" class="headerlink" title="map数据结构是什么，底层是基于哈希表实现的，碰撞冲突用的是开链法"></a>map数据结构是什么，底层是基于哈希表实现的，碰撞冲突用的是开链法</h2><ol><li>hmap存的是哈希结构，里面包含一个bmap，B，extra字段，bmap存的时bucket，B用于扩容，extra存溢出的bucket指针</li><li>bucket的数量是通过B计算的 = 2^B，每个bucket包含8个kv对，和一个overflow指针，用于开链解决冲突，</li><li>bmap存的是topbits[8], keys[8] values[8] overflow指针(移动到hmap的extra字段)</li></ol><h2 id="查一个kv的时候，怎么查的"><a href="#查一个kv的时候，怎么查的" class="headerlink" title="查一个kv的时候，怎么查的"></a>查一个kv的时候，怎么查的</h2><ol><li>myMap[“key0”]</li><li>对key0做哈希函数；，这个时候落到某个桶中，再查找hashcode高8位，也就是在bmap中查找topbits[8]来查找在桶的哪个位置</li></ol><h2 id="map扩容是怎么做的"><a href="#map扩容是怎么做的" class="headerlink" title="map扩容是怎么做的"></a>map扩容是怎么做的</h2><p><strong>增量扩容</strong>时机是插入时，计算这个map的装载因子，大于6.5时把bucket的2^B +1，才进行扩容。</p><ol><li>loadfactor = count / 2^B 大于6.5。发生增量扩容，B+1，然后rehash重新分配kv到不同bucket</li></ol><p><strong>等量扩容</strong>是overflow的bucket过多是发生<br>当1. B小于15时，overflow的bucket超过2^B个；<br>当2. B大于15时，超过2^15个，hasgrowth()函数进行判断，在mapassign的时候进行逐步搬迁</p><ol><li>等量扩容，重新计算一次hashcode进行等量扩容</li><li>扩容时，会对bucket的内存进行搬迁，先把现有bucket挂到oldbucket字段，然后在插入动作（mapassign）中执行<h2 id="为什么负载因子是6-5"><a href="#为什么负载因子是6-5" class="headerlink" title="为什么负载因子是6.5"></a>为什么负载因子是6.5</h2>至于装载因子为什么选择6.5，以下是go源码中对不同装载因子的测试，其中有四个重要的指标<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%overflow : hmap中拥有溢出桶的bucket数量</span><br><span class="line">bytes/entry：平均每对key/elem使用的内存数量</span><br><span class="line">hitprobe：查找一个存在的keys所需要的检查的kv数量</span><br><span class="line">missprobe：查找一个不存在的key需要检查的kv数量</span><br></pre></td></tr></table></figure></li></ol><p>可以看到，当负载因子过大时会导致查找性能急速下降，但是负载因子太小时又会导致有大量内存被浪费，所以go team最终选择了6.5做负载因子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// Picking loadFactor: too large and we have lots of overflow</span><br><span class="line"></span><br><span class="line">// buckets, too small and we waste a lot of space. I wrote</span><br><span class="line"></span><br><span class="line">// a simple program to check some stats for different loads:</span><br><span class="line"></span><br><span class="line">// (64-bit, 8 byte keys and elems)</span><br><span class="line"></span><br><span class="line">//  loadFactor    %overflow  bytes/entry     hitprobe    missprobe</span><br><span class="line"></span><br><span class="line">//        4.00         2.13        20.77         3.00         4.00</span><br><span class="line"></span><br><span class="line">//        4.50         4.05        17.30         3.25         4.50</span><br><span class="line"></span><br><span class="line">//        5.00         6.85        14.77         3.50         5.00</span><br><span class="line"></span><br><span class="line">//        5.50        10.55        12.94         3.75         5.50</span><br><span class="line"></span><br><span class="line">//        6.00        15.27        11.67         4.00         6.00</span><br><span class="line"></span><br><span class="line">//        6.50        20.90        10.79         4.25         6.50</span><br><span class="line"></span><br><span class="line">//        7.00        27.14        10.15         4.50         7.00</span><br><span class="line"></span><br><span class="line">//        7.50        34.03         9.73         4.75         7.50</span><br><span class="line"></span><br><span class="line">//        8.00        41.10         9.40         5.00         8.00</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">// %overflow   = percentage of buckets which have an overflow bucket</span><br><span class="line"></span><br><span class="line">// bytes/entry = overhead bytes used per key/elem pair</span><br><span class="line"></span><br><span class="line">// hitprobe    = # of entries to check when looking up a present key</span><br><span class="line"></span><br><span class="line">// missprobe   = # of entries to check when looking up an absent key</span><br></pre></td></tr></table></figure><h2 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h2><h2 id="讲讲go程序的执行过程：预处理，编译、链接、运行"><a href="#讲讲go程序的执行过程：预处理，编译、链接、运行" class="headerlink" title="讲讲go程序的执行过程：预处理，编译、链接、运行"></a>讲讲go程序的执行过程：预处理，编译、链接、运行</h2><p>词法分析、语法分析、类型检查、代码生成、编译器优化、链接</p><ul><li>go run做了什么：编译、链接、运行</li></ul><h2 id="channel和共享内存有什么优劣"><a href="#channel和共享内存有什么优劣" class="headerlink" title="channel和共享内存有什么优劣"></a>channel和共享内存有什么优劣</h2><p>channel</p><ul><li>隐式同步，减少锁的使用</li><li>不适合大量数据传输<br>共享内存</li><li>显式用锁，性能高</li><li>适合大量数据，但难以调试，存在复杂的同步机制</li></ul><h2 id="context原理和场景【并发安全的】"><a href="#context原理和场景【并发安全的】" class="headerlink" title="context原理和场景【并发安全的】"></a>context原理和场景【并发安全的】</h2><p>【withtimeout超时取消，withvalue传递共享数据】<br><strong>确切的说它是 goroutine 的上下文，包含了 goroutine 的运行状态、环境、现场等信息。</strong><br><strong>作用的话一般是用取消信号，控制超时</strong><br>context用于多个goroutine之间进行通信和控制的官方库，实现并发控制，包括取消信号、控制超时时间<br>注意点</p><ol><li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</li><li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</li><li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</li></ol><p>ctx, cancel := context.WithCancel(context.Background())<br>defer cancel() // 避免其他地方忘记 cancel，且重复调用不影响</p><h3 id="原理，Context-Value查找"><a href="#原理，Context-Value查找" class="headerlink" title="原理，Context.Value查找"></a>原理，Context.Value查找</h3><p>Context 指向它的父节点，链表则指向下一个节点。通过 WithValue 函数，可以创建层层的 valueCtx，存储 goroutine 间可以共享的变量。<br>取值的过程，实际上是一个递归查找的过程，它会顺着链路一直往上找，比较当前节点的 key是否是要找的 key，如果是，则直接返回 value。否则，一直顺着 context 往前，最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。<br>父节点没法获取子节点存储的值，子节点却可以获取父节点的值。</p><h2 id="waitgroup的原理和场景【多个groutine的等待结束-并发控制】"><a href="#waitgroup的原理和场景【多个groutine的等待结束-并发控制】" class="headerlink" title="waitgroup的原理和场景【多个groutine的等待结束/并发控制】"></a>waitgroup的原理和场景【多个groutine的等待结束/并发控制】</h2><ul><li>内部维护了一个计数器，初始化为0。</li><li>调用 Add 方法时，计数器会增加；</li><li>每当调用 Done 方法时，计数器会减少；</li><li>调用 Wait 方法时，如果计数器不为零，则会阻塞当前 Goroutine，直到计数器减至零。</li></ul><h2 id="string和byte的转换发生内存拷贝吗【会】为什么？"><a href="#string和byte的转换发生内存拷贝吗【会】为什么？" class="headerlink" title="string和byte的转换发生内存拷贝吗【会】为什么？"></a>string和byte的转换发生内存拷贝吗【会】为什么？</h2><p>string底层是一个不可变的字符数组，执行[]byte(str)，拷贝完，之前分配的空间被gc</p><h2 id="为什么go协程堵掉不会阻塞，C-的线程堵掉"><a href="#为什么go协程堵掉不会阻塞，C-的线程堵掉" class="headerlink" title="为什么go协程堵掉不会阻塞，C++的线程堵掉"></a>为什么go协程堵掉不会阻塞，C++的线程堵掉</h2><p>【C++的线程pthread是内核态，Go的调度时runtime系统管理的，相当于套了一层壳，运行在用户态，但是有内核态的速度,然后goroutine堵掉会通过GPM模型的handoff机制移交给其他的M去执行</p><h2 id="除了mutex还有什么方法实现并发安全"><a href="#除了mutex还有什么方法实现并发安全" class="headerlink" title="除了mutex还有什么方法实现并发安全"></a>除了mutex还有什么方法实现并发安全</h2><p>atomic包和channel</p><h2 id="mutex和RWmutex的区别"><a href="#mutex和RWmutex的区别" class="headerlink" title="mutex和RWmutex的区别"></a>mutex和RWmutex的区别</h2><ol><li>可重入性：mutex不是可重入锁，Mutex 不会记录持有锁的协程的信息，所以它也无法区分是不是重入这种场景。</li><li>读写锁的读锁可重入，写锁不可以<h2 id="锁的正常和饥饿状态"><a href="#锁的正常和饥饿状态" class="headerlink" title="锁的正常和饥饿状态"></a>锁的正常和饥饿状态</h2><h2 id="这个runtime系统解释一下"><a href="#这个runtime系统解释一下" class="headerlink" title="这个runtime系统解释一下"></a>这个runtime系统解释一下</h2>golang 的 runtime 在 golang 中的地位类似于 Java 的虚拟机。<br>包括</li><li>GPM模型</li><li>GC机制</li><li>内存分配：Go 程序在启动时，会首先向系统申请一块内存(虚拟地址空间)，然后自己切成小块进行管理. 将申请的内存，分成 3 个区域,spans、bitmap、arena<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arena: 就是堆区，go runtime 在动态分配的内存都在这个区域，并且将内存块分成 8kb 的页，一些组合起来的称为 **mspan，**成为 go 中内存管理的基本单元，这种连续的页一般是操作系统的内存页几倍大小.</span><br><span class="line">bitmap: 顾名思义，用来标记堆区使用的映射表，它记录了哪些区域保存了对象，对象是否包含指针，以及 GC 的标记信息.</span><br><span class="line">spans: 存放 mspan 的指针，根据 spans 区域的信息可以很容易找到 mspan. 它可以在 GC 时更快速的找到的大块的内存 mspan.</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-go的数组和切片"><a href="#1-go的数组和切片" class="headerlink" title="1.go的数组和切片"></a>1.go的数组和切片</h2><ol><li>数组是固定长度的，切片是可以变化的</li><li>切片实际是对数组的封装，切片底层是由指向数组的指针，切片长度，切片容量三个参数组成。指向底层数组的指针就标志着切片的开始</li><li>切片是对底层数组的一个引用，不同的切片可以指向同一个底层数组，操纵同一个底层数组。</li></ol><p><strong>需要注意的几点</strong></p><ol><li><p>传递切片作为函数参数，其实拷贝的是切片这个结构体，会产生一个新的切片结构体实例，指向同一个底层数组。虽然也会改变底层数组得值，但是对于原来的切片来说，是没有任何变化的，只是对应的底层数组中某些元素的值变了。</p></li><li><p>切片进行append扩容的时候，会产生新的切片地址，所以要将append函数返回的值重新赋给切片</p></li><li><p>Go1.18不再以1024为临界点，而是设定了一个值为256的threshold，以256为临界点；超过256，不再是每次扩容1/4，而是每次增加（旧容量+3256）/4；</p></li></ol><ul><li>当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容；</li><li>当原 slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的 2 倍；</li><li>当原 slice 容量 &gt; threshold，进入一个循环，每次容量增加（旧容量+3threshold）/4。</li></ul><ol start="4"><li>需要注意切片是对数组的引用, 所以当切片被赋值给别的切片变量时, 改变新的切片变量中的值, 会连带改变原切片值</li></ol><h2 id="2-读已经关闭的channel发生什么"><a href="#2-读已经关闭的channel发生什么" class="headerlink" title="2.读已经关闭的channel发生什么"></a>2.读已经关闭的channel发生什么</h2><ol><li><p>读已关闭的channel <code>读已经关闭的channel无影响。</code></p><ul><li><p>如果在关闭前，通道内部有元素，会正确读到元素的值；</p></li><li><p>如果关闭前通道无元素，则会读取到通道内元素类型对应的零值。</p></li><li><p>若遍历通道，如果通道未关闭，读完元素后，会报死锁的错误。<code>会引发fatal error: all goroutines are asleep - deadlock!</code></p></li></ul></li><li><p>写已关闭的通道<br><code>会引发panic: send on closed channel</code></p></li><li><p>关闭已关闭的通道<br><code>会引发panic: close of closed channel</code></p></li></ol><p><strong>需要注意的几点</strong>：对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。如果我们试图关闭一个已经关闭了的通道，也会引发 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 读一个已经关闭的通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">channel &lt;- <span class="number">2</span></span><br><span class="line"><span class="built_in">close</span>(channel)</span><br><span class="line">x := &lt;-channel</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[Output]: 不会报错，输出2*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历读关闭通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">channel &lt;- <span class="number">2</span></span><br><span class="line">channel &lt;- <span class="number">3</span></span><br><span class="line"><span class="built_in">close</span>(channel) <span class="comment">//若不关闭通道，则会报死锁错误</span></span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> channel &#123;</span><br><span class="line">fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[Output]: 不会报错，输出2 3*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 写一个已经关闭的通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[Output]: panic: send on closed channel*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 关闭一个已经关闭的管道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[Output]: panic: close of closed channel */</span></span><br></pre></td></tr></table></figure><h2 id="3-Go是如何实现继承的"><a href="#3-Go是如何实现继承的" class="headerlink" title="3.Go是如何实现继承的"></a>3.Go是如何实现继承的</h2><p>通过struct的组合实现的继承</p><h2 id="13-map取一个key，修改这个key，原map会更改吗【会，是引用类型】"><a href="#13-map取一个key，修改这个key，原map会更改吗【会，是引用类型】" class="headerlink" title="13.map取一个key，修改这个key，原map会更改吗【会，是引用类型】"></a>13.map取一个key，修改这个key，原map会更改吗【会，是引用类型】</h2><p>从map中取出一个值并对其进行修改时，原始的map也会受到影响，因为map是引用类型，它们在底层是指向相同的数据结构的指针</p><ul><li><p>引用类型：map slice channel interface</p></li><li><p>【*不可以边遍历边修改元素】</p></li></ul><h2 id="16-struct能否-比较【可以】，成员里有struct呢？【可以】"><a href="#16-struct能否-比较【可以】，成员里有struct呢？【可以】" class="headerlink" title="16. struct能否==比较【可以】，成员里有struct呢？【可以】"></a>16. struct能否==比较【可以】，成员里有struct呢？【可以】</h2><ol><li>但是只能1.相同类型结构体，2.成员结构相同并且都是可比较类型</li><li>但切片、映射和函数等类型无法比较<h2 id="25-go的深浅拷贝"><a href="#25-go的深浅拷贝" class="headerlink" title="25. go的深浅拷贝"></a>25. go的深浅拷贝</h2></li><li>浅拷贝: <code>person1 := person2</code> ，拷贝后的数据是原来数据的引用，更改后原来的也会改</li><li>深拷贝: <code>person3 := Person{name : person1.name}</code>，独立的对象<h2 id="29-如何判断channel是否关闭"><a href="#29-如何判断channel是否关闭" class="headerlink" title="29. 如何判断channel是否关闭"></a>29. 如何判断channel是否关闭</h2></li><li>_, ok := &lt;- mych</li></ol><h2 id="30-make-和-new-的区别"><a href="#30-make-和-new-的区别" class="headerlink" title="30. make 和 new 的区别"></a>30. make 和 new 的区别</h2><ul><li>make创建、初始化引用类型</li><li>new返回的是一个类型的指针，只有创建没有初始化，可以用于任何数据<h2 id="31-Slice的append"><a href="#31-Slice的append" class="headerlink" title="31. Slice的append"></a>31. Slice的append</h2>扩容，每次达到阈值会扩容大改 1/4<h2 id="44-goroutine获取不到锁会一直等待吗【当然会】"><a href="#44-goroutine获取不到锁会一直等待吗【当然会】" class="headerlink" title="44. goroutine获取不到锁会一直等待吗【当然会】"></a>44. goroutine获取不到锁会一直等待吗【当然会】</h2><h2 id="58-空结构体用来干嘛【占位符，某个集合的存在性检查】"><a href="#58-空结构体用来干嘛【占位符，某个集合的存在性检查】" class="headerlink" title="58. 空结构体用来干嘛【占位符，某个集合的存在性检查】"></a>58. 空结构体用来干嘛【占位符，某个集合的存在性检查】</h2><h2 id="60-defer用来干什么【释放锁，关协程，关channel，文件，recover-panic】"><a href="#60-defer用来干什么【释放锁，关协程，关channel，文件，recover-panic】" class="headerlink" title="60. defer用来干什么【释放锁，关协程，关channel，文件，recover panic】"></a>60. defer用来干什么【释放锁，关协程，关channel，文件，recover panic】</h2><h2 id="61-context包的作用【并发安全】"><a href="#61-context包的作用【并发安全】" class="headerlink" title="61. context包的作用【并发安全】"></a>61. context包的作用【并发安全】</h2></li></ul><p><strong>处理网络请求和并发任务时常用</strong>，处理请求范围内的值传递、取消和超时等问题，</p><ol><li>并发安全，可以在多个goroutine中共享</li><li>传递信号给goroutine，进行管理</li><li>传递请求范围内的值</li></ol><h2 id="64-panic如何恢复"><a href="#64-panic如何恢复" class="headerlink" title="64. panic如何恢复"></a>64. panic如何恢复</h2><ol><li>当程序遇到一个 panic，它会立即停止当前函数的执行，并沿着调用栈一直向上传播，直到到达 recover 所在的延迟函数。</li><li>如果在defer 中调用了 recover，它会停止 panic 的传播并返回 panic 的值。</li><li>如果没有发生 panic，recover 会返回 nil<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Recovered:"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 引发 panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"something went wrong"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="【多协程】"><a href="#【多协程】" class="headerlink" title="【多协程】"></a>【多协程】</h2><ol><li>子协程A的panic，B能否捕获到？【不可以，但是对其他协程不影响】</li><li>主协程能捕获子协程吗【也不能，因为只有协程自己内部的 recover 才能捕获自己抛出的 panic】</li></ol><h2 id="70-go的init函数何时执行的"><a href="#70-go的init函数何时执行的" class="headerlink" title="70. go的init函数何时执行的"></a>70. go的init函数何时执行的</h2><ul><li>导包初始化的时候执行，多个init时，都会执行</li><li>一个文件里有多个init时，根据包的导入关系决定</li><li>在包内有多个init，init执行顺序，golang没有明确定义，字典序？<h2 id="72-Gin的路由如何实现【压缩版的前缀树路由，httprouter库】"><a href="#72-Gin的路由如何实现【压缩版的前缀树路由，httprouter库】" class="headerlink" title="72. Gin的路由如何实现【压缩版的前缀树路由，httprouter库】"></a>72. Gin的路由如何实现【压缩版的前缀树路由，httprouter库】</h2></li></ul><h2 id="74-struct的传递场景：大struct避免复制，用浅拷贝"><a href="#74-struct的传递场景：大struct避免复制，用浅拷贝" class="headerlink" title="74. struct的传递场景：大struct避免复制，用浅拷贝"></a>74. struct的传递场景：大struct避免复制，用浅拷贝</h2><h2 id="79-sync-Pool-对象池用来干嘛的，应用场景如何"><a href="#79-sync-Pool-对象池用来干嘛的，应用场景如何" class="headerlink" title="79. sync.Pool 对象池用来干嘛的，应用场景如何"></a>79. sync.Pool 对象池用来干嘛的，应用场景如何</h2><ul><li>它用于存储和复用临时对象，以减少内存分配和垃圾回收的开销。</li><li>适用于需要频繁创建和销毁对象的场景<ul><li>一些高并发场景，频繁创建和销毁一些对象</li><li>协程池，数据库连接池，http连接池</li><li>临时缓冲区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原理如下</span><br><span class="line">1. 每个 sync.Pool 实例内部维护了两个 interface&#123;&#125; 类型的字段，一个用于存储临时对象（私有私有的 local 对象池），另一个用于存储共享对象（共享的 shared 对象池）。</span><br><span class="line">2. 当你调用 pool.Get() 方法时，sync.Pool 会首先尝试从当前 Goroutine 的私有对象池 local 中获取一个对象。</span><br><span class="line">3. 如果 local 中没有可用的对象，它会转而尝试从共享对象池 shared 中获取一个对象。</span><br><span class="line">4. 如果 shared 中也没有可用的对象，它会调用 New 函数创建一个新的对象。</span><br><span class="line">5. 当你调用 pool.Put(obj) 方法时，对象会被放回到当前 Goroutine 的私有对象池 local 中。</span><br><span class="line">6. 如果私有对象池 local 已满，或者对象过期，那么该对象会被丢弃。</span><br><span class="line">这个机制保证了对象会在同一个 Goroutine 中被复用，从而减少了对象的创建和垃圾回收的开销。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="sync-pool怎么实现的"><a href="#sync-pool怎么实现的" class="headerlink" title="sync.pool怎么实现的"></a>sync.pool怎么实现的</h3><p>私有对象池和共享对象池+互斥锁保证线程安全,通过get和put</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">    private <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    shared  []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">M sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="83-变量申请类型是为了做什么"><a href="#83-变量申请类型是为了做什么" class="headerlink" title="83. 变量申请类型是为了做什么"></a>83. 变量申请类型是为了做什么</h2><p>类型就是根据不同的数据类型可以存储不同的数据，所以需要申请对应类型地址<br>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请</p><h2 id="88-Go的GC机制介绍一下"><a href="#88-Go的GC机制介绍一下" class="headerlink" title="88. Go的GC机制介绍一下"></a>88. Go的GC机制介绍一下</h2><h2 id="84-Go和Java的GC机制有什么区别"><a href="#84-Go和Java的GC机制有什么区别" class="headerlink" title="84. Go和Java的GC机制有什么区别"></a>84. Go和Java的GC机制有什么区别</h2><ul><li>目前主流的Java虚拟机实现都采用了分代垃圾回收的思想，堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收，年老代主要使用标记-整理垃圾回收算法</li><li>然后go的垃圾回收是混合写屏障机制，stw的时间更短，1.3用的标记清除，1.5改为用三色标记，但是还需要stw扫描栈所以就演进为混合写屏障，栈上新增对象都为黑色，暂时活过这一轮，然后删除的对象为灰色或者白色，节点都会变为灰色，黑色节点下新增节点都为灰色</li><li>java语言中选择了可达性分析进行对象存活判断，而不是引用计数，主要也是因为java中软引用、弱引用、虚引用等多种引用方式使用引用计数并不能进行有效的存活判断，同时为了避免循环引用的问题，所以java选择了可达性分析的方式进行对象存活判断。</li><li>在java中触发垃圾回收的条件是：<ul><li>cpu空闲的时候；</li><li>在堆栈满了的时候；</li><li>主动调用 System.gc() 后尝试进行回收；</li></ul></li></ul><p><strong>Go的gc最佳应用场景是自身的分配行为不容易导致碎片堆积，并且程序分配新对象的速度不太高的情况，这种情况下go的垃圾回收比java更高效。相反的，当对象分配速度高时，java的gc的优势就会明显体现</strong></p><h2 id="102-什么时候触发线程切换"><a href="#102-什么时候触发线程切换" class="headerlink" title="102. 什么时候触发线程切换"></a>102. 什么时候触发线程切换</h2><ol><li>阻塞</li><li>时间片用完</li><li>显式调用 runtime.Gosched():主动让出当前 Goroutine 的执行权限，让调度器选择另一个可运行的 Goroutine 执行</li><li>互斥锁</li><li>等待组 sync.WaitGroup()<h2 id="107-http库的设计原理是什么？为什么不池化？"><a href="#107-http库的设计原理是什么？为什么不池化？" class="headerlink" title="107. http库的设计原理是什么？为什么不池化？"></a>107. http库的设计原理是什么？为什么不池化？</h2>采用的是连接池：http 包会自动维护一个连接池，用于复用 TCP 连接，从而提升性能。</li></ol><ul><li>不池化的原因：处理的对象不一样，场景也不一样<ul><li>对象池管理创建、销毁常用对象，减少gc压力</li><li>连接池是复用连接，减少资源分配的开销，连接池中的资源通常会被长时间地重复使用，而对象池中的对象可能在短时间内就会被释放</li></ul></li></ul><h2 id="110-关闭一个已关闭的channel会发生什么？【panic】"><a href="#110-关闭一个已关闭的channel会发生什么？【panic】" class="headerlink" title="110. 关闭一个已关闭的channel会发生什么？【panic】"></a>110. 关闭一个已关闭的channel会发生什么？【panic】</h2><h2 id="110-238-有缓存channel和没缓存channel的区别是什么？"><a href="#110-238-有缓存channel和没缓存channel的区别是什么？" class="headerlink" title="110/238. 有缓存channel和没缓存channel的区别是什么？"></a>110/238. 有缓存channel和没缓存channel的区别是什么？</h2><p>无缓冲的与有缓冲 channel 有着重大差别，那就是一个是同步的 一个是非同步的</p><h2 id="116-138-类型断言"><a href="#116-138-类型断言" class="headerlink" title="116/138. 类型断言"></a>116/138. 类型断言</h2><ul><li><code>t := i.(T)</code>，这个表达式可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回值给 t，如果断言失败，就会触发 panic</li><li><code>t, ok:= i.(T)</code>，这个表达式也是可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回其类型给 t，并且此时 ok 的值 为 true，表示断言成功。这个不会触发 panic，而是将 ok 的值设为 false ，表示断言失败，此时t 为 T 的零值。<h2 id="8-channel的实现方式-原理-概念-底层实现"><a href="#8-channel的实现方式-原理-概念-底层实现" class="headerlink" title="8.channel的实现方式/原理/概念/底层实现"></a>8.channel的实现方式/原理/概念/底层实现</h2></li></ul><h2 id="117-实现一种等待或者监听的机制【使用select-channel，或者time-sleep】"><a href="#117-实现一种等待或者监听的机制【使用select-channel，或者time-sleep】" class="headerlink" title="117. 实现一种等待或者监听的机制【使用select channel，或者time.sleep】"></a>117. 实现一种等待或者监听的机制【使用select channel，或者time.sleep】</h2><h2 id="118-sleep的底层实现？slice的append返回一个新切片会发生什么"><a href="#118-sleep的底层实现？slice的append返回一个新切片会发生什么" class="headerlink" title="118. sleep的底层实现？slice的append返回一个新切片会发生什么"></a>118. sleep的底层实现？slice的append返回一个新切片会发生什么</h2><ul><li>append不超threshold，底层引用的数组还是原来的地址</li><li>超过了的话，原来的和新的都会指向新数组</li></ul><h2 id="120-137-291-interface的底层实现"><a href="#120-137-291-interface的底层实现" class="headerlink" title="120/137/291. interface的底层实现"></a>120/137/291. interface的底层实现</h2><ul><li>带有方法的interface，一种是不带方法的interface</li><li>任何一个interface变量都是占用16个byte的内存空间</li><li>第一个字段 _type指针，指向数据类型，runtime中的每个数据类型都包含一个这样的字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有方法的interface</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type <span class="comment">//重要字段，记录着某种数据类型的一些基本特征，比如这个数据类型占用的内存大小（size字段），数据类型的名称（nameOff字段）等等</span></span><br><span class="line">    <span class="comment">// 每种数据类型都存在一个与之对应的_type结构体</span></span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有方法的interface</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录着Go语言中某个数据类型的基本特征</span></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size    <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata  <span class="keyword">uintptr</span></span><br><span class="line">    hash    <span class="keyword">uint32</span></span><br><span class="line">    tflag   tflag</span><br><span class="line">    align   <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    kind    <span class="keyword">uint8</span></span><br><span class="line">    alg    *typeAlg</span><br><span class="line">    gcdata  *<span class="keyword">byte</span></span><br><span class="line">    str    nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type <span class="comment">//重要</span></span><br><span class="line">    link  *itab</span><br><span class="line">    hash  <span class="keyword">uint32</span></span><br><span class="line">    bad  <span class="keyword">bool</span></span><br><span class="line">    inhash <span class="keyword">bool</span></span><br><span class="line">    unused [<span class="number">2</span>]<span class="keyword">byte</span></span><br><span class="line">    fun  [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// interface数据类型对应的type</span></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ   _type</span><br><span class="line">    pkgpath name</span><br><span class="line">    mhdr  []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="404-defer的底层实现"><a href="#404-defer的底层实现" class="headerlink" title="404. defer的底层实现"></a>404. defer的底层实现</h2><h2 id="160-string的底层实现"><a href="#160-string的底层实现" class="headerlink" title="160. string的底层实现"></a>160. string的底层实现</h2><h2 id="121-STW-在-go-的哪些阶段发生？1-8的改进是什么【混合写】"><a href="#121-STW-在-go-的哪些阶段发生？1-8的改进是什么【混合写】" class="headerlink" title="121. STW 在 go 的哪些阶段发生？1.8的改进是什么【混合写】"></a>121. STW 在 go 的哪些阶段发生？1.8的改进是什么【混合写】</h2><p>标记和清理阶段都会发生</p><h2 id="132-如何避免panic"><a href="#132-如何避免panic" class="headerlink" title="132. 如何避免panic"></a>132. 如何避免panic</h2><h2 id="133-结构体对齐优化"><a href="#133-结构体对齐优化" class="headerlink" title="133. 结构体对齐优化"></a>133. 结构体对齐优化</h2><p>内存对齐:CPU访问内存时，通过字来访问，一个字在32位cpu中4个字节，所以对于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> demo&#123;</span><br><span class="line">    a <span class="keyword">int8</span> <span class="comment">//1</span></span><br><span class="line">    b <span class="keyword">int32</span><span class="comment">//4</span></span><br><span class="line">    c <span class="keyword">int16</span> <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">会变成 <span class="number">1</span>+<span class="number">3</span> + <span class="number">2</span>+<span class="number">2</span> + <span class="number">4</span> 字节，而下面会变成 <span class="number">3</span>+<span class="number">1</span> + <span class="number">4</span></span><br><span class="line"><span class="keyword">struct</span> demo&#123;</span><br><span class="line">    a <span class="keyword">int8</span> <span class="comment">//1</span></span><br><span class="line">    b <span class="keyword">int16</span><span class="comment">//2</span></span><br><span class="line">    c <span class="keyword">int32</span><span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="244-go实现func自定义参数"><a href="#244-go实现func自定义参数" class="headerlink" title="244. go实现func自定义参数"></a>244. go实现func自定义参数</h2><p><code>type myFunc func(int) int</code></p><h2 id="252-copy是操作符还是内置函数【内置函数，深拷贝】"><a href="#252-copy是操作符还是内置函数【内置函数，深拷贝】" class="headerlink" title="252. copy是操作符还是内置函数【内置函数，深拷贝】"></a>252. copy是操作符还是内置函数【内置函数，深拷贝】</h2><h2 id="290-解释一下Go的通信机制"><a href="#290-解释一下Go的通信机制" class="headerlink" title="290. 解释一下Go的通信机制"></a>290. 解释一下Go的通信机制</h2><p>是通过channel实现的，chan定义实现了<strong>环形队列</strong>，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序，这一点和管道是一样的；chan在实现时定义了:</p><ul><li>指针</li><li>环形队列</li><li>(阻塞)协程链表<br>来控制通信，当chan满足条件时，通过指针sendx 、recvx 进行读写数据。</li></ul><h2 id="296-slice函数传参，先赋值再append与先append再赋值，哪个发生了改变【先赋值的改变了，因为先append的地址发生了改变】"><a href="#296-slice函数传参，先赋值再append与先append再赋值，哪个发生了改变【先赋值的改变了，因为先append的地址发生了改变】" class="headerlink" title="296. slice函数传参，先赋值再append与先append再赋值，哪个发生了改变【先赋值的改变了，因为先append的地址发生了改变】"></a>296. slice函数传参，先赋值再append与先append再赋值，哪个发生了改变【先赋值的改变了，因为先append的地址发生了改变】</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendThenAssign</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assignThenAppend</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">appendThenAssign(arr)</span><br><span class="line"><span class="comment">//print arr: 1 2</span></span><br><span class="line">assignThenAppend(arr)</span><br><span class="line"><span class="comment">//print arr: 99 2</span></span><br></pre></td></tr></table></figure><h2 id="297-有没有什么线程安全的办法？"><a href="#297-有没有什么线程安全的办法？" class="headerlink" title="297. 有没有什么线程安全的办法？"></a>297. 有没有什么线程安全的办法？</h2><p>互斥锁<br>信号量，条件变量<br>原子操作<br>线程安全的库</p><h2 id="golang-http包的内存泄漏情况"><a href="#golang-http包的内存泄漏情况" class="headerlink" title="golang http包的内存泄漏情况"></a>golang http包的内存泄漏情况</h2><ol><li>忘记关闭response的 body</li><li>忘记释放连接，或者一直创建连接，没有有效复用的情况？</li></ol><h2 id="306-go-map的时间复杂度"><a href="#306-go-map的时间复杂度" class="headerlink" title="306. go map的时间复杂度"></a>306. go map的时间复杂度</h2><h2 id="307-go由源码变二进制代码的整个流程"><a href="#307-go由源码变二进制代码的整个流程" class="headerlink" title="307. go由源码变二进制代码的整个流程"></a>307. go由源码变二进制代码的整个流程</h2><h2 id="309-select-poll-epoll"><a href="#309-select-poll-epoll" class="headerlink" title="309. select poll epoll"></a>309. select poll epoll</h2><h2 id="314-make底层原理"><a href="#314-make底层原理" class="headerlink" title="314. make底层原理"></a>314. make底层原理</h2><h2 id="315-string-强转-byte-发生了什么"><a href="#315-string-强转-byte-发生了什么" class="headerlink" title="315. string 强转 []byte 发生了什么"></a>315. string 强转 []byte 发生了什么</h2><p>底层的不可变字符数组拷贝到byte类型的内存，然后原来的内存被gc掉</p><h2 id="335-411-go的包管理工具除了go-mod还有什么"><a href="#335-411-go的包管理工具除了go-mod还有什么" class="headerlink" title="335/411. go的包管理工具除了go mod还有什么"></a>335/411. go的包管理工具除了go mod还有什么</h2><ul><li>go mod能下载和管理指定版本的库，实现高效的模块化开发，和管理依赖关系的功能</li><li>go sum干什么的：提供了安全机制<ul><li>块路径：列出了项目中所使用的所有直接依赖模块的路径。</li><li>版本号：对应每个模块的版本号。</li><li>哈希值：对应每个模块版本的哈希值，用于确保模块的<strong>代码完整性</strong>。<h2 id="356-介绍一下go的反射"><a href="#356-介绍一下go的反射" class="headerlink" title="356. 介绍一下go的反射"></a>356. 介绍一下go的反射</h2>typeof和valueof来实现，每个类型，包括符合类型都维护了一个type和value区域</li></ul></li></ul><h2 id="396-go的-oop-面向对象与传统面向对象的区别"><a href="#396-go的-oop-面向对象与传统面向对象的区别" class="headerlink" title="396. go的 oop 面向对象与传统面向对象的区别"></a>396. go的 oop 面向对象与传统面向对象的区别</h2><p>go是用结构体定义对象，然后通过组合实现继承，对于多态来说，go强调接口的使用</p><h2 id="397-go里面interface对于java的接口和c-的虚函数区别在哪"><a href="#397-go里面interface对于java的接口和c-的虚函数区别在哪" class="headerlink" title="397. go里面interface对于java的接口和c++的虚函数区别在哪"></a>397. go里面interface对于java的接口和c++的虚函数区别在哪</h2><ul><li>Go 接口是隐式实现的，一个类型只要实现了接口中的所有方法，就被认为是实现了该接口，无需显式声明。这种方式让 Go 具有了更大的灵活性。</li><li>Go 倾向于使用接口和返回错误值的方式来处理错误，而不是像 Java 或者 C++ 中那样使用异常</li></ul><h2 id="402-Go-runtime的程序计数器，为什么是私有的（为什么程序猿不能操作）"><a href="#402-Go-runtime的程序计数器，为什么是私有的（为什么程序猿不能操作）" class="headerlink" title="402. Go runtime的程序计数器，为什么是私有的（为什么程序猿不能操作）"></a>402. Go runtime的程序计数器，为什么是私有的（为什么程序猿不能操作）</h2><ul><li><p>在 Go 的 runtime 中，程序计数器用于跟踪当前 Goroutine 正在执行的代码位置，从而支持 Goroutine 的并发执行。</p></li><li><p>在单线程情况下，程序计数器会指向当前 Goroutine 执行的代码块。当发生 Goroutine 切换时，程序计数器的值会保存到当前 Goroutine 的上下文中，然后加载新 Goroutine 的上下文中的程序计数器值，以便从上次中断的地方继续执行。</p></li><li><p>避免混乱，保护Groutine在并发环境下的完整性</p></li></ul><h2 id="423-interface和nil可以比较吗【可以】"><a href="#423-interface和nil可以比较吗【可以】" class="headerlink" title="423. interface和nil可以比较吗【可以】"></a>423. interface和nil可以比较吗【可以】</h2><p>但是必须要类型和值都相同</p><ul><li>果接口变量的动态值和动态类型同时都为 nil，那么接口变量将与 nil 比较相等。</li><li>如果类型和值有一个不为nil，那么就是不相等</li></ul><h2 id="447-struct组合与java继承有什么区别"><a href="#447-struct组合与java继承有什么区别" class="headerlink" title="447. struct组合与java继承有什么区别"></a>447. struct组合与java继承有什么区别</h2><ul><li>相同点是，都是静态语言，在编译期实现</li><li>go组合支持多继承，java需要extends 父类来继承，只能继承一个</li></ul><h2 id="448-go的强制类型转换与隐式类型转换"><a href="#448-go的强制类型转换与隐式类型转换" class="headerlink" title="448. go的强制类型转换与隐式类型转换"></a>448. go的强制类型转换与隐式类型转换</h2><p>Go 支持两种类型转换：</p><ul><li><code>var a int = 10，var b float64 = float64(a)</code> 将整数 a 转换为浮点数。</li><li>在算术表达式中，如果操作符两侧的类型不一致，Go 会自动将其中一个值转换为与另一个值相同的类型。</li></ul><h2 id="451-多个interface间可以存在什么关系"><a href="#451-多个interface间可以存在什么关系" class="headerlink" title="451. 多个interface间可以存在什么关系"></a>451. 多个interface间可以存在什么关系</h2><p>组合，嵌套都可以</p><ul><li>一个接口可以嵌套在另一个接口内部，这种情况下，外部接口会继承内部接口的所有方法</li><li>一个接口可以由多个其他接口组合而成，组合后的接口将具有所有组成接口的方法<h2 id="510-go方法和函数的区别"><a href="#510-go方法和函数的区别" class="headerlink" title="510. go方法和函数的区别"></a>510. go方法和函数的区别</h2>方法是定义了 Receiver 的函数，分为receiver</li><li>Value Receiver，不会修改receiver的内容</li><li>Pointer Receiver，会修改receiver的内容</li></ul><h2 id="512-Go函数返回局部变量的指针是否安全【安全，发生内存逃逸，监测到没使用的时候就GC掉】"><a href="#512-Go函数返回局部变量的指针是否安全【安全，发生内存逃逸，监测到没使用的时候就GC掉】" class="headerlink" title="512. Go函数返回局部变量的指针是否安全【安全，发生内存逃逸，监测到没使用的时候就GC掉】"></a>512. Go函数返回局部变量的指针是否安全【安全，发生内存逃逸，监测到没使用的时候就GC掉】</h2><h2 id="5-Go的GMP模型"><a href="#5-Go的GMP模型" class="headerlink" title="5.Go的GMP模型"></a>5.Go的GMP模型</h2><h2 id="6-Go和Java相比"><a href="#6-Go和Java相比" class="headerlink" title="6.Go和Java相比"></a>6.Go和Java相比</h2><h2 id="9-同一个goroutine里面，对无缓冲channel同时发送和接收数据有什么问题"><a href="#9-同一个goroutine里面，对无缓冲channel同时发送和接收数据有什么问题" class="headerlink" title="9.同一个goroutine里面，对无缓冲channel同时发送和接收数据有什么问题"></a>9.同一个goroutine里面，对无缓冲channel同时发送和接收数据有什么问题</h2><p>导致死锁</p><h2 id="10-channel和锁的对比"><a href="#10-channel和锁的对比" class="headerlink" title="10.channel和锁的对比"></a>10.channel和锁的对比</h2><h2 id="11-channel的应用场景"><a href="#11-channel的应用场景" class="headerlink" title="11.channel的应用场景"></a>11.channel的应用场景</h2><h2 id="12"><a href="#12" class="headerlink" title="12."></a>12.</h2><h2 id="227-go实现一个链表"><a href="#227-go实现一个链表" class="headerlink" title="227. go实现一个链表"></a>227. go实现一个链表</h2><h2 id="289-写一个将字符串json转成一个可用的map的函数，json的value类型可能不定"><a href="#289-写一个将字符串json转成一个可用的map的函数，json的value类型可能不定" class="headerlink" title="289. 写一个将字符串json转成一个可用的map的函数，json的value类型可能不定"></a>289. 写一个将字符串json转成一个可用的map的函数，json的value类型可能不定</h2><h1 id="Slice专题"><a href="#Slice专题" class="headerlink" title="Slice专题"></a>Slice专题</h1><h2 id="455-内置cap函数可以用于？【arrary-slice-channel】的capability计算"><a href="#455-内置cap函数可以用于？【arrary-slice-channel】的capability计算" class="headerlink" title="455. 内置cap函数可以用于？【arrary slice channel】的capability计算"></a>455. 内置cap函数可以用于？【arrary slice channel】的capability计算</h2><p>为什么map不能用cap来计算：</p><ul><li>map因为有bucket，在内存存放的大小可能不和make出来的大小一致。是编译器计算后的结果，</li></ul><h2 id="463-切片扩容机制"><a href="#463-切片扩容机制" class="headerlink" title="463. 切片扩容机制"></a>463. 切片扩容机制</h2><p><strong>扩容是为切片分配新的内存空间并复制原切片中元素的过程。</strong><br>先确定新的切片大致容量而分配内存空间，根据该切片当前容量选择不同的策略：<br>【旧】</p><ul><li>如果期望容量大于当前容量的两倍，就会使用期望容量</li><li>如果当前切片的长度小于 1024，容量就会翻倍</li><li>如果当前切片的长达大于 1024，每次扩容 25% 的容量，直到新容量大于期望容量。</li></ul><p>roundupsize 函数来确定待申请的内存，该函数会从一个数组中获取整数，使用这个数组中的元素可以提高内存分配效率并减少碎片，这个数组叫做 NumSizeClasses 。</p><h2 id="520-Slice为什么不是线程安全的"><a href="#520-Slice为什么不是线程安全的" class="headerlink" title="520. Slice为什么不是线程安全的"></a>520. Slice为什么不是线程安全的</h2><p>因为他是引用类型，其他指针可以同时指向底层数组，而且没有同步的措施</p><h2 id="443-slice底层，内存泄漏分析"><a href="#443-slice底层，内存泄漏分析" class="headerlink" title="443. slice底层，内存泄漏分析"></a>443. slice底层，内存泄漏分析</h2><p>1）发生场景：截取长slice中的一段导致长slice未释放。</p><p>由于底层都是数组，如果截图长slice的一段，其实相当于引用了底层数组中的一小段。只要还有引用，golang的gc就不能回收数组。这种情况导致未使用的数组空间，未及时回收。</p><p>​<strong>解决方案</strong>：新建一个长度为0的slice，将需要的一小段slice使用append方法添加到新的slice。再将原来的slice置为nil。</p><p>2）发生场景：没有重置丢失的子切片元素中的指针</p><p>没有及时将不再使用的slice置为nil</p><p>​<strong>解决方案</strong>：如果slice中包含很多元素，再只有一小部分元素需要使用的情况下。建议重新分配一个slice将需要保留的元素加入其中，将原来的长slice整个置为nil。</p><h1 id="Map专题"><a href="#Map专题" class="headerlink" title="Map专题"></a>Map专题</h1><h2 id="32-如何实现一个线程安全的map"><a href="#32-如何实现一个线程安全的map" class="headerlink" title="32. 如何实现一个线程安全的map"></a>32. 如何实现一个线程安全的map</h2><p><a href="https://github.com/guowei-gong/go-demo/blob/main/mutex/demo.go" target="_blank" rel="noopener">https://github.com/guowei-gong/go-demo/blob/main/mutex/demo.go</a></p><ol><li>加读写锁</li><li>分片加锁</li><li>sync.Map（很少用）<ul><li>场景一：只会增长的缓存系统，一个 key 值写入一次而被读很多次；</li><li>场景二：多个 goroutine 为不相交的键读、写和重写键值对。</li></ul></li><li>channel做串行访问:通过将 map 的读写操作发送到一个单独的 Goroutine 中，使得对 map 的访问变成串行的，从而避免了竞态条件。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">read</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    ch &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result = m[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(key, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m[key] = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    value := read(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">println</span>(value) <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="34-Map的底层实现"><a href="#34-Map的底层实现" class="headerlink" title="34. Map的底层实现"></a>34. Map的底层实现</h2><p><strong>使用Hash表和搜索树作为底层实现</strong>,底层是一个hmap和一个bmap</p><ul><li>bmap被称之为“桶”。<strong>一个桶里面会最多装 8 个 key</strong>，key 经过哈希计算后，哈希结果是“一类”的将会落入到同一个桶中。在桶内，会根据key计算出来的hash值的高 8 位来决定key到底落入桶内的哪个位置。</li><li>这也是为什么map无法使用cap()来求容量的关键原因：map的容量是编译器进行计算后得出的一个结果，由于桶的存在，map在内存中实际存放的大小不一定同make出来后的map的大小一致。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count      <span class="keyword">int</span>            <span class="comment">//元素个数，调用len(map)时直接返回</span></span><br><span class="line">    flags      <span class="keyword">uint8</span>          <span class="comment">//标志map当前状态,正在删除元素、添加元素.....</span></span><br><span class="line">    B          <span class="keyword">uint8</span>          <span class="comment">//单元(buckets)的对数 B=5表示能容纳32个元素</span></span><br><span class="line">    noverflow  <span class="keyword">uint16</span>        <span class="comment">//单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元</span></span><br><span class="line">    hash0      <span class="keyword">uint32</span>         <span class="comment">//哈希种子</span></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">//指向单元(buckets)数组,大小为2^B，可以为nil</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">//扩容的时候，buckets长度会是oldbuckets的两倍</span></span><br><span class="line">    nevacute   <span class="keyword">uintptr</span>        <span class="comment">//指示扩容进度，小于此buckets迁移完成</span></span><br><span class="line">    extra      *mapextra      <span class="comment">//与gc相关 可选字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实际上编译期间会生成一个新的数据结构</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/gomapbuckets.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="36-map的key可以是哪些类型，可以是nil吗？nil不可以，嵌套不可以"><a href="#36-map的key可以是哪些类型，可以是nil吗？nil不可以，嵌套不可以" class="headerlink" title="36. map的key可以是哪些类型，可以是nil吗？nil不可以，嵌套不可以"></a>36. map的key可以是哪些类型，可以是nil吗？nil不可以，嵌套不可以</h2><ul><li>可以作为 map 的键的类型必须<strong>满足相等性比较的条件</strong>，包括基本数据类型和一些自定义类型，string必然可以</li><li>不可以做key的类型：切片，函数，包含切片和函数的符合类型</li></ul><h2 id="36-struct-interface-nil可以做map的key吗"><a href="#36-struct-interface-nil可以做map的key吗" class="headerlink" title="36. struct{} interface{} nil可以做map的key吗"></a>36. struct{} interface{} nil可以做map的key吗</h2><ul><li>nil不可以，其他的可以</li><li>struct{} 以值的字面量形式去比较</li><li>interface{} 以动态类型去比较</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">m[<span class="string">"string"</span>] = <span class="number">20</span></span><br><span class="line">m[<span class="number">3.14</span>] = <span class="number">30</span></span><br><span class="line">fmt.Println(m[<span class="number">1</span>])       <span class="comment">// 输出 10</span></span><br><span class="line">fmt.Println(m[<span class="string">"string"</span>]) <span class="comment">// 输出 20</span></span><br><span class="line">fmt.Println(m[<span class="number">3.14</span>])    <span class="comment">// 输出 30</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">struct</span>&#123;&#125;]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">key1 := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">key2 := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">m[key1] = <span class="number">10</span></span><br><span class="line">m[key2] = <span class="number">20</span></span><br><span class="line">fmt.Println(m[key1]) <span class="comment">// 输出 10</span></span><br><span class="line">fmt.Println(m[key2]) <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure><h2 id="251-sync-Map-怎么解决线程安全问题？源码看过吗"><a href="#251-sync-Map-怎么解决线程安全问题？源码看过吗" class="headerlink" title="251. sync.Map 怎么解决线程安全问题？源码看过吗"></a>251. sync.Map 怎么解决线程安全问题？源码看过吗</h2><p>支持并发读写，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty. </p><ul><li><p>优点是读多写少场景下使用，比如只会增长的缓存</p></li><li><p>缺点是写多场景下，导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</p></li><li><p>和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line">    read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">    dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="275-map的分段锁拆了几个分片？"><a href="#275-map的分段锁拆了几个分片？" class="headerlink" title="275 map的分段锁拆了几个分片？"></a>275 map的分段锁拆了几个分片？</h2><h2 id="379-如果一个map没申请空间，去向里面取值【发生panic】"><a href="#379-如果一个map没申请空间，去向里面取值【发生panic】" class="headerlink" title="379. 如果一个map没申请空间，去向里面取值【发生panic】"></a>379. 如果一个map没申请空间，去向里面取值【发生panic】</h2><p>一般用的时候就给他make一个stuct{}{}空类型</p><h2 id="407-map取一个key，然后修改这个值，原来的数据会发生变化吗？【会】引用类型"><a href="#407-map取一个key，然后修改这个值，原来的数据会发生变化吗？【会】引用类型" class="headerlink" title="407. map取一个key，然后修改这个值，原来的数据会发生变化吗？【会】引用类型"></a>407. map取一个key，然后修改这个值，原来的数据会发生变化吗？【会】引用类型</h2><h2 id="526-map的负载因子是多少【6-5】为什么？"><a href="#526-map的负载因子是多少【6-5】为什么？" class="headerlink" title="526. map的负载因子是多少【6.5】为什么？"></a>526. map的负载因子是多少【6.5】为什么？</h2><p>默认当 map 中的元素个数达到总容量的 65% 时，会触发扩容操作。<br>为什么？</p><h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><h2 id="9-同一个协程里面，对无缓冲channel同时进行读写会发生什么问题"><a href="#9-同一个协程里面，对无缓冲channel同时进行读写会发生什么问题" class="headerlink" title="9.同一个协程里面，对无缓冲channel同时进行读写会发生什么问题"></a>9.同一个协程里面，对无缓冲channel同时进行读写会发生什么问题</h2><p>原则上不可以这样写，会导致死锁。</p><p>对于一个无缓冲的channel而言，只有不同的协程之间一方发送数据一方接受数据才不会阻塞。channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。</p><h2 id="14-向为nil的channel发送数据会怎样【发生panic】为什么"><a href="#14-向为nil的channel发送数据会怎样【发生panic】为什么" class="headerlink" title="14.向为nil的channel发送数据会怎样【发生panic】为什么"></a>14.向为nil的channel发送数据会怎样【发生panic】为什么</h2><h2 id="连续两次close-ch-会发生panic-runtime-err"><a href="#连续两次close-ch-会发生panic-runtime-err" class="headerlink" title="连续两次close(ch)会发生panic: runtime err"></a>连续两次close(ch)会发生panic: runtime err</h2><h2 id="51-channel-线程安全吗【安全】里面有互斥锁"><a href="#51-channel-线程安全吗【安全】里面有互斥锁" class="headerlink" title="51. channel 线程安全吗【安全】里面有互斥锁"></a>51. channel 线程安全吗【安全】里面有互斥锁</h2><p><strong>互斥锁是如何起作用的</strong>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a20f10cd62284684963a3a1edd44a90e~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据。</p><h2 id="【重点】分布式session如何实现"><a href="#【重点】分布式session如何实现" class="headerlink" title="【重点】分布式session如何实现"></a>【重点】分布式session如何实现</h2><p><a href="https://juejin.cn/post/6965665934165950495" target="_blank" rel="noopener">https://juejin.cn/post/6965665934165950495</a></p><p>golang是用redis实现的，启动redis-trib.rb</p><p>spring cloud可以用原生的分布式session支持</p><h2 id="98-99-分布式锁有哪些？如何用channel实现？"><a href="#98-99-分布式锁有哪些？如何用channel实现？" class="headerlink" title="98/99. 分布式锁有哪些？如何用channel实现？"></a>98/99. 分布式锁有哪些？如何用channel实现？</h2><p><strong>基于数据库的分布式锁</strong></p><p>使用数据库的事务特性来实现分布式锁，通过在数据库中创建一个唯一索引或者唯一约束来保证锁的唯一性。</p><p><a href="https://www.cnblogs.com/paulwhw/p/17049575.html" target="_blank" rel="noopener"><strong>基于Redis的分布式锁,非阻塞的trylock</strong></a></p><p>使用 Redis 提供的 SETNX（SET if Not eXists）指令，可以在 Redis 中创建一个分布式锁。</p><p><strong>基于etcd的分布式锁，阻塞的等待lock</strong></p><p>使用 etcd 提供的分布式锁实现，可以实现分布式系统中的互斥访问。</p><p><strong>基于ZooKeeper的分布式锁</strong></p><p>使用 ZooKeeper 提供的临时有序节点和监视机制，可以实现分布式锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">lockCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>) <span class="comment">// 带缓冲的 channel，容量为1表示只能同时有一个 Goroutine 获取到锁</span></span><br><span class="line">locked = <span class="literal">false</span>                 <span class="comment">// 标记是否已经获取到锁</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireLock</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> lockCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">locked = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> locked &#123;</span><br><span class="line">&lt;-lockCh</span><br><span class="line">locked = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> acquireLock() &#123;</span><br><span class="line"><span class="keyword">defer</span> releaseLock()</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">fmt.Println(<span class="string">"Lock acquired!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Failed to acquire lock"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="174-go-里的-sync的Lock-和-channel-的性能区别"><a href="#174-go-里的-sync的Lock-和-channel-的性能区别" class="headerlink" title="174. go 里的 sync的Lock 和 channel 的性能区别"></a>174. go 里的 sync的Lock 和 channel 的性能区别</h2><h2 id="134-channel实现一个排序算法"><a href="#134-channel实现一个排序算法" class="headerlink" title="134. channel实现一个排序算法"></a>134. channel实现一个排序算法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">swapped := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">swapped = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !swapped &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// 排序完成，向通道发送信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> bubbleSort(nums[:<span class="built_in">len</span>(nums)/<span class="number">2</span>], ch) <span class="comment">// 在一个 Goroutine 中排序前半部分</span></span><br><span class="line"><span class="keyword">go</span> bubbleSort(nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>:], ch) <span class="comment">// 在另一个 Goroutine 中排序后半部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个 Goroutine 完成</span></span><br><span class="line">&lt;-ch</span><br><span class="line">&lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line">merged := merge(nums[:<span class="built_in">len</span>(nums)/<span class="number">2</span>], nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>:])</span><br><span class="line">fmt.Println(merged)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line">i, j, k := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line"><span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">result[k] = left[i]</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result[k] = right[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &#123;</span><br><span class="line">result[k] = left[i]</span><br><span class="line">i++</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">result[k] = right[j]</span><br><span class="line">j++</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="202-channel-实现一个限流器"><a href="#202-channel-实现一个限流器" class="headerlink" title="202. channel 实现一个限流器"></a>202. channel 实现一个限流器</h2><p>在每次循环中，我们先向 limiter channel 发送当前时间，如果 channel 已满（达到了最大并发数），则会阻塞等待。接着，启动一个新的协程来执行操作，当操作执行完毕后，通过匿名函数中的 defer 语句从 channel 中接收一个值，表示释放一个协程的位置。</p><h2 id="473-channel的ring-buffer"><a href="#473-channel的ring-buffer" class="headerlink" title="473. channel的ring buffer"></a>473. channel的ring buffer</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/gochannelringbuffer.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>适用FIFO，recvx 指向最早被读取的数 据，sendx 指向再次写入时插入的位置</p><h1 id="go的同步库"><a href="#go的同步库" class="headerlink" title="go的同步库"></a>go的同步库</h1><h2 id="15-sync-waitgroup的坑"><a href="#15-sync-waitgroup的坑" class="headerlink" title="15. sync.waitgroup的坑"></a>15. sync.waitgroup的坑</h2><p>① Add一个负数</p><p>如果计数器的值小于0会直接panic</p><p>② Add在Wait之后调用</p><p>比如一些子协程开头调用Add结束调用Wait，这些 Wait无法阻塞子协程。正确做法是在开启子协程之前先Add特定的值。</p><p>③ 未置为0就重用</p><p>WaitGroup可以完成一次编排任务，计数值降为0后可以继续被其他任务所用，但是不要在还没使用完的时候就用于其他任务，这样由于带着计数值，很可能出问题。</p><p>④ 复制waitgroup</p><p>WaitGroup有nocopy字段，不能被复制。也意味着WaitGroup不能作为函数的参数。</p><h2 id="18-读写锁怎么实现的"><a href="#18-读写锁怎么实现的" class="headerlink" title="18. 读写锁怎么实现的"></a>18. 读写锁怎么实现的</h2><ol><li>读写锁内部是通过互斥锁实现的,主要应用于写操作少，读操作多的场景。</li><li>goroutine获得写锁时，其他读写都会阻塞，读锁相互之间不会阻塞，当所有读锁释放后，才可以获取写锁<br>读锁可重入，写锁不可重入<br>原理：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 基于一个计数器和两个队列</span><br><span class="line">2. RLOCK WLOCK</span><br></pre></td></tr></table></figure></li></ol><h2 id="114-mutex-如何处理正常和饥饿状态？rwmutex中写操作如何处理写操作阻止读操作"><a href="#114-mutex-如何处理正常和饥饿状态？rwmutex中写操作如何处理写操作阻止读操作" class="headerlink" title="114. mutex 如何处理正常和饥饿状态？rwmutex中写操作如何处理写操作阻止读操作"></a>114. mutex 如何处理正常和饥饿状态？rwmutex中写操作如何处理写操作阻止读操作</h2><p><strong>正常模式和饥饿状态：</strong></p><ul><li>正常状态下，Mutex 的锁是公平的，当一个 Goroutine 尝试获取锁时，如果锁已经被其他 Goroutine 持有，那么它将被放入一个等待队列中，直到锁被释放。</li><li>饥饿状态指的是某些 Goroutine 一直无法获得锁，而其他 Goroutine 不断获得锁的情况。在 Go 中，sync.Mutex 并没有专门的机制来处理饥饿状态。如果出现饥饿状态，通常是由于程序逻辑设计不合理导致的，可能需要重新考虑并发结构和资源的设计。</li></ul><p><strong>读写操作</strong></p><ul><li>如果一个 Goroutine 持有写锁，那么其他 Goroutine 将无法获取读锁，直到写锁被释放。这种机制保证了在写操作进行时，不会有其他 Goroutine 进行并发的读取操作，从而避免了数据的并发写入。</li></ul><h2 id="33-go的锁是可重入的吗【不是】"><a href="#33-go的锁是可重入的吗【不是】" class="headerlink" title="33. go的锁是可重入的吗【不是】"></a>33. go的锁是可重入的吗【不是】</h2><p><strong>可重入锁</strong>（也称为递归锁）是指允许同一个线程或 Goroutine 多次获取同一个锁，而不会发生死锁的情况。这在一些场景下是很有用的，比如在一个函数中多次调用其他需要锁保护的函数</p><p><strong>但是go的sync.Mutex不是可重入。</strong></p><h2 id="210-如何检测死锁的？"><a href="#210-如何检测死锁的？" class="headerlink" title="210. 如何检测死锁的？"></a>210. 如何检测死锁的？</h2><ul><li>go vet 进行静态分析</li><li>go run/build -race 可以检测死锁，在编译好静态文件后</li></ul><h2 id="211-怎么处理锁分段（Lock-Sharding）"><a href="#211-怎么处理锁分段（Lock-Sharding）" class="headerlink" title="211. 怎么处理锁分段（Lock Sharding）"></a>211. 怎么处理锁分段（Lock Sharding）</h2><ol><li>锁分段是将一个大锁拆分成多个小锁，每个小锁只保护一部分共享资源，从而减小锁的粒度，提高并发度。</li><li>使用锁分段的优点在于它可以将大锁拆分成多个小锁，提高并发性能，特别是在高并发的情况下。然而，需要注意的是在设计分段锁时，需要考虑到资源的访问模式和分段的粒度，以避免出现性能瓶颈或竞争条件<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LockShard <span class="keyword">struct</span> &#123;</span><br><span class="line">    locks []sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化锁分段init lock shard</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLockShard</span><span class="params">(numShards <span class="keyword">int</span>)</span> *<span class="title">LockShard</span></span> &#123;</span><br><span class="line">    shard := &amp;LockShard&#123;</span><br><span class="line">        locks: <span class="built_in">make</span>([]sync.Mutex, numShards),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shard</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//确定分段索引</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ls *LockShard)</span> <span class="title">GetShardIndex</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 根据 key 计算出分段索引</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> shardIndex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 取和释放分段锁</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ls *LockShard)</span> <span class="title">Lock</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    shardIndex := ls.GetShardIndex(key)</span><br><span class="line">    ls.locks[shardIndex].Lock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ls *LockShard)</span> <span class="title">Unlock</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    shardIndex := ls.GetShardIndex(key)</span><br><span class="line">    ls.locks[shardIndex].Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="226-sync-mutex的底层实现（Linux）"><a href="#226-sync-mutex的底层实现（Linux）" class="headerlink" title="226. sync.mutex的底层实现（Linux）"></a>226. sync.mutex的底层实现（Linux）</h2><ul><li>实现可能因操作系统和硬件平台而异</li><li>使用 pthreads 库（POSIX 线程库）中的互斥锁实现。</li><li>这是一个用户态的锁，它会使用操作系统提供的系统调用来进行加锁和解锁</li><li>mutex维护一个state，类型是int32</li></ul><h3 id="提供了两种锁定方式：阻塞锁和自旋锁"><a href="#提供了两种锁定方式：阻塞锁和自旋锁" class="headerlink" title="提供了两种锁定方式：阻塞锁和自旋锁"></a>提供了两种锁定方式：阻塞锁和自旋锁</h3><ul><li>阻塞锁：当一个 Goroutine 尝试获取一个被其他 Goroutine 持有的锁时，它会被阻塞，直到锁被释放。</li><li>自旋锁：自旋锁是一种非阻塞的锁机制，在尝试获取锁时，如果锁已经被其他 Goroutine 持有，它会在一段时间内快速尝试获取锁，而不是被阻塞。如果在一定时间内无法获取到锁，那么它会转为阻塞模式。</li></ul><h3 id="mutex允许自旋的条件是什么【执行状态的M个数-lt-mapprocs】"><a href="#mutex允许自旋的条件是什么【执行状态的M个数-lt-mapprocs】" class="headerlink" title="mutex允许自旋的条件是什么【执行状态的M个数&lt; mapprocs】"></a>mutex允许自旋的条件是什么【执行状态的M个数&lt; mapprocs】</h3><p>开发者可以使用 runtime.GOMAXPROCS() 函数来设置 Goroutine 的最大并发数，从而影响自旋锁的行为。</p><h1 id="goroutine使用"><a href="#goroutine使用" class="headerlink" title="goroutine使用"></a>goroutine使用</h1><h2 id="20-两个goroutine交替打印字母和数字"><a href="#20-两个goroutine交替打印字母和数字" class="headerlink" title="20. 两个goroutine交替打印字母和数字"></a>20. 两个goroutine交替打印字母和数字</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">limit := <span class="number">26</span></span><br><span class="line"></span><br><span class="line">numChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">charChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">mainChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">charChan &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; limit; i++ &#123;</span><br><span class="line">&lt;-charChan</span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="string">'a'</span>+i)</span><br><span class="line">numChan &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; limit; i++ &#123;</span><br><span class="line">&lt;-numChan</span><br><span class="line">fmt.Println(i)</span><br><span class="line">charChan &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mainChan &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-mainChan</span><br><span class="line"><span class="built_in">close</span>(charChan)</span><br><span class="line"><span class="built_in">close</span>(numChan)</span><br><span class="line"><span class="built_in">close</span>(mainChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-为什么不要大量使用goroutine"><a href="#26-为什么不要大量使用goroutine" class="headerlink" title="26. 为什么不要大量使用goroutine"></a>26. 为什么不要大量使用goroutine</h2><ul><li>上下文切换，开销变大</li><li>可能会存在内存泄漏的问题，得<br>要根据具体的情况来评估并发的需求，避免不必要的并发，以免引入不必要的复杂性和潜在的问题。</li></ul><h3 id="协程池如何实现-worker"><a href="#协程池如何实现-worker" class="headerlink" title="协程池如何实现 worker"></a>协程池如何实现 worker</h3><h2 id="40-for-循环多次执行goroutine-有什么坑？"><a href="#40-for-循环多次执行goroutine-有什么坑？" class="headerlink" title="40. for 循环多次执行goroutine 有什么坑？"></a>40. for 循环多次执行goroutine 有什么坑？</h2><ul><li>go支持闭包， 如果用了循环的这个i，里面的变量就可能出错，用临时变量的副本比较好。</li><li>Goroutine 是异步执行的，它们可能会在循环变量发生变化之后才开始执行，导致不确定的结果</li></ul><h2 id="48-如果要等待所有goroutine结束，怎么做？【使用waitgroup】"><a href="#48-如果要等待所有goroutine结束，怎么做？【使用waitgroup】" class="headerlink" title="48. 如果要等待所有goroutine结束，怎么做？【使用waitgroup】"></a>48. 如果要等待所有goroutine结束，怎么做？【使用waitgroup】</h2><h2 id="55-goroutine为什么轻量"><a href="#55-goroutine为什么轻量" class="headerlink" title="55. goroutine为什么轻量"></a>55. goroutine为什么轻量</h2><p><strong>独立的栈空间</strong> 每个 Goroutine 都有自己独立的栈空间，相对于传统的线程来说，Goroutines 的栈空间通常会小很多。这使得创建和销毁 Goroutines 更加快速和节省内存。</p><p><strong>灵活的调度器</strong> Go 的运行时（runtime）包含了一个高效的调度器，它可以在多个操作系统线程上调度 Goroutines，以便充分利用多核处理器的优势。这使得在单个程序中可以同时执行大量的 Goroutines，而不会导致线程过度切换和资源浪费。</p><p><strong>快速的启动和停止</strong> 相对于传统的线程，创建和销毁 Goroutines 更加快速。这使得在需要短暂执行某些任务时，使用 Goroutines 更为合适。</p><p><strong>共享的堆空间</strong> 所有 Goroutines 共享相同的堆空间，这意味着它们可以相对容易地共享数据，而不需要显式的同步机制。</p><p><strong>通信通过通道</strong> Goroutines 之间的通信主要依赖于通道（channel），它们提供了一种安全且高效的方式来传递数据。通过通道，可以实现 Goroutines 之间的同步和数据传递，而无需显式的锁。</p><p><strong>自动的垃圾回收</strong> Go 具有垃圾回收机制，它会自动管理内存的分配和释放，使得开发者无需手动管理内存，降低了并发程序中内存泄漏的风险。</p><h2 id="85-使用两个channel实现a-b"><a href="#85-使用两个channel实现a-b" class="headerlink" title="85. 使用两个channel实现a+b"></a>85. 使用两个channel实现a+b</h2><h2 id="92-goroutine的实现方式"><a href="#92-goroutine的实现方式" class="headerlink" title="92. goroutine的实现方式"></a>92. goroutine的实现方式</h2><h2 id="100-并行goroutine如何实现"><a href="#100-并行goroutine如何实现" class="headerlink" title="100. 并行goroutine如何实现"></a>100. 并行goroutine如何实现</h2><h2 id="111-父-goroutine-退出，如何使得子goroutine也退出【waitgroup-用channel-，defer】"><a href="#111-父-goroutine-退出，如何使得子goroutine也退出【waitgroup-用channel-，defer】" class="headerlink" title="111. 父 goroutine 退出，如何使得子goroutine也退出【waitgroup 用channel ，defer】"></a>111. 父 goroutine 退出，如何使得子goroutine也退出【waitgroup 用channel ，defer】</h2><ul><li>父 Goroutine 退出时，只要main不退出，所有的子 Goroutines 不会强制关闭</li></ul><h1 id="Go的GC机制"><a href="#Go的GC机制" class="headerlink" title="Go的GC机制"></a>Go的GC机制</h1><h2 id="24-go的gc什么是否触发"><a href="#24-go的gc什么是否触发" class="headerlink" title="24. go的gc什么是否触发"></a>24. go的gc什么是否触发</h2><p><strong>主动触发(手动触发)</strong>，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。</p><p><strong>被动触发</strong>，分为两种方式：</p><ul><li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认100%，即当内存扩大一倍时启用GC。</li><li>使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC。</li></ul><h2 id="148-Go-语言什么时候垃圾回收，写代码时，如何减少对象分配"><a href="#148-Go-语言什么时候垃圾回收，写代码时，如何减少对象分配" class="headerlink" title="148. Go 语言什么时候垃圾回收，写代码时，如何减少对象分配"></a>148. Go 语言什么时候垃圾回收，写代码时，如何减少对象分配</h2><p><strong>对象池</strong>：可以使用 sync.Pool 或者自定义对象池来重用对象，避免频繁分配和释放。</p><p><strong>必要时使用数组而不是切片</strong>：如果你知道元素数量固定，可以使用数组而不是切片，因为切片底层数组可能会导致对象分配。</p><p><strong>避免逃逸</strong>：逃逸发生在编译器无法确定一个变量的生命周期时，变量将会在堆上分配。尽量避免函数内部的变量逃逸到堆上</p><p><strong>使用内置函数</strong>：Go 提供了一些内置函数（如 append、copy）来处理切片，它们会在底层做一些优化，避免不必要的分配。</p><h2 id="176-Golang-内存分配和管理"><a href="#176-Golang-内存分配和管理" class="headerlink" title="176. Golang 内存分配和管理"></a>176. Golang 内存分配和管理</h2><p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p><p>Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的TCMalloc算法，全称Thread-Caching Malloc。</p><p>核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。</p><h3 id="管理如何管理？"><a href="#管理如何管理？" class="headerlink" title="管理如何管理？"></a>管理如何管理？</h3><p>Go自带GC，可以自动回收垃圾，对比C语言不用malloc申请内存及free释放，Go的GC采取三色标记法动态；</p><p>Go自动分配内存，开发者可以不用关注堆、栈，Go在编译阶段会做变量的生命周期分析做逃逸分析，自动将变量分配在堆或栈上。</p><h2 id="354-go的内存分配机制"><a href="#354-go的内存分配机制" class="headerlink" title="354. go的内存分配机制"></a>354. go的内存分配机制</h2><p>Go 的内存分配借鉴了 Google 的 TCMalloc 分配算法，其核心思想是内存池 + 多级对象管理。内存池主要是预先分配内存，减少向系统申请的频率；多级对象有：mheap、mspan、arenas、mcentral、mcache。<br>它们以 mspan 作为基本分配单位。具体的分配逻辑如下：</p><ul><li>当要分配大于 32K 的对象时，从 mheap 分配。</li><li>当要分配的对象小于等于 32K 大于 16B 时，从 P 上的 mcache 分配，如果 mcache 没有内存，则从 mcentral 获取，如果 mcentral 也没有，则向 mheap 申请，如果 mheap 也没有，则从操作系统申请内存。</li><li>当要分配的对象小于等于 16B 时，从 mcache 上的微型分配器上分配。<h2 id="324-go的内存分配机制中，有mcentral为什么要mcache"><a href="#324-go的内存分配机制中，有mcentral为什么要mcache" class="headerlink" title="324. go的内存分配机制中，有mcentral为什么要mcache"></a>324. go的内存分配机制中，有mcentral为什么要mcache</h2></li></ul><h2 id="177-如何避免内存逃逸【合理用指针，设定slice长度】"><a href="#177-如何避免内存逃逸【合理用指针，设定slice长度】" class="headerlink" title="177. 如何避免内存逃逸【合理用指针，设定slice长度】"></a>177. 如何避免内存逃逸【合理用指针，设定slice长度】</h2><ol><li>不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大。</li><li>预先设定好slice长度，避免频繁超出容量，重新分配。</li><li>一个经验是，指针指向的数据大部分在堆上分配的，请注意。</li></ol><p>出现内存逃逸的情况有：</p><ol><li><p>发送指针或带有指针的值到channel，因为编译时候无法知道那个goroutine会在channel接受数据，编译器无法知道什么时候释放。</p></li><li><p>在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。</p></li><li><p>切片的append导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。</p></li><li><p>调用接口类型时，接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定，如一个接口类型为io.Reader的变量r，对r.Read(b)的调用将导致r的值和字节片b的后续转义并因此分配到堆上。</p></li><li><p>在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，导致内存溢出。</p><h2 id="237-gc和-delete-free-有什么区别，优势？"><a href="#237-gc和-delete-free-有什么区别，优势？" class="headerlink" title="237. gc和 delete free 有什么区别，优势？"></a>237. gc和 delete free 有什么区别，优势？</h2></li></ol><ul><li>delete free是手动释放的，一有忘记的就可能导致内存泄漏，产生内存碎片</li><li>gc的话是自动释放堆的内存，<strong>能有效避免内存泄漏和内存碎片</strong>，没有垃圾回收的情况下，程序员可能需要手动释放不再使用的内存，以避免内存碎片的问题<ul><li>内存碎片是指分配在堆上的内存块中，由于频繁的分配和释放操作，导致堆中的可用内存呈现出碎片化的状态，使得大块的连续内存难以分配。</li></ul></li></ul><h2 id="355-go的性能调优是怎么做的"><a href="#355-go的性能调优是怎么做的" class="headerlink" title="355. go的性能调优是怎么做的"></a>355. go的性能调优是怎么做的</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>A、将小对象合并成结构体一次分配，减少内存分配次数</p><p>Go runtime底层采用内存池机制，每个span大小为4k，同时维护一个cache。cache有一个0到n的list数组，list数组的每个单元挂载的是一个链表，链表的每个节点就是一块可用的内存块，同一链表中的所有节点内存块都是大小相等的；但是不同链表的内存大小是不等的，即list数组的一个单元存储的是一类固定大小的内存块，不同单元里存储的内存块大小是不等的。cache缓存的是不同类大小的内存对象，申请的内存大小最接近于哪类缓存内存块时，就分配哪类内存块。当cache不够时再向spanalloc中分配。</p><p>B、缓存区内容一次分配足够大小空间，并适当复用</p><p>在协议编解码时，需要频繁地操作[]byte，可以使用bytes.Buffer或其它byte缓存区对象。<br>bytes.Buffer等通过预先分配足够大的内存，避免当增长时动态申请内存，减少内存分配次数。对于byte缓存区对象需要考虑适当地复用。<br>C、slice和map采make创建时，预估大小指定容量<br>slice和map与数组不一样，不存在固定空间大小，可以根据增加元素来动态扩容。<br>slice初始会指定一个数组，当对slice进行append等操作时，当容量不够时，会自动扩容：<br>如果新的大小是当前大小2倍以上，则容量增涨为新的大小；<br>否则循环以下操作：如果当前容量小于1024，按2倍增加；否则每次按当前容量1/4增涨，直到增涨的容量超过或等新大小。<br>map的扩容比较复杂，每次扩容会增加到上次容量的2倍。map的结构体中有一个buckets和oldbuckets，用于实现增量扩容：<br>正常情况下，直接使用buckets，oldbuckets为空；<br>如果正在扩容，则oldbuckets不为空，buckets是oldbuckets的2倍，<br>因此，建议初始化时预估大小指定容量</p><p>D、长调用栈避免申请较多的临时对象</p><p>Goroutine的调用栈默认大小是4K（1.7修改为2K），采用连续栈机制，当栈空间不够时，Go runtime会自动扩容：<br>当栈空间不够时，按2倍增加，原有栈的变量会直接copy到新的栈空间，变量指针指向新的空间地址；<br>退栈会释放栈空间的占用，GC时发现栈空间占用不到1/4时，则栈空间减少一半。<br>比如栈的最终大小2M，则极端情况下，就会有10次的扩栈操作，会带来性能下降。<br>因此，建议控制调用栈和函数的复杂度，不要在一个goroutine做完所有逻辑；如的确需要长调用栈，而考虑goroutine池化，避免频繁创建goroutine带来栈空间的变化。</p><p>E、避免频繁创建临时对象</p><p>Go在GC时会引发stop the world，即整个情况暂停。Go1.8最坏情况下GC为100us。但暂停时间还是取决于临时对象的个数，临时对象数量越多，暂停时间可能越长，并消耗CPU。<br>因此，建议GC优化方式是尽可能地减少临时对象的个数：尽量使用局部变量；所多个局部变量合并一个大的结构体或数组，减少扫描对象的次数，一次回尽可能多的内存。</p><h3 id="并发优化"><a href="#并发优化" class="headerlink" title="并发优化"></a>并发优化</h3><p>A、高并发的任务处理使用goroutine池<br>Goroutine虽然轻量，但对于高并发的轻量任务处理，频繁来创建goroutine来执行，执行效率并不会太高，因为：过多的goroutine创建，会影响go runtime对goroutine调度，以及GC消耗；高并发时若出现调用异常阻塞积压，大量的goroutine短时间积压可能导致程序崩溃。<br>B、避免高并发调用同步系统接口<br>goroutine的实现，是通过同步来模拟异步操作。<br>网络IO、锁、channel、Time.sleep、基于底层系统异步调用的Syscall操作并不会阻塞go runtime的线程调度。<br>本地IO调用、基于底层系统同步调用的Syscall、CGo方式调用C语言动态库中的调用IO或其它阻塞会创建新的调度线程。<br>网络IO可以基于epoll的异步机制（或kqueue等异步机制），但对于一些系统函数并没有提供异步机制。例如常见的posix api中，对文件的操作就是同步操作。虽有开源的fileepoll来模拟异步文件操作。但Go的Syscall还是依赖底层的操作系统的API。系统API没有异步，Go也做不了异步化处理。<br>因此，建议：把涉及到同步调用的goroutine，隔离到可控的goroutine中，而不是直接高并的goroutine调用。<br>C、高并发时避免共享对象互斥<br>传统多线程编程时，当并发冲突在4~8线程时，性能可能会出现拐点。Go推荐不通过共享内存来通信，Go创建goroutine非常容易，当大量goroutine共享同一互斥对象时，也会在某一数量的goroutine出在拐点。<br>因此，建议：goroutine尽量独立，无冲突地执行；若goroutine间存在冲突，则可以采分区来控制goroutine的并发个数，减少同一互斥对象冲突并发数。</p><h3 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h3><p>A、避免使用CGO或者减少CGO调用次数<br>GO可以调用C库函数，但Go带有垃圾收集器且Go的栈动态增涨，无法与C无缝地对接。Go的环境转入C代码执行前，必须为C创建一个新的调用栈，把栈变量赋值给C调用栈，调用结束现拷贝回来。调用开销较大，需要维护Go与C的调用上下文，两者调用栈的映射。相比直接的GO调用栈，单纯的调用栈可能有2个甚至3个数量级以上。<br>因此，建议：尽量避免使用CGO，无法避免时，要减少跨CGO的调用次数。<br>B、减少[]byte与string之间转换，尽量采用[]byte来字符串处理<br>GO里面的string类型是一个不可变类型，GO中[]byte与string底层是两个不同的结构，转换存在实实在在的值对象拷贝，所以尽量减少不必要的转化。<br>因此，建议：存在字符串拼接等处理，尽量采用[]byte。<br>C、字符串的拼接优先考虑bytes.Buffer<br>string类型是一个不可变类型，但拼接会创建新的string。GO中字符串拼接常见有如下几种方式：<br>string + 操作 ：导致多次对象的分配与值拷贝<br>fmt.Sprintf ：会动态解析参数，效率好不哪去<br>strings.Join ：内部是[]byte的append<br>bytes.Buffer ：可以预先分配大小，减少对象分配与拷贝<br>因此，建议：对于高性能要求，优先考虑bytes.Buffer，预先分配大小。fmt.Sprintf可以简化不同类型转换与拼</p><h2 id="500-写屏障-插入写屏障-删除写屏障-混合写屏障"><a href="#500-写屏障-插入写屏障-删除写屏障-混合写屏障" class="headerlink" title="500. 写屏障-插入写屏障-删除写屏障-混合写屏障"></a>500. 写屏障-插入写屏障-删除写屏障-混合写屏障</h2><ul><li>混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫 描垃圾即可；</li><li>混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC 期间，任 何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就 消除了插入写屏障时期最后 STW 的重新扫描栈；</li><li>混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的 是 GC 过程全程无 STW；</li><li>混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是 要停止这个 goroutine 赋值器的工作（针对一个 goroutine 栈来说，是 暂停扫的，要么全灰，要么全黑哈，原子状态切换）。</li></ul><h2 id="505-gc流程"><a href="#505-gc流程" class="headerlink" title="505. gc流程"></a>505. gc流程</h2><p>GCMark 标记准备阶段，为并发标记做准备工作，启动写屏障</p><p>STWGCMark 扫描标记阶段，与赋值器并发执行，写屏障开启并发</p><p>GCMarkTermination 标记终止阶段，保证一个周期内标记任务完成，停止写屏障</p><p>GCoff 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭</p><p>GCoff 内存归还阶段，将过多的内存归还给操作系统，写屏障关闭。</p><h2 id="506-GC是如何调优的"><a href="#506-GC是如何调优的" class="headerlink" title="506. GC是如何调优的"></a>506. GC是如何调优的</h2><h2 id="Go-内存分配机制？"><a href="#Go-内存分配机制？" class="headerlink" title="Go 内存分配机制？"></a>Go 内存分配机制？</h2><h2 id="Go-内存逃逸机制？"><a href="#Go-内存逃逸机制？" class="headerlink" title="Go 内存逃逸机制？"></a>Go 内存逃逸机制？</h2><h2 id="Go-内存对齐机制"><a href="#Go-内存对齐机制" class="headerlink" title="Go 内存对齐机制"></a>Go 内存对齐机制</h2><h2 id="563-waitgroup的底层实现"><a href="#563-waitgroup的底层实现" class="headerlink" title="563. waitgroup的底层实现"></a>563. waitgroup的底层实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line"> noCopy noCopy</span><br><span class="line"> state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="564-cond实现原理"><a href="#564-cond实现原理" class="headerlink" title="564. cond实现原理"></a>564. cond实现原理</h2><h2 id="run-race能用于什么【排查逃逸，死锁，数据竞争等】"><a href="#run-race能用于什么【排查逃逸，死锁，数据竞争等】" class="headerlink" title="run -race能用于什么【排查逃逸，死锁，数据竞争等】"></a>run -race能用于什么【排查逃逸，死锁，数据竞争等】</h2><h1 id="go其他"><a href="#go其他" class="headerlink" title="go其他"></a>go其他</h1><h2 id="17-不重启实现热更新"><a href="#17-不重启实现热更新" class="headerlink" title="17. 不重启实现热更新"></a>17. 不重启实现热更新</h2><p>根据系统的 SIGHUP 信号量，以此信号量触发进程重启，达到热更新的效果。</p><p>热部署我们需要考虑几个能力：</p><ul><li>新进程启动成功，老进程不会有资源残留</li><li>新进程初始化的过程中，服务不会中断</li><li>新进程初始化失败，老进程仍然继续工作</li><li>同一时间，只能有一个更新动作执行<br>监听信号量的方法的环境是在 类 UNIX 系统中，在现在的 UNIX 内核中，允许多个进程同时监听一个端口。在收到 SIGHUP 信号量时，先 fork 出一个新的进程监听端口，同时等待旧进程处理完已经进来的连接，最后杀掉旧进程。</li></ul><p>示例代码，仓库地址：<a href="https://github.com/guowei-gong/tablefilp-example，" target="_blank" rel="noopener">https://github.com/guowei-gong/tablefilp-example，</a> 如果你希望动手来加深印象可以打开看看。</p><h2 id="157-日志框架logrus"><a href="#157-日志框架logrus" class="headerlink" title="157. 日志框架logrus"></a>157. 日志框架logrus</h2><h2 id="go实现stack-和-set"><a href="#go实现stack-和-set" class="headerlink" title="go实现stack 和 set"></a>go实现stack 和 set</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Push</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    s.data = <span class="built_in">append</span>(s.data, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s.data) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    item := s.data[<span class="built_in">len</span>(s.data)<span class="number">-1</span>]</span><br><span class="line">    s.data = s.data[:<span class="built_in">len</span>(s.data)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span> <span class="title">Add</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    s[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span> <span class="title">Remove</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span> <span class="title">Contains</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    _, exists := s[item]</span><br><span class="line">    <span class="keyword">return</span> exists</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="200-项目上线了，但是发现协程-内存泄漏，如何处理"><a href="#200-项目上线了，但是发现协程-内存泄漏，如何处理" class="headerlink" title="200. 项目上线了，但是发现协程/内存泄漏，如何处理"></a>200. 项目上线了，但是发现协程/内存泄漏，如何处理</h2><p>1.goroutine泄漏。<br>2.有一些全局的数据结构意外的挂住了本该释放的对象，虽然goroutine已经退出了，但是这些对象并没有从这类数据结构中删除，导致对象一直被引用，无法被收回。<br>所以发现有内存泄漏的话，具体问题具体分析。</p><h2 id="RPC基础"><a href="#RPC基础" class="headerlink" title="RPC基础"></a>RPC基础</h2><p>讲一下RPC基础：</p><p>RPC的概念<br>RPC（Romote Procedure Call，远程过程调用），作为分布式系统中不同节点之间的通信方式，是分布式系统的基石之一，RPC不是具体的方法，而是一种解决不同服务之间调用的设计。</p><p>基于RPC开发的框架可以称为RPC框架，典型的有谷歌的gRPC、阿里的Dubbo、Facebook的Thrift等，当然成熟的RPC框架还会有服务注册与发现、服务治理、负载均衡等功能。</p><p>RPC的四个要素<br>Client<br>服务调用的发起方</p><p>Client Stub<br>用于存储要调用的服务器地址、以及将要请求的数据信息打包，通过网络请求发送给Server Stub，然后阻塞，直到接受到返回的数据，然后进行解析。</p><p>Server<br>Server，包含要调用的方法</p><p>Server Stub<br>用于接受Client Stub发送的请求数据包并进行解析，完成功能调用，最后将结果进行打包并返回给Client Stub。在没有接受到请求数据包时则处于阻塞状态。</p><p>封装了Client Stub和Server Stub后，从Client的角度来看，似乎和本地调用一样。从Server的角度看，似乎就是客户直接调用。</p><p>RPC的具体通信步骤<br>Client以类似本地调用的方式调Client Stub<br>Client Stub序列化生成消息，然后调用本地操作系统的通信模块， Stub阻塞<br>本地操作系统与远程Server进行通信，消息传输到远程操作系统<br>远程操作系统将消息传递给Server Stub<br>Server Stub进行反序列化，然后调用Server的对应方法<br>Server程序执行方法，将结果传递给Server Stub<br>Server Stub将结果进行序列化，然后传递给Server操作系统<br>Server操作系统将结果传递给Client<br>Client操作系统将其交给Client Stub， Stub从阻塞状态恢复<br>Client Stub对结果进行反序列化，并将值返回给Client程序<br>Client程序获得返回结果</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁的概念其实很简单，就是在操作一个共享变量时，我们先认为多个线程之间没有冲突</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是乐观锁的一种实现，CAS全称是比较和替换，CAS的操作主要由以下几个步骤组成：</p><ol><li>先查询原始值</li><li>操作时比较原始值是否修改</li><li>如果修改，则操作失败，禁止更新操作，如果没有发生修改，则更新为新值<h3 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h3>CAS虽然在低并发量的情况下可以减少系统的开销，但是CAS也有一些问题：</li><li>CPU开销过大问题</li><li>ABA问题</li><li>只能针对一个共享变量<h3 id="CPU开销过大"><a href="#CPU开销过大" class="headerlink" title="CPU开销过大"></a>CPU开销过大</h3>在我们使用CAS时，如果并发量过大，我们的程序有可能会一直自旋，长时间占用CPU资源。<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3>假设有个共享变量J，原始值为1。</li><li>线程A读取变量J，值为1</li><li>线程B读取变量J，值为1</li><li>线程A变量J+1，CAS成功从1修改为2</li><li>线程C读取变量J，值为2</li><li>线程C将变量J-1，CAS成功从2修改为1</li><li>线程A通过CAS比较和替换，依然可以改为自己想修改的值<br>上述过程，线程B和C已经将变量J的值已经改变了，但是线程A无法发现，依然可以修改共享变量，这就产生了ABA问题。<h3 id="共享变量单一"><a href="#共享变量单一" class="headerlink" title="共享变量单一"></a>共享变量单一</h3>CAS操作单个共享变量的时候可以保证原子的操作，无法操作多个变量。<br>但是在JDK5之后，AtomicReference可以用来保证对象之间的原子性，我们可以把多个对象放入CAS中操作。</li></ol><h3 id="如何防止CAS的ABA"><a href="#如何防止CAS的ABA" class="headerlink" title="如何防止CAS的ABA"></a>如何防止CAS的ABA</h3><p>四个字：加标志位（version）。<br>至于标志位可以是自增的数字，也可以是时间戳。通过标志位我们可以精确的知道每次修改。</p><h2 id="go-python-java的协程区别"><a href="#go-python-java的协程区别" class="headerlink" title="go python java的协程区别"></a>go python java的协程区别</h2><h3 id="python协程特点"><a href="#python协程特点" class="headerlink" title="python协程特点"></a>python协程特点</h3><ol><li>单线程内切换，适用于IO密集型程序中，能够最大化IO多路复用的效果。</li><li>没法利用多核。</li><li>协程间彻底同步，不会并行。不须要考虑数据安全。</li><li>关键词yield</li></ol><h3 id="java协程特点"><a href="#java协程特点" class="headerlink" title="java协程特点"></a>java协程特点</h3><h3 id="go协程特点"><a href="#go协程特点" class="headerlink" title="go协程特点"></a>go协程特点</h3><ol><li>协程间须要保证数据安全，好比经过channel或锁。</li><li>能够利用多核并行执行。</li><li>协程间不彻底同步，能够并行运行，具体要看channel的设计。</li><li>抢占式调度，可能没法实现公平。<h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3></li><li>java引入了一个虚拟线程的东西，然后结合Thread库的VirtualThread来创建，用JVM管理，用共享内存的方式实现的通信，本质上还是原生thread那一套，golang是原生支持goroutine机制来支持并发的，runtime/GMP模型管理的，python用一个asyncio库实现并发的，awaitable对象实现的通信</li></ol><h2 id="性能排查"><a href="#性能排查" class="headerlink" title="性能排查"></a>性能排查</h2><ol><li>使用性能分析工具（如pprof）来获取详细的性能数据，了解哪些函数或代码段消耗了大量的时间。</li><li>检查缓存、连接、数据库等</li><li>日志里也可能有信息<br>## <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goroutine5</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//ctx := context.Background()</span></span><br><span class="line"><span class="comment">//quere := make(chan int,1000)</span></span><br><span class="line">q1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">q2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">q3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">q4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">q5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">ch5 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">suc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">oper := <span class="function"><span class="keyword">func</span><span class="params">(sort <span class="keyword">int</span>, in, out <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, q <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//defer wg.Done()</span></span><br><span class="line"><span class="comment">//fmt.Println(sort)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> q &#123;</span><br><span class="line">&lt;-in</span><br><span class="line">fmt.Println(sort, <span class="string">" print : "</span>, i)</span><br><span class="line"><span class="comment">//_, ok := &lt;-q</span></span><br><span class="line"><span class="comment">//if ok &#123;</span></span><br><span class="line"><span class="comment">//fmt.Println("sl ", sort)</span></span><br><span class="line">out &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//_, ok := &lt;-out</span></span><br><span class="line"><span class="comment">//if ok &#123;</span></span><br><span class="line"><span class="comment">//fmt.Println("close --------", sort)</span></span><br><span class="line"><span class="comment">//close(out)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//close(in)</span></span><br><span class="line">fmt.Println(<span class="string">"close "</span>, sort)</span><br><span class="line">&#125;</span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//defer wg.Done()</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch1 &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="comment">//fmt.Println(i, "==========")</span></span><br><span class="line"><span class="keyword">switch</span> i % <span class="number">5</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">q1 &lt;- i</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">q2 &lt;- i</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">q3 &lt;- i</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">q4 &lt;- i</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">q5 &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//fmt.Println("s")</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(q1)</span><br><span class="line"><span class="built_in">close</span>(q2)</span><br><span class="line"><span class="built_in">close</span>(q3)</span><br><span class="line"><span class="built_in">close</span>(q4)</span><br><span class="line"><span class="built_in">close</span>(q5)</span><br><span class="line">suc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(suc)</span><br><span class="line"><span class="comment">//close(ch1)</span></span><br><span class="line">fmt.Println(<span class="string">"ws"</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> s := <span class="keyword">range</span> suc &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> ch1 &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="built_in">close</span>(ch1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> oper(<span class="number">1</span>, ch1, ch2, q1)</span><br><span class="line"><span class="keyword">go</span> oper(<span class="number">2</span>, ch2, ch3, q2)</span><br><span class="line"><span class="keyword">go</span> oper(<span class="number">3</span>, ch3, ch4, q3)</span><br><span class="line"><span class="keyword">go</span> oper(<span class="number">4</span>, ch4, ch5, q4)</span><br><span class="line"><span class="keyword">go</span> oper(<span class="number">5</span>, ch5, ch1, q5)</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"suc"</span>, &lt;-ch1)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Golang questions&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://waynamigo.github.io/categories/Golang/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="go" scheme="http://waynamigo.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Tutorial base knowledge</title>
    <link href="http://waynamigo.github.io/2023/01/01/2023-01-01-%E9%9D%A2%E7%BB%8Fdockerk8s/"/>
    <id>http://waynamigo.github.io/2023/01/01/2023-01-01-面经dockerk8s/</id>
    <published>2022-12-31T16:00:00.000Z</published>
    <updated>2023-11-21T06:57:02.532Z</updated>
    
    <content type="html"><![CDATA[<p>本篇为OverView，内容包括kubectl的基础操作，整理的知识框架基于kubernetes官方文档<a href="https://kubernetes.io/docs/tutorials/" target="_blank" rel="noopener">v1.26</a>， 元旦期间系统整理一下。</p><a id="more"></a><h1 id="pod生命周期-Pending-Runing-Succeed-Failed-Unknown"><a href="#pod生命周期-Pending-Runing-Succeed-Failed-Unknown" class="headerlink" title="pod生命周期 Pending Runing Succeed Failed Unknown"></a>pod生命周期 Pending Runing Succeed Failed Unknown</h1><ul><li>Pending(挂起):API server已经创建pod，但是该pod还有一个或多个容器的镜像没有创建，包括正 在下载镜像的过程; </li><li>Running(运行中):Pod内所有的容器已经创建，且至少有一个容器处于运行状态、正在启动括正在重 启状态;</li><li>Succeed(成功):Pod内所有容器均已退出，且不会再重启; </li><li>Failed(失败):Pod内所有容器均已退出，且至少有一个容器为退出失败状态 </li><li>Unknown(未知):某于某种原因apiserver无法获取该pod的状态，可能由于网络通行问题导致<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1></li></ul><p><a href="https://zhuanlan.zhihu.com/p/571931032" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/571931032</a></p><h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h2><p>CGroups 全称control group，</p><ul><li>用来限定一个进程的资源使用，</li><li>由 Linux 内核支持，可以限制和隔离Linux进程组 (process groups) 所使用的物理资源，比如cpu，内存，磁盘和网络IO，是Linux container技术的物理基础。</li></ul><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><ul><li><p>如果CGroup设计出来的目的是为了隔离上面描述的物理资源，那么namespace则用来隔离PID(进程ID),IPC,Network等系统资源。</p></li><li><p>将它们分配给特定的Namespace，每个Namespace里面的资源对其他Namespace都是透明的。</p></li><li><p>不同container内的进程属于不同的Namespace，彼此透明，互不干扰。</p><h2 id="unionFS（storage-driver：overlay2）"><a href="#unionFS（storage-driver：overlay2）" class="headerlink" title="unionFS（storage driver：overlay2）"></a>unionFS（storage driver：overlay2）</h2></li><li><p>unionFS可以把文件系统上多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的</p></li><li><p>借助Linux的unionFS，宿主机只需要在磁盘上保存一份base镜像，内存中也只需要加载一份，就能被所有基于这个镜像的容器共享</p></li></ul><h1 id="k8s是什么"><a href="#k8s是什么" class="headerlink" title="k8s是什么"></a>k8s是什么</h1><p>K8S 负责自动化运维管理多个 Docker 程序的集群</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://amos-x.com/wp-content/uploads/2019/11/image.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="组件1-etcd"><a href="#组件1-etcd" class="headerlink" title="组件1 etcd"></a>组件1 etcd</h2><p>分布式键值存储，用于保存Kubernetes集群的所有重要信息，例如配置数据、状态信息等</p><h2 id="组件2-apiserver-kube-apiserver"><a href="#组件2-apiserver-kube-apiserver" class="headerlink" title="组件2 apiserver: kube-apiserver"></a>组件2 apiserver: kube-apiserver</h2><p>kube-apiserver是Kubernetes API的前端，提供了Kubernetes控制平面的统一接口</p><h2 id="组件3-controller-kube-controller-manager"><a href="#组件3-controller-kube-controller-manager" class="headerlink" title="组件3 controller: kube-controller-manager"></a>组件3 controller: kube-controller-manager</h2><p>kube-controller-manager负责管理控制器，这些控制器包括节点控制器、副本控制器、端点控制器等，它们负责保证系统的状态符合用户定义的期望状态</p><h2 id="组件4-scheduler-kube-scheduler"><a href="#组件4-scheduler-kube-scheduler" class="headerlink" title="组件4 scheduler: kube-scheduler"></a>组件4 scheduler: kube-scheduler</h2><p>kube-scheduler负责将Pod调度到具体的节点上，它考虑了诸如资源需求、硬件/软件约束等因素</p><h2 id="组件5-kubelet"><a href="#组件5-kubelet" class="headerlink" title="组件5 kubelet"></a>组件5 kubelet</h2><p>kubelet是每个节点上运行的代理，负责确保Pods按照规定运行 </p><h2 id="组件6-kube-proxy"><a href="#组件6-kube-proxy" class="headerlink" title="组件6 kube-proxy"></a>组件6 kube-proxy</h2><p>kube-proxy负责维护节点上的网络规则，使得服务可以被正确地路由</p><h2 id="组件7-container-runtime"><a href="#组件7-container-runtime" class="headerlink" title="组件7 container runtime"></a>组件7 container runtime</h2><p>容器运行时，比如docker，containerd</p><h2 id="组件8-container-advisor"><a href="#组件8-container-advisor" class="headerlink" title="组件8 container advisor"></a>组件8 container advisor</h2><p>是一个监控代理，用于收集容器资源使用情况和性能数据</p><h2 id="【面试题】一个网络请求来了，还没处理要怎么办"><a href="#【面试题】一个网络请求来了，还没处理要怎么办" class="headerlink" title="【面试题】一个网络请求来了，还没处理要怎么办"></a>【面试题】一个网络请求来了，还没处理要怎么办</h2><p>kube-proxy处理，负责集群内部外部流量，正确路由到正确的pod上，实现高可用</p><h2 id="1-etcd是什么？分布式键值存储系统"><a href="#1-etcd是什么？分布式键值存储系统" class="headerlink" title="1.etcd是什么？分布式键值存储系统"></a>1.etcd是什么？分布式键值存储系统</h2><h2 id="2-etcd适用场景是什么，"><a href="#2-etcd适用场景是什么，" class="headerlink" title="2.etcd适用场景是什么，"></a>2.etcd适用场景是什么，</h2><h2 id="1-简述K8s的工作流程"><a href="#1-简述K8s的工作流程" class="headerlink" title="1. 简述K8s的工作流程"></a>1. 简述K8s的工作流程</h2><ol><li>创建一个包含应用程序的Deployment的yml文件，然后通过kubectl客户端工具发送给ApiServer。</li><li>ApiServer接收到客户端的请求并将资源内容存储到数据库(etcd)中。</li><li>Controller组件(包含scheduler、replication、endpoint)监控资源变化并作出反应。</li><li>ReplicaSet检查数据库变化，创建期望数量的pod实例。</li><li>Scheduler再次检查数据库变化，发现尚未被分配到具体执行节点(Node)的Pod，然后根据一组相关规则将Pod分配到可以运行它们的节点(Node)上，并更新数据库，记录Pod分配情况。</li><li>Kubelet监控数据库变化，管理后续Pod的生命周期，发现被分配到它所在的节点上运行的那些Pod。如果找到新Pod，则会在该节点上运行这个新Pod。例如当有数据发送到主机时，将其路由到正确的pod或容器。<h2 id="2-简述控制器类型Deployment，StatefulSet，DaemonSet的区别"><a href="#2-简述控制器类型Deployment，StatefulSet，DaemonSet的区别" class="headerlink" title="2. 简述控制器类型Deployment，StatefulSet，DaemonSet的区别"></a>2. 简述控制器类型Deployment，StatefulSet，DaemonSet的区别</h2></li><li><strong>应用场景</strong><ul><li>Deployment适用于无状态的应用场景，副本可以动态增加和减少</li><li>StatefulSet适用于有状态的应用场景，副本要顺序启动停止</li><li>DaemonSet适用于每个节点都运行一个或多个pod的场景</li></ul></li><li><strong>存储</strong><ul><li>Deployment不需要特别的存储支持</li><li>StatefulSet需要为每个Pod提供独立的存储，这可以通过后端存储完成</li><li>DaemonSet的每个pod要挂载 volume<h2 id="3-简述一下k8s的存储管理"><a href="#3-简述一下k8s的存储管理" class="headerlink" title="3. 简述一下k8s的存储管理"></a>3. 简述一下k8s的存储管理</h2></li></ul></li></ol><ul><li>持久卷，持久卷声明（PV，PVC）：适用于持久化数据的应用，比如数据库</li><li>存储类（StroageClass），根据PVC动态创建PV，适用于需要动态创建存储的场景，如云存储、分布式存储</li><li>子路径卷 (Subpath Volume)，多个pod共享存储</li><li>本地卷（Local Volume），节点的本地卷映射到pod中，节点间共享存储<h2 id="4-如何实现滚动更新和回滚【实现平滑升级和故障恢复的手段】"><a href="#4-如何实现滚动更新和回滚【实现平滑升级和故障恢复的手段】" class="headerlink" title="4. 如何实现滚动更新和回滚【实现平滑升级和故障恢复的手段】"></a>4. 如何实现滚动更新和回滚【实现平滑升级和故障恢复的手段】</h2></li><li>滚动更新逐步将pod下线，由新deployment进行更新<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 创建pod副本,在执行Deployment和升级的时候最好带上record参数，便于查看历史版本信息。</span><br><span class="line">kubectl apply -f abcdocker-test.yaml  --record</span><br><span class="line"><span class="meta">#</span> 更新1.替换镜像版本去更新</span><br><span class="line"><span class="meta">#</span> 我们可以看到pod执行过程是等待新的pod启动完成，在进行销毁旧的pod，这样就完成了集群的更新工作我们可以看到pod执行过程是等待新的pod启动完成，在进行销毁旧的pod，这样就完成了集群的更新工作</span><br><span class="line">sed -i 's#1.13.0-alpine#1.10.0-alpine#g' abcdocker-test.yaml</span><br><span class="line">kubectl apply -f abcdocker-test.yaml --record</span><br><span class="line"><span class="meta">#</span> 更新2.直接更新deployment【不是修改yaml文件】，要用kubctl edit deployment</span><br><span class="line">kubectl get deployment</span><br><span class="line">kubectl edit deployments deployment_name</span><br><span class="line"><span class="meta">#</span> 更新3. kubctl set替换镜像</span><br><span class="line">kubectl set image deployment/SVC_NAME -n namespace_name container_name=images:v1</span><br></pre></td></tr></table></figure></li></ul><p>回滚,使用 kubectl rollout</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout history deployment [deployment_name]查看所有的history</span><br><span class="line">kubectl rollout undo deploy_name</span><br></pre></td></tr></table></figure><h2 id="5-如何进行日志管理"><a href="#5-如何进行日志管理" class="headerlink" title="5. 如何进行日志管理"></a>5. 如何进行日志管理</h2><ol><li>使用kubectl的logs，获取制定pod的日志<code>kubectl logs [pod_name]</code></li><li>修改Kube-proxy的配置文件，通常位于<code>/etc/kubernetes/manifests/kube-proxy.yaml</code>将Pod的日志输出到宿主机的日志文件中，一般使用本地卷挂载</li><li>重启kube-proxy，使用宿主机的日志轮转工具，logrotate，设置轮转策略<code>sudo logrotate -d /etc/logrotate.d/pod-logs</code><h2 id="6-如何进行监控管理"><a href="#6-如何进行监控管理" class="headerlink" title="6. 如何进行监控管理"></a>6. 如何进行监控管理</h2></li><li>k8s提供了一个metrics，访问这个http请求就返回一个表单，是以#开头的注释行和以指标名称为前缀的键值对</li><li>工具有Prometheus比较常用，Grafana进行可视化展示</li><li>使用Heapster对Kubernetes集群进行监控数据的采集和存储<h2 id="7-etcd的作用"><a href="#7-etcd的作用" class="headerlink" title="7. etcd的作用"></a>7. etcd的作用</h2></li><li>存储所有资源信息，保证数据的强一致性，作用是<strong>数据存储、配置管理、故障恢复</strong></li><li>这些资源信息包括：服务发现、分布式锁、分布式数据队列、分布式通知和协调等功能<h2 id="8-etc的基本原理"><a href="#8-etc的基本原理" class="headerlink" title="8. etc的基本原理"></a>8. etc的基本原理</h2></li><li>分布式存储：Etcd采用分布式存储方式，可以配置多节点群集，通过数据同步来保证数据可靠性。</li><li>高可用性：Etcd通过选举算法来保证在任何时候都有一个领导者节点负责数据的写入和更新，从而保证了数据的强一致性。</li><li>数据持久化：Etcd中的数据会定期进行持久化存储，即使在系统崩溃时也可以保证数据的完整性。<h2 id="9-k8s的kube-scheduler调度器"><a href="#9-k8s的kube-scheduler调度器" class="headerlink" title="9. k8s的kube-scheduler调度器"></a>9. k8s的kube-scheduler调度器</h2></li></ol><h2 id="10-k8s怎样负载均衡的"><a href="#10-k8s怎样负载均衡的" class="headerlink" title="10. k8s怎样负载均衡的"></a>10. k8s怎样负载均衡的</h2><ol><li>Kubernetes的内置负载均衡器：Service组件，Service会根据服务后端的Pod IP和端口，将流量均衡地转发给每个Pod。这种方式是基于IP的负载均衡，支持TCP和UDP协议。</li><li>用传统的Nginx负载均衡服务器做边车（Sidecar）容器运行，监控流量<h2 id="11-k8s的Labels和Selectors的作用"><a href="#11-k8s的Labels和Selectors的作用" class="headerlink" title="11. k8s的Labels和Selectors的作用"></a>11. k8s的Labels和Selectors的作用</h2></li></ol><p><strong>Label：用于标识和选择资源对象。</strong></p><ul><li>附加在资源对象上的键值对标签，标pod，service</li><li>标在资源上，可以供Selector进行服务发现，关联选择资源，监控日志等</li></ul><p><strong>Selector：用于选择资源，服务发现</strong></p><h2 id="12-k8s的Service是什么"><a href="#12-k8s的Service是什么" class="headerlink" title="12. k8s的Service是什么"></a>12. k8s的Service是什么</h2><p>Service为一组pod定义一个服务的入口地址，提供给前端用Ingress访问这个集群实例，可以起到服务发现，负载均衡，故障隔离的作用。</p><ol><li>提供服务的稳定入口：Service为前端的应用程序或者ingress提供了稳定的服务入口，这个入口拥有一个全局唯一的虚拟IP地址，前端的应用可以通过这个IP地址访问后端的Pod集群。</li><li>实现负载均衡：Service内部实现了负载均衡机制，它会将所有进入的请求均匀地分配给后端的Pod副本，确保每个请求都能得到正确的响应。</li><li>实现故障隔离：当某个Pod发生故障时，Service会自动将该Pod从服务池中剔除，保证请求不会被故障的Pod处理，从而实现了故障隔离。</li><li>实现服务发现：Service允许前端的应用程序通过Label Selector来找到提供特定服务的Pod，从而实现了服务的自动发现。</li></ol><h2 id="13-Pod周期和状态是什么"><a href="#13-Pod周期和状态是什么" class="headerlink" title="13. Pod周期和状态是什么"></a>13. Pod周期和状态是什么</h2><p>周期：创建启动运行停止<br>状态：Pending/Running Succeed/Failed Unknown</p><h1 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h1><h2 id="1-pod的原理"><a href="#1-pod的原理" class="headerlink" title="1. pod的原理"></a>1. pod的原理</h2><h2 id="2-pod的特点"><a href="#2-pod的特点" class="headerlink" title="2. pod的特点"></a>2. pod的特点</h2><p>一个pod是一个最小的部署单元，容器的组合体，这些容器共享网络命名空间和存储卷，并共享生命周期</p><h2 id="3-pause容器作用"><a href="#3-pause容器作用" class="headerlink" title="3. pause容器作用"></a>3. pause容器作用</h2><h2 id="4-pod的重启策略"><a href="#4-pod的重启策略" class="headerlink" title="4. pod的重启策略"></a>4. pod的重启策略</h2><p>在yaml文件的restartPolicy字段定义，默认是always</p><ul><li>Always（总是重启）：<br>当容器退出时，无论是正常退出还是异常退出，Kubernetes 将总是重启该容器。这是默认的重启策略。</li><li>OnFailure（仅在失败时重启）：<br>当容器以非零的退出代码（表示失败）退出时，Kubernetes 将自动重启该容器。如果容器以零的退出代码（表示成功）退出，Pod 将不会被重启。</li><li>ever（永不重启）：<br>当容器退出时，无论是以何种退出代码，Kubernetes 将不会重启该容器。这通常用于一次性任务，确保任务完成后不会再次启动。</li></ul><h2 id="5-pod的镜像拉取策略"><a href="#5-pod的镜像拉取策略" class="headerlink" title="5. pod的镜像拉取策略"></a>5. pod的镜像拉取策略</h2><p>也是三种策略</p><h2 id="6-pod的存活探针有哪几种"><a href="#6-pod的存活探针有哪几种" class="headerlink" title="6. pod的存活探针有哪几种"></a>6. pod的存活探针有哪几种</h2><ul><li>HTTP 探针通过向容器的指定端口发送 HTTP 请求来检查容器的存活状态。如果返回的 HTTP 状态码表示成功（在指定的范围内），则认为容器是存活的。</li><li>TCP 探针通过尝试与容器的指定端口建立 TCP 连接来检查容器的存活状态。如果连接成功，则认为容器是存活的。</li><li>Exec 探针通过在容器内执行指定的命令来检查容器的存活状态。如果执行成功，即命令返回零退出码，则认为容器是存活的。<h2 id="7-存活探针的属性参数"><a href="#7-存活探针的属性参数" class="headerlink" title="7. 存活探针的属性参数"></a>7. 存活探针的属性参数</h2><h2 id="8-pod的就绪探针有哪几种"><a href="#8-pod的就绪探针有哪几种" class="headerlink" title="8. pod的就绪探针有哪几种"></a>8. pod的就绪探针有哪几种</h2><h2 id="9-就绪探针的属性参数"><a href="#9-就绪探针的属性参数" class="headerlink" title="9. 就绪探针的属性参数"></a>9. 就绪探针的属性参数</h2><h2 id="10-就绪探针和存活探针的区别是什么"><a href="#10-就绪探针和存活探针的区别是什么" class="headerlink" title="10.就绪探针和存活探针的区别是什么"></a>10.就绪探针和存活探针的区别是什么</h2></li><li>存活探针是将检查失败的容器杀死，创建新的启动容器来保持pod正常工作</li><li>就绪探针是，当就绪探针检查失败，并不重启容器，而是将pod移出endpoint，<strong>就绪探针确保了service 中的pod都是可用的</strong>，确保客户端只与正常的pod交互并且客户端永远不会知道系统存在问题<h2 id="11-pod创建过程"><a href="#11-pod创建过程" class="headerlink" title="11. pod创建过程"></a>11. pod创建过程</h2></li></ul><ol><li><p>kubectl run 创建pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、首先，用户通过kubectl或其他api客户端工具提交需要创建的pod信息给apiserver; </span><br><span class="line">2、apiserver验证客户端的用户权限信息，验证通过开始处理创建请求生成pod对象信息，并将信息存入 etcd，然后返回确认信息给客户端; </span><br><span class="line">3、apiserver开始反馈etcd中pod对象的变化，其他组件使用watch机制跟踪apiserver上的变动; </span><br><span class="line">4、scheduler发现有新的pod对象要创建，开始调用内部算法机制为pod分配最佳的主机，并将结果信息 更新至apiserver; </span><br><span class="line">5、node节点上的kubelet通过watch机制跟踪apiserver发现有pod调度到本节点，尝试调用docker启动 容器，并将结果反馈apiserver;</span><br><span class="line">6、apiserver将收到的pod状态信息存入etcd中。</span><br></pre></td></tr></table></figure></li><li><p>使用deployment创建pod</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、kubectl apply -f mydeployment.yaml</span><br><span class="line"></span><br><span class="line">2、api-server收到创建资源的请求后，会对客户端操作进行身份认证，在客户端的~/.kube文件夹下，已 经设置好了相关的用户认证信息，这样api-server会知道我是哪个用户，并对此用户进行鉴权，当api- server确定客户端的请求合法后，就会接受本次操作，并把相关的信息保存到etcd中，然后返回确认信 息给客户端。 </span><br><span class="line"></span><br><span class="line">3、apiserver开始反馈etcd中过程创建的对象的变化，其他组件使用watch机制跟踪apiserver上的变动。</span><br><span class="line"></span><br><span class="line">4、controller-manager组件会监听api-server的信息，controller-manager是有多个类型的，比如 Deployment Controller, 它的作用就是负责监听Deployment，此时Deployment Controller发现有新的deployment要创建，那么它就会去创建一个ReplicaSet，一个ReplicaSet的产生，又被另一个叫做 ReplicaSet Controller监听到了，紧接着它就会去分析ReplicaSet的语义，它了解到是要依照ReplicaSet 的template去创建Pod, 它一看这个Pod并不存在，那么就新建此Pod，当Pod刚被创建时，它的 nodeName属性值为空，代表着此Pod未被调度。 </span><br><span class="line"></span><br><span class="line">5、调度器Scheduler组件开始介入工作，Scheduler也是通过watch机制跟踪apiserver上的变动，发现 有未调度的Pod，则根据内部算法、节点资源情况，pod定义的亲和性反亲和性等等，调度器会综合的选 出一批候选节点，在候选节点中选择一个最优的节点，然后将pod绑定该该节点，将信息反馈给api- server。</span><br><span class="line"></span><br><span class="line">6、kubelet组件布署于Node之上，它也是通过watch机制跟踪apiserver上的变动，监听到有一个Pod应 该要被调度到自身所在Node上来，kubelet首先判断本地是否在此Pod，如果不存在，则会进入创建Pod 流程，创建Pod有分为几种情况，第一种是容器不需要挂载外部存储，则相当于直接docker run把容器 启动，但不会直接挂载docker网络，而是通过CNI调用网络插件配置容器网络，如果需要挂载外部存 储，则还要调用CSI来挂载存储。kubelet创建完pod，将信息反馈给api-server，api-servier将pod信息 写入etcd</span><br><span class="line"></span><br><span class="line">7、Pod建立成功后，ReplicaSet Controller会对其持续进行关注，如果Pod因意外或被我们手动退出， ReplicaSet Controller会知道，并创建新的Pod，以保持replicas数量期望值。</span><br></pre></td></tr></table></figure><h2 id="12-pod的终止过程"><a href="#12-pod的终止过程" class="headerlink" title="12.pod的终止过程"></a>12.pod的终止过程</h2><ol><li>用户向apiserver发送pod删除的命令</li><li>kubectl监控pod为terminating状态，就启动关闭pod过程</li><li>endpoint控制器监控pod对象的关闭行为时，讲所有资源从endpoint列表删除</li><li>如果当前pod对象定义了preStop钩子处理器，则在其被标记为terminating后会意同步的方式启动执行</li><li>pod对象容器进程收到了停止信息</li><li>宽限期过后，kubelet请求apiserver讲pod资源宽限期设0，对用户不可见<h2 id="13-pod的初始化容器-init-container"><a href="#13-pod的初始化容器-init-container" class="headerlink" title="13. pod的初始化容器 init container"></a>13. pod的初始化容器 init container</h2></li></ol><ul><li>负责在主应用容器启动之前执行一些预处理工作或者初始化任务，挂载volume，等待外部服务就绪，安全检查等<h2 id="14-pod的资源请求、限制如何定义"><a href="#14-pod的资源请求、限制如何定义" class="headerlink" title="14.pod的资源请求、限制如何定义"></a>14.pod的资源请求、限制如何定义</h2>resources下的limits和requests，cpu核数和内存大小<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><h2 id="1-service如何与pod关联"><a href="#1-service如何与pod关联" class="headerlink" title="1. service如何与pod关联"></a>1. service如何与pod关联</h2>pod后跟了label，然后service使用标签选择器，selector选择关联哪些pod作为后段<h2 id="2-service的域名解析格式"><a href="#2-service的域名解析格式" class="headerlink" title="2. service的域名解析格式"></a>2. service的域名解析格式</h2><code>&lt;service-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code></li><li><code>&lt;service-name&gt;</code> 是服务的名称，是在创建服务时指定的。</li><li><code>&lt;namespace&gt;</code> 是服务所在的命名空间，默认为 “default”。</li><li><code>&lt;cluster-domain&gt;</code> 是集群的域名，通常为 “cluster.local”。<h2 id="3-service的类型"><a href="#3-service的类型" class="headerlink" title="3. service的类型"></a>3. service的类型</h2></li></ul><p><strong>一般情况下service都是ClusterIP类型的，通过ingress接入的外部流量</strong></p><ol><li>ClusterIP：仅供集群内部使用，默认ClusterIP</li><li>NodePort：service可以对外访问应用，在每个节点暴露一个端口，外部访问任意NodeIP:port就可以脸上service</li><li>LoadBalancer：service对外访问应用，公有云环境下，需要公网IP地址</li><li>ExternalName:这种类型的service会把集群外部的服务引入集群内部，这样集群内直接访问service就 可以间接的使用集群外部服务了<h2 id="4-一个应用pod如何连接service"><a href="#4-一个应用pod如何连接service" class="headerlink" title="4. 一个应用pod如何连接service"></a>4. 一个应用pod如何连接service</h2></li><li>环境变量，配置注入</li><li>DNS方式，k8s集群内有DNS服务器<h2 id="5-如何创建一个service代理外部的服务-集群内的应用如何访问外部的数据库服务？"><a href="#5-如何创建一个service代理外部的服务-集群内的应用如何访问外部的数据库服务？" class="headerlink" title="5. 如何创建一个service代理外部的服务/集群内的应用如何访问外部的数据库服务？"></a>5. 如何创建一个service代理外部的服务/集群内的应用如何访问外部的数据库服务？</h2>创建一个没有标签选择器的service代理集群外部服务。</li><li>创建service时不指定selector，没了selector就不会自动创建endpoint</li><li>手动创建一个<strong>与service同名的</strong>endpoint，在这个endpoint里定义外部服务的IP和端口，然后就自动关联了<h2 id="6-service-endpoint-kubeproxy的关系"><a href="#6-service-endpoint-kubeproxy的关系" class="headerlink" title="6. service endpoint kubeproxy的关系"></a>6. service endpoint kubeproxy的关系</h2></li></ol><ul><li><strong>service</strong>:在kubernetes中，service是一种为一组功能相同的pod提供单一不变的接入点的资源。当 service被建立时，service的IP和端口不会改变，这样外部的客户端(也可以是集群内部的客户端)通过 service的IP和端口来建立链接，这些链接会被路由到提供该服务的任意一个pod上。通过这样的方式， 客户端不需要知道每个单独提供服务的pod地址，这样pod就可以在集群中随时被创建或销毁。 </li><li><strong>endpoint</strong>:service维护一个叫endpoint的资源列表，endpoint资源对象保存着service关联的pod的ip和 端口。从表面上看，当pod消失，service会在endpoint列表中剔除pod，当有新的pod加入，service就 会将pod ip加入endpoint列表;但是正在底层的逻辑是，endpoint的这种自动剔除、添加、更新pod的 地址其实底层是由endpoint controller控制的，endpoint controller负责监听service和对应的pod副本 的变化，如果监听到service被删除，则删除和该service同名的endpoint对象，如果监听到新的service 被创建或者修改，则根据该service信息获取得相关pod列表，然后创建或更新service对应的endpoint对 象，如果监听到pod事件，则更新它所对应的service的endpoint对象。 </li><li><strong>kube-proxy</strong>:kube-proxy运行在node节点上，在Node节点上实现Pod网络代理，维护网络规则和四层 负载均衡工作，kube-proxy会监听api-server中从而获取service和endpoint的变化情况，创建并维护路 由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能 是将到某个Service的访问请求转发到后端的多个Pod实例上<h2 id="kubelet的功能和作用"><a href="#kubelet的功能和作用" class="headerlink" title="kubelet的功能和作用"></a>kubelet的功能和作用</h2></li></ul><ol><li>Node管理，kubelet启动时向kubeproxy注册，定时向apiserver汇报节点和资源状态</li><li>Pod管理，kubelet维护pod的生命周期，当kubelet监听到master的下发到自己节点的任务时，比如要创建、更新、删除一个pod，kubelet 就会通过CRI(容器运行时接口)插件来调用不同的容器运行时来创建、更新、删除容器。</li><li>容器健康检查。Pod中可以定义<strong>启动探针-存活探针-就绪探针</strong>，定期调用容器的探针检测Pod的生命周期，对失败的容器进行重启等操作</li><li>在Node上部署Metrics server进行资源监控<h2 id="kube-apiserver的功能和作用，端口号是8080和6443"><a href="#kube-apiserver的功能和作用，端口号是8080和6443" class="headerlink" title="kube-apiserver的功能和作用，端口号是8080和6443"></a>kube-apiserver的功能和作用，端口号是8080和6443</h2>在命名空间的kube-system命名空间里，有一个名称为kube-api-master的pod，这个pod就是运行着 kube-api-server进程，它绑定了master主机的ip地址和6443端口，但是在default命名空间下，存在一个叫kubernetes的服务，该服务对外暴露端口为443，目标端口6443，这个服务的ip地址是clusterip地 址池里面的第一个地址，同时这个服务的yaml定义里面并没有指定标签选择器，也就是说这个 kubernetes服务所对应的endpoint是手动创建的，该endpoint也是名称叫做kubernetes，该endpoint 的yaml定义里面代理到master节点的6443端口，也就是kube-api-server的IP和端口。这样一来，其他 pod 访问kube-api-server的整个流程就是: pod创建后嵌入了环境变量，pod获取到了kubernetes这个服务的ip和443端口，请求到kubernetes这个服务其实就是转发到了master节点上的6443端口的kube-api-server这个pod里面<h2 id="pod挂了，原本到这个pod的流量要怎么办【面试题】"><a href="#pod挂了，原本到这个pod的流量要怎么办【面试题】" class="headerlink" title="pod挂了，原本到这个pod的流量要怎么办【面试题】"></a>pod挂了，原本到这个pod的流量要怎么办【面试题】</h2>首先请求到<br>kubelet用存活探针检测到这个pod挂了，<h2 id="k8s的namespace是什么"><a href="#k8s的namespace是什么" class="headerlink" title="k8s的namespace是什么"></a>k8s的namespace是什么</h2>实现多套环境的资源隔离，限定不同租户能占用的资源，比如CPU和内存Usage等</li></ol><h2 id="持续集成CI的好处，用途是什么"><a href="#持续集成CI的好处，用途是什么" class="headerlink" title="持续集成CI的好处，用途是什么"></a>持续集成CI的好处，用途是什么</h2><p>用于整合团队开发 中不同开发者提交到开发仓库 中的项目代码变化，并即时整合编译，检查整合 编译错误的服务。它需要一天中多次整合编译代码的能力，若出现整合错误， 可以优异地准确定位提交错误源</p><h2 id="14-Docker-Swarm？docker集群"><a href="#14-Docker-Swarm？docker集群" class="headerlink" title="14. Docker Swarm？docker集群"></a>14. Docker Swarm？docker集群</h2><p><strong>是原生的 Docker 集群服务工具。</strong>它将一群 Docker 主机集成为单一一个 虚拟 Docker 主机。利用一个 Docker 守护进程， 通过标准的 Docker API 和任何完善的通讯工具， Docker Swarm 提供透明地将 Docker 主机扩散到多台主机上的服务</p><h2 id="15-Docker-Compose？"><a href="#15-Docker-Compose？" class="headerlink" title="15. Docker Compose？"></a>15. Docker Compose？</h2><h2 id="16-Dockerfile里，ADD和COPY"><a href="#16-Dockerfile里，ADD和COPY" class="headerlink" title="16. Dockerfile里，ADD和COPY"></a>16. Dockerfile里，ADD和COPY</h2><p>差不多，都用来向镜像加文件，一般就COPY就行<br>有必要使用 ADD 指令的最好例子是需要在本地自动解压归档文件到容器中的情况，如 ADD rootfs.tar.xz 。</p><h2 id="17-Dockerfile里，ONBUILD命令"><a href="#17-Dockerfile里，ONBUILD命令" class="headerlink" title="17 Dockerfile里，ONBUILD命令"></a>17 Dockerfile里，ONBUILD命令</h2><p>构建阶段的触发器，当一个镜像被用作另一个镜像的基础镜像时，ONBUILD 指令将在构建过程中自动触发，一般后接一些COPY命令。</p><p>## </p><h2 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h2><p>主要指在发生硬件故障时，通过备份和恢复机制保证业务连续性（能够继续正常运行）的手段。适用于对业务连续性要求非常高的场景。</p><h2 id="【场景】pod都处于pending状态，调度器失败，pv没做好，无法创建存储卷"><a href="#【场景】pod都处于pending状态，调度器失败，pv没做好，无法创建存储卷" class="headerlink" title="【场景】pod都处于pending状态，调度器失败，pv没做好，无法创建存储卷"></a>【场景】pod都处于pending状态，调度器失败，pv没做好，无法创建存储卷</h2><ul><li>使用kubectl describe podname</li><li>长时间都在pending，可能是schduler无法为pod分配node，Scheduer调度器无法为pod分配一个合适的node节点。而这又会有很多种情况， 比如，node节点处在cpu、内存压力，导致无节点可调度;pod定义了资源请求，没有node节点满足资 源请求;node节点上有污点而pod没有定义容忍;pod中定义了亲和性或反亲和性而没有节点满足这些 亲和性或反亲和性;以上是调度器调度失败的几种情况。</li><li>pvc，pv无法动态创建。比如要使用StatefulSet 创建redis集群，因为粗心大意，定义的storageClassName名称写错了，那么会造成 无法创建pvc，这种情况pod也会一直处于pending状态，或者，即使pvc是正常创建了，但是由于某些异 常原因导致动态供应存储无法正常创建pv，那么这种情况pod也会一直处于pending状态</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇为OverView，内容包括kubectl的基础操作，整理的知识框架基于kubernetes官方文档&lt;a href=&quot;https://kubernetes.io/docs/tutorials/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;v1.26&lt;/a&gt;， 元旦期间系统整理一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Kubernetes" scheme="http://waynamigo.github.io/categories/Kubernetes/"/>
    
    
      <category term="CloudComputing" scheme="http://waynamigo.github.io/tags/CloudComputing/"/>
    
      <category term="Kubernetes" scheme="http://waynamigo.github.io/tags/Kubernetes/"/>
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Golang</title>
    <link href="http://waynamigo.github.io/2023/01/01/2023-01-02-%E9%9D%A2%E7%BB%8FGo/"/>
    <id>http://waynamigo.github.io/2023/01/01/2023-01-02-面经Go/</id>
    <published>2022-12-31T16:00:00.000Z</published>
    <updated>2023-12-02T03:39:58.367Z</updated>
    
    <content type="html"><![CDATA[<p>总 ：<a href="https://www.bookstack.cn/read/qcrao-Go-Questions/interface.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/qcrao-Go-Questions/interface.md</a></p><a id="more"></a><h1 id="不要通过共享内存来通信，要通过通信来共享内存"><a href="#不要通过共享内存来通信，要通过通信来共享内存" class="headerlink" title="不要通过共享内存来通信，要通过通信来共享内存"></a>不要通过共享内存来通信，要通过通信来共享内存</h1><ul><li>降低共享内存的使用，本来就是解耦和的重要手段之一</li><li>理解时go使用主动的channel通信以最小限度使用这些存在channel里的内存空间，与其他通信的goroutine共享这个channel，范围可以控制在必要的最小规模；而不是先设定好共享内存，再其他开发过程中通过互斥锁、条件变量等方式提供给不同线程去共享内容，导致<h2 id="阐述golang并发机制"><a href="#阐述golang并发机制" class="headerlink" title="阐述golang并发机制"></a>阐述golang并发机制</h2></li><li>goroutine</li><li>channel</li><li>waitgroup管理goroutine<h2 id="为什么小对象多了会造成gc压力"><a href="#为什么小对象多了会造成gc压力" class="headerlink" title="为什么小对象多了会造成gc压力"></a>为什么小对象多了会造成gc压力</h2></li></ul><ol><li>内存碎片</li><li>gc时会移堆，将对象从一个堆移动到另一个堆（内存拷贝）</li><li>标记的内存块也变多了，遍历的时间变长了<h2 id="gc的触发条件"><a href="#gc的触发条件" class="headerlink" title="gc的触发条件"></a>gc的触发条件</h2></li><li>内存使用量超阈值，这个阈值可以用debug.ReadGCStats的包来看，</li><li>使用runtime.GC手动触发<h2 id="gc的栈空间管理机制是什么"><a href="#gc的栈空间管理机制是什么" class="headerlink" title="gc的栈空间管理机制是什么"></a>gc的栈空间管理机制是什么</h2></li><li>runtime负责</li><li>每个goroutine分配一个固定栈空间，大小大概在2kb到4kb左右</li><li>栈空间不够时，runtime自动扩展栈的大小，回收时runtime回收栈空间变量<h2 id="defer原理"><a href="#defer原理" class="headerlink" title="defer原理"></a>defer原理</h2>defer的原理是先进后出的，遇到defer时，将defer后的函数用语句进行压栈处理。</li></ol><ul><li><strong>底层实现</strong><br>每个 defer 语句都对应一个_defer 实例，多个实例使用指针连接起来形成一个单连表，保存在 gotoutine 数据结构中，每次插入_defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成后进先出的效果。</li></ul><h2 id="select原理，多路复用机制"><a href="#select原理，多路复用机制" class="headerlink" title="select原理，多路复用机制"></a>select原理，多路复用机制</h2><p>监听多个channel，与linux多路复用的select区别是linux的select是轮训一个数组，golang是基于事件驱动，有通信操作是才执行时才会进行操作</p><ol><li>有多个case执行，随机选一个执行，</li><li>case都不满足，执行default，再不满足就阻塞<h2 id="go的逃逸分析"><a href="#go的逃逸分析" class="headerlink" title="go的逃逸分析"></a>go的逃逸分析</h2></li></ol><p><strong>是在编译过程中的静态分析机制，优化内存分配</strong>用来决定各个变量分配在堆上还是栈上，如果一个变量在函数内部初始化，但是传递到外部了，就说发生逃逸，分配到heap上</p><h2 id="线程模型有哪些？为什么go-scheduler需要实现M：N方案？scheduler-由哪些元素组成"><a href="#线程模型有哪些？为什么go-scheduler需要实现M：N方案？scheduler-由哪些元素组成" class="headerlink" title="线程模型有哪些？为什么go scheduler需要实现M：N方案？scheduler 由哪些元素组成"></a>线程模型有哪些？为什么go scheduler需要实现M：N方案？scheduler 由哪些元素组成</h2><ul><li>M:N 线程模型：<br>Go 语言采用了 M: N 线程模型。在这个模型中，多个用户线程会映射到少量的操作系统线程上，这些操作系统线程被称为 M（Machine）。同时，Go 语言的调度器（Scheduler）负责在这些 M 之间分发工作。</li></ul><ol><li>灵活，轻量级的用户态goroutine可以避免系统级别的上下文切换开销</li><li>通过runtime去调度，</li></ol><ul><li>组成元素：GPM，本地队列全局队列<h2 id="解释hand-off，work-stealing"><a href="#解释hand-off，work-stealing" class="headerlink" title="解释hand off，work stealing"></a>解释hand off，work stealing</h2>当一个任务队列满，没有空闲的P时，调度器会选择一个空闲的p，直接分配给该处理器执行。</li><li>当一个P执行完自己的任务后，它可以尝试从其他处理器的队列中窃取（steal）一个任务来执行。这样做的目的是使得各个处理器的负载尽量均衡。</li></ul><h2 id="mutex-有几种模式【正常和饥饿】"><a href="#mutex-有几种模式【正常和饥饿】" class="headerlink" title="mutex 有几种模式【正常和饥饿】"></a>mutex 有几种模式【正常和饥饿】</h2><p>正常模式保证了公平竞争，适用于大多数情况，而饥饿模式则优先保证了长时间等待的协程能够获得锁。</p><ul><li>mutex没有提供接口，要引入一个计数器来实现饥饿模式<h2 id="defer和return的先后顺序"><a href="#defer和return的先后顺序" class="headerlink" title="defer和return的先后顺序"></a>defer和return的先后顺序</h2>return先执行获取返回值，然后暂停函数的执行，接下来就按defer的压栈顺序执行defer语句，顺序是后进先出的顺序<h2 id="go-recover的执行时机"><a href="#go-recover的执行时机" class="headerlink" title="go recover的执行时机"></a>go recover的执行时机</h2></li></ul><p><strong>需要进行defer func捕获上级的panic</strong>：<br>recover 必须在 defer 函数中运行。recover 捕获的是祖父级调用时的异常，直接调用时无效。</p><h2 id="闭包错误引用同一个变量问题怎么处理-？"><a href="#闭包错误引用同一个变量问题怎么处理-？" class="headerlink" title="闭包错误引用同一个变量问题怎么处理 ？"></a>闭包错误引用同一个变量问题怎么处理 ？</h2><ol><li>将闭包需要<strong>引用的变量作为参数</strong>传递给闭包函数，而不是直接在闭包内部引用外部变量。</li><li>在闭包函数里创建一个新的临时变量<h2 id="负载因子为什么是6-5"><a href="#负载因子为什么是6-5" class="headerlink" title="负载因子为什么是6.5"></a>负载因子为什么是6.5</h2><a href="https://blog.csdn.net/eddycjy/article/details/120359475" target="_blank" rel="noopener">https://blog.csdn.net/eddycjy/article/details/120359475</a><h2 id="golang中的大端序和小端序"><a href="#golang中的大端序和小端序" class="headerlink" title="golang中的大端序和小端序"></a>golang中的大端序和小端序</h2>大端序是低地址存高字节，高地址存低字节，同时也是网络字节序【大端就是顺序从左到右存放】，解析之后就是字符顺序<br>小端时低地址存低字节，高地址存高字节，是主机序【golang默认小端序，主机x86和arm64都是小端】，小端主机虚，符合电路的读取逻辑</li></ol><h2 id="syncOnce是什么【确保一个代码块只执行一次，一般用来实现一个线程安全的单例模式】"><a href="#syncOnce是什么【确保一个代码块只执行一次，一般用来实现一个线程安全的单例模式】" class="headerlink" title="syncOnce是什么【确保一个代码块只执行一次，一般用来实现一个线程安全的单例模式】"></a>syncOnce是什么【确保一个代码块只执行一次，一般用来实现一个线程安全的单例模式】</h2><h2 id="routine为什么比thread轻量"><a href="#routine为什么比thread轻量" class="headerlink" title="routine为什么比thread轻量"></a>routine为什么比thread轻量</h2><ol><li>routine是纯用户态调度，非抢占，由runtime管理，创建，切换的开销不需要内核态参与</li><li>协程在同一个地址空间共享堆栈，每个线程都有自己独立的堆栈<h2 id="为什么要用协程，好处是什么"><a href="#为什么要用协程，好处是什么" class="headerlink" title="为什么要用协程，好处是什么"></a>为什么要用协程，好处是什么</h2>go的协程是为了解决多核CPU利用率问题，go语言层面并不支持多进程或多线程，但是协程更好用，<strong>协程被称为用户态线程</strong>，CPU上下文切换效率非常高。几乎所有IO密集型的应用，都可以利用协程提高速度<h2 id="原子操作和锁的区别"><a href="#原子操作和锁的区别" class="headerlink" title="原子操作和锁的区别"></a>原子操作和锁的区别</h2></li><li>原子操作是对共享变量的单一操作，要么执行完药么全不执行；锁对一段临界区代码，操作的变量可以有一堆</li><li>原子操作开销小，锁开销较大，涉及到上下文切换等<h2 id="go的多返回值如何实现"><a href="#go的多返回值如何实现" class="headerlink" title="go的多返回值如何实现"></a>go的多返回值如何实现</h2><h2 id="uintptr和unsafe-Pointer的区别"><a href="#uintptr和unsafe-Pointer的区别" class="headerlink" title="uintptr和unsafe.Pointer的区别"></a>uintptr和unsafe.Pointer的区别</h2></li></ol><ul><li><strong>uintptr</strong>：将指针转换整数表示，不包含指针的类型信息。</li><li><strong>unsafe.Pointer</strong>：包含任意类型指针，将任意类型的指针转换为通用指针类型，很灵活<br>uintptr 是一个整数类型，它被用于<strong>存储指针的整数表示</strong>形式。<br>使用 uintptr 可以<strong>将指针转换为整数，也可以将整数转换为指针</strong>，但这种转换是不安全的，可能会导致未定义的行为。<br>因为 uintptr 只是整数，<strong>不包含指针的类型信息</strong>，因此在转换后需要谨慎使用，可能会导致类型不匹配或内存安全问题。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">uintptrValue := <span class="keyword">uintptr</span>(unsafe.Pointer(p))</span><br></pre></td></tr></table></figure><ul><li><strong>unsafe.Pointer</strong><br>unsafe.Pointer 是一个特殊的指针类型，它可以包含任意类型的指针，并允许在不进行类型检查的情况下进行指针操作。<br>使用 unsafe.Pointer 可以将任意类型的指针转换为通用的指针类型，也可以将通用指针转换为具体类型的指针。这种转换也是不安全的，可能会导致未定义的行为。<br>示例：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">pointerValue := unsafe.Pointer(p)</span><br></pre></td></tr></table></figure></li></ul><h2 id="switch中如何强制执行下一个case块【fallthrough关键字，忽略后续条件的判断，直接执行下一个-case-的代码】"><a href="#switch中如何强制执行下一个case块【fallthrough关键字，忽略后续条件的判断，直接执行下一个-case-的代码】" class="headerlink" title="switch中如何强制执行下一个case块【fallthrough关键字，忽略后续条件的判断，直接执行下一个 case 的代码】"></a>switch中如何强制执行下一个case块【fallthrough关键字，忽略后续条件的判断，直接执行下一个 case 的代码】</h2><h2 id="如何关闭http响应体"><a href="#如何关闭http响应体" class="headerlink" title="如何关闭http响应体"></a>如何关闭http响应体</h2><p>在defer里close，或者用完就close</p><h2 id="解析json时，默认将数值当作哪种类型【数值默认为float64】"><a href="#解析json时，默认将数值当作哪种类型【数值默认为float64】" class="headerlink" title="解析json时，默认将数值当作哪种类型【数值默认为float64】"></a>解析json时，默认将数值当作哪种类型【数值默认为float64】</h2><h2 id="如何从panic中恢复"><a href="#如何从panic中恢复" class="headerlink" title="如何从panic中恢复"></a>如何从panic中恢复</h2><p>defer func(){ recover() }</p><h2 id="解释一下静态类型声明"><a href="#解释一下静态类型声明" class="headerlink" title="解释一下静态类型声明"></a>解释一下静态类型声明</h2><p>golang生命变量时是<strong>在编译阶段确定类型</strong></p><h2 id="Golang的可变参数是什么，怎么用，要注意什么"><a href="#Golang的可变参数是什么，怎么用，要注意什么" class="headerlink" title="Golang的可变参数是什么，怎么用，要注意什么"></a>Golang的可变参数是什么，怎么用，要注意什么</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    total := nums[<span class="number">0</span>]+<span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line">sum()</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>可变参数必须是函数参数列表的最后一个参数：如果函数有多个参数，可变参数必须放在参数列表的最后。</li><li>可变参数可以不传递：如果调用者不传递任何参数，可变参数会被初始化为空切片。</li><li>可变参数可以传递多个值：可以传递任意数量的参数，甚至可以传递零个。</li><li>调用时可以传递切片：如果已经有一个切片，可以在调用函数时使用 … 操作符将其展开为可变参数。<h2 id="golang支持接口的多继承（C-extends-A-and-C）吗【不支持，依靠组合实现】"><a href="#golang支持接口的多继承（C-extends-A-and-C）吗【不支持，依靠组合实现】" class="headerlink" title="golang支持接口的多继承（C extends A and C）吗【不支持，依靠组合实现】"></a>golang支持接口的多继承（C extends A and C）吗【不支持，依靠组合实现】</h2></li></ol><h2 id="go多返回值"><a href="#go多返回值" class="headerlink" title="go多返回值"></a>go多返回值</h2><p>go多返回值是通过栈传递的。将多个返回值先传回参数上，函数栈帧销毁后并不会销毁参数部分（这里用作返回值），再将参数部分进行拷贝然后再参与运算</p><h2 id="简述scheduler函数"><a href="#简述scheduler函数" class="headerlink" title="简述scheduler函数"></a>简述scheduler函数</h2><p>runtime.Gosched()：<br>Gosched() 函数手动触发一次调度，它会将当前 Goroutine 放回队列并让其他等待执行的 Goroutine 有机会运行。这个函数主要用于释放一些处理器资源给其他 Goroutines 使用。</p><h2 id="简述全局运行队列中获取goroutine的时机【其他本地队列中没有可stealing的】"><a href="#简述全局运行队列中获取goroutine的时机【其他本地队列中没有可stealing的】" class="headerlink" title="简述全局运行队列中获取goroutine的时机【其他本地队列中没有可stealing的】"></a>简述全局运行队列中获取goroutine的时机【其他本地队列中没有可stealing的】</h2><h2 id="简述如何从工作线程的本底运行队列中获取routine【运行队列为空时】"><a href="#简述如何从工作线程的本底运行队列中获取routine【运行队列为空时】" class="headerlink" title="简述如何从工作线程的本底运行队列中获取routine【运行队列为空时】"></a>简述如何从工作线程的本底运行队列中获取routine【运行队列为空时】</h2><h2 id="init是什么时候执行的【包初始化阶段，程序开始执行前】"><a href="#init是什么时候执行的【包初始化阶段，程序开始执行前】" class="headerlink" title="init是什么时候执行的【包初始化阶段，程序开始执行前】"></a>init是什么时候执行的【包初始化阶段，程序开始执行前】</h2><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="1-map的key为什么无序，如何处理冲突的【链地址法】"><a href="#1-map的key为什么无序，如何处理冲突的【链地址法】" class="headerlink" title="1. map的key为什么无序，如何处理冲突的【链地址法】"></a>1. map的key为什么无序，如何处理冲突的【链地址法】</h2><p>底层用hash实现的，维护了一个hmap和bmap，bmap是bucket存实际的key，</p><h2 id="2-map可以边遍历边删元素吗【不能】为什么"><a href="#2-map可以边遍历边删元素吗【不能】为什么" class="headerlink" title="2. map可以边遍历边删元素吗【不能】为什么"></a>2. map可以边遍历边删元素吗【不能】为什么</h2><p>线程不安全，删除的时候会导致存储结构发生变化，</p><h2 id="3-float类型可以作为key吗，哪些不可以作为map的key"><a href="#3-float类型可以作为key吗，哪些不可以作为map的key" class="headerlink" title="3. float类型可以作为key吗，哪些不可以作为map的key"></a>3. float类型可以作为key吗，哪些不可以作为map的key</h2><p>从语法上看，是可以的。Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、整型、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。<br><strong>channel 也可以当key？</strong></p><h2 id="4-非接口的任意类型都能调用-T方法吗"><a href="#4-非接口的任意类型都能调用-T方法吗" class="headerlink" title="4. 非接口的任意类型都能调用 *T方法吗"></a>4. 非接口的任意类型都能调用 *T方法吗</h2><p>不能吧，至少引用类型不能</p><h2 id="5-map的赋值过程-底层用了mapassign函数"><a href="#5-map的赋值过程-底层用了mapassign函数" class="headerlink" title="5. map的赋值过程 底层用了mapassign函数"></a>5. map的赋值过程 底层用了mapassign函数</h2><p>对 key 计算 hash 值，根据 hash 值按照之前的流程，找到要赋值的位置（可能是插入新 key，也可能是更新老 key），对相应位置进行赋值。</p><h2 id="6-如何实现两种get操作"><a href="#6-如何实现两种get操作" class="headerlink" title="6. 如何实现两种get操作"></a>6. 如何实现两种get操作</h2><p>map重载了两个函数一个带comma的一个不带comma的</p><h2 id="7-map删除一个key，内存会释放吗【不会，要等gc扫描过来】"><a href="#7-map删除一个key，内存会释放吗【不会，要等gc扫描过来】" class="headerlink" title="7. map删除一个key，内存会释放吗【不会，要等gc扫描过来】"></a>7. map删除一个key，内存会释放吗【不会，要等gc扫描过来】</h2><h2 id="8-解析tag怎么实现的"><a href="#8-解析tag怎么实现的" class="headerlink" title="8. 解析tag怎么实现的"></a>8. 解析tag怎么实现的</h2><p>反射实现的，用Field(i).Tag</p><h2 id="map可以取地址吗【不能】"><a href="#map可以取地址吗【不能】" class="headerlink" title="map可以取地址吗【不能】"></a>map可以取地址吗【不能】</h2><p>本身就是一个指向其他地址的指针，会导致编译错误</p><h2 id="9-rune是int32"><a href="#9-rune是int32" class="headerlink" title="9. rune是int32"></a>9. rune是int32</h2><h2 id="10-值receiver-和-指针receiver的区别"><a href="#10-值receiver-和-指针receiver的区别" class="headerlink" title="10. 值receiver 和 指针receiver的区别"></a>10. 值receiver 和 指针receiver的区别</h2><p>值receiver 是创建结构体的一个副本，不修改原始字段的value<br>指针rcver是在原结构体实例上操作</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">数值类型：</span><br><span class="line">int：有符号整数类型，根据平台可能为32位或64位。</span><br><span class="line">uint：无符号整数类型，根据平台可能为32位或64位。</span><br><span class="line">int8、int16、int32、int64：分别为8位、16位、32位、64位的有符号整数类型。</span><br><span class="line">uint8、uint16、uint32、uint64：分别为8位、16位、32位、64位的无符号整数类型。</span><br><span class="line">float32、float64：分别为32位和64位的浮点数类型。</span><br><span class="line">complex64、complex128：分别为64位和128位的复数类型。</span><br><span class="line">布尔类型：</span><br><span class="line">bool：表示逻辑值，只能取 true 或 false。</span><br><span class="line">字符串类型：</span><br><span class="line">string：表示一串字符，是不可变的。</span><br><span class="line">字符类型：</span><br><span class="line">rune：表示一个Unicode字符。</span><br><span class="line">错误类型：</span><br><span class="line">error：表示错误的接口类型。</span><br><span class="line">派生类型：</span><br><span class="line">byte：实际上是 uint8 的别名，用于表示一个字节的值。</span><br><span class="line">rune：实际上是 int32 的别名，用于表示一个Unicode字符。</span><br><span class="line">uintptr：用于存储一个指针的值，适用于底层编程。</span><br><span class="line">复合类型：</span><br><span class="line">数组（array）：具有固定长度的、相同类型的元素序列。</span><br><span class="line">切片（slice）：是对数组的一个引用，它可以动态增长。</span><br><span class="line">映射（map）：用于存储键-值对的集合，类似于字典或哈希表。</span><br><span class="line">结构体（struct）：可以包含不同类型的字段。</span><br><span class="line">接口（interface）：定义了一组方法的集合。</span><br><span class="line">通道（channel）：用于在多个goroutine之间传递数据。</span><br></pre></td></tr></table></figure><h2 id="1-什么是协程"><a href="#1-什么是协程" class="headerlink" title="1.什么是协程"></a>1.什么是协程</h2><p>是Golang提供的线程调度的基本单位。</p><ul><li>一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会自动伸缩，因此可以轻易实现成千上万个goroutine同时启动。</li><li>每个goroutine（Go程序并发执行的基本单元）都会分配一块独立的栈内存，用于保存函数的局部变量、参数等信息。</li><li>和线程的对比：一个是<strong>切换</strong>管理用runtime，没有内核态参与，<strong>资源</strong>协程共享地址空间；<strong>通信手段</strong> 使用通信共享内存，thread使用共享内存通信</li></ul><h2 id="2-介绍一下channel"><a href="#2-介绍一下channel" class="headerlink" title="2.介绍一下channel"></a>2.介绍一下channel</h2><ul><li>channel时go提供的用于并发编程的特殊类型，使 goroutine 之间的进行数据传递和共享，避免了显式的锁机制，比较安全和高效</li></ul><p><strong>Go以通信的手段来共享内存</strong></p><ul><li>包括有缓冲和无缓冲channel，其中无缓冲是同步的，有缓冲异步的</li><li>底层数据结构是hchan的结构体，内部是一个循环数组</li></ul><h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><p>new分配内存，返回一个指向某类型指针，make创建slice map channel的实例，初始化</p><ul><li>不能用 new() 来创建 slice、map、chan 这样的引用类型。如果用 new() 来创建 slice，那么创建的 header 中的 pointer 做0值处理，就会被初始化为 nil，而 length 和 capacity 也会被初始化为0，这样显然是不正确的。</li></ul><h3 id="【问题】有缓冲channel和无缓冲channel的区别【阻塞情况，同步异步】"><a href="#【问题】有缓冲channel和无缓冲channel的区别【阻塞情况，同步异步】" class="headerlink" title="【问题】有缓冲channel和无缓冲channel的区别【阻塞情况，同步异步】"></a>【问题】有缓冲channel和无缓冲channel的区别【阻塞情况，同步异步】</h3><ul><li>对于无缓冲区channel:<br>发送的数据如果没有被接收方接收，那么发送方阻塞;如果一直接收不到发送方的数据，接收方阻塞;</li><li>有缓冲的channel:<br>发送方在缓冲区满的时候阻塞，接收方不阻塞; 接收方在缓冲区为空的时候阻塞，发送方不阻塞。</li></ul><h3 id="【问题】channel的等待队列如果写满了，内存占用很高，怎么解决"><a href="#【问题】channel的等待队列如果写满了，内存占用很高，怎么解决" class="headerlink" title="【问题】channel的等待队列如果写满了，内存占用很高，怎么解决"></a>【问题】channel的等待队列如果写满了，内存占用很高，怎么解决</h3><ol><li>读协程可能出现问题，去修改</li><li>限制写操作的并发数量，避免大量写</li><li>使用select和超时机制<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- value:</span><br><span class="line">    <span class="comment">// 写入成功</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="【问题】协程泄漏是什么，什么引发的，怎么解决"><a href="#【问题】协程泄漏是什么，什么引发的，怎么解决" class="headerlink" title="【问题】协程泄漏是什么，什么引发的，怎么解决"></a>【问题】协程泄漏是什么，什么引发的，怎么解决</h3><ul><li>程序中创建的某些协程没有被正确地释放或终止（或者发生死锁），从而导致这些协程持续存在并占用资源（阻塞，死锁，无限循环）</li><li><strong>解决方法</strong><ul><li>defer：在需要释放资源的地方使用 defer</li><li>使用go tool trace进行检查<h2 id="3-介绍一下Go语言的内存分配模型：src-runtime-mheap"><a href="#3-介绍一下Go语言的内存分配模型：src-runtime-mheap" class="headerlink" title="3.介绍一下Go语言的内存分配模型：src/runtime/mheap"></a>3.介绍一下Go语言的内存分配模型：src/runtime/mheap</h2></li></ul></li><li>内存分配器：维护一块大的全局内存，每个线程(Golang中为P)维护一块小的私有内存，私有内存不足再从全局申请。</li><li>预申请的内存划分为span（512MB），bitmap（16G），arena（512G堆区域），span和bitmap是管理堆区域，每个页的大小为8KB。<h2 id="4-介绍一下Go的GC机制：以防止内存泄漏"><a href="#4-介绍一下Go的GC机制：以防止内存泄漏" class="headerlink" title="4.介绍一下Go的GC机制：以防止内存泄漏"></a>4.介绍一下Go的GC机制：以防止内存泄漏</h2></li><li>Go使用的是三色标记法，已被引用的被mark表示不可回收，未引用的被回收掉。</li><li>这里的标记由一个管理内存分配的数据结构mspan管理，按内存块维护资源</li><li>mspan这个结构体中，使用allocBits位图表示每个内存块的分配情况，使用gcmarkBits标记内存块被引用的情况</li><li>这里的标记是从<strong>根对象进行递归扫描</strong>记录的，因为存在指针变量和记录的逻辑地址</li><li>标记队列存放待标记的对象，<strong>灰色表示等待，白色未被标记，黑色被标记</strong>，把标记值记录在gcmarkBits中，标记的表示正在被引用<ul><li>白色对象：尚未被访问，处于初始状态。</li><li>灰色对象：已被访问，但其引用还未被访问。</li><li>黑色对象：已被访问，且其引用也已被访问。</li></ul></li><li>STW机制：停掉所有的goroutine，专心做垃圾回收，回收白色对象，结束后恢复goroutine<h3 id="【问题】对STW的优化是什么？混合写，并发垃圾回收"><a href="#【问题】对STW的优化是什么？混合写，并发垃圾回收" class="headerlink" title="【问题】对STW的优化是什么？混合写，并发垃圾回收"></a>【问题】对STW的优化是什么？混合写，并发垃圾回收</h3>Go 通过在后台运行一个专用的垃圾回收线程，与程序的其他部分并发地进行垃圾回收。</li><li>并发标记</li><li>混合写，将并发标记和 STW 结合起来的阶段。在这个阶段，部分垃圾回收工作会在并发进行，同时也会暂停所有 Goroutine 进行一些必要的 STW 操作。</li><li>并发清理<h3 id="混合写导致的问题，为了减少停顿时间"><a href="#混合写导致的问题，为了减少停顿时间" class="headerlink" title="混合写导致的问题，为了减少停顿时间"></a>混合写导致的问题，为了减少停顿时间</h3></li></ul><ol><li>内存和CPU开销，因为要引入额外元信息</li><li>在某些情况下，混合写屏障可能会导致一些额外的延迟，尤其是对于极短寿命的对象，因为它们在逃逸到堆之前可能会留在栈上</li></ol><h3 id="【问题】根对象是什么"><a href="#【问题】根对象是什么" class="headerlink" title="【问题】根对象是什么"></a>【问题】根对象是什么</h3><p>在Go语言中，<strong>全局变量、栈上的变量以及程序计数器指向的对象</strong>等都被认为是根对象。</p><p>垃圾回收器会从这些根对象出发，逐步遍历所有可以访问到的对象，并标记它们。</p><h3 id="【问题】goroutine-可以无限创建吗，如果创建过多会有什么后果？从GC的角度来考虑"><a href="#【问题】goroutine-可以无限创建吗，如果创建过多会有什么后果？从GC的角度来考虑" class="headerlink" title="【问题】goroutine 可以无限创建吗，如果创建过多会有什么后果？从GC的角度来考虑"></a>【问题】goroutine 可以无限创建吗，如果创建过多会有什么后果？从GC的角度来考虑</h3><p>理论上可以无限创建，取决于操作系统的限制，比如内存大小</p><ul><li>goroutine执行完会产生垃圾，增大gc压力</li><li>标记阶段时会遍历对象，goroutine多了会导致标记的压力增加</li><li>停顿时间变长：需要回收大量的内存，可能会导致垃圾回收器的停顿时间变长<h3 id="【TIPs】在程序中要避免在短时间内产生大量临时对象，以减小垃圾回收的压力。"><a href="#【TIPs】在程序中要避免在短时间内产生大量临时对象，以减小垃圾回收的压力。" class="headerlink" title="【TIPs】在程序中要避免在短时间内产生大量临时对象，以减小垃圾回收的压力。"></a>【TIPs】在程序中要避免在短时间内产生大量临时对象，以减小垃圾回收的压力。</h3></li></ul><h3 id="如何优化STW机制"><a href="#如何优化STW机制" class="headerlink" title="如何优化STW机制"></a>如何优化STW机制</h3><ul><li>混合写屏障：类似于一种开关，在GC的特定时机开启，开启后指针传递时会把指针标记，即 本轮不回收，下次GC时再确定</li><li>辅助GC：新分配的goroutine如果要分配内存，那就去辅助完成一部分gc工作，也就是自己的资源自己挣的感觉</li></ul><h2 id="4-介绍一下GMP"><a href="#4-介绍一下GMP" class="headerlink" title="4.介绍一下GMP"></a>4.介绍一下GMP</h2><ol><li>G : 协程   goroutine</li><li>P : 处理器 processor ： 和M一对一，runtime.Gomaxprocs配置 </li><li>M : 线程   thread    ：runtime.setMaxThreads最大10000个，<ol><li>有一个M阻塞，会创建一个新M</li><li>有M空闲，就回收或睡眠M</li></ol></li></ol><ul><li>线程是运行 goroutine 的实体，调度器的功能是把可运行的 G 分配到工作线程<br>M 上</li><li>全局队列：存放正在等待运行的G</li><li>本地队列：不超过256个G<h2 id="【问题】调度器P的workstealing机制和handoff机制"><a href="#【问题】调度器P的workstealing机制和handoff机制" class="headerlink" title="【问题】调度器P的workstealing机制和handoff机制"></a>【问题】调度器P的workstealing机制和handoff机制</h2></li><li>work stealing<ul><li>当本线程M没有可运行的G时，尝试从其他线程绑定的P中偷G</li><li>当从其他线程偷不到时，从全局队列偷取（为什么？因为全局队列有锁）</li></ul></li><li>hand off<ul><li>当本线程M因为有G阻塞时，会释放自己的P给另一个唤醒/新建的M执行（runtime调度器来做detach）</li></ul></li></ul><h2 id="【问题】go-func-的执行流程"><a href="#【问题】go-func-的执行流程" class="headerlink" title="【问题】go func(){} 的执行流程"></a>【问题】go func(){} 的执行流程</h2><ol><li>创建一个G，优先加入到func所在线程M对应P的本底队列中，满了的话，放在全局队列中</li><li>G运行在M中，如果本地G队列为空，就去其他M P组合去偷</li><li>【问题】当M系统调用结束时，所属的G会尝试获取一个空闲P去执行，并加入到这个P的G队列，如果找不到，就休眠这个M，并将这个G加入到全局队列</li></ol><h2 id="【问题】Go的生命周期-M0，G0是什么"><a href="#【问题】Go的生命周期-M0，G0是什么" class="headerlink" title="【问题】Go的生命周期 M0，G0是什么"></a>【问题】Go的生命周期 M0，G0是什么</h2><p><strong>M0</strong></p><ul><li>M0指程序启动时，编号为0主线程，runtime的M0</li><li>M0负责初始化和启动第一个G</li><li>启动G之后，和其他M地位一样了</li></ul><p><strong>G0</strong></p><ul><li>每次启动一个M，都会有一个G0</li><li>G0仅负责调度其他的G1，G2</li><li>G0本身不执行任何func</li><li>G1执行完，先执行G0，G0再切换其他的G2</li></ul><h3 id="【场景1】G1嵌套创建G3"><a href="#【场景1】G1嵌套创建G3" class="headerlink" title="【场景1】G1嵌套创建G3"></a>【场景1】G1嵌套创建G3</h3><p>保证局部性，G3优先加入G1所在的本底队列，满了的话看场景3</p><h3 id="【场景2】G执行完毕"><a href="#【场景2】G执行完毕" class="headerlink" title="【场景2】G执行完毕"></a>【场景2】G执行完毕</h3><p>执行完毕后，切换G0，G0调度切换下一个G</p><h3 id="【场景3】连续创建多个G导致本地队列满"><a href="#【场景3】连续创建多个G导致本地队列满" class="headerlink" title="【场景3】连续创建多个G导致本地队列满"></a>【场景3】连续创建多个G导致本地队列满</h3><ol><li>对队列头部的一半打乱，放在全局队列</li><li>新创建的G也放在全局队列中</li><li>当前的本底队列变成原来长度的1/2<h3 id="【场景4】唤醒正在休眠的M"><a href="#【场景4】唤醒正在休眠的M" class="headerlink" title="【场景4】唤醒正在休眠的M"></a>【场景4】唤醒正在休眠的M</h3></li></ol><ul><li>什么时候唤醒？调度器自动唤醒，当某个 Goroutine 可以被执行时，当一个被阻塞的 Channel 操作可以继续执行时。</li></ul><p>新M所在的G队列如果为空，称为<strong>自旋线程</strong>，不断寻找G</p><ul><li>由于<strong>自旋线程拥有P</strong>，handoff机制不会把P给自旋线程<h3 id="【场景5】自旋线程从哪里获取G"><a href="#【场景5】自旋线程从哪里获取G" class="headerlink" title="【场景5】自旋线程从哪里获取G"></a>【场景5】自旋线程从哪里获取G</h3></li><li>首先从全局队列获取</li><li>全局队列如果为空，触发workstealing，从其他队列队尾偷一半<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2>strings.Join ≈ strings.Builder &gt; bytes.Buffer &gt; “+” &gt; fmt.Sprintf</li></ul><h2 id="slice中删除具体的值"><a href="#slice中删除具体的值" class="headerlink" title="slice中删除具体的值"></a>slice中删除具体的值</h2><p>移位法最快。</p><p>原地删除，扫描到具体值后，使用<figure class="highlight plain"><figcaption><span>slice[index+1:])```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## b = b[:len(a)] 作用</span><br><span class="line">- 优化边界检查 Bounds Check ELimination</span><br><span class="line">- 在运行时，Go 语言每次都会对 b[i] 做边界检查，看看是否越界了，如果越界了，就 panic。</span><br><span class="line">- 如果加上这一句，Go语言在编译时，能够做一些简单的静态分析，发现 b[i] 是不可能越界的</span><br><span class="line"></span><br><span class="line">## error</span><br><span class="line">【面试问题】如果一个函数的返回值是error，里面执行了多个defer，并且这些defer里面调用了不同的方法，也会返回error，但是这些error的格式是不一样的（比如有一些方法返回的是官方的errors，有一些是业务定义的错误，比如错误码和错误信息）。怎么样能统一处理这些defer的错误并且返回？</span><br><span class="line">- go泛型接收不同error类型，由特殊需求的话，使用断言判断后返回特定信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 【问题】控制goroutine超时退出</span><br><span class="line">- 使用 context 包</span><br><span class="line">```go</span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建一个上下文，设置超时时间为 2 秒</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)</span><br><span class="line">defer cancel() // 在完成任务后取消上下文以释放资源</span><br><span class="line"></span><br><span class="line">// 在另一个 goroutine 中执行任务</span><br><span class="line">go func() &#123;</span><br><span class="line">// 模拟一个耗时的任务</span><br><span class="line">time.Sleep(3 * time.Second)</span><br><span class="line"></span><br><span class="line">// 判断上下文是否被取消</span><br><span class="line">if ctx.Err() == context.Canceled &#123;</span><br><span class="line">fmt.Println(&quot;Task canceled due to timeout&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">// 等待一段时间，以确保上下文超时</span><br><span class="line">time.Sleep(4 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="【问题】Go语言闭包【让闭包函数拥有一个初始状态，记住了创建时所在的环境，各种变量的值，减少全局变量的使用，在栈区方便回收】"><a href="#【问题】Go语言闭包【让闭包函数拥有一个初始状态，记住了创建时所在的环境，各种变量的值，减少全局变量的使用，在栈区方便回收】" class="headerlink" title="【问题】Go语言闭包【让闭包函数拥有一个初始状态，记住了创建时所在的环境，各种变量的值，减少全局变量的使用，在栈区方便回收】"></a>【问题】Go语言闭包【让闭包函数拥有一个初始状态，记住了创建时所在的环境，各种变量的值，减少全局变量的使用，在栈区方便回收】</h2><p>简单来说，闭包允许一个函数记住并访问了它创建时所在的环境，即使在这个函数在其他地方被调用时仍然可以使用这个环境中的变量</p><ul><li>闭包用来减少全局变量，在函数调用过程中隐式传递共享变量</li><li>编译器检测到闭包，将外部变量分配到堆上</li><li>下面的程序中，a分配在堆上</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">a = a + i</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f:= fn(<span class="number">3</span>)</span><br><span class="line">g:= fn(<span class="number">3</span>)</span><br><span class="line">f(<span class="number">1</span>) <span class="comment">//输出 4</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">//输出 5</span></span><br><span class="line">g(<span class="number">1</span>) <span class="comment">//输出 4</span></span><br><span class="line">g(<span class="number">1</span>) <span class="comment">//输出 5</span></span><br></pre></td></tr></table></figure><h2 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h2><p>函数签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>(i <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="built_in">recover</span>() <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="主动调用-抛出panic"><a href="#主动调用-抛出panic" class="headerlink" title="主动调用/抛出panic"></a>主动调用/抛出panic</h3><ol><li>主动调用panic结束程序运行</li><li>调试时用panic快速退出，并打印出来堆栈信息</li><li>需要主动在程序分支流程上调用recover拦截错误</li></ol><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">os.Stdin：标准输入的文件实例，类型为*File</span><br><span class="line">os.Stdout：标准输出的文件实例，类型为*File</span><br><span class="line">os.Stderr：标准错误输出的文件实例，类型为*File</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err Error)</span></span></span><br><span class="line"><span class="function">//根据提供的文件名创建新的文件，返回一个文件对象，默认权限是0666</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">uintptr</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span></span><br><span class="line"><span class="function">// 根据文件描述符创建相应的文件，返回一个文件对象</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err Error)</span></span></span><br><span class="line"><span class="function">// 只读方式打开一个名称为<span class="title">name</span>的文件</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm <span class="keyword">uint32</span>)</span> <span class="params">(file *File, err Error)</span></span></span><br><span class="line"><span class="function">// 打开名称为<span class="title">name</span>的文件，<span class="title">flag</span>是打开的方式，只读、读写等，<span class="title">perm</span>是权限</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">写入<span class="title">byte</span>类型的信息到文件</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">WriteAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">在指定位置开始写入<span class="title">byte</span>类型的信息</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(ret <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">写入<span class="title">string</span>信息到文件</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">读取数据到<span class="title">b</span>中</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">从<span class="title">off</span>开始读取数据到<span class="title">b</span>中</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Error</span></span></span><br><span class="line"><span class="function">删除文件名为<span class="title">name</span>的文件</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">logFile, err := os.OpenFile("./xx.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)</span><br></pre></td></tr></table></figure><h3 id="实现一个cat命令"><a href="#实现一个cat命令" class="headerlink" title="实现一个cat命令"></a>实现一个cat命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cat命令实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(r *bufio.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf, err := r.ReadBytes(<span class="string">'\n'</span>) <span class="comment">//注意是字符</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(os.Stdout, <span class="string">"%s"</span>, buf)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse() <span class="comment">// 解析命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有参数默认从标准输入读取内容</span></span><br><span class="line">        cat(bufio.NewReader(os.Stdin))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次读取每个指定文件的内容并打印到终端</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err := os.Open(flag.Arg(i))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stdout, <span class="string">"reading from %s failed, err:%v\n"</span>, flag.Arg(i), err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        cat(bufio.NewReader(f))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="net包"><a href="#net包" class="headerlink" title="net包"></a>net包</h2><h2 id="context包"><a href="#context包" class="headerlink" title="context包"></a>context包</h2><p>当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的例子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如何接收外部命令实现退出</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker()</span><br><span class="line">    <span class="comment">// 如何优雅的实现结束子goroutine</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Zinx"><a href="#Zinx" class="headerlink" title="Zinx"></a>Zinx</h2><h3 id="ziface"><a href="#ziface" class="headerlink" title="ziface"></a><strong>ziface</strong></h3><p>  接口包括</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- IService 基础服务的启动</span><br><span class="line">  - Start() <span class="comment">//启动服务器</span></span><br><span class="line">  - Stop()  <span class="comment">//停止服务器</span></span><br><span class="line">  - Serve() <span class="comment">//开启业务服务方法</span></span><br><span class="line">  - AddRouter(router IRouter)<span class="comment">//路由功能：给当前服务注册一个路由业务方法，供客户端链接处理使用</span></span><br><span class="line">- IConnection 基于net库</span><br><span class="line">  - Start() <span class="comment">//启动连接，让当前连接开始工作</span></span><br><span class="line">  - Stop()  <span class="comment">//停止连接，结束当前连接状态M</span></span><br><span class="line">  - GetTCPConnection() * net.TCPConn <span class="comment">//从当前连接获取原始的socket TCPConn</span></span><br><span class="line">  - GetConnID() <span class="keyword">uint32</span>    <span class="comment">//获取当前连接ID</span></span><br><span class="line">  - RemoteAddr() net.Addr <span class="comment">//获取远程客户端地址信息</span></span><br><span class="line"></span><br><span class="line">  - <span class="keyword">type</span> HandFunc <span class="function"><span class="keyword">func</span><span class="params">(*net.TCPConn, []<span class="keyword">byte</span>, <span class="keyword">int</span>)</span> <span class="title">error</span> //定义一个统一处理链接业务的接口,是所有<span class="title">conn</span>链接在处理业务的函数接口，第一参数是<span class="title">socket</span>原生链接，第二个参数是客户端请求的数据，第三个参数是客户端请求的数据长度。这样，如果我们想要指定一个<span class="title">conn</span>的处理业务，只要定义一个<span class="title">HandFunc</span>类型的函数，然后和该链接绑定就可以了。</span></span><br><span class="line"><span class="function">- <span class="title">IRequest</span> //每次客户端的全部请求数据，一起放到一个<span class="title">Request</span>结构体里</span></span><br><span class="line"><span class="function">  - <span class="title">GetConnection</span><span class="params">()</span> <span class="title">IConnection</span>    //获取请求连接信息</span></span><br><span class="line"><span class="function">  - <span class="title">GetData</span><span class="params">()</span> []<span class="title">byte</span>            //获取请求消息的数据</span></span><br><span class="line"><span class="function">- <span class="title">IRouter</span>  //路由配置类</span></span><br><span class="line"><span class="function">  - <span class="title">PreHandle</span><span class="params">(request IRequest)</span>  //在处理<span class="title">conn</span>业务之前的钩子方法</span></span><br><span class="line"><span class="function">  - <span class="title">Handle</span><span class="params">(request IRequest)</span>     //处理<span class="title">conn</span>业务的方法</span></span><br><span class="line"><span class="function">  - <span class="title">PostHandle</span><span class="params">(request IRequest)</span> //处理<span class="title">conn</span>业务之后的钩子方法</span></span><br><span class="line"><span class="function">- <span class="title">IMessage</span> //消息封装</span></span><br><span class="line"><span class="function">  - <span class="title">GetDataLen</span><span class="params">()</span> <span class="title">uint32</span> //获取消息数据段长度</span></span><br><span class="line"><span class="function">  - <span class="title">GetMsgId</span><span class="params">()</span> <span class="title">uint32</span>   //获取消息<span class="title">ID</span></span></span><br><span class="line"><span class="function">  - <span class="title">GetData</span><span class="params">()</span> []<span class="title">byte</span>    //获取消息内容</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  - <span class="title">SetMsgId</span><span class="params">(<span class="keyword">uint32</span>)</span>    //设计消息<span class="title">ID</span></span></span><br><span class="line"><span class="function">  - <span class="title">SetData</span><span class="params">([]<span class="keyword">byte</span>)</span>     //设计消息内容</span></span><br><span class="line"><span class="function">  - <span class="title">SetDataLen</span><span class="params">(<span class="keyword">uint32</span>)</span>  //设置消息数据段长度</span></span><br><span class="line"><span class="function">- <span class="title">IDataPack</span> //消息封包拆包</span></span><br><span class="line"><span class="function">  - <span class="title">GetHeadLen</span><span class="params">()</span> <span class="title">uint32</span>                  //获取包头长度方法</span></span><br><span class="line"><span class="function">  - <span class="title">Pack</span><span class="params">(msg IMessage)</span><span class="params">([]<span class="keyword">byte</span>, error)</span>   //封包方法</span></span><br><span class="line"><span class="function">    // 通过<span class="title">encoding</span>/<span class="title">binary</span>.<span class="title">write</span>方法将<span class="title">byte</span>数组小端写入<span class="title">bytes</span>来压缩数据</span></span><br><span class="line"><span class="function">  - <span class="title">Unpack</span><span class="params">([]<span class="keyword">byte</span>)</span><span class="params">(IMessage, error)</span>     //拆包方法</span></span><br><span class="line"><span class="function">- <span class="title">IMsgHandle</span> //消息管理模块</span></span><br><span class="line"><span class="function">  - <span class="title">DoMsgHandler</span><span class="params">(request IRequest)</span>          //马上以非阻塞方式处理消息</span></span><br><span class="line"><span class="function">  - <span class="title">AddRouter</span><span class="params">(msgId <span class="keyword">uint32</span>, router IRouter)</span> //为消息添加具体的处理逻辑</span></span><br><span class="line"><span class="function">  - <span class="title">StartWorkerPool</span><span class="params">()</span>                       //启动<span class="title">worker</span>工作池</span></span><br><span class="line"><span class="function">  - <span class="title">SendMsgToTaskQueue</span><span class="params">(request IRequest)</span>    //将消息交给<span class="title">MsgHandle</span>的消息队列<span class="title">TaskQueue</span>,由<span class="title">worker</span>进行处理</span></span><br><span class="line"><span class="function">- <span class="title">IConnManager</span> // <span class="title">TCP</span>的链接管理模块</span></span><br><span class="line"><span class="function">  - <span class="title">Add</span><span class="params">(conn IConnection)</span>                   //添加链接</span></span><br><span class="line"><span class="function">  - <span class="title">Remove</span><span class="params">(conn IConnection)</span>                //删除连接</span></span><br><span class="line"><span class="function">  - <span class="title">Get</span><span class="params">(connID <span class="keyword">uint32</span>)</span> <span class="params">(IConnection, error)</span> //利用<span class="title">ConnID</span>获取链接</span></span><br><span class="line"><span class="function">  - <span class="title">Len</span><span class="params">()</span> <span class="title">int</span>                               //获取当前连接</span></span><br><span class="line"><span class="function">  - <span class="title">ClearConn</span><span class="params">()</span>                             //删除并停止所有链接</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">    id         <span class="keyword">int</span></span><br><span class="line">    jobChannel <span class="keyword">chan</span> Job</span><br><span class="line">    quit       <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    workerCount <span class="keyword">int</span></span><br><span class="line">    jobChannel  <span class="keyword">chan</span> Job</span><br><span class="line">    workers     []Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJob</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">Job</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Job&#123;id: id&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(id <span class="keyword">int</span>, jobChannel <span class="keyword">chan</span> Job)</span> <span class="title">Worker</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Worker&#123;</span><br><span class="line">        id:         id,</span><br><span class="line">        jobChannel: jobChannel,</span><br><span class="line">        quit:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">(workerCount, jobCount <span class="keyword">int</span>)</span> <span class="title">Pool</span></span> &#123;</span><br><span class="line">    jobChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> Job, jobCount)</span><br><span class="line">    workers := <span class="built_in">make</span>([]Worker, workerCount)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        workers[i] = NewWorker(i, jobChannel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Pool&#123;</span><br><span class="line">        workerCount: workerCount,</span><br><span class="line">        jobChannel:  jobChannel,</span><br><span class="line">        workers:     workers,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> job := &lt;-w.jobChannel:</span><br><span class="line">                fmt.Printf(<span class="string">"Worker %d processing job %d\n"</span>, w.id, job.id)</span><br><span class="line">            <span class="keyword">case</span> &lt;-w.quit:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        w.quit &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pool)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.workerCount; i++ &#123;</span><br><span class="line">        p.workers[i].Start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pool)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.workerCount; i++ &#123;</span><br><span class="line">        p.workers[i].Stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pool)</span> <span class="title">AddJob</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">    p.jobChannel &lt;- job</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := NewPool(<span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">    pool.Start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        job := NewJob(i)</span><br><span class="line">        pool.AddJob(job)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待一段时间，以便观察协程池的工作</span></span><br><span class="line">    <span class="comment">// 在实际应用中，你可能需要使用 sync.WaitGroup 或其他同步方法来确保所有任务完成后再关闭协程池</span></span><br><span class="line">    <span class="comment">// 这里仅做演示，实际中请根据需要进行调整</span></span><br><span class="line">    fmt.Println(<span class="string">"等待一段时间，以观察协程池的工作..."</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>Job</code> 结构体:</p><ul><li><code>id int</code>: 用于表示一个任务的唯一标识。</li></ul></li><li><p><code>Worker</code> 结构体:</p><ul><li><code>id int</code>: 表示工作者的唯一标识。</li><li><code>jobChannel chan Job</code>: 是一个任务通道，用于接收工作者执行的任务。</li><li><code>quit chan bool</code>: 是一个退出通道，用于通知工作者停止运行。</li></ul></li><li><p><code>Pool</code> 结构体:</p><ul><li><code>workerCount int</code>: 表示协程池中的工作者数量。</li><li><code>jobChannel chan Job</code>: 是一个任务通道，用于向协程池中添加任务。</li><li><code>workers []Worker</code>: 存储了所有的工作者。</li></ul></li></ol><h3 id="方法解析："><a href="#方法解析：" class="headerlink" title="方法解析："></a>方法解析：</h3><ol><li><p><code>NewJob(id int) Job</code>:</p><ul><li>返回一个新的任务 <code>Job</code> 对象，带有指定的任务ID。</li></ul></li><li><p><code>NewWorker(id int, jobChannel chan Job) Worker</code>:</p><ul><li>返回一个新的工作者 <code>Worker</code> 对象，使用指定的工作者ID和任务通道。</li></ul></li><li><p><code>NewPool(workerCount, jobCount int) Pool</code>:</p><ul><li>创建一个新的协程池，初始化了工作者和任务通道。</li><li>参数 <code>workerCount</code> 表示协程池中的工作者数量。</li><li>参数 <code>jobCount</code> 表示任务通道的缓冲区大小。</li></ul></li><li><p><code>Worker.Start()</code>:</p><ul><li>启动了一个工作者协程，该协程会不断地监听任务通道和退出通道。</li><li>当从任务通道收到任务时，工作者会执行任务；当从退出通道收到信号时，工作者会停止运行。</li></ul></li><li><p><code>Worker.Stop()</code>:</p><ul><li>启动了一个协程，向退出通道发送信号，通知工作者停止运行。</li></ul></li><li><p><code>Pool.Start()</code>:</p><ul><li>启动了协程池中所有工作者。</li></ul></li><li><p><code>Pool.Stop()</code>:</p><ul><li>停止协程池中所有工作者。</li></ul></li><li><p><code>Pool.AddJob(job Job)</code>:</p><ul><li>向任务通道中添加一个任务。</li></ul></li></ol><h3 id="主函数-main-解析："><a href="#主函数-main-解析：" class="headerlink" title="主函数 main 解析："></a>主函数 <code>main</code> 解析：</h3><ol><li><p>创建一个协程池 <code>pool</code>，包括了 3 个工作者和 10 个任务的通道缓冲区。</p></li><li><p>调用 <code>pool.Start()</code> 启动所有工作者。</p></li><li><p>循环创建了 5 个任务，每个任务被添加到协程池的任务通道中。</p></li><li><p>由于在主函数结束后，主协程也会结束，所以在这里使用了 <code>select{}</code> 语句使主协程保持活跃状态。</p></li></ol><h3 id="运行流程："><a href="#运行流程：" class="headerlink" title="运行流程："></a>运行流程：</h3><ol><li><p>在主函数中创建了一个协程池 <code>pool</code>，初始化了 3 个工作者和一个任务通道。</p></li><li><p>每个工作者通过 <code>Worker.Start()</code> 方法启动了一个独立的协程，开始监听任务通道和退出通道。</p></li><li><p>主函数循环创建了 5 个任务，并通过 <code>pool.AddJob(job)</code> 方法将它们添加到协程池的任务通道中。</p></li><li><p>每个工作者从任务通道中接收到任务后，会执行相应的任务。</p></li><li><p>当主函数结束后，通过 <code>select{}</code> 语句使主协程保持活跃状态，保证所有工作者有足够的时间来处理任务。</p></li></ol><p>请注意，实际应用中，你可能需要使用合适的同步机制（例如 <code>sync.WaitGroup</code>）来确保所有任务完成后再关闭协程池，以及处理一些错误和异常情况。</p><h2 id="3-下面赋值正确的是"><a href="#3-下面赋值正确的是" class="headerlink" title="3.下面赋值正确的是()"></a>3.下面赋值正确的是()</h2><p>A. var x = nil<br>B. var x interface{} = nil<br>C. var x string = nil<br>D. var x error = nil<br>参考答案及解析：BD。知识点：nil 值。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看下方贴出的源码就知道，所以 D 是对的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GIN问题"><a href="#GIN问题" class="headerlink" title="GIN问题"></a>GIN问题</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总 ：&lt;a href=&quot;https://www.bookstack.cn/read/qcrao-Go-Questions/interface.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bookstack.cn/read/qcrao-Go-Questions/interface.md&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Golang" scheme="http://waynamigo.github.io/categories/Golang/"/>
    
    
      <category term="面试" scheme="http://waynamigo.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="go" scheme="http://waynamigo.github.io/tags/go/"/>
    
  </entry>
  
</feed>
