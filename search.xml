<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>部分MACOS风格的ubuntu</title>
      <link href="/2019/07/09/2019-07-09-%E6%88%91%E7%9A%84ubuntu%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E9%A3%8E%E6%A0%BC/"/>
      <url>/2019/07/09/2019-07-09-%E6%88%91%E7%9A%84ubuntu%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>记录一下以防以后电脑崩了还得重新配,感觉撑不住了</p><a id="more"></a><h3 id="效果这样"><a href="#效果这样" class="headerlink" title="效果这样"></a>效果这样</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/screenshot.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">#extensions.gnome.org install [ User themes]</span><br><span class="line"> </span><br><span class="line">#www.gnome-look.org [ gtk-3 themes:McOS-HS]</span><br><span class="line">tar -zxvf McOS-HS-2-themes.tar.gz</span><br><span class="line">#go to tweaks and chose this theme</span><br><span class="line"></span><br><span class="line">tar -zxvf macOS11.tar.xz </span><br><span class="line">#extensions.gnome.org [dash-to-dock]</span><br><span class="line">#www.gnome-look.org [OSX.for.Dash.to.DOCK]</span><br><span class="line">#www.gnome-look.org [Icon Themes: macOS icons]</span><br><span class="line"># extensioons.gnome.org [blyr]</span><br></pre></td></tr></table></figure><p>go to tweaks and choose them</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/tweaks.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>cd ./OSX.for.Dash.to.DOCK/Dock Settings/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock show-apps-at-top true</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-running-dots false</span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-customize-running-dots false</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-shrink false</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock transparency-mode DEFAULT</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#www.gnome-look.org [GDM themes:SetAsWallpaper]</span></span><br><span class="line"></span><br><span class="line">mv ubuntu.css /usr/share/gnome-shell/theme/</span><br><span class="line"></span><br><span class="line">sudo mv /usr/share/gnome-shell/extensions/ubuntu-dock@ubuntu.com ~/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> tweak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用了个bash手动打包java项目并在tomcat中运行</title>
      <link href="/2019/07/03/2019-07-03-%E7%BB%8F%E7%AE%A1%E5%90%8C%E5%AD%A6%E7%9A%84tomcat%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/07/03/2019-07-03-%E7%BB%8F%E7%AE%A1%E5%90%8C%E5%AD%A6%E7%9A%84tomcat%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>帮信管专业的同学把项目部署到服务器上，因为没打包过war，中间有个地方卡住了，好麻烦记一下。（佛了，为什么不用maven</p><a id="more"></a><h2 id="jdbc和tomcat和手写的DAO，怀旧。"><a href="#jdbc和tomcat和手写的DAO，怀旧。" class="headerlink" title="jdbc和tomcat和手写的DAO，怀旧。"></a>jdbc和tomcat和手写的DAO，怀旧。</h2><p>用idea打包：</p><p>先是在idea里面配置的Webapplication的archive，里面要选一个WEB-INF和META-INF。</p><p>将avaliavle elements进行put into outputroot操作，左边的out layout栏里，出现META-INF<br>build project 再 build artifacts</p><p>好了<br><strong>但是我没成功</strong>，不知道为啥，war包也导出来了，tomcat运行出错？？？？nmd</p><p>项目结构这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   └── out.jar</span><br><span class="line">├── build</span><br><span class="line">│   └── source.txt</span><br><span class="line">├── build.sh</span><br><span class="line">├── classdesign.war</span><br><span class="line">├── out</span><br><span class="line">│   ├── artifacts</span><br><span class="line">│   └── production</span><br><span class="line">├── src</span><br><span class="line">│   ├── com</span><br><span class="line">│   └── MANIFEST.MF</span><br><span class="line">└── web</span><br><span class="line">    ├── commom</span><br><span class="line">    ├── css</span><br><span class="line">    ├── iconfont</span><br><span class="line">    ├── images</span><br><span class="line">    ├── js</span><br><span class="line">    └── WEB-INF</span><br></pre></td></tr></table></figure><h3 id="然后手动打包了，（写了个循环shellfor-javac）"><a href="#然后手动打包了，（写了个循环shellfor-javac）" class="headerlink" title="然后手动打包了，（写了个循环shellfor javac）"></a>然后手动打包了，（写了个循环shellfor javac）</h3><p><a href="https://github.com/waynamigo/templates/blob/master/bashs/build.sh" target="_blank" rel="noopener">代码在这</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"></span><br><span class="line">path=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="function"><span class="title">dependence</span></span>()&#123;</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="variable">$1</span>|grep -v <span class="string">".bak"</span>`</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      dependence <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">local</span> file_path=<span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">echo</span> <span class="variable">$file_path</span>|grep <span class="string">"MANIFEST.MF"</span>&gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">      c=c</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="variable">$file_path</span> &gt;&gt; <span class="variable">$path</span>/build/source.txt</span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependence <span class="variable">$path</span>/src</span><br><span class="line">libs=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> java_lib <span class="keyword">in</span> $(ls <span class="variable">$path</span>/web/WEB-INF/lib);<span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [[ libs != <span class="string">""</span> ]];<span class="keyword">then</span></span><br><span class="line">libs=<span class="variable">$libs</span>:<span class="variable">$path</span>/web/WEB-INF/lib/<span class="variable">$java_lib</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">libs=<span class="variable">$path</span>/web/WEB-INF/lib/<span class="variable">$java_lib</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">javac -encoding utf-8 -Xlint:unchecked -d <span class="variable">$path</span>/build -classpath <span class="variable">$path</span>/web/WEB-INF/lib @<span class="variable">$path</span>/build/source.txt</span><br><span class="line">jar cvf  <span class="variable">$path</span>/src/MANIFEST.MF  <span class="variable">$path</span>/bin/classdesign.war ./*</span><br></pre></td></tr></table></figure><h3 id="把war烤到webapps执行startup-sh就可以运行了"><a href="#把war烤到webapps执行startup-sh就可以运行了" class="headerlink" title="把war烤到webapps执行startup.sh就可以运行了"></a>把war烤到webapps执行startup.sh就可以运行了</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> tomcat </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习考试复习</title>
      <link href="/2019/06/25/2019-06-25-machinelearning/"/>
      <url>/2019/06/25/2019-06-25-machinelearning/</url>
      
        <content type="html"><![CDATA[<p> 统  计  学  习</p><a id="more"></a><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><p>选择 3分×9<br>简答题 5分×5<br>综合分析 7分×7</p><h2 id="绪论，回归"><a href="#绪论，回归" class="headerlink" title="绪论，回归"></a>绪论，回归</h2><ul><li><p>按学习方式分类的机器学习算法 四类</p></li><li><p>模型评估指标：泛化误差、经验误差</p></li><li><p>欠拟合和过拟合（避免过拟合的方法 正则化-L2、dropout等）</p></li><li><p>分类和聚类和回归的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">回归和分类本质相同，都是根据训练集（有标签，有监督学习）做预测，区别是输出不同，分类是定性输出，回归是定量输出</span><br><span class="line">聚类是无监督学习，产生多个集合，单个集合中的元素属性相似</span><br></pre></td></tr></table></figure></li><li><p>多元线性回归求解权重w的方法：最小二乘、梯度下降、误差函数</p></li><li><p>非线性回归如何进行计算:通过中间函数映射</p></li><li><p>岭回归的特点（简答？</p><h2 id="LDA-应该有大题"><a href="#LDA-应该有大题" class="headerlink" title="LDA 应该有大题"></a>LDA 应该有大题</h2></li><li><p>LDA结构，LDA生成文档D的步骤（简答</p></li><li><p>使用LDA的目的：得到文章库中每篇文章的主题分布；<br>   得到新输入文章的主题分布。</p><h2 id="决策树-随机森林-支持向量机"><a href="#决策树-随机森林-支持向量机" class="headerlink" title="决策树 随机森林 支持向量机"></a>决策树 随机森林 支持向量机</h2></li><li><p>决策树是一种有监督的分类方法,它用已有的数据构造出一棵树,再用这棵树对新的数据进行预测。</p></li><li><p>学习过程：通过对训练样本的分析来确定“划分属性”（即内部结点所对应的属性）</p></li><li><p>预测过程：将测试示例从根结点开始，沿着划分属性所构成的“判定测试序列”下行，直到叶结点。</p></li><li><p>决策树（简答）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1构造过程：特征选择；决策树生成；剪枝（预剪枝和后剪枝的方法）是自根到叶的递归过程</span><br><span class="line">2生成停止条件</span><br><span class="line">当前结点包含的样本全属于同一类别，无需划分;</span><br><span class="line">当前属性集为空, 或是所有样本在所有属性上取值相同，无法划分;</span><br><span class="line">当前结点包含的样本集合为空，不能划分.</span><br><span class="line">3预剪枝：在构造树的过程中，对每个结点在划分前进行估计，如果当前结点的划分不能带来决策树模型泛化性能的提升，则不对当前结点进行划分并且将当前结点标记为叶结点。</span><br><span class="line">后剪枝：先把整颗决策树构造完毕，自底向上对非叶结点进行考察，若将该结点对应的子树换为叶结点能够带来泛化性能的提升，则把该子树替换为叶结点。</span><br><span class="line"></span><br><span class="line">（预剪后剪的对比）</span><br></pre></td></tr></table></figure><p>对节点划分的方法 信息增益 增益率 基尼指数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信息增益=△信息熵，信息熵越小纯度越大</span><br><span class="line">根据基尼指数：选取划分后使基尼指数最小的属性</span><br></pre></td></tr></table></figure><ul><li>随机森林（简答）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始训练集为D,应用Bootstrap法有放回地随机抽取k个新的自助样本集,并由此构建k 棵决策树</span><br><span class="line">每棵树最大限度地生长,不做任何修剪</span><br><span class="line">将生成的多棵决策树组成随机森林,用随机森林分类器对新的数据进行判别与分类,森林中的每一棵树都对新的数据进行预测和投票,最终得票最多的分类项即为随机森林对该数据的预测结果。</span><br><span class="line"></span><br><span class="line">优点：随机森林对于高维数据集的处理能力比较好,它可以处理成千上万的输入变量,并确定最重要的变量,因此被认为是一个不错的降维方法。此外,该模型能够输出变量的重要性程度,这是一个非常便利的功能。</span><br><span class="line">在对缺失数据进行估计时,随机森林是一个十分有效的方法。就算存在大量的数据缺失,随机森林也能较好地保持精确性。</span><br><span class="line">当存在分类不平衡的情况时,随机森林能够提供平衡数据集误差的有效方法。</span><br><span class="line">缺点：随机森林给人的感觉像是一个黑盒子———你几乎无法控制模型内部的运行,只能在不同的参数和随机种子之间进行尝试,从而得到一个更优的分类器。</span><br></pre></td></tr></table></figure><ul><li>支持向量机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概念：基本模型定义为特征空间上的间隔最大的线性分类器（按监督学习方式对数据进行二分类的广义线性分类器）</span><br><span class="line">决策边界是对学习样本求解的最大边距超平面</span><br></pre></td></tr></table></figure><ul><li>间隔，最大间隔</li><li>超平面的距离计算（可能考计算 r = |w.T·x+b|/|w|</li><li>核方法 设计核函数（综合题）根据mercer定理：若一个对称函数所对应的核矩阵半正定，那么它可以设为核函数<h2 id="神经网络-kmeans"><a href="#神经网络-kmeans" class="headerlink" title="神经网络 kmeans"></a>神经网络 kmeans</h2></li><li>结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入层：接受来自网络外部的数据的顶点</span><br><span class="line">隐藏层：除了输入层和输出层以外的其他层</span><br><span class="line">输出层：向网络外部输出数据的顶点</span><br></pre></td></tr></table></figure><ul><li>超参数有哪些</li><li>如何衡量你的预测算法，损失函数loss</li><li>感知机是啥</li><li>BP是啥 RBF是啥 hopfield是啥 SOM是啥</li><li>计算隐藏层结点数目（计算题？</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">隐层结点数s与模式数N的关系是：s＝log2N；</span><br><span class="line">隐层结点数s＝2n＋1（n为输入层结点数）；</span><br></pre></td></tr></table></figure><ul><li>CNN</li><li>LSTM</li><li>聚类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">1.原理简单，实现方便，收敛速度快；</span><br><span class="line">2.聚类效果较优；</span><br><span class="line">3.模型的可解释性较强；</span><br><span class="line">4.调参只需要簇数k；</span><br><span class="line">缺点：</span><br><span class="line">1.k的选取不好把握；</span><br><span class="line">2.初始聚类中心的选择；</span><br><span class="line">3.如果数据的类型不平衡，比如数据量严重失衡或者类别的方差不同，则聚类效果不佳；</span><br><span class="line">4.采用的是迭代的方法，只能得到局部最优解；</span><br><span class="line">5.对于噪声和异常点比较敏感。</span><br></pre></td></tr></table></figure><ul><li>聚类性能度量 外部指标 内部指标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外：聚类结果与某个“参考模型”(reference model) 进行比较，需要标记数据如Jaccard 系数，FM 指数，Rand 指数</span><br><span class="line">内：直接考察聚类结果而不用任何参考模型，类内聚集程度和类间离散程度。定义簇内样本间的距离，簇间距离，如DB 指数，Dunn 指数等</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这学期项目中的坑</title>
      <link href="/2019/06/12/2019-06-12-%E8%B8%A9%E5%9D%91%E9%9B%86%E9%94%A6/"/>
      <url>/2019/06/12/2019-06-12-%E8%B8%A9%E5%9D%91%E9%9B%86%E9%94%A6/</url>
      
        <content type="html"><![CDATA[<p>在？为什么国内博客上点击多的都是废话</p><a id="more"></a><h2 id="mysql分离-springboot-eurake"><a href="#mysql分离-springboot-eurake" class="headerlink" title="mysql分离 + springboot + eurake"></a>mysql分离 + springboot + eurake</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原因是 配置远程数据库时，springboot 没有创建表，自己手动建了hibernate sequence后就会报这个错。</span><br><span class="line">表现为插入数据失败，error &quot;could not read a hi value - you need to populate the table&quot;.</span><br><span class="line"></span><br><span class="line">解决方法是对nextval设置初始值，stackoverflow的另一种方案是</span><br><span class="line">改掉注释</span><br><span class="line">@GeneratedValue(strategy = GenerationType.AUTO)改为@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jekyll加入live2d的模型</title>
      <link href="/2019/05/14/2019-05-14-jekyll%E5%8A%A0%E5%85%A5live2d%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/05/14/2019-05-14-jekyll%E5%8A%A0%E5%85%A5live2d%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><del>由于不打算再迁到hexo了，把jekyll加入live2d模型的方法记录一下</del><br>迁hexo了草。</p><a id="more"></a><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>npm install hexo-cli</p><p>使用hexo初始化一个本地的博客文件夹 hexo init</p><p>安装需要的依赖 npm install就可以了</p><h3 id="在hexo安装live2d插件"><a href="#在hexo安装live2d插件" class="headerlink" title="在hexo安装live2d插件"></a>在hexo安装live2d插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-helper-live2d</span><br></pre></td></tr></table></figure><ul><li>详见 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a></li></ul><h3 id="在hexo配置一下"><a href="#在hexo配置一下" class="headerlink" title="在hexo配置一下"></a>在hexo配置一下</h3><p>在config里面加入live2d的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hexo-helper-live2d项目给的配置文件例子</span><br><span class="line">live2d:</span><br><span class="line">  model:</span><br><span class="line">    scale: 1</span><br><span class="line">    hHeadPos: 0.5</span><br><span class="line">    vHeadPos: 0.618</span><br><span class="line">  display:</span><br><span class="line">    superSample: 2</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">    position: right</span><br><span class="line">    hOffset: 0</span><br><span class="line">    vOffset: -20</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">    scale: 0.5</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.2</span><br></pre></td></tr></table></figure><p>找你要加入的live2d模型（有钱的可以去订做，把widget替换掉。</p><p><strong>koharu在这里面<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">live2d-widget-model</a></strong></p><p>clone所需要的live2d模型后，还需要在config里面加入一个live2d配置。</p><p>配置文件如下<del>（注释是wife还行）</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#wife</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    use: koharu  #模板目录，在node_modules里</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150 </span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br></pre></td></tr></table></figure><h3 id="启动hexo，会自动编译生成可用的模型文件"><a href="#启动hexo，会自动编译生成可用的模型文件" class="headerlink" title="启动hexo，会自动编译生成可用的模型文件"></a>启动hexo，会自动编译生成可用的模型文件</h3><p>目的文件live2d文件夹，编译后的文件目录如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_config.yml  live2d_models  package.json  scaffolds  themes</span><br><span class="line">db.json      node_modules   public        <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了"><a href="#在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了" class="headerlink" title="在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了"></a>在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;L2Dwidget.init(&#123;<span class="string">"pluginModelPath"</span>:<span class="string">"assets/"</span>,<span class="string">"model"</span>:&#123;<span class="string">"jsonPath"</span>:<span class="string">"/live2dw/assets/koharu.model.json"</span>&#125;,<span class="string">"display"</span>:&#123;<span class="string">"position"</span>:<span class="string">"right"</span>,<span class="string">"width"</span>:<span class="number">150</span>,<span class="string">"height"</span>:<span class="number">300</span>&#125;,<span class="string">"mobile"</span>:&#123;<span class="string">"show"</span>:<span class="literal">false</span>&#125;,<span class="string">"log"</span>:<span class="literal">false</span>,<span class="string">"pluginJsPath"</span>:<span class="string">"lib/"</span>,<span class="string">"pluginRootPath"</span>:<span class="string">"live2dw/"</span>,<span class="string">"tagMode"</span>:<span class="literal">false</span>&#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live2d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程经济学</title>
      <link href="/2019/05/04/2019-05-04-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
      <url>/2019/05/04/2019-05-04-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>from 华南理工大学 左保和老师<br>软件项目如何进行融资、分析风险、敏感性因素等</p><a id="more"></a><h2 id="软件工程经济学基础"><a href="#软件工程经济学基础" class="headerlink" title="软件工程经济学基础"></a>软件工程经济学基础</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">requirement</span><br><span class="line">design</span><br><span class="line">constructure 详细设计和总体设计在design完成，</span><br><span class="line">testing</span><br><span class="line">maintenance</span><br><span class="line">configure management，软件团队的管理办法</span><br><span class="line">management </span><br><span class="line">tools and method</span><br><span class="line">engineering process</span><br><span class="line">quality</span><br></pre></td></tr></table></figure><h3 id="货币的时间成本，举例说明这个概念的重要性"><a href="#货币的时间成本，举例说明这个概念的重要性" class="headerlink" title="货币的时间成本，举例说明这个概念的重要性"></a>货币的时间成本，举例说明这个概念的重要性</h3><p>1、货币时间成本<br>按利率衡量<br>特定时间内 ，利息/借贷资本</p><ul><li>利息计算方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单利 I = iP N ==&gt; 利率*存款*计息周期数</span><br><span class="line">复利 F = P（1+i）^N</span><br></pre></td></tr></table></figure></li></ul><h3 id="掌握的重要概念part1"><a href="#掌握的重要概念part1" class="headerlink" title="掌握的重要概念part1"></a>掌握的重要概念part1</h3><p>利率、利息额、借贷资本总额<br>通货膨胀率、消费者价格指数（CPI）、生产者价格指数（PPI）<br>利息的计算方法：单利、复利、计息期（一般为年，或换算为年）<br>等值计算的概念和意义（现值、折现率）<br>等额支付（等额本金、等额本息）<br>税收、营业税、增值税、营改增<br>贬值、折旧</p><h4 id="工程经济学的概念"><a href="#工程经济学的概念" class="headerlink" title="工程经济学的概念"></a>工程经济学的概念</h4><p>工程经济学是运用有效的方法对工程各种因素进行评价，确定最佳方案，做出投资决策的学科，的研究对象是工程项目。<br>对软件工程领域来说，</p><h4 id="金融学"><a href="#金融学" class="headerlink" title="金融学"></a>金融学</h4><p>明确目标周期机构<br>商业战略 管理现今流量管理</p><h4 id="会计学原理资产"><a href="#会计学原理资产" class="headerlink" title="会计学原理资产"></a>会计学原理资产</h4><p>对外投资<br>固定资产<br>货币资金<br>收入费用利润</p><h4 id="现金流量"><a href="#现金流量" class="headerlink" title="现金流量"></a>现金流量</h4><p>现金的定义</p><ul><li>指企业的库存现金和银行存款，还包括现金等价物，即企业持有的期限短、流动性强、容易转换为已知金额现金、价值变动风险很小的投资等</li><li>一项投资被确认为现金等价物必须同时具备四个条件：期限短、流动性强、易于转换为已知金额现金、价值改动风险小。</li><li>是企业财力的评价指标之一</li></ul><h4 id="现金流量图"><a href="#现金流量图" class="headerlink" title="现金流量图"></a>现金流量图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现金流入流出</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|_________________</span><br><span class="line">|                 时间,指财务周期</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br></pre></td></tr></table></figure><h4 id="支付方式"><a href="#支付方式" class="headerlink" title="支付方式"></a>支付方式</h4><p>等额支付</p><p>线性梯度支付<br>p=G{}<br>几何梯度支付<br>第二年 = 第一年* (1+G)</p><h4 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h4><p>纸币的发行量超过了流通中实际需要的数量，多余的部分继续在流通中流转，就会造成通货膨胀（百度百科）</p><h4 id="折现"><a href="#折现" class="headerlink" title="折现"></a>折现</h4><p>衡量现金流量，税收，</p><h4 id="税收"><a href="#税收" class="headerlink" title="税收"></a>税收</h4><p>营业 教育 增值</p><p>###基准收益率与利率的区别<br>基准收益率也被称为基准折现率。<br>区别1：和利率不同，利率是资金利息额与借贷资金额的比率；收益率是投资的回报率，利润占使用平均资金的百分比。<br>区别2：基准收益率是企业或行业或投资者以动态的观点所确定的、可接受的投资项目最低标准的受益水平，由国家发改委和建设部制定。<br>基准利率由中国人民银行制定。<br>区别3：上节讲的通货膨胀、利息等宏观因素是影响利率的主要因素；<br>而对收益率来说，商品的生产率、运维生产率，投资，不确定度、消费者的消费偏好、投资风险、物价变动等因素是主要因素，并且根据每个行业的行情变动相对利率较大。<br>软件行业的基准收益率是15%。</p><ul><li>发改委官网、国家统计局官网上找不到数据，在材料《建设项目经济评价方法与参数》上有对各行业经济的各项参数的详细介绍</li><li>部分数据参照“北京软件造价评估技术创新联盟”网站的报告，包括2016-2018年，<a href="http://www.bscea.org/Uploads/ueditor/file/20181012/5bc00c9f71b20.pdf" target="_blank" rel="noopener">2018中国软件行业基准数据报告</a></li></ul><h3 id="cpi-，-spi"><a href="#cpi-，-spi" class="headerlink" title="cpi ， spi"></a>cpi ， spi</h3><p>CPI=EV/AC，SPI=EV/PV</p><p>cpi 成本绩效指标<br>甘特图 贬值进度计划<br>进度控制指标<br>spi &lt;1  进度落后  =1 按计划进行  &gt;1 超前进行<br>开发者效率</p><h3 id="软件项目质量"><a href="#软件项目质量" class="headerlink" title="软件项目质量"></a>软件项目质量</h3><p>ISO度量</p><h3 id="软件质量保证"><a href="#软件质量保证" class="headerlink" title="软件质量保证"></a>软件质量保证</h3><p>制定推行软件工程质量标准<br>研究 采用各种技术手段<br>控制各种变更<br>制定并执行测试计划<br>按质量标准对软件质量进行度量<br>组织各种技术评审会</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘的一些操作</title>
      <link href="/2019/04/17/2019-04-17-%E5%A4%87%E5%BF%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%83%A6%E4%BA%BA%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/17/2019-04-17-%E5%A4%87%E5%BF%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%83%A6%E4%BA%BA%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>包括用linux自带openssl签postfix证书、流媒体证书按网上教程（百度找了九篇都是一样的还都没用，还转载转你🐴呢）找不到之类的问题，最后自己把证书试出来了，见第一部分，博客cdn换成tx云因为配置不一样导致好久没发现cdn没启用等尴尬的问题；</p><a id="more"></a><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>ubuntu自带的openssl包含的证书和RSA密钥等，相当于一套封装的加密套件。</p><ul><li>based on SSL&amp;TLS</li><li>生成常用key的指令如下（很久远了，之前记下的只有几个，以后更新）</li><li>如果没有的话可以下载包ca-certificates</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">openssl rsa -in rsa_private.key -pubout -out rsa_public.key</span><br><span class="line"></span><br><span class="line">private ase256加密:</span><br><span class="line">openssl genrsa -aes256 -passout pass:111111 -out rsa_aes_private.key 2048</span><br><span class="line"></span><br><span class="line">签postfix实现加密，关键的两步:</span><br><span class="line">由于Thawte_Premium_Server_CA.pem证书失效，在新的cacert包里面更换成thawte_Primary_Root_CA.pem</span><br><span class="line">cat /etc/ssl/certs/thawte_Primary_Root_CA.pem | sudo tee -a /etc/postfix/cacert.pem</span><br><span class="line">修改main.cf的smtp_tls_CAfile = /etc/postfix/cacert.pem，</span><br><span class="line">使用postmap生成用户名和密码的hash表</span><br><span class="line">重新加载/etc/init.d/postfix（postfix服务的jio本）就可以使用了</span><br></pre></td></tr></table></figure><h2 id="怪事情，opencv的cvtColor突然不能用，但是服务器上没问题"><a href="#怪事情，opencv的cvtColor突然不能用，但是服务器上没问题" class="headerlink" title="怪事情，opencv的cvtColor突然不能用，但是服务器上没问题"></a>怪事情，opencv的cvtColor突然不能用，但是服务器上没问题</h2><ul><li>解决方法找了其他源。。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install --channel https://conda.anaconda.org/menpo opencv3</span><br></pre></td></tr></table></figure></li></ul><h2 id="shell以前记的笔记"><a href="#shell以前记的笔记" class="headerlink" title="shell以前记的笔记(_ _)"></a>shell以前记的笔记(_ _)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开头加一句#!/bin/bash 说明是一个脚本</span><br><span class="line">变量不需要声明可以直接用</span><br><span class="line">变量取值的话加美元</span><br><span class="line">If while中条件注意空格</span><br><span class="line">变量赋值不加空格</span><br><span class="line">Echo重定向：如果需要变量值和字符串相连，加大括号。</span><br><span class="line">没写i自增导致死循环</span><br><span class="line">If后一定要写fi代表结束，汇编格式吼啊</span><br></pre></td></tr></table></figure><ul><li>一个技巧，似乎是以前在用别人写的caffe库的时候出现了这个问题，忘了报什么错了，不是记得很清楚</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    在Linux下编程时，或者说在一个有很多头文件互相 include 的场景中，经常会遇到不清楚一个变量</span><br><span class="line">的完整类型定义的情况（因为有用 <span class="keyword">typedef</span> 封装），从而有可能遇到编译出错。</span><br><span class="line">    例如在使用 stat 来读取文件属性的 i-node number 时，查看 stat 的手册，得知这个变量 st_ino 的变量类型是 <span class="keyword">ino_t</span>，而我们不清楚 <span class="keyword">ino_t</span>的准确定义究竟是什么。</span><br><span class="line">可以用如下方法：声明一个这样的变量即可。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">ino_t</span> blah;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">然后运行如下指令：</span><br><span class="line"></span><br><span class="line">gcc -E test.c | grep <span class="keyword">ino_t</span></span><br><span class="line">-E 选项的意思是：在预处理过程后结束并输出到标准输出。</span><br><span class="line">文档原文如下</span><br><span class="line">-E Stop after the preprocessing stage; <span class="keyword">do</span> <span class="keyword">not</span> run the compiler proper. </span><br><span class="line">The output is in the form of preprocessed source code, which is sent to the standard output.</span><br></pre></td></tr></table></figure><ul><li>c文件生成的步骤</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C/C++文件经过预处理(preprocessing)、编译(compilation)、汇编(assembly)、和连接(linking)才能变成可执行文件。</span><br></pre></td></tr></table></figure><ul><li>查看已经建立的tcp链接数量，包括close_waite ,established,time_wait状态，</li><li>不会awk的时候感觉这是个什么东西orz</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br></pre></td></tr></table></figure><h2 id="安装lua的时候-readline缺失"><a href="#安装lua的时候-readline缺失" class="headerlink" title="安装lua的时候 readline缺失"></a>安装lua的时候 readline缺失</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装一下 libreadline-dev，或者readline-dev，版本不一样有哪个装哪个</span><br></pre></td></tr></table></figure><h2 id="树莓派摄像头（非dsi口）"><a href="#树莓派摄像头（非dsi口）" class="headerlink" title="树莓派摄像头（非dsi口）"></a>树莓派摄像头（非dsi口）</h2><ul><li><p>可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer -tv driver=v4l2:width=800:height=700:device=/dev/video1 tv://</span><br></pre></td></tr></table></figure></li><li><p>python调用的时候使用PiCamera库或者cv库，PiCamera可以测试下能不能用，毕竟两行代码，做视觉还是用cv了</p><h2 id="tx云cdn"><a href="#tx云cdn" class="headerlink" title="tx云cdn"></a>tx云cdn</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置cdn</span><br><span class="line">源站信息： 自有源站，waynamigo.github.io</span><br><span class="line">回源配置： 回源host，waynamigo.cn</span><br></pre></td></tr></table></figure></li></ul><h3 id="发现使用shadowsocks还行，那个ssr扔了"><a href="#发现使用shadowsocks还行，那个ssr扔了" class="headerlink" title="发现使用shadowsocks还行，那个ssr扔了"></a>发现使用shadowsocks还行，那个ssr扔了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sslocal -c /etc/shadowsocks/config.json -d start</span><br></pre></td></tr></table></figure><p>sslocal 直接用apt安装shadowsocks</p><h3 id="使用的"><a href="#使用的" class="headerlink" title="使用的"></a>使用的</h3><h3 id="流媒体搭建"><a href="#流媒体搭建" class="headerlink" title="流媒体搭建"></a>流媒体搭建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/arut/nginx-rtmp-module.git</span><br><span class="line"></span><br><span class="line">wget http://nginx.org/download/nginx-1.8.1.tar.gz </span><br><span class="line">tar -zxvf nginx-1.8.1.tar.gz </span><br><span class="line">cd nginx-1.8.1 </span><br><span class="line">先安装一下依赖</span><br><span class="line">yum install pcre-devel</span><br><span class="line">yum install zlib zlib-devel</span><br><span class="line">yum install openssl openssl-devel</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx  --add-module=../nginx-rtmp-module  --with-http_ssl_module   </span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>/usr/local/nginx/conf/nginx.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rtmp &#123;   </span><br><span class="line">     </span><br><span class="line">    server &#123;   </span><br><span class="line">     </span><br><span class="line">        listen 1935;  #监听的端口 </span><br><span class="line">     </span><br><span class="line">        chunk_size 4000;   </span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        application hls &#123;  #rtmp推流请求路径 </span><br><span class="line">            live on;   </span><br><span class="line">            hls on;   </span><br><span class="line">            hls_path /usr/share/nginx/html/hls;   </span><br><span class="line">            hls_fragment 5s;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125; </span><br><span class="line">修改server模块的</span><br><span class="line">location / &#123; </span><br><span class="line">        root   /usr/share/nginx/html; </span><br><span class="line">        index  index.html index.htm; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="git配置多用户"><a href="#git配置多用户" class="headerlink" title="git配置多用户"></a>git配置多用户</h3><p>.ssh/config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_qq</span><br><span class="line">    User nanamya</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd  .git</span><br><span class="line">设置本项目的用户名和邮箱</span><br><span class="line">git config user.name <span class="string">"yourname"</span></span><br><span class="line">git config user.email <span class="string">"youremail"</span></span><br><span class="line">如果重设 则：</span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure><p>如果还是8行，检查一下，正常的话会有如下提示，否则会有debug的信息<br>ssh -vT <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><ul><li>提示Hi waynamigo! You’ve successfully authenticated, but GitHub does not provide shell access.</li></ul><h3 id="作死小能手"><a href="#作死小能手" class="headerlink" title="作死小能手"></a>作死小能手</h3><ul><li>:() { function :|:&amp; }; :</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker笔记整理（二）</title>
      <link href="/2019/03/27/2019-03-27-docker%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2019/03/27/2019-03-27-docker%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>咕</p><a id="more"></a><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ul><li>dockerhub ： <a href>waynamigo</a></li></ul><p>$$ \left\<br>{\begin{array}{c} a_1x+b_1y+c_1z=d_1 \ a_2x+b_2y+c_2z=d_2 \ a_3x+b_3y+c_3z=d3 \end{array} \<br>right.$$</p><p> 公式1\( \sqrt{\frac{n!}{k!(n-k)!}} \)</p><ul><li><p>2 \( \sqrt{\frac{n!}{k!(n-k)!}} \)</p></li><li><p>3 \( x^2 + y^2 = r^2 \)</p></li></ul><p>Let’s try a first example. Here’s a dummy equation:</p><p>$$a^2 + b^2 = c^2$$</p><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker笔记整理（一）</title>
      <link href="/2019/03/21/2019-03-21-docker%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%80/"/>
      <url>/2019/03/21/2019-03-21-docker%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>基本使用方法</p><a id="more"></a><h2 id="使用docker仓库"><a href="#使用docker仓库" class="headerlink" title="使用docker仓库"></a>使用docker仓库</h2><ul><li><p>首先，docker的一个镜像是由多层组成的，每一层一个id，在pull的时候可以看到</p></li><li><p>以下面为例，imageID是镜像的唯一id，但是镜像的完整id是第三行的sha256哈希值，使用docker images 指令的时候，默认id的位数显示是截断的，可以后跟参数<strong>–no-trunc=true</strong>来显示全部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID</span><br><span class="line">ubuntu              latest              94e814e2efa8</span><br><span class="line">Digest: sha256:94e814e2efa8845d95b2112d54497fbad173e45121ce9255b93401392f538499</span><br><span class="line">从官方下载，默认  docker pull &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">如果从第三方下载，需要在仓库前指定完整仓库地址（例如hub.c.163.com/public/&lt;image&gt;:&lt;tag&gt;）</span><br></pre></td></tr></table></figure></li><li><p>如果感觉DockerHub慢的话，可以使用镜像代理 <a href="https://registry.docker-cn.com。" target="_blank" rel="noopener">https://registry.docker-cn.com。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/systemd/system/docker.service.d/http_proxy.conf </span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=https://registry.docker-cn.com"</span></span><br><span class="line">然后</span><br><span class="line">systemctl daemon-reload，先reload units，重新加载一下配置单元，再重启docker服务</span><br><span class="line">systemctlrestart docker</span><br></pre></td></tr></table></figure></li><li><p>除了docker images，还有一个docker inspect &lt;image&gt;:&lt;tag&gt; 查看详细信息(json)</p></li><li><p>docker history &lt;image&gt;:&lt;tag&gt;查看历史信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"sha256:94e814e2efa8845d95b2112d54497fbad173e45121ce9255b93401392f538499"</span>,</span><br><span class="line">        <span class="attr">"RepoTags"</span>: [</span><br><span class="line">       <span class="string">"ubuntu:latest"</span></span><br><span class="line">       ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等"><a href="#基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等" class="headerlink" title="基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等"></a>基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等</h2><ul><li>docker search搜索镜像，也是按关键字来的。（你搜docker search mysql可以搜到MariaDB</li><li>docker image prune -f，强删本地垃圾。<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3></li><li>基于本地已有镜像创建，docker commit，和git格式差不多</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：docker commit -m <span class="string">'message'</span> -a <span class="string">'authorname'</span> &lt;changed imageid or name&gt; &lt;yourimage&gt;:&lt;tag&gt;</span><br><span class="line">docker commit -m <span class="string">'add one file'</span> -a <span class="string">'waynamigo'</span> c4b6b5b3e7d8 myimage:waynamigo</span><br><span class="line"></span><br><span class="line">ps:另外两个参数为</span><br><span class="line">-c 执行dockerfile，在后面整理</span><br><span class="line">-p 提交时暂停容器的进程</span><br></pre></td></tr></table></figure><ul><li>基于本地模板导入（只用了OpenVZ提供的一个linux模板搞了一下，准备有时间拿上学期的floppylinux的文件弄一个镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;filename&gt; | docker import - &lt;image&gt;:&lt;tag&gt;,后者为自定义的名字，导入成功后会显示镜像id</span><br></pre></td></tr></table></figure><ul><li>基于dockerfile创建镜像，下面是一个demo</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos #指定基镜像 </span><br><span class="line"></span><br><span class="line">MAINTAINER waynamigo #该镜像维护者的信息（我）</span><br><span class="line"></span><br><span class="line">COPY jdk1.8.0_79 jdk1.8.0_79 #从centos复制jdk，（竟然没有openjdk。。。还得配置环境变量</span><br><span class="line">ADD &lt;localfile&gt; # 跑了一个jar。。</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME=/jdk1.8.0_79</span><br><span class="line">ENV PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"></span><br><span class="line">EXPOSE 8080 #开放8080端口，其实不用写，因为jar里面已经把yml的配置打包好了</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/filename"</span>]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t waynamigo:webapp .</span><br><span class="line">生成后就可以创建容器并运行了</span><br><span class="line">docker run -p localhost:8080:8080 --name webapp_running  waynamigo:webapp</span><br></pre></td></tr></table></figure><ul><li>不放心的话可以进去康康<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it waynamigo:webapp<span class="comment"># 运行这个docker容器</span></span><br><span class="line">top <span class="comment"># 看进程</span></span><br><span class="line">lsof -i:8080 <span class="comment"># 或者看端口占用</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><ul><li><p>导出到本地，格式类似gcc++</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save &lt;image&gt;:&lt;tag&gt; -o xxx.tar</span><br></pre></td></tr></table></figure></li><li><p>如果要重新导入，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker load -i xxx.tar</span><br><span class="line">docker load &lt; xxx.tar</span><br></pre></td></tr></table></figure></li></ul><h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><ul><li><del>还是git</del>，docker push</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先上传到本地仓库（误</span><br><span class="line">docker tag &lt;image&gt;:&lt;tag&gt; waynamigo/&lt;image&gt;:&lt;tag&gt;</span><br><span class="line">然后push</span><br><span class="line">docker push waynamigo/&lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学期项目-begining</title>
      <link href="/2019/03/06/2019-03-06-%E5%AD%A6%E6%9C%9F%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/"/>
      <url>/2019/03/06/2019-03-06-%E5%AD%A6%E6%9C%9F%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>项目启动，本项目主要综合行为识别、目标检测、物体识别、文本情感分析进行开发.由于我负责行为识别和目标检测这一模块，只整理自己的工作内容</p><a id="more"></a><h2 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Through image, video recognition, text recognition, the</span><br><span class="line">students&apos; words and deeds are processed by the system to determine whether it has adverse effects on public civilization.</span><br></pre></td></tr></table></figure><h2 id="Environment-Support"><a href="#Environment-Support" class="headerlink" title="Environment Support"></a>Environment Support</h2><ol><li>Keras 2.0/2.2</li><li>Tensorflow 1.2</li><li><del>Pytorch</del><h2 id="Main-References"><a href="#Main-References" class="headerlink" title="Main References"></a>Main References</h2>I GET THE set of papers from <a href="https://blog.csdn.net/whfshuaisi/article/details/79116265" target="_blank" rel="noopener"><strong>HERE</strong></a><br><a href="https://arxiv.org/pdf/1505.00487.pdf" target="_blank" rel="noopener">VIDEO TO TEXT</a><br><a href="https://arxiv.org/pdf/1411.4555.pdf" target="_blank" rel="noopener">IMAGE CAPTION</a><br><a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">GET THE NAME FORM DETAIL F-CNN</a><br><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Donahue_Long-Term_Recurrent_Convolutional_2015_CVPR_paper.pdf" target="_blank" rel="noopener">CVPR</a><h3 id="Two-stream"><a href="#Two-stream" class="headerlink" title="Two-stream"></a>Two-stream</h3>The development of my Action-Recgnization module is based on <a href="https://arxiv.org/abs/1406.2199" target="_blank" rel="noopener"><strong>Two Stream</strong></a> 《Two-StreamConvolutional Networks for Action  Recognition in Videos》.</li></ol><h3 id="Reasons-of-using-Two-stream"><a href="#Reasons-of-using-Two-stream" class="headerlink" title="Reasons of using Two-stream"></a>Reasons of using Two-stream</h3><p> The Action-Recgnization is developed on the way of Two-Stream recent years,And researchers have come out many papers on IEEE SCI and others.but the main reason is that I did Video caption last year, both of them are Analyzing Video Infomation, I want try other algorithm to finish my project in higher quality(<del>get higher score</del>). </p><h3 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h3><p>Graphviz</p><ul><li>using dot generate this picture<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/asserts/imgs/" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><p><strong>the basic of Two-Stream is The Fusion of spatiotemporal information in a dual stream network.</strong><br>or<br><strong>The KEY POINT is  the better Fusion of spatial and temporal features</strong></p><ul><li>The interaction between layers within a single network, such as ResNet/Inception.</li><li>between dual-stream networks, including the exploration of different fusion methods. It is worth considering the structure of ResNet and connecting the dual-stream network.</li></ul><p>This project use the second method.</p><h4 id="Spatial-network"><a href="#Spatial-network" class="headerlink" title="Spatial network"></a>Spatial network</h4><p>It mainly captures important object features in video frames.</p><h4 id="Time-series-network"><a href="#Time-series-network" class="headerlink" title="Time series network"></a>Time series network</h4><p>both of them : finetune the ImageNet</p><h2 id="Document-Quality-Attributes"><a href="#Document-Quality-Attributes" class="headerlink" title="Document-Quality Attributes"></a>Document-Quality Attributes</h2><p>Each contains:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── Avaliability(Quality Attributes eg.)</span><br><span class="line">     ├── Scenario</span><br><span class="line">     ├── Stimulus Source</span><br><span class="line">     ├── Stimulus</span><br><span class="line">     ├── Artifact</span><br><span class="line">     ├── Environment</span><br><span class="line">     ├── Response</span><br><span class="line">     ├── Response measure</span><br><span class="line">     └── Tactics</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">Avaliability</th><th align="center">Performance</th><th align="center">Modifiability</th><th align="center">Usability</th><th align="center">Security</th><th align="center">Testability</th></tr></thead><tbody><tr><td align="center">Scenario</td><td align="center">Can not identify bad behavior</td><td align="center">The exported files are shown well</td><td align="center">New demands&amp;Structural optimization</td><td align="center">Customers want to export statistics file easily and need a reliable data</td><td align="center">Databases  is intruded</td><td align="center">Unit testing</td></tr><tr><td align="center">Stimulus Source</td><td align="center">System dependencies</td><td align="center">Customers</td><td align="center">Developers and Customers</td><td align="center">Customers</td><td align="center">Attackers</td><td align="center">Developers</td></tr><tr><td align="center">Stimulus</td><td align="center">Can’t solve information of the video</td><td align="center">Exporting operation</td><td align="center">Customers</td><td align="center">Runtime(?)</td><td align="center">Sql injection&amp;entitlement</td><td align="center">Unit testing each module</td></tr><tr><td align="center">Artifact</td><td align="center">whole system</td><td align="center">UI</td><td align="center">system</td><td align="center">UI</td><td align="center">DBMS</td><td align="center">Code</td></tr><tr><td align="center">Environment</td><td align="center">Windows/Linux x86_64/32 in Runtime environment</td><td align="center">Web browser</td><td align="center">Runtime environment</td><td align="center">Web browser</td><td align="center">Firewall&amp;Encryption</td><td align="center">Runtime environment</td></tr><tr><td align="center">Response</td><td align="center">Send a feedback to backend if can’t analyze the video from surveillance cameras;Retry if can’t export the list of score</td><td align="center">Export statistics files in 10s</td><td align="center">Extend and modify functions when come out a new demand</td><td align="center">Provide a easy-operated UI and reliable information</td><td align="center">Resist intrusion</td><td align="center">Each module passed the Test Cases</td></tr><tr><td align="center">Response measure</td><td align="center">within 5min;within 5s</td><td align="center">within 10s</td><td align="center">All modules is extensible and under the control of the evaluation indexs</td><td align="center">The satisfaction of user</td><td align="center">Database is protected</td><td align="center">Developers</td></tr><tr><td align="center">Tactics</td><td align="center">Retry Self-test</td><td align="center">Increase Resource Efficiency</td><td align="center">Split Module</td><td align="center">aaa</td><td align="center">warm backup</td><td align="center">Limit Non-determinism</td></tr></tbody></table><h3 id="Project-Details"><a href="#Project-Details" class="headerlink" title="Project Details"></a>Project Details</h3><ul><li>This project explores prominent action recognition models with UCF-101 dataset</li><li>Perfomance of different models are compared and analysis of experiment results are provided</li></ul><h2 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h2>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习DQN简介</title>
      <link href="/2019/03/02/2019-03-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%AD%A5/"/>
      <url>/2019/03/02/2019-03-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>QLearing的算法目标是：达到reward最大的state（状态，以一个使用无监督学习环境的agent为例，自<a href="https://blog.csdn.net/qq_16234613/article/details/80268564" target="_blank" rel="noopener">https://blog.csdn.net/qq_16234613/article/details/80268564</a></p><a id="more"></a><h1 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">预设值：首先将图中的每一条边预设reward，目标节点指向自己的邻接边的reward设100，其他设为0</span><br><span class="line">Q、R矩阵： 包括状态action和行为state，作为行列</span><br><span class="line">环境反馈: 对于每一次的episode （相当于迭代的东西），每一次尝试attemp，会根据反馈进行对网络更新</span><br><span class="line">环境更新.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R+r*max_Q(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">基本规则如下：</span><br><span class="line">Q表内容为index--state（agent的位置），columns--action(行为集)</span><br><span class="line">Q表（记录行为值）的计算规则是每次对于行为集合中的每一个action，对其进行计算、并进行选择。</span><br><span class="line">每一次episode，Q表更新一次</span><br><span class="line">定义EPSILON的目的是控制贪婪程度，其中，它可以随着时间推移 逐渐增加，贪婪)</span><br></pre></td></tr></table></figure><ul><li>主循环：图示<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/2-1-1.png)" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><p>首先要对其评估和更新准则进行确定，代码中表示可以直接定义在一个结构中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_env</span><span class="params">(S, episode, step_counter)</span>:</span></span><br><span class="line">    <span class="comment"># This is how environment be updated</span></span><br><span class="line">    env_list = [<span class="string">'-'</span>]*(N_STATES<span class="number">-1</span>) + [<span class="string">'T'</span>]   <span class="comment"># '---------T' our environment</span></span><br><span class="line">    <span class="keyword">if</span> S == <span class="string">'terminal'</span>:</span><br><span class="line">        interaction = <span class="string">'Episode %s: total_steps = %s'</span> % (episode+<span class="number">1</span>, step_counter)</span><br><span class="line">        print(<span class="string">'\r&#123;&#125;'</span>.format(interaction), end=<span class="string">''</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'\r                                '</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        env_list[S] = <span class="string">'o'</span></span><br><span class="line">        interaction = <span class="string">''</span>.join(env_list)</span><br><span class="line">        print(<span class="string">'\r&#123;&#125;'</span>.format(interaction), end=<span class="string">''</span>)</span><br><span class="line">        time.sleep(FRESH_TIME)</span><br></pre></td></tr></table></figure><h2 id="demo-参考莫烦python的一个例子"><a href="#demo-参考莫烦python的一个例子" class="headerlink" title="demo,参考莫烦python的一个例子"></a>demo,参考莫烦python的一个例子</h2><p>预先设置的参数，就是上述的预设值，其中gamma参数是作为奖励递减值，作用见后文代码，它是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N_STATES =  <span class="comment">#1维宽度</span></span><br><span class="line">ACTIONS =  <span class="comment">#动作集合</span></span><br><span class="line">EPSILON = <span class="comment">#greedy贪婪值</span></span><br><span class="line">ALPHA =  <span class="comment"># learning rate 学习率</span></span><br><span class="line">GAMMA =  <span class="comment"># discount factor 奖励递减值</span></span><br><span class="line">MAX_EPISODES =  <span class="comment"># maximum episodes 最大回合数</span></span><br></pre></td></tr></table></figure><p>Q表的行和列存储action和state，它的Value 每一次更新就是更新它的<strong>行为准则</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_q_table</span><span class="params">(n_states, actions)</span>:</span></span><br><span class="line">    table = pd.DataFrame(</span><br><span class="line">        np.zeros((n_states, len(actions))),</span><br><span class="line">        columns=actions,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> table</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> DQN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《Computer Communications_Incorporating energy and load balance into virtual》翻译</title>
      <link href="/2019/02/05/2019-02-05-Computer%20Communications_Incorporating%20energy%20and%20load%20balance%20into%20virtual%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/02/05/2019-02-05-Computer%20Communications_Incorporating%20energy%20and%20load%20balance%20into%20virtual%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>张老师论文翻译，有些事情搁置了</p><a id="more"></a><hr><h2 id="p1-introduction"><a href="#p1-introduction" class="headerlink" title="p1-introduction"></a>p1-introduction</h2><p>With the advancement of science and technology, many Internet end-users have the demand of deploying new protocols or installing new services on the existing network architecture. Unfortunately, the current Internet architecture cannot meet the increasing demands of these end-users, and the architecture of current Internet appears to be ossification. Network virtualization technique has been propounded as one of the important techniques to fend off the Internet ossification. Through the technique of network virtualization, Service Providers (SPs) can provide different services for different users by means of sliceable management of the existing substrate network resources, and can improve the resource utilization of substrate network and reduce the wasting of substrate network resources. Virtual network embedding is the core component of the network virtualization, it concerns mainly on the allocation of substrate resources and it leads to the virtual network embedding algorithm to be a hotspot of the research.<br>Due to the fact that the problem of virtual network embedding is proved to be an NP-hard problem, therefore, domestic and overseas scholars have proposed some of heuristic algorithms to address this issue or carried out the simulation under the small scale of network topology using the optimization tools. As mentioned earlier, the issue of virtual network embedding is a multi-objective optimization problem. It involves how to maximize the revenue of InPs, how to minimize the cost of accommodating virtual network requests, how to minimize the energy consumption of servers and equipment, and how to balance the workload of substrate networks. However, the prior studies concentrated primarily on the maximization of revenue by accommodating more virtual network requests or increasing the network resource utilization through optimizing virtual link mapping solutions. Fortunately,some researchers begin to study the energy-aware and security-aware virtual network embedding algorithms. In the subsequent section, we will introduce these two kinds of virtual network embedding algorithms.</p><p>In recent years, energy-aware virtual network embedding algorithms [1–5] have received considerable attention because the power consumption of an average data center is the same as 25,000 households [6] and it is becoming the major energy cost of network operators which almostly account for 42% of the total operating costs. In addition, the security vulnerabilities caused by network virtualization technologies have been attracted great attention from researchers. The security-aware virtual network embedding algorithms have been deeply investigated in the literature of [7–11]. The issues of network fragmentation and load balance can affect the acceptance ratio of VN requests and the Quality of Services (QoS) of the networks, and can equally affect the revenue of SPs since some high level customers are willing to pay the extra price for high quality of services.<br>However, these aforementioned algorithms involve two objective optimization. Therefore, there are some room for improvement by consideration more objectives on virtual network embedding algorithms. The main difference between our paper and previous works is that we take into consideration of energy consumption and load balance into virtual network embedding. This involves three objective optimization including revenue/cost, energy consumption and load balance, since our work is on the foundation of the classical heuristic algorithm which is the default consideration of revenue/cost. In our work, we investigated the multi-objective virtual network embedding algorithms,especially studied the energy and load balance aware virtual network embedding algorithm. Specifically, we first incorporate the node resource utilization and node energy consumption into the node ranking method aiming to give a comprehensive node ranking approach during the node mapping process. Then we utilize an improved differentiated pricing strategy with the purpose of selecting the substrate path with the minimum link consumption for virtual links. Finally, we take into account the node resource utilization to balance the node load in the node mapping stage, and adopt the improved differentiated pricing strategy for assigning different weights to different virtual links to balance the link load in the link mapping stage.</p><p>The main contributions of this paper can be summarized as follows:</p><ol><li>We introduce a comprehensive node ranking approach based on node available resource, node resource utilization and node energy consumption. The node ranking method not only takes into account the node energy consumption, but also takes the node resource utilization into consideration.</li><li>We leverage an improved differentiated pricing strategy to set different weights for different substrate links according to their bandwidth resource utilizations with the purpose of balancing the link load of substrate network, and employ the shortest path algorithm aiming at selecting the substrate path with the minimum link consumption for each virtual link from VNRs to perform the link mapping procedure. </li><li>We conduct extensive simulations and evaluate our proposed algorithm compared with the other state-of-the-art algorithms in terms of the acceptance ratio of VNRs, the long-term average revenue, the revenue to cost ratio, the standard deviation of node resource usage ratio, and the standard deviation of link resource usage ratio. The remainder of the paper is organized as follows. In Section 2, we briefly review the related works that associated with multi-objective virtual network embedding issues. We describe the system model and problem statement in Section 3. In Section 4, we elaborate our proposed algorithm E-LB-VNE in details. Experimental results and analysis are illustrated in Section 5. Section 6 concludes this paper.</li></ol><ul><li>翻译<br>随着科学技术的进步，许多互联网终端用户需要在现有网络架构上部署新协议或安装新服务。不幸的是，当前的互联网架构无法满足这些终端用户日益增长的需求，而当前互联网的架构似乎是僵化。网络虚拟化技术已被提出作为抵御互联网僵化的重要技术之一。通过网络虚拟化技术，服务提供商（SP）可以通过现有基板网络资源的可切片管理为不同用户提供不同的服务，可以提高基板网络的资源利用率，减少基板网络资源的浪费。虚拟网络嵌入是网络虚拟化的核心组成部分，它主要关注基板资源的分配，导致虚拟网络嵌入算法成为研究的热点。<br>由于虚拟网络嵌入问题被证明是NP难问题，因此国内外学者提出了一些启发式算法来解决这个问题，或者在小规模的网络拓扑中进行仿真。优化工具。如前所述，虚拟网络嵌入问题是一个多目标优化问题。它涉及如何最大化InP的收入，如何最小化容纳虚拟网络请求的成本，如何最小化服务器和设备的能耗，以及如何平衡基板网络的工作量。然而，先前的研究主要集中在通过优化虚拟链路映射解决方案来容纳更多虚拟网络请求或增加网络资源利用率来最大化收入。幸运的是，一些研究人员开始研究能量感知和安全感知虚拟网络嵌入算法。在接下来的部分中，我们将介绍这两种虚拟网络嵌入算法。</li></ul><p>近年来，能量感知虚拟网络嵌入算法[1-5]受到了广泛的关注，因为平均数据中心的功耗与25,000个家庭相同[6]，并且它正成为网络运营商的主要能源成本。几乎占总运营成本的42％。此外，网络虚拟化技术带来的安全漏洞也引起了研究人员的高度重视。在[7-11]的文献中深入研究了安全感知虚拟网络嵌入算法。网络分片和负载均衡的问题会影响VN请求的接受率和网络的服务质量（QoS），并且同样会影响SP的收入，因为一些高级客户愿意支付额外的高价格服务质量。<br>然而，这些上述算法涉及两个客观优化。因此，通过考虑虚拟网络嵌入算法的更多目标，存在一些改进的空间。我们的论文与以前的工作之间的主要区别在于我们将能耗和负载平衡考虑到虚拟网络嵌入中。这包括三个客观优化，包括收入/成本，能源消耗和负载平衡，因为我们的工作是经典启发式算法的基础，这是收入/成本的默认考虑因素。在我们的工作中，我们研究了多目标虚拟网络嵌入算法，特别研究了能量和负载平衡感知虚拟网络嵌入算法。具体来说，我们首先将节点资源利用率和节点能耗纳入节点排序方法，旨在在节点映射过程中提供全面的节点排序方法。然后，我们利用改进的差异化定价策略，目的是选择虚拟链路的最小链路消耗的基板路径。最后，我们考虑节点资源利用率来平衡节点映射阶段的节点负载，并采用改进的差异化定价策略为不同的虚拟链路分配不同的权重，以平衡链路映射阶段的链路负载。</p><p>本文的主要贡献可归纳如下：<br>1.我们引入了基于节点可用资源，节点资源利用率和节点能耗的综合节点排序方法。节点排序方法不仅考虑节点能耗，还考虑节点资源利用率。<br>2.我们利用改进的差异化定价策略，根据其带宽资源利用率为不同的基板链路设置不同的权重，以平衡基板网络的链路负载，</p><h2 id="p2-related-works"><a href="#p2-related-works" class="headerlink" title="p2-related works"></a>p2-related works</h2><p>In recent years, the problem of virtual network embedding has received considerable attention from domestic and overseas researchers.<br>However, most of previous studies do not consider it to be a multiobjective optimization problem while at most do a tradeoff between two objectives. The main goal of prior work with single objective is to maximize the revenue of SPs by accommodating more virtual network requests and reducing the bandwidth utilization of substrate links [12–16]. The main drawback of these single-objective algorithms is that<br>they did not realize the issue of virtual network embedding is a multi-objective problem, since a large amount of energy consumption can lead to reducing the overall revenue for ISPs, high quality of QoS will<br>increase the extra incomes of ISPs. To address these issues, two-objective virtual network embedding algorithms attract great attention from many researchers. The most representatives of these algorithms with two objectives are energy aware virtual network embedding algorithms, security aware virtual network embedding algorithms, and load balance aware virtual network embedding algorithms.</p><ul><li>翻译<br>近年来，虚拟网络嵌入问题受到国内外研究者的广泛关注。然而，大多数先前的研究并不认为它是多目标优化问题，而最多只是在两个目标之间进行权衡。单个目标的先前工作的主要目标是通过容纳更多的虚拟网络请求和降低基板链路的带宽利用来最大化SP的收入[12-16]。这些单目标算法的主要缺点是他们没有意识到虚拟网络嵌入问题是一个多目标问题，因为大量的能耗会导致ISP的整体收入减少，高质量的QoS将会增加ISP的额外收入。为了解决这些问题，双目标虚拟网络嵌入算法引起了许多研究者的极大关注。具有两个目标的这些算法的最多代表是能量感知虚拟网络嵌入算法，安全感知虚拟网络嵌入算法和负载平衡感知虚拟网络嵌入算法。</li></ul><h3 id="p2-1-energy-aware-VNE-algorithms"><a href="#p2-1-energy-aware-VNE-algorithms" class="headerlink" title="p2.1-energy aware VNE algorithms"></a>p2.1-energy aware VNE algorithms</h3><p>Due to the exponentially growing amount of physical machines for service provisioning in data centers, the energy consumption caused by a large amount of servers has been becoming a crucial issue, and it has<br>attracted significant attention in recent years.<br>Two approaches with two objectives that heuristic-based algorithm and particle-swarm-optimization-based algorithm are presented in [2], the authors traded off between energy consumption that is consumed<br>by supporting VN requests and revenue that obtained from accommodating VN requests, and proposed an energy cost model and formulated the energy-aware virtual network embedding problem as an<br>integer linear programming problem. The authors formulated a discrete-time model to capture the concrete values of electricity price to deal with electricity price fluctuation issue, classified the substrate<br>nodes into active nodes and inactive nodes, and separated the substrate nodes into host nodes that can be running some computing tasks and router nodes that only perform forwarding tasks so as to further<br>quantify the server energy consumption. However, the formulated mathematical model is based on the experimental simulation system, it cannot reflect the genuine network environments.<br>The power consumption that is consumed by data centers can be decomposed of three parts: the first part is the communication energy consumption that is consumed by substrate links, the second part is the<br>server energy consumption that is consumed by substrate nodes, and the third part is the other energy consumption that caused by cooling and power distribution systems. In the literature of [1], the authors<br>formulated a power-efficient VN provisioning issue into a mixed integer linear programming problem to address the first two parts of energy consumption problems. The contributions of this paper is to give the<br>refinement of communication energy consumption by means of modeling the substrate links as wavelength-division multiplexing (WDM) network which is much closer to the genuine network environments,<br>and employed an improved differentiated pricing strategy for choosing the routing paths. The proposed framework achieved a better tradeoff between the energy consumption and the blocking ratio of virtual<br>network requests. However, the disadvantage of this paper is that the proposed algorithm is based on two steps which cannot coordinate the two mapping stages, the main improvements lies in the improved dif-<br>ferentiated pricing strategy in the link mapping stage while ignoring the enhancement of node mapping algorithm for facilitating the subsequent link mapping, and it can be further improved and intensified.<br>The author of [4] proposed a memetic multi-objective energy aware virtual network embedding algorithm, in this paper, the author formulated an energy-aware virtual network embedding model and devised some of metrics for evaluating the embedding algorithms. This paper proposed a multi-objective particle swarm optimization algorithm to do a tradeoff among all of the optimization objectives, used the local search technique to accelerate the convergence of the proposed algorithm. Extensive simulations shown that the proposed algorithm outperforms the other existing algorithms in terms of increasing revenue and decreasing energy consumption. Nevertheless, the suggested algorithm does not consider the communication energy consumption that is consumed by substrate links.<br>The main differences between the work [1] and our work are summarized as follows. The first difference is that our proposed algorithm takes into consideration of both energy consumption and load balance. The second difference is that our method improved the differentiated pricing strategy with an aim to avoid link bandwidth resource bottleneck issue. The third difference is that our method adopts the genuine model to formulate the substrate link energy consumption.</p><h3 id="p2-2-load-balance-aware-VNE-algorithms"><a href="#p2-2-load-balance-aware-VNE-algorithms" class="headerlink" title="p2.2-load balance aware VNE algorithms"></a>p2.2-load balance aware VNE algorithms</h3><p>The load balance issue is an important aspect of virtual network embedding problems apart from the issues of revenue and energy consumption. The unbalanced workload in the substrate network can lead to the decreasing quality of services and quality of user experience (QoE) which does not guarantee that the offered services comply with the prescribed service level agreements (SLAs). In this section, we<br>summarize the load balance aware virtual network embedding approaches.<br>Li et al. [17] suggested a virtual network embedding algorithm from the perspective of load balance with diverse virtual network requests. In their studies, they computed the node link resource ratio and link node resource ratio of substrate network using the available resource on substrate nodes and substrate links, and computed the node link resource ratio and link node resource ratio of virtual networks using the demand requirements of virtual nodes and virtual links. In the node mapping stage, they choose substrate node with the node link resource ratio is closest to the node link resource ratio of virtual node. In the link mapping stage, they choose substrate link with the link node resource ratio is closest to the link node resource ratio of virtual link. Extensive simulation demonstrated that the proposed algorithm can achieve higher acceptance ratio, revenue, and the state of load balancing.<br>The authors of [18] presented an energy-aware virtual network embedding heuristic algorithm in their studies. They used a balancing factor to tradeoff between CPU resource of nodes and bandwidth resource of adjacent links for measuring the node importance. The proposed algorithm is based on the principle of energy consumption optimization and coordination between node mapping and link mapping, a comprehensive node ranking method is presented with the purpose of reducing the energy consumption and increasing the acceptance ratio.<br>Aim at achieving the simultaneous load balancing of the substrate node and the substrate link, Huang [19] formulated a mathematical model of virtual network embedding problem which constrained by the number of hops, and proposed a multi-objective particle swarm optimization algorithm called LB-PSO to solve it, the proposed algorithm has significantly increased the acceptance ratio and resource utilization.<br>In the study of [20], the authors formulated an integer linear programming model for the fragmentation-aware virtual network embedding problem for the first time, and carried out some simulations in three different scenarios to indicate that their algorithm outperforms the other existing algorithms.</p><h2 id="p3-system-model-and-problem-statement"><a href="#p3-system-model-and-problem-statement" class="headerlink" title="p3-system model and problem statement"></a>p3-system model and problem statement</h2><p>公式整理待更新</p><h2 id="p4-the-proposed-algorithm"><a href="#p4-the-proposed-algorithm" class="headerlink" title="p4-the proposed algorithm"></a>p4-the proposed algorithm</h2><h2 id="p5-evaluation-results"><a href="#p5-evaluation-results" class="headerlink" title="p5-evaluation results"></a>p5-evaluation results</h2><h2 id="p6-conclusion"><a href="#p6-conclusion" class="headerlink" title="p6-conclusion"></a>p6-conclusion</h2><p>物理网络资源（指民用网络）的能耗 由于网络用户急速增长的原因而大幅增加。<br>另外它还会导致不平衡的基础网络的负载的超重部分，并减少（virtual network embedding system)的性能。<br>所以，研究将能耗和负载均衡纳入虚拟化网络嵌入过程对多目标具有重要意义虚拟网络嵌入算法。<br>在本文中，我们首先研究了节点能量的影响<br>节点排名计算中的sumption和节点资源利用率<br>灰。然后我们提出了一种全面的节点排序方法CNRM<br>在节点期间测量衬底节点的嵌入电位<br>映射过程。此外，我们改善了差异化定价<br>为了选择的目的加权衬底链接的策略<br>基板路径，每个链路能耗最小<br>虚拟链接。仿真结果表明我们的方法可以<br>降低能耗，改善子负载平衡<br>战略网络，同时略微恶化长期平均转速<br>enue，接受率和收入与成本比率。<br>由于不同的网络拓扑结构有所不同<br>因此，我们将需要不同的映射方法<br>专注于不同的虚拟网络嵌入算法<br>我们未来工作中的各种网络拓扑。在我们的工作中，我们主要是<br>专注于启发式虚拟网络嵌入算法，<br>而确切的VNE算法超出了我们的研究工作。我们打算<br>在未来的工作中做这项工作。</p>]]></content>
      
      
      <categories>
          
          <category> 翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决软件源更新，旧版本软件应用无法使用的问题</title>
      <link href="/2019/01/17/2019-01-17-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E4%BF%AE%E6%94%B9deb%E4%BE%9D%E8%B5%96/"/>
      <url>/2019/01/17/2019-01-17-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E4%BF%AE%E6%94%B9deb%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>简单的修改官方deb依赖的操作例子，以修改网易云音乐debian包为例</p><a id="more"></a><hr><h1 id="查看软件包里的文件内容-不必要，只是避免好久不用忘了参数"><a href="#查看软件包里的文件内容-不必要，只是避免好久不用忘了参数" class="headerlink" title="查看软件包里的文件内容(不必要，只是避免好久不用忘了参数"></a>查看软件包里的文件内容(不必要，只是避免好久不用忘了参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -c neteasemusic.deb</span><br></pre></td></tr></table></figure><h1 id="用dpkg解压"><a href="#用dpkg解压" class="headerlink" title="用dpkg解压"></a>用dpkg解压</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将软件包中的文件释放到extracted目录下</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -x neteasemusic.deb extracted/</span><br></pre></td></tr></table></figure><h1 id="解压deb包中DEBIAN目录下的文件"><a href="#解压deb包中DEBIAN目录下的文件" class="headerlink" title="解压deb包中DEBIAN目录下的文件"></a>解压deb包中DEBIAN目录下的文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将主控信息解压，control中包括了所有依赖</span><br></pre></td></tr></table></figure><ul><li>dpkg创建包的时候，依赖的控制信息在DEBIAN文件夹中，所以首先要创建一个DEBIAN文件夹（大写</li></ul><p>否则会出现错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb: error: failed to open package info file <span class="string">'build//DEBIAN/control'</span> <span class="keyword">for</span> reading: No such file or directory</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -e neteasemusic.deb extracted/DEBIAN</span><br></pre></td></tr></table></figure><h1 id="创建debian软件包"><a href="#创建debian软件包" class="headerlink" title="创建debian软件包"></a>创建debian软件包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -b extract/ ./</span><br></pre></td></tr></table></figure><h1 id="参数如下"><a href="#参数如下" class="headerlink" title="参数如下"></a>参数如下</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* -c：显示软件包中的文件列表；</span><br><span class="line">* -e：将主控信息解压；</span><br><span class="line">* -f：把字段内容打印到标准输出；</span><br><span class="line">* -x：将软件包中的文件释放到指定目录下；</span><br><span class="line">* -X：将软件包中的文件释放到指定目录下，并显示释放文件的详细过程；</span><br><span class="line">* -w：显示软件包的信息；</span><br><span class="line">* -l：显示软件包的详细信息；</span><br><span class="line">* -R：提取控制信息和存档的清单文件；</span><br><span class="line">* -b：创建debian软件包。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debian </tag>
            
            <tag> dpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算复习</title>
      <link href="/2019/01/08/2019-01-08-%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/01/08/2019-01-08-%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>云计算概论</p><a id="more"></a><hr><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 云计算的定义</span><br><span class="line">* 云计算的人群</span><br></pre></td></tr></table></figure><h2 id="云计算的特征"><a href="#云计算的特征" class="headerlink" title="云计算的特征"></a>云计算的特征</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">超大规模</span><br><span class="line">高可扩展性</span><br><span class="line">虚拟化</span><br><span class="line">高可靠性</span><br><span class="line">通用性</span><br><span class="line">廉价性</span><br><span class="line">灵活定制</span><br></pre></td></tr></table></figure><h2 id="云计算的优点"><a href="#云计算的优点" class="headerlink" title="云计算的优点"></a>云计算的优点</h2><ul><li>虚拟化技术</li><li>动态可扩展</li><li>按需部署</li><li>高灵活性</li><li>高可靠性</li><li>高性价比</li></ul><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">降低用户计算机的成本</td><td align="center">要求持续的网络连接</td></tr><tr><td align="center">改善性能</td><td align="center">低带宽网络连接环境下不能很好地工作</td></tr><tr><td align="center">降低IT基础设施投资</td><td align="center">反应慢</td></tr><tr><td align="center">减少维护问题</td><td align="center"></td></tr><tr><td align="center">减少软件开支</td><td align="center"></td></tr><tr><td align="center">即时的软件更新</td><td align="center"></td></tr><tr><td align="center">计算能力的增长</td><td align="center">功能有限制</td></tr><tr><td align="center">无限的存储能力</td><td align="center"></td></tr><tr><td align="center">增强的数据安全性</td><td align="center">无法确保数据的安全性</td></tr><tr><td align="center">改善操作系统的兼容性</td><td align="center"></td></tr><tr><td align="center">改善文档格式的兼容性</td><td align="center">不能保证数据不会丢失</td></tr><tr><td align="center">简化团队协作</td><td align="center"></td></tr><tr><td align="center">没有地点限制的数据获取</td><td align="center"></td></tr><tr><td align="center">绿色计算思想的实现者</td><td align="center"></td></tr></tbody></table><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>服务类型： 基础设施、平台、应用<br>部署范围： 公有、私有、混合</p><ul><li>并行计算、分布式计算、网格计算属于计算科学</li><li>云计算、效用计算属于计算模式、商业模式<h2 id="与网格计算的区别："><a href="#与网格计算的区别：" class="headerlink" title="与网格计算的区别："></a>与网格计算的区别：</h2></li><li>网格是共享资源、协同计算，是一种资源共享模型。</li><li>而云计算采用网络将集群资源连接在一起，单向提供给用户资源进行数据处理。</li><li><strong>资源调度模式</strong> ：云计算以数据为中心，采用集群存储管理资源；网格计算以计算为中心，资源分布在各地。云计算进一步将硬件虚拟化。<h2 id="云计算体系结构"><a href="#云计算体系结构" class="headerlink" title="云计算体系结构"></a>云计算体系结构</h2>IaaS、PaaS、SaaS</li><li>infrastructure asa service： 硬件 资源</li><li>platform asa service： 软件环境</li><li>software asa service：应用程序</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/IPS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="云存储结构-GFS-Google-File-System-HDFS-Hadoop-Distributed-File-System"><a href="#云存储结构-GFS-Google-File-System-HDFS-Hadoop-Distributed-File-System" class="headerlink" title="云存储结构 GFS (Google File System) HDFS(Hadoop Distributed File System)"></a>云存储结构 GFS (Google File System) HDFS(Hadoop Distributed File System)</h2><ul><li>存储层</li><li>基础管理层</li><li>应用接口层</li><li>访问层<h2 id="云计算技术体系结构"><a href="#云计算技术体系结构" class="headerlink" title="云计算技术体系结构"></a>云计算技术体系结构</h2></li><li>物理资源层：计算机、存储器、网络设施、数据库、软件</li><li>资源池层：将大量相同类型的资源构成资源池</li><li>管理中间件层： 资源管理、任务管理、用户管理、安全管理</li><li>SOA(Service-Oriented Architecture）构建层：将云计算能力封装成标准的Web Services</li></ul><h2 id="云计算的两条底层技术路线"><a href="#云计算的两条底层技术路线" class="headerlink" title="云计算的两条底层技术路线"></a>云计算的两条底层技术路线</h2><ul><li>分布式计算：把一个任务分解成多个小人物，在不同的服务器进行计算，整合计算资源</li></ul><ul><li><p>虚拟化：提供Iaas虚机，分割计算资源</p><h2 id="VMM的分类-VMM-virtual-machine-monitor-虚拟化核心软件"><a href="#VMM的分类-VMM-virtual-machine-monitor-虚拟化核心软件" class="headerlink" title="VMM的分类 VMM(virtual machine monitor)虚拟化核心软件"></a>VMM的分类 VMM(virtual machine monitor)虚拟化核心软件</h2><p>管理虚拟环境、管理物理资源</p></li><li><p>所谓虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟化就是由位于下层的软件模块,通过向上一层软件模块</span><br><span class="line">提供一个与它原先所期待的运行环境 完全一致 的接口的方法,</span><br><span class="line">抽象出一个虚拟的软件或硬件接口,使得上层软件可以直接运行在虚拟环境上。</span><br></pre></td></tr></table></figure></li><li><p>虚拟化的优点:封装(逻辑化)\多实例–计算资源的充分利用率、绿色节能、降低成本\隔离\硬件兼容\虚拟化层特权</p></li><li><p>虚拟化的缺点:性能错误安全影响复杂：虚拟化层的引入增加了系统出错层面(如有些驱动无法加载)</p></li><li><p>虚拟平台：完全虚拟化 半虚拟化</p></li><li><p>实现结构 ：Hypervisor模型宿主模型混合模型</p><h2 id="IO虚拟化"><a href="#IO虚拟化" class="headerlink" title="IO虚拟化"></a>IO虚拟化</h2></li><li><p>发现虚拟设备</p></li><li><p>虚机加载驱动，通过vmm提供的后端接口驱动设备</p></li><li><p>后端驱动程序调用物理驱动程序管理物理IO设备</p></li></ul><p>设备模型指VMM中进行设备模拟,并处理所有设备请求和响应的逻辑模块</p><h2 id="ssh原理"><a href="#ssh原理" class="headerlink" title="ssh原理"></a>ssh原理</h2><ul><li><p>客户端向服务器端发出连接请求</p></li><li><p>服务器端向客户端发出自己的公钥</p></li><li><p>客户端使用服务器端的公钥加密通讯密钥然后发给服务器端</p></li><li><p>如果通讯过程被截获,由于窃听者即使获知公钥和经过公钥加密的内容,但不拥有私钥依然无法解密(RSA算法)</p></li><li><p>服务器端接收到密文后,用私钥解密,获知通讯密钥</p></li><li><p>ssh-keygen命令给服务器端产生公私钥密钥对</p></li><li><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2></li><li><p>HDFS</p></li><li><p>NameNode</p></li><li><p>DataNode</p></li><li><p>事务日志</p></li><li><p>映像文件</p></li><li><p>SecondaryNameNode</p></li><li><p>读取数据流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端要访问HDFS中的一个文件</span><br><span class="line">首先从namenode获得组成这个文件的数据块位置列表</span><br><span class="line">根据列表知道存储数据块的datanode</span><br><span class="line">访问datanode获取数据</span><br><span class="line">Namenode并不参与数据实际传输</span><br></pre></td></tr></table></figure></li><li><p>冗余副本策略,所有数据块都有副本</p></li><li><p>心跳机制，保证数据一致性</p></li><li><p>机架策略</p></li></ul><h2 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h2><ul><li><p>HBase是一个分布式的、面向列的开源数据库</p></li><li><p>适合于非结构化数据存储的数据库</p></li><li><p>行键是数据行在表里的唯一标识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 以表的形式存放数据</span><br><span class="line">* 表由行与列组成,每个列属于某个列族,由行和列确定的存储单元称为元素</span><br><span class="line">* 每个元素保存了同一份数据的多个版本,由时间戳来标识区分</span><br></pre></td></tr></table></figure></li><li><p>列表示为&lt;列族&gt;:&lt;限定符&gt;</p></li><li><p>Hbase在磁盘上按照列族存储数据,这种列式数据库的设计非常适合于数据分析</p></li><li><p>列族里的元素最好具有相同的读写方式(例如等长的字符串),以提高性能，可压缩</p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2></li><li><p>把Linux的cgroup、namespace,chroot等容器底层技术进行封装抽象,为用户提供了创建和管理容器的便捷界面</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> Cloud Computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理应用层复习</title>
      <link href="/2019/01/07/2019-01-07-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2019/01/07/2019-01-07-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>运输层是两个进程之间的逻辑通信，网络层是为主机之间提供逻辑通信，运输层负责对报文差错检测</p><a id="more"></a><ul><li>域名系统 DNS</li><li>文件传送协议</li><li>远程终端协议 TELNET</li><li>万维网 WWW</li><li>电子邮件</li><li>动态主机配置协议 DHCP</li><li>P2P 应用</li></ul><hr><p>#总结</p><ul><li>国家顶级域名 nTLD</li><li>通用顶级域名 gTLD</li><li>基础结构域名 (infrastructure domain)，<em>顶级域名只有一个,即 arpa</em></li><li>一个服务器所负责管辖的(或有权限的)范围叫<strong>区 (zone)</strong>。</li><li>每一个区设置相应的权限域名服务器,用来保存该区中的所有主机的域名到 IP 地址的映射。<br>根域名服务器共有 13 套装置,不是 13 个机器</li><li>可靠性：DNS 域名服务器都把数据复制到几个域名服务器来保存,其中的一个是主域名服务器,其他<br>的是辅助域名服务器<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2></li><li>根域名服务器 最高层次的域名服务器,也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址<br>a.rootservers.net<br>b.rootservers.net</li><li>顶级域名服务器</li><li>权限域名服务器</li><li>本地域名服务器<h2 id="域名的解析过程"><a href="#域名的解析过程" class="headerlink" title="域名的解析过程"></a>域名的解析过程</h2></li><li>主机向本地域名服务器的查询一般都是采用递归查询</li><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询。<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3></li><li><em>每个域名服务器都维护一个高速缓存*</em> ,存放最近用过<br>的名字以及从何处获得名字映射信息的记录</li></ul><hr><h1 id="文件传输-文件传送协议-FTP-File-Transfer-Protocol"><a href="#文件传输-文件传送协议-FTP-File-Transfer-Protocol" class="headerlink" title="文件传输 文件传送协议 FTP (File Transfer Protocol)"></a>文件传输 文件传送协议 FTP (File Transfer Protocol)</h1><ul><li>提供交互式的访问<h2 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h2></li><li>打开熟知端口(端口号为 21),使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程来处理客户进程发来的请求。</li><li>回到等待状态,继续接受其他客户进程发来的请求。<h2 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h2>控制连接在整个会话期间一直保持打开，实际用于传输文件的是“数据连接”<h1 id="超媒体超文本"><a href="#超媒体超文本" class="headerlink" title="超媒体超文本"></a>超媒体超文本</h1></li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理运输层复习</title>
      <link href="/2019/01/06/2019-01-06-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2019/01/06/2019-01-06-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>运输层是两个进程之间的逻辑通信，网络层是为主机之间提供逻辑通信，运输层负责对报文差错检测</p><a id="more"></a><ul><li>用户数据报协议 UDP</li><li>传输控制协议 TCP</li><li>可靠传输的工作原理</li><li>TCP 报文段的首部格式</li><li>TCP 的流量控制、拥塞控制</li><li>TCP 的运输连接管理</li></ul><hr><h1 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP  UDP"></a>TCP  UDP</h1><ul><li>传输的数据单位：运输协议数据单元 TPDU (Transport Protocol Data Unit)</li></ul><h2 id="用户数据报协议UDP-User-Datagram-Protocol"><a href="#用户数据报协议UDP-User-Datagram-Protocol" class="headerlink" title="用户数据报协议UDP (User Datagram Protocol)"></a>用户数据报协议UDP (User Datagram Protocol)</h2><ul><li><strong>无连接</strong> </li><li>├── 在传送数据之前不需要先建立连接</li><li>├── 对方的运输层在收到 UDP 报文后,不需要给出任何确认。</li><li>└── 不提供可靠交付<br>与IP数据报的区别：IP需要经过存储转发过程、UDP在运输层的端到端（进程）的逻辑信道中传送，只比IP数据报服务多了</li><li>复用分用</li><li>差错检测<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li><li>UDP 是无连接的,发送数据之前不需要建立连接,因此减少了开销和发送数据之前的时延</li><li>UDP 使用尽最大努力交付,即不保证可靠交付</li><li>UDP 是面向报文的,UDP 一次交付一个完整的报文。</li><li>UDP 没有拥塞控制</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信,全双工</li><li>UDP 的首部开销小,<strong>只有 8 个字节</strong>,比TCP 的 20 个字节的首部要短。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/UDP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="传输控制协议-TCP-Transmission-Control-Protocol"><a href="#传输控制协议-TCP-Transmission-Control-Protocol" class="headerlink" title="传输控制协议 TCP (Transmission Control Protocol)"></a>传输控制协议 TCP (Transmission Control Protocol)</h2></li><li>面向连接的运输层协议</li><li>TCP 连接只能有两个端点</li><li>提供可靠交付</li><li>提供全双工通信</li><li>面向字节流<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3>根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节<br>(UDP 发送的报文长度是应用进程给出的)</li></ul><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><ul><li><p>停止等待协议</p></li><li><p>连续ARQ协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">发送方维持的发送窗口,它的意义是:</span><br><span class="line">位于发送窗口内的分组都可连续发送出去,而不需要等待对方的确认。</span><br><span class="line">这样,信道利用率就提高了。</span><br><span class="line">连续 ARQ 协议规定,发送方每收到一个确认,就把发送窗口向前滑动一个分组的位置。</span><br><span class="line"></span><br><span class="line">接收方一般采用累积确认的方式。</span><br><span class="line">即不必对收到的分组逐个发送确认,而是对按序到达的最</span><br><span class="line">后一个分组发送确认,</span><br><span class="line">这样就表示:到这个分组为止的所有分组都已正确收到了。</span><br></pre></td></tr></table></figure></li><li><p>确认丢失<strong>不必重传</strong></p></li><li><p>不能向发送方反映出接收方已经正确收到的所有分组的信息</p><h3 id="GBN重传"><a href="#GBN重传" class="headerlink" title="GBN重传"></a>GBN重传</h3></li><li><p>可以在连续收到好几个正确的确认帧后，才对最后一个数据帧发确认信息</p></li><li><p>这就是说，对某一数据帧的确认就表明该数据帧和这以前所有的数据帧均已正确无误地收到了。</p></li><li><p>后退N帧协议的接受窗口为1，可以保证按序接受数据帧。若采用n个比特对帧编号，则其发送窗口的尺寸Wt应满足：1&lt;=Wt&lt;=2^n-1</p></li><li><p>ACK(n+1)表示对第n号帧的确认，表明接受方已正确收到第n帧及以前的所有帧</p><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>数据链路层采用了后退N帧(GBN)协议，发送方已经发送了编号为0～7的帧。当计时器超时时，若发送方只收到0、2、3号帧的确认，则发送方需要重发的帧数是( )。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解析：根据后退N帧协议，接收方的窗口为“<span class="number">1</span>”，如果发送方收到了<span class="number">3</span>号帧的确认，则说明<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>号帧都已经发送成功，所以只需要重发<span class="number">4</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">7</span>号帧即可。</span><br></pre></td></tr></table></figure></li></ul><h2 id="TCP可靠重传"><a href="#TCP可靠重传" class="headerlink" title="TCP可靠重传"></a>TCP可靠重传</h2><ul><li>字节为单位的滑动窗口 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">发送缓存：存放①发送应用程序传送给发送方 TCP 准备发送的数据</span><br><span class="line">        ②TCP 已发送出但尚未收到确认的数据</span><br><span class="line">* 超时重传时间</span><br><span class="line">* 选择确认SACK</span><br><span class="line">## TCP流量控制</span><br><span class="line">出现拥塞的原因:</span><br><span class="line">∑对资源需求 &gt; 可用资源</span><br><span class="line"></span><br><span class="line">* 增加资源不能解决拥塞，重传也不行，反而可能加剧</span><br><span class="line">* 拥塞控制：为了防止过多数据注入到网络中，一个全局性的过程</span><br><span class="line">* 流量控制：点对通信量的控制，一个端到端的过程，抑制发送端发送数据的速率,以便使接收端来得及接收</span><br><span class="line">开环控制、闭环控制。</span><br><span class="line">### tcp拥塞控制方法（闭环控制</span><br><span class="line">TCP发送方维持一个拥塞窗口 CWND(Congestion Window)</span><br><span class="line">*判断方式 有两个：*</span><br><span class="line">* 使用**重传定时器**定时，若超时，重传；</span><br><span class="line">* 收到三个重复的ACK</span><br><span class="line">算法有四种，慢开始，&lt;blue&gt;拥塞避免&lt;/blue&gt;、快重传、快恢复</span><br><span class="line">* 拥塞窗口 cwnd 设置：最大报文段 SMSS 窗口数值</span><br><span class="line">* 慢开始门限 ssthresh(状态变量):防止拥塞窗口cwnd 增长过大引起网络拥塞。</span><br></pre></td></tr></table></figure></li></ul><p>当 cwnd &lt; ssthresh 时,使用慢开始算法。<br>当 cwnd &gt; ssthresh 时,停止使用慢开始算法而改<br>用拥塞避免算法。<br>当 cwnd = ssthresh 时,既可使用慢开始算法,也<br>可使用拥塞避免算法。</p><pre><code>* 3ACK  拥塞避免，变成一半，然后拥塞避免，线性增加* 超时  cwnd=1，慢开始，从1开始增加### 快重传：让发送方尽早知道发生了个别报文段的丢失发送方只要一连收到三个重复确认,就知道接收方确实没有收到报文段,因而应当立即进行重传(即“快重传”),这样就不会出现超时,发送方也不就会误认为出现了网络拥塞{% image {{site.baseurl}}/assets/img/FN.png '' '' %}## TCP三次握手发送链接请求报文段* A ---------------------------------------- B* A发请求报文段，同步位SYN=1，选择序号seq=x表示第一个数据字节的序号为x* B发确认报文段，同步位SYN=1，确认位ACK=1，确认号ack=x+1，自己的数据序号seq=y* A发确认报文段，确认位ACK=1，数据序号seq=x+1，确认号ack=y+1发送链接释放报文段* A ---------------------------------------- B* A发请求报文段，FIN=1，选择序号seq=u* B发确认报文段，ACK=1，确认号ack=u+1，数据序号seq=v，A半关闭* B发确认报文段，FIN=1，ACK=1，确认号ack=u+1，数据序号seq=w* A发确认报文段，ACK=1，确认号ack=w+1，数据序号seq=u+1，A关闭**其中，A 必须等待 2MSL 的时间*** 保证 A 发送的最后一个 ACK 报文段能够到达 B。* A 在发送完最后一个 ACK 报文段后,再经过时间 2MSL,就可以使本连接持续的时间内所产生的所有报文段,都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理网络层复习</title>
      <link href="/2019/01/05/2019-01-05-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/01/05/2019-01-05-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>限于IP层</p><a id="more"></a><p>网络层向运输层提供的服务</p><h2 id="面向连接-无连接"><a href="#面向连接-无连接" class="headerlink" title="面向连接  无连接"></a>面向连接  无连接</h2><h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 地址解析协议 ARP(Address Resolution Protocol)** </span><br><span class="line">* 网际控制报文协议 ICMP(Internet Control Message Protocol)**</span><br><span class="line">* 网际组管理协议 IGMP(Internet Group Management Protocol)**</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/IPands.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>互联时使用中间设备</strong></p><ul><li>物理层中继系统:转发器 (repeater)。</li><li>数据链路层中继系统:网桥 或 桥接器 (bridge)。</li><li>网络层中继系统:路由器 (router)。</li><li>网桥和路由器的混合物:桥路器 (brouter)。</li><li>网络层以上的中继系统:网关 (gateway)。<h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2></li><li><em>A B C三类*</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">网络号|主机号  一共<span class="number">32</span>位</span><br><span class="line">IPv6 <span class="number">128</span>位</span><br><span class="line">IP 地址 ::= &#123; &lt;网络号&gt;, &lt;主机号&gt;&#125;</span><br><span class="line">A类地址 <span class="number">8</span> ，<span class="number">24</span> [最大可指派网络<span class="number">126</span> (<span class="number">2</span>^<span class="number">7</span> -<span class="number">1</span> -<span class="number">1</span>)]</span><br><span class="line">B类地址 <span class="number">16</span>，<span class="number">16</span> [最大可指派网络(<span class="number">2</span>^<span class="number">14</span> -<span class="number">1</span> -<span class="number">1</span>)]</span><br><span class="line">C类地址 <span class="number">24</span>, <span class="number">8</span>  [最大可指派网络(<span class="number">2</span>^<span class="number">21</span> -<span class="number">1</span> -<span class="number">1</span>)]</span><br></pre></td></tr></table></figure></li></ul><p>IP地址与硬件地址报文、数据帧的区别</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/IPandHard.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="其他分类方式"><a href="#其他分类方式" class="headerlink" title="其他分类方式"></a>其他分类方式</h3><ul><li><p>子网划分</p></li><li><p>构成超网</p><h2 id="ARP协议-解决同一个局域网的主机或路由器的IP：MAC问题"><a href="#ARP协议-解决同一个局域网的主机或路由器的IP：MAC问题" class="headerlink" title="ARP协议,解决同一个局域网的主机或路由器的IP：MAC问题"></a>ARP协议,解决同一个局域网的主机或路由器的IP：MAC问题</h2></li><li><p>不管网络层使用的是什么协议,在实际网络的链路上传送数据帧时,最终还是必须使用<strong>硬件地址</strong>。</p></li><li><p>ARP 高速缓存 (ARPcache),里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br>格式 &lt; IP address;MAC address;TTL &gt; TTL (Time To Live):地址映射有效时间 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存放最近获得的 IP 地址到 MAC 地址的绑定,以减少 ARP 广播的数量。</span><br><span class="line">为了减少网络上的通信量,主机 A 在发送其ARP请求分组时,就将自己的 IP 地址</span><br><span class="line">到硬件地址的映射写入 ARP 请求分组。</span><br><span class="line">当主机 B 收到 A 的 ARP 请求分组时,就将主机 A的这一地址映射写入</span><br><span class="line">主机 B 自己的 ARP高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。</span><br></pre></td></tr></table></figure></li><li><p>ARP请求分组<br>包含发送方硬件地址 / 发送方IP 地址/目标方硬件地址(未知时填 0)/ 目标方IP 地址。</p></li><li><p>本地广播 ARP 请求</p></li><li><p>ARP 响应分组 包含发送方硬件地址/发送方IP地址/目标方硬件地址/目标方 IP 地址。</p></li></ul><h2 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h2><p>数据报字段格式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/IPziduan.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>转发过程：根据IP数据报的目的地址就可以确定下一跳路由器<br>分组转发算法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。</span><br><span class="line">(<span class="number">2</span>) 若网络 N 与此路由器直接相连,则把数据报直接交付目的主机D;</span><br><span class="line">否则是间接交付,执行(<span class="number">3</span>)。</span><br><span class="line">(<span class="number">3</span>) 若路由表中有目的地址为 D 的特定主机路由,则把数据报传送给</span><br><span class="line">路由表中所指明的下一跳路由器;否则,执行(<span class="number">4</span>)。</span><br><span class="line">(<span class="number">4</span>) 若路由表中有到达网络 N 的路由,则把数据报传送给路由表指</span><br><span class="line">明的下一跳路由器;否则,执行(<span class="number">5</span>)。</span><br><span class="line">(<span class="number">5</span>) 若路由表中有一个默认路由,则把数据报传送给路由表中所指</span><br><span class="line">明的默认路由器;否则,执行(<span class="number">6</span>)。</span><br><span class="line">(<span class="number">6</span>) 报告转发分组出错。</span><br></pre></td></tr></table></figure></li></ul><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>从 主机号借用几位 划分子网号</p><ul><li>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}<br>与上述转发过程不同点：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)路由器在收到 IP 数据报后,再按目的网络号 net-id 和子网号 subnet-id 找到目的子网</span><br><span class="line"><span class="number">2</span>)通过子网掩码与IP地址进行&amp;操作，匹配，则说明子网掩码代表的这个子网就是目的网络。</span><br></pre></td></tr></table></figure></li></ul><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><ul><li>无分类编址 CIDR，IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;},中间使用符号‘/’来表示网络前缀<h3 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h3>路由聚合 有利于减少路由器之间选择的次数，从而提高性能。</li><li>CIDR记法 0 可以省略</li></ul><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p><strong>原因</strong>：使用 CIDR 时,路由表中的每个项目由“网络前缀”和“下一跳地址”组成。<br>在查找路由表时可能会得到不止一个匹配结果<br><strong>方案</strong>：在匹配结果中选择最长网络前缀的路由。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul><li>报文格式</li><li>ICMP首部检验和<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/ICMP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2></li><li>内部网关协议　RIP   ———|</li><li>内部网关协议　OSPF  ———|–IGP</li><li>外部网关协议  BGP 将路由选择协议传递到另一个自制系统中<br>使用4种报文<br>打开 更新 保活 keepalive  通知 notification</li></ul><p>RIP<br>(1)仅和相邻路由器交换信息。<br>(2)交换的信息是当前本路由器所知道的全部信息,即自己的路由表。<br>(3)按固定的时间间隔交换路由信息,例如,每隔30秒。<br>当网络拓扑发生变化时,路由器也及时向相邻路由器通告拓扑变化后的路由信息。</p><h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><ul><li><p>在 IPv6 数据报要进入IPv4网络时,把 IPv6 数据报封装成为 IPv4 数据报,<br>整个的 IPv6 数据报变成了 IPv4 数据报的数据部分。</p></li><li><p>当 IPv4 数据报离开 IPv4 网络中的隧道时,再把数据部分(即原来的 IPv6 数据报)<br>交给主机的 IPv6 协议栈。</p></li></ul><h2 id="NAT技术-网络地址转换-Network-Address-Translation"><a href="#NAT技术-网络地址转换-Network-Address-Translation" class="headerlink" title="NAT技术 网络地址转换(Network Address Translation)"></a>NAT技术 网络地址转换(Network Address Translation)</h2><p><strong>解决</strong>：在专用网上使用专用地址的主机如何与互联网上的主机通信(并不需要加密)的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内部主机 A 用本地地址 IP A 和互联网上主机 B 通信所</span><br><span class="line">发送的数据报必须经过 NAT 路由器。</span><br><span class="line"></span><br><span class="line">NAT 路由器将数据报的源地址 IP A 转换成全球地址IP G ,</span><br><span class="line">并把转换结果记录到NAT地址转换表中,目的地址 IP B 保持不变,然后发送到互联网。</span><br><span class="line"></span><br><span class="line">NAT 路由器收到主机 B 发回的数据报时,知道数据报中的源地址是 IP B 而目的地址是 IP G 。</span><br><span class="line"></span><br><span class="line">根据 NAT 转换表,NAT 路由器将目的地址 IP G 转换为IP A ,转发给最终的内部主机 A。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理物理层链路层复习</title>
      <link href="/2019/01/05/2019-01-05-%E7%89%A9%E7%90%86%E5%B1%82%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2019/01/05/2019-01-05-%E7%89%A9%E7%90%86%E5%B1%82%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>限于物理层、链路层 </p><a id="more"></a><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h2 id="屏蔽双绞线-STP-Shielded-Twisted-Pair"><a href="#屏蔽双绞线-STP-Shielded-Twisted-Pair" class="headerlink" title="屏蔽双绞线 STP (Shielded Twisted Pair)"></a>屏蔽双绞线 STP (Shielded Twisted Pair)</h2><h2 id="无屏蔽双绞线-UTP-Unshielded-Twisted-Pair"><a href="#无屏蔽双绞线-UTP-Unshielded-Twisted-Pair" class="headerlink" title="无屏蔽双绞线 UTP (Unshielded Twisted Pair)"></a>无屏蔽双绞线 UTP (Unshielded Twisted Pair)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">室内传送数据的无屏蔽双绞线和屏蔽双绞线的标准 EIA/TIA-568。</span><br></pre></td></tr></table></figure><h2 id="多模光纤"><a href="#多模光纤" class="headerlink" title="多模光纤"></a>多模光纤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以存在多条不同角度入射的光线在一条光纤中传输。</span><br><span class="line">这种光纤就称为多模光纤。</span><br></pre></td></tr></table></figure><h2 id="单模光纤"><a href="#单模光纤" class="headerlink" title="单模光纤"></a>单模光纤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，</span><br><span class="line">它可使光线一直向前传播，而不会产生多次反射,这样的光纤称为单模光纤</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 通信容量非常大。</span><br><span class="line">(2) 传输损耗小，中继距离长。</span><br><span class="line">(2) 抗雷电和电磁干扰性能好。</span><br><span class="line">(3) 无串音干扰，保密性好。</span><br><span class="line">(4) 体积小，重量轻。</span><br><span class="line">TIPS:光纤应用于：**企业网络 FTTH 和访问网络 长途网络 水下网络**</span><br></pre></td></tr></table></figure><h3 id="自由空间称为“非导引型传输媒体”。"><a href="#自由空间称为“非导引型传输媒体”。" class="headerlink" title="自由空间称为“非导引型传输媒体”。"></a>自由空间称为“非导引型传输媒体”。</h3><p><strong>短波通信（即高频通信）</strong>主要是靠【电离层】的反射，但短波信道的通信质量较差，<br>传输速率低微波在空间主要是直线传播</p><p><strong>传统微波</strong>：地面微波接力通信 、卫星通信</p><p><strong>宽带接入技术</strong>：有线宽带接入 无线宽带接入</p><h2 id="非对称数字用户线-ADSL-Asymmetric-Digital-Subscriber-Line-技术"><a href="#非对称数字用户线-ADSL-Asymmetric-Digital-Subscriber-Line-技术" class="headerlink" title="非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术"></a>非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</span><br><span class="line">特点：上行和下行带宽做成不对称的(上行指从用户到 ISP，而下行指从 ISP 到用户)。</span><br><span class="line">ADSL 在用户线（铜线）的两端各安装一个ADSL 调制解调器。</span><br><span class="line">我国目前采用的方案是离散多音调 DMT (Discrete Multi-Tone)调制技术。</span><br><span class="line">（这里的“多音调”就是【“多载波”或“多子信道”】的意思。</span><br><span class="line"></span><br><span class="line">DMT 调制技术采用【频分复用】的方法</span><br><span class="line">ADSL 采用【自适应调制技术】使用户线能够传送尽可能高的数据率，但【不能保证固定的数据率】</span><br><span class="line">第二代ADSL【无缝速率自适应技术 SRA (Seamless Rate Adaptation)】HFC网使用【模拟光纤技术】</span><br><span class="line">【电缆调制解调器】是为【 HFC 网】而使用的调制解调器</span><br></pre></td></tr></table></figure><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h2 id="链路层使用的信道-点对点信道、广播信道"><a href="#链路层使用的信道-点对点信道、广播信道" class="headerlink" title="链路层使用的信道 :点对点信道、广播信道"></a>链路层使用的信道 :点对点信道、广播信道</h2><p><strong>链路&lt;通路</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据（逻辑）链路 (data link) 除了【物理线路】外，还必须有【通信协议】来控制这些数据的传输。</span><br><span class="line">若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</span><br><span class="line">现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</span><br><span class="line">一般的适配器都包括了【数据链路层和物理层】这两层的功能。</span><br></pre></td></tr></table></figure><h2 id="数据链路层协议要解决的基本问题"><a href="#数据链路层协议要解决的基本问题" class="headerlink" title="数据链路层协议要解决的基本问题"></a>数据链路层协议要解决的基本问题</h2><p>【封装成帧】【透明传输】【差错控制】</p><p>①<strong>封装成帧</strong>，在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。<br>作用：确定帧的界限【帧定界】。—帧定界符SOH_DATA_EOT（end of transmission）</p><p>②<strong>透明传输</strong>：如果数据中的某个字节的二进制代码恰好和SOH或EOT一样<br>数据链路层就会错误地“找到帧的边界”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决方法：【字节填充 (byte stuffing)】或【字符填充(character stuffing)】。</span><br><span class="line">1发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面</span><br><span class="line">插入一个转义字符“ESC”(其十六进制编码是 1B)。</span><br><span class="line">2接收端的数据链路层在将数据送往网络层之前删除插入的转义字符</span><br><span class="line">3如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。</span><br><span class="line">当接收端收到连续的两个转义字符时，就删除其中前面的一个</span><br></pre></td></tr></table></figure><p>③<strong>差错检测</strong>：在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1<br>在一段时间内，传输错误的比特占所传输比特总数的比率称为【误码率 BER (Bit Error Rate)】。</p><h2 id="循环冗余检验CRC"><a href="#循环冗余检验CRC" class="headerlink" title="循环冗余检验CRC"></a>循环冗余检验CRC</h2><p>计算冗余码，余数作为FCS【帧检验序列】</p><ul><li>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 </li><li>FCS 可以用 CRC 这种方法得出，但 CRC 并不是获得 FCS 的唯一方法</li><li>“无比特差错”与“无传输差错”是不同的概念。</li></ul><p>(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。</p><p>(2) 若余数 R！=0，则判定这个帧有差错，就丢弃。<br>数据链路层的CRC检验可以实现【无比特差错】，</p><ul><li>但是【不可靠传输】【不能确定是哪个比特出了差错】，只能做到【无差错接受】（无比特差错）<br>要做到“可靠传输”（即发送什么就收到什么）就必须再加上【确认和重传机制】</li></ul><h2 id="PROTOCAL-PPP-Point-to-Point-Protocol-协议】点对点协议（包含了物理层和ip层的内容）"><a href="#PROTOCAL-PPP-Point-to-Point-Protocol-协议】点对点协议（包含了物理层和ip层的内容）" class="headerlink" title="PROTOCAL PPP(Point-to-Point Protocol)协议】点对点协议（包含了物理层和ip层的内容）"></a>PROTOCAL PPP(Point-to-Point Protocol)协议】点对点协议（包含了物理层和ip层的内容）</h2><ul><li>【面向字节，以字节为单位】</li><li>【一个将 IP 数据报封装到串行链路的方法】</li><li>【链路控制协议 LCP (Link Control Protocol)】</li><li>【网络控制协议 NCP (Network Control Protocol)】</li><li>【同步传输时，采用硬件完成【比特填充】，零比特传输：五个连续的1就填入一个0，接收时删除】</li><li>【异步传输时，使用特殊的字符填充法】<br>MAC帧格式<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/mac.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="PROTOCAL-CSMA-CD"><a href="#PROTOCAL-CSMA-CD" class="headerlink" title="PROTOCAL CSMA/CD"></a>PROTOCAL CSMA/CD</h2><p>局域网具有如下主要优点：</p><ul><li>【具有广播功能】，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>【便于系统的扩展和逐渐地演变】，各设备的位置可灵活调整和改变。</li><li>【提高了系统的可靠性、可用性、残存性】</li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网上的API</title>
      <link href="/2018/12/19/2018-12-19-bilibili%E6%B1%97%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9BAPI/"/>
      <url>/2018/12/19/2018-12-19-bilibili%E6%B1%97%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9BAPI/</url>
      
        <content type="html"><![CDATA[<p>持续更新</p><a id="more"></a><h2 id="抓包和浏览器-CTRL-C-搞到的一些API"><a href="#抓包和浏览器-CTRL-C-搞到的一些API" class="headerlink" title="抓包和浏览器(CTRL C)搞到的一些API"></a>抓包和浏览器<del>(CTRL C)</del>搞到的一些API</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://music.163.com/outchain/player?type=2&id=28563201&auto=1&height=66&bg=e8e8e8" alt title>                </div>                <div class="image-caption"></div>            </figure><h1 id="APIset"><a href="#APIset" class="headerlink" title="APIset"></a>APIset</h1><p>抓包和浏览器<del>(CTRL C)</del>搞到的一些API</p><h1 id="教务系统API"><a href="#教务系统API" class="headerlink" title="教务系统API"></a>教务系统API</h1><p>不需要用沙雕IE登沙雕教务系统搞照片了（格式*/pic/学号.JPG</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://211.87.177.1/jwxt/uploadfile/studentphoto/pic/</span><br></pre></td></tr></table></figure><h1 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://music.163.com/outchain/player?<span class="built_in">type</span>=2&amp;id=28563201&amp;auto=1&amp;height=66&amp;<span class="built_in">bg</span>=e8e8e8</span><br></pre></td></tr></table></figure><h1 id="bilibili抓数据的API（json"><a href="#bilibili抓数据的API（json" class="headerlink" title="bilibili抓数据的API（json"></a>bilibili抓数据的API（json</h1><h2 id="弹幕API"><a href="#弹幕API" class="headerlink" title="弹幕API"></a>弹幕API</h2><h3 id="CID-DANMAKU-format-cid"><a href="#CID-DANMAKU-format-cid" class="headerlink" title="CID_DANMAKU.format(cid)"></a>CID_DANMAKU.format(cid)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CID_DANMAKU = <span class="string">'http://comment.bilibili.com/&#123;0&#125;.xml'</span></span><br></pre></td></tr></table></figure><h3 id="CID-DANMAKU-HIS-format-cid"><a href="#CID-DANMAKU-HIS-format-cid" class="headerlink" title="CID_DANMAKU_HIS.format(cid)"></a>CID_DANMAKU_HIS.format(cid)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CID_DANMAKU_HIS = <span class="string">'http://comment.bilibili.com/rolldate,&#123;0&#125;'</span></span><br></pre></td></tr></table></figure><h3 id="CID-HISDANMAKU-format-timestamp-cid"><a href="#CID-HISDANMAKU-format-timestamp-cid" class="headerlink" title="CID_HISDANMAKU.format(timestamp, cid)"></a>CID_HISDANMAKU.format(timestamp, cid)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CID_HISDANMAKU = <span class="string">'http://comment.bilibili.com/dmroll,&#123;0&#125;,&#123;1&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="动态DYNAMICAPI"><a href="#动态DYNAMICAPI" class="headerlink" title="动态DYNAMICAPI"></a>动态DYNAMICAPI</h2><h3 id="动态的detail，具体自己打开浏览器见json"><a href="#动态的detail，具体自己打开浏览器见json" class="headerlink" title="动态的detail，具体自己打开浏览器见json"></a>动态的detail，具体自己打开浏览器见json</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DynamicAPI = <span class="string">'https://api.vc.bilibili.com/dynamic_svr/v1/dynamic_svr/get_dynamic_detail?dynamic_id='</span> + Dynamic_id</span><br></pre></td></tr></table></figure><h3 id="param-offset"><a href="#param-offset" class="headerlink" title="param offset"></a>param offset</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'https://api.live.bilibili.com/dynamic_repost/v1/dynamic_repost/view_repost?dynamic_id='</span>+ Dynamic_id + <span class="string">'&amp;offset='</span>+ each_count</span><br></pre></td></tr></table></figure><h3 id="私聊API（你甚至可以"><a href="#私聊API（你甚至可以" class="headerlink" title="私聊API（你甚至可以"></a>私聊API（你甚至可以</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'https://message.bilibili.com/#/whisper/mid'</span>+uid</span><br></pre></td></tr></table></figure><h2 id="番剧信息API"><a href="#番剧信息API" class="headerlink" title="番剧信息API"></a>番剧信息API</h2><p><del>（目前b站似乎后台API都换了，下次搞的时候更新</del></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijstra</title>
      <link href="/2018/12/11/2018-12-11-dijstra/"/>
      <url>/2018/12/11/2018-12-11-dijstra/</url>
      
        <content type="html"><![CDATA[<p>求最短路的算法只记得Floyd，单源最短路Dijstra差点忘了<del>已经忘了</del></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Link</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,dist;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> d,u;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> HeapNode &amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubstrateNetwork</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nodes;</span><br><span class="line"><span class="keyword">int</span> links</span><br><span class="line"><span class="built_in">vector</span>&lt;Link&gt; maplinks;</span><br><span class="line"><span class="keyword">bool</span> isvisited[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> distance[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;n = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)G[i].clear();</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)p[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)d[i] = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line">q.push(Node&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">distance[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">Node temp = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> u = temp.u;</span><br><span class="line"><span class="keyword">if</span>(isvisited[u])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">isvisited[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)&#123;</span><br><span class="line">Link e = maplinks[G[u][i]];</span><br><span class="line"><span class="keyword">if</span>(distance[e.to] &gt; distance[u] + e.dist)&#123;</span><br><span class="line">distance[e.to] = distance[u] + e.dist;</span><br><span class="line">p[e.to] = u;</span><br><span class="line">q.push(HeapNode&#123;distance[e.to],e.to&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些网页链接</title>
      <link href="/2018/12/08/2018-12-08-%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/"/>
      <url>/2018/12/08/2018-12-08-%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>网络原理相关期刊</p><!--description--><h1 id="顶级期刊"><a href="#顶级期刊" class="headerlink" title="顶级期刊"></a>顶级期刊</h1><h2 id="名称：ieee-network"><a href="#名称：ieee-network" class="headerlink" title="名称：ieee network"></a>名称：ieee network</h2><h2 id="主页网址："><a href="#主页网址：" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=65" target="_blank" rel="noopener">ieee network</a></p><h2 id="名称：journal-of-network-and-computer-applications"><a href="#名称：journal-of-network-and-computer-applications" class="headerlink" title="名称：journal of network and computer applications"></a>名称：journal of network and computer applications</h2><h2 id="主页网址：-1"><a href="#主页网址：-1" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/10848045" target="_blank" rel="noopener">journal of network and computer applications</a></p><h2 id="名称：ieee-acm-transactions-on-networking"><a href="#名称：ieee-acm-transactions-on-networking" class="headerlink" title="名称：ieee-acm transactions on networking"></a>名称：ieee-acm transactions on networking</h2><h2 id="主页网址：-2"><a href="#主页网址：-2" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=90" target="_blank" rel="noopener">ieee-acm transactions on networking</a></p><h2 id="名称：Ad-Hoc-Networks"><a href="#名称：Ad-Hoc-Networks" class="headerlink" title="名称：Ad Hoc Networks"></a>名称：Ad Hoc Networks</h2><h2 id="主页网址：-3"><a href="#主页网址：-3" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/15708705" target="_blank" rel="noopener">Ad Hoc Networks</a></p><h2 id="名称：cluster-computing-the-journal-of-networks-software-tools-and-applications"><a href="#名称：cluster-computing-the-journal-of-networks-software-tools-and-applications" class="headerlink" title="名称：cluster computing-the journal of networks software tools and applications"></a>名称：cluster computing-the journal of networks software tools and applications</h2><h2 id="主页网址：-4"><a href="#主页网址：-4" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/10586" target="_blank" rel="noopener">cluster computing-the journal of networks software tools and applications</a></p><h2 id="名称：Computer-Networks"><a href="#名称：Computer-Networks" class="headerlink" title="名称：Computer Networks"></a>名称：Computer Networks</h2><h2 id="主页网址：-5"><a href="#主页网址：-5" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/13891286" target="_blank" rel="noopener">Computer Networks</a></p><h2 id="名称：Optical-Switching-and-Networking"><a href="#名称：Optical-Switching-and-Networking" class="headerlink" title="名称：Optical Switching and Networking"></a>名称：Optical Switching and Networking</h2><h2 id="主页网址：-6"><a href="#主页网址：-6" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/15734277" target="_blank" rel="noopener">Optical Switching and Networking</a></p><h2 id="名称：Mobile-Networks-and-Applications"><a href="#名称：Mobile-Networks-and-Applications" class="headerlink" title="名称：Mobile Networks and Applications"></a>名称：Mobile Networks and Applications</h2><h2 id="主页网址：-7"><a href="#主页网址：-7" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/11036" target="_blank" rel="noopener">Mobile Networks and Applications</a></p><h2 id="名称：Wireless-Networks"><a href="#名称：Wireless-Networks" class="headerlink" title="名称：Wireless Networks"></a>名称：Wireless Networks</h2><h2 id="主页网址：-8"><a href="#主页网址：-8" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/11276" target="_blank" rel="noopener">Wireless Networks</a></p><h2 id="名称：Networks"><a href="#名称：Networks" class="headerlink" title="名称：Networks"></a>名称：Networks</h2><h2 id="主页网址：-9"><a href="#主页网址：-9" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://onlinelibrary.wiley.com/journal/" target="_blank" rel="noopener">Networks</a></p><h2 id="名称：Journal-of-Network-and-Systems-Management"><a href="#名称：Journal-of-Network-and-Systems-Management" class="headerlink" title="名称：Journal of Network and Systems Management"></a>名称：Journal of Network and Systems Management</h2><h2 id="主页网址：-10"><a href="#主页网址：-10" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/10922" target="_blank" rel="noopener">Journal of Network and Systems Management</a></p><h1 id="顶级会议："><a href="#顶级会议：" class="headerlink" title="顶级会议："></a>顶级会议：</h1><h2 id="名称：acm-sigcomm"><a href="#名称：acm-sigcomm" class="headerlink" title="名称：acm sigcomm"></a>名称：acm sigcomm</h2><h2 id="主页网址：-11"><a href="#主页网址：-11" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sigcomm.org/" target="_blank" rel="noopener">acm sigcomm</a></p><h2 id="名称-ieee-infocom"><a href="#名称-ieee-infocom" class="headerlink" title="名称: ieee infocom"></a>名称: ieee infocom</h2><h2 id="主页网址：-12"><a href="#主页网址：-12" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://infocom2017.ieee-infocom.org/" target="_blank" rel="noopener">ieee infocom</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>椭圆加密等</title>
      <link href="/2018/12/02/2018-12-01-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/"/>
      <url>/2018/12/02/2018-12-01-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB/</url>
      
        <content type="html"><![CDATA[<p>先鸽了</p><a id="more"></a><hr><h2 id="椭圆加密算法解析"><a href="#椭圆加密算法解析" class="headerlink" title="椭圆加密算法解析"></a>椭圆加密算法解析</h2><p>椭圆加密原理公式E(a,b) : y^2 = x^3  + a*x +b mod p</p><ul><li>每个点 通过带入x的变量，选取一个质数p来进行模运算。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>映射过程描述</title>
      <link href="/2018/12/01/2018-12-01-%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0/"/>
      <url>/2018/12/01/2018-12-01-%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>虚拟网络映射算法的节点、链路映射一般过程</p><a id="more"></a><h1 id="映射过程"><a href="#映射过程" class="headerlink" title="映射过程"></a>映射过程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(request:requestList)&#123;</span><br><span class="line">映射成功标记 flag</span><br><span class="line">① flag = 节点映射结果</span><br><span class="line"><span class="keyword">if</span>(falg)  节点资源分配 执行②部分</span><br><span class="line"><span class="keyword">else</span> 本组request映射失败</span><br><span class="line">② flag = 链路映射结果</span><br><span class="line"><span class="keyword">if</span>(falg)  链路资源分配</span><br><span class="line"><span class="keyword">else</span> 本组request映射失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节点映射过程"><a href="#节点映射过程" class="headerlink" title="节点映射过程"></a>节点映射过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">排序物理网络、网络请求的节点;<span class="comment">//每一次按改进的H值（加入负载均衡系数后）对物理网络进行排序</span></span><br><span class="line"><span class="keyword">for</span>( vn_node : vn_nodes)&#123;<span class="comment">//对每一个排序后的虚拟节点</span></span><br><span class="line"><span class="keyword">for</span>(遍历物理节点)&#123;</span><br><span class="line"><span class="keyword">if</span>(物理节点节点剩余CPU &gt; 虚拟节点CPU需求)&#123;</span><br><span class="line">存储映射结果，跳出<span class="keyword">for</span>循环，映射下一个节点</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(物理节点遍历结束)&#123;</span><br><span class="line">映射失败,返回<span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">节点映射成功，分配物理节点资源</span><br></pre></td></tr></table></figure><h2 id="链路映射过程"><a href="#链路映射过程" class="headerlink" title="链路映射过程"></a>链路映射过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(vn_link :vn_links)&#123;<span class="comment">//对每一个request的链路请求</span></span><br><span class="line">       取出链路需求带宽，起、止节点id</span><br><span class="line">       根据起止节点id(from,to)查找最短路径 floyd</span><br><span class="line">       <span class="keyword">if</span>(finded)&#123;</span><br><span class="line"> <span class="comment">//找到链路后验证带宽</span></span><br><span class="line"><span class="keyword">if</span>(链路需求带宽 &gt; 物理链路剩余带宽)  映射失败;</span><br><span class="line"> <span class="keyword">else</span> 将这一条链路加入resultLinks（链路映射最终结果）</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//链路不通，映射失败</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap zmap使用</title>
      <link href="/2018/12/01/2018-12-01-nmap&amp;zmap/"/>
      <url>/2018/12/01/2018-12-01-nmap&amp;zmap/</url>
      
        <content type="html"><![CDATA[<p>nmap 和 zmap的参数表，端口嗅探</p><a id="more"></a><hr><h2 id="参数表"><a href="#参数表" class="headerlink" title="参数表"></a>参数表</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/nmap_param.png" alt title>                </div>                <div class="image-caption"></div>            </figure><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-sL</td><td align="center">TCP SYN</td></tr><tr><td align="center">-sT</td><td align="center">Connect</td></tr><tr><td align="center">-sA</td><td align="center">ACK</td></tr><tr><td align="center">-sW</td><td align="center">Window</td></tr><tr><td align="center">-sM</td><td align="center">Maimon scans</td></tr><tr><td align="center">-sU</td><td align="center">UDP scan</td></tr><tr><td align="center">-sN</td><td align="center">TCP NULL</td></tr><tr><td align="center">-sF</td><td align="center">FIN</td></tr><tr><td align="center">-sX</td><td align="center">Xmax scans</td></tr><tr><td align="center">-sI host:probeport]</td><td align="center">zombie host scan</td></tr><tr><td align="center">-sY</td><td align="center">SCTP INIT</td></tr><tr><td align="center">-sZ</td><td align="center">Cookie-echo scans</td></tr><tr><td align="center">-sO</td><td align="center">IP protocol scan</td></tr><tr><td align="center">-b FTPserver</td><td align="center">FTP bounce scan</td></tr></tbody></table><h2 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/nmaphostscan.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>参照的详解文章<br>[<a href="https://www.cnblogs.com/nmap/p/6232969.html]" target="_blank" rel="noopener">https://www.cnblogs.com/nmap/p/6232969.html]</a></li></ul><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-sL</td><td align="center">TCP SYN</td></tr><tr><td align="center">-sn</td><td align="center">Ping Scan - disable port scan（测试过对方主机把icmp包都丢弃掉，依然能检测到对方开机状态）</td></tr><tr><td align="center">-sS</td><td align="center">发送SYN包到远程主机，但不会产生任何会话，目标主机不会把连接记入系统日志。（为了防止对方判断为扫描攻击，目前挺多加防服务器直接会把扫自己端口的的ip拉黑）</td></tr><tr><td align="center">-sA</td><td align="center">Connect，探测主机是否开机</td></tr><tr><td align="center">-PE</td><td align="center">Connect</td></tr><tr><td align="center">-PS80</td><td align="center">ACK</td></tr><tr><td align="center">-PR</td><td align="center">Window</td></tr><tr><td align="center">-Pn</td><td align="center">无ping扫描</td></tr><tr><td align="center">-sP</td><td align="center">快速ping，扫描本地局域网有那些机器，或者直接可以用前缀式表示类似于x.x.x.0/24</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sniffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot+modleView+rmi调用自己写的天气预报的新闻系统</title>
      <link href="/2018/11/30/2018-11-30-newsSystem/"/>
      <url>/2018/11/30/2018-11-30-newsSystem/</url>
      
        <content type="html"><![CDATA[<p>一个springboot(collect springmvc、hibernate、modleView）+rmi远程调用天气预报系统的小项目</p><a id="more"></a><h1 id="newsSystem"><a href="#newsSystem" class="headerlink" title="newsSystem"></a>newsSystem</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/assets/images/fgo1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>先放上作业的代码地址</p></blockquote><h2 id="新闻系统"><a href="#新闻系统" class="headerlink" title="新闻系统"></a>新闻系统</h2><ul><li><a href="https://github.com/waynamigo/newsSystem" target="_blank" rel="noopener">newsSystem</a></li></ul><h2 id="下面是在centos服务器上部署环境，建一个新数据库用户进行管理"><a href="#下面是在centos服务器上部署环境，建一个新数据库用户进行管理" class="headerlink" title="下面是在centos服务器上部署环境，建一个新数据库用户进行管理"></a>下面是在centos服务器上部署环境，建一个新数据库用户进行管理</h2><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql mysql-server mysql-devel</span><br><span class="line">create user newsadmin;</span><br><span class="line">create database newsbase;</span><br><span class="line">grant all privileges on newsbase.* to newsadmin@localhost identified by<span class="string">'password'</span>;</span><br><span class="line">revoke all on *.* from <span class="string">'admin'</span>@<span class="string">'%'</span>;</span><br><span class="line">grant all on *.* to <span class="string">'admin'</span>@<span class="string">'%'</span> identified by <span class="string">'wdnm'</span></span><br></pre></td></tr></table></figure><ul><li>数据库用户名，密码在application.yml文件中配置</li></ul><h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk-devel</span><br><span class="line">安装maven到usr/<span class="built_in">local</span>/apache-maven</span><br><span class="line"><span class="built_in">export</span> MAVEN_HOME=/usr/<span class="built_in">local</span>/apache-maven</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;MAVEN_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">服务器端Could not find or load main class org.apache.maven.wrapper.MavenWrapperMain</span><br><span class="line">错误解决：mvn io.takari:maven:wrapper</span><br></pre></td></tr></table></figure><ul><li>环境变量别写错<h2 id="mysql服务没启动的错误，很奇妙"><a href="#mysql服务没启动的错误，很奇妙" class="headerlink" title="mysql服务没启动的错误，很奇妙"></a>mysql服务没启动的错误，很奇妙</h2></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/init.d/mysqld status </span><br><span class="line"></span><br><span class="line">/etc/init.d/mysqld start</span><br></pre></td></tr></table></figure><h2 id="创建项目文件夹"><a href="#创建项目文件夹" class="headerlink" title="创建项目文件夹"></a>创建项目文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /classdesign</span><br><span class="line">chmod 754 /classdesign</span><br></pre></td></tr></table></figure><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar newsSystem.jar &gt; springbootinfo.out 2&gt;&amp;1  &amp;</span><br><span class="line">或</span><br><span class="line">nohup ./mvnw spring-boot:run &gt; springbootinfo.out 2&gt;&amp;1  &amp;</span><br></pre></td></tr></table></figure><hr><h2 id="代码高亮测试，还行"><a href="#代码高亮测试，还行" class="headerlink" title="代码高亮测试，还行"></a>代码高亮测试，还行</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService=<span class="keyword">new</span> UserService();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    NewsService newsService=<span class="keyword">new</span> NewsService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isadmin = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(PageController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam(value = <span class="string">"username"</span>, defaultValue = <span class="string">"null"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, defaultValue = <span class="string">"null"</span>)</span> String password,</span></span><br><span class="line"><span class="function">                        Model model)</span>&#123;<span class="comment">//String username, String password,Model model</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User user = userService.findUser(name,password);</span><br><span class="line">            <span class="keyword">if</span> (user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">                <span class="keyword">if</span>(user.getId()==<span class="number">1</span>)&#123;</span><br><span class="line">                    logger.info(<span class="string">"admin status"</span>);</span><br><span class="line">                    isadmin=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">"login success:username="</span>+name);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"redirect:/newspage/"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                model.addAttribute(<span class="string">"msg"</span>,<span class="string">"nosuchuser"</span>);</span><br><span class="line">                logger.info(<span class="string">"login failed:no such user"</span>);</span><br><span class="line">               <span class="comment">// return "success";</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据库内容"><a href="#数据库内容" class="headerlink" title="数据库内容"></a>数据库内容</h1><table><thead><tr><th>Tables_in_newsbase</th></tr></thead><tbody><tr><td>hibernate_sequence</td></tr><tr><td>news</td></tr><tr><td>user</td></tr><tr><td>——————–</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> rmi </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
