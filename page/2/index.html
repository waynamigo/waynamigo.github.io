<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>waynamigo&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content>
    <meta property="og:type" content="website">
<meta property="og:title" content="waynamigo&#39;s blog">
<meta property="og:url" content="http://waynamigo.github.io/page/2/index.html">
<meta property="og:site_name" content="waynamigo&#39;s blog">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="waynamigo&#39;s blog">
    
        <link rel="alternate" type="application/atom+xml" title="waynamigo&#39;s blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">waynamigo</h5>
          <a href="mailto:waynamigo@gmail.com" title="waynamigo@gmail.com" class="mail">waynamigo@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Homepage
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/waynamigo" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">waynamigo&#39;s blog</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header index-header">

    <div class="container fade-scale">
        <h1 class="title">waynamigo&#39;s blog</h1>
        <h5 class="subtitle">
            
                
            
        </h5>
    </div>

    


</header>

<div class="container body-wrap">

    <ul class="post-list">
    
        <li class="post-list-item fade">
            <article id="post-report1"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-03-12 16:29:32" datetime="2023-03-12T08:29:32.070Z"  itemprop="datePublished">2023-03-12</time>

        


    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/03/12/report1/">No title</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h2 id="一、近期学习工作总结"><a href="#一、近期学习工作总结" class="headerlink" title="一、近期学习工作总结"></a>一、近期学习工作总结</h2><p><strong>视觉定位任务</strong></p>
<p>目前拟定的论文题目是”<em>AEME : An Adaptive Enhancement Mask Auto-Encoder for Visual Grounding</em>“。一种用于视觉定位任务的自适应增强型掩码自编码器。</p>
<p><strong>论文完成情况</strong></p>
<p>论文的动机：当前用于VG任务的transformer仅依赖于自注意力机制，对于中间层的特征融合过于关注细粒度融合，而其他基于ROI的方法偏粗粒度融合，通过本文提出的AEME模块，可以有效地将视觉ROI与文本的中间层特征进行由粗到细(coarse-to-fine)地交互。</p>
<p><strong>实验情况</strong></p>
<ol>
<li>完成了将AEME用在ReSC上的测试，已出结果。</li>
<li>年后进行了在TransVG上的应用，预估时间140多个小时（90个epoch），暂时各置，最近在跑其他出结果快的baseline，目前还没有结果。</li>
<li>最近一周跑的实验是SeqTR的baseline，是两个月前出的新方法，和ReSC性能持平，并且出结果更快，在尝试将AEME用在这上面能否验证得到提升。</li>
</ol>
<p><strong>多模态目标检测任务</strong></p>
<p>假期时进一步完成了相关论文的追踪和调查，目前以VoxelRCNN作为baseline进行实验，数据集为KITTI。</p>
<p>当前思路：</p>
<ol>
<li>点云特征提取，用VoxelRCNN的体素表示方法。</li>
<li>在VoxelRCNN的特征表示的基础上，加入一个transformer分支获取浅层的全局场景视图特征表示，concat到 VoxelRCNN结构的pooling操作后，进行ROI的回归。</li>
<li>transformer分支的代码参考了Point Cloud Transformer。</li>
<li>加入场景视图后，能让这一transoformer分支在VoxelRCNN上起作用的loss设计是必要的，这部分还没有想好怎么设计。<h2 id="二、本学期目标和计划"><a href="#二、本学期目标和计划" class="headerlink" title="二、本学期目标和计划"></a>二、本学期目标和计划</h2></li>
</ol>
<p><strong>论文计划</strong></p>
<ol>
<li>Visualgrounding方向的论文争取三月内完成初稿，四月底前根据要投的期刊或会议修改润色完投稿。</li>
<li>优先解决第一篇VG任务的论文，多模态目标检测任务的实验放缓进行，完成第一篇投稿后开始推进。</li>
</ol>
<p><strong>下一步实验计划</strong></p>
<ol>
<li>将AEME在ReSC,TransVG,SeqTR三个baseline上进行验证</li>
</ol>
<ul>
<li>ReSC上加入AEME的实验在referit、refcoco、refcoco+三个数据集上的结果已得到，各数据集目前跑了四次取平均，后期需要增加实验次数</li>
<li>下一步是在TransVG上跑结果，代码已改好，跑一次预估时间要一周暂时搁置，在测试SeqTR上加入AEME的性能</li>
<li>SeqTR是2022年具有代表性的新VG框架，目前在调试，一个数据集出实验结果的周期在24小时左右</li>
</ul>
<p>以下是论文准备的实验表格，’ - ‘ 表示暂时没有数据，将在近期及三四月完成。</p>
<table>
<thead>
<tr>
<th>baseline</th>
<th>referit game</th>
<th>RefCOCO val testA testB</th>
<th>RefCOCO+ val testA testB</th>
<th>RefCOCOg val testA testB</th>
</tr>
</thead>
<tbody><tr>
<td>ReSC(ECCV 2020)</td>
<td>64.60</td>
<td>77.63 80.45 72.30</td>
<td>63.59 68.36 56.81</td>
<td>63.12 67.30 67.20</td>
</tr>
<tr>
<td>TransVG(ICCV 2021)</td>
<td>70.73</td>
<td>81.02 82.72 78.35</td>
<td>64.82 70.70 56.94</td>
<td>67.02 68.67 67.73</td>
</tr>
<tr>
<td>SeqTR(ECCV 2022)</td>
<td>69.66</td>
<td>81.23 85.00 76.08</td>
<td>68.82 75.37 58.78</td>
<td>-  71.35 71.58</td>
</tr>
<tr>
<td>ReSC+AEME</td>
<td>65.21</td>
<td>79.67 81.91 73.15</td>
<td>64.55 70.08 56.49</td>
<td>- - -</td>
</tr>
<tr>
<td>TransVG+AEME</td>
<td>-</td>
<td>- - -</td>
<td>- - -</td>
<td>- - -</td>
</tr>
<tr>
<td>SeqTR+AEME</td>
<td>调试中</td>
<td>- - -</td>
<td>- - -</td>
<td>- - -</td>
</tr>
</tbody></table>

    

        <a href="/2023/03/12/report1/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-2023-01-04-面试微服务"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-01-24 00:00:00" datetime="2023-01-23T16:00:00.000Z"  itemprop="datePublished">2023-01-24</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Golang/">Golang</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/01/24/2023-01-04-面试微服务/">微服务</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <p>持续更新</p>
    

        <a href="/2023/01/24/2023-01-04-面试微服务/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CPP，面试/">CPP，面试</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-面经设计模式"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-01-05 00:00:00" datetime="2023-01-04T16:00:00.000Z"  itemprop="datePublished">2023-01-05</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/软件工程/">软件工程</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/01/05/面经设计模式/">设计模式</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="设计模式六大原则"><a href="#设计模式六大原则" class="headerlink" title="设计模式六大原则"></a>设计模式六大原则</h1><p>开闭原则：软件实体（类、函数、模块）对扩展开放，对修改封闭</p>
<p>单一职责：每个类只做它负责的事情（一个类应该只有一个引起它修改的原因）<br>里氏替换：子类可以完全代替父类</p>
<p>依赖倒置：细节依赖于抽象，抽象不依赖于细节，程序细节由底层完成</p>
<p>最少知道：迪米特法则，尽量降低类与类之间的耦合。一个类不应该知道自己操作的类的细节</p>
<p>接口隔离：一个接口实现时，如果有冗余，就应该把接口拆分，让实现的类只依赖自己需要的接口，客户端不应依赖于它不知道的接口</p>
<h1 id="创造型模式"><a href="#创造型模式" class="headerlink" title="创造型模式"></a>创造型模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">工厂方法模式：为每一类对象建立工厂，将对象交由工厂创建，客户端只和工厂打交道。</span><br><span class="line">抽象工厂模式：为每一类工厂提取出抽象接口，使得新增工厂、替换工厂变得非常容易。</span><br><span class="line">建造者模式：用于创建构造过程稳定的对象，不同的 Builder 可以定义不同的配置。</span><br><span class="line">单例模式：全局使用同一个对象，分为饿汉式和懒汉式。懒汉式有双检锁和内部类两种实现方式。</span><br><span class="line">原型模式：为一个类定义 clone 方法，使得创建相同的对象更方便。</span><br></pre></td></tr></table></figure>

<p>饿汉：变量在声明时便初始化，但饿汉式有一个弊端，那就是即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。<br>懒汉：先声明一个空变量，需要用时才初始化。懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。<br>    - 但是懒汉不是线程安全的，要实现线程安全的懒汉，需要加同步锁</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"sync"</span><span class="comment">// 同步包</span></span><br><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//饿汉</span></span><br><span class="line"><span class="keyword">var</span> instance *Singleton = &amp;Singleton&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//懒汉线程安全</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getInstance</span><span class="params">()</span> *<span class="title">Singleton</span></span>&#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        instance := &amp;Singleton&#123;&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>工厂模式</strong><br><strong>抽象工厂模式</strong><br><strong>单例模式</strong><br><strong>建造者模式</strong><br><strong>原型模式</strong></p>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">适配器模式：用于有相关性但不兼容的接口</span><br><span class="line">桥接模式：用于同等级的接口互相组合</span><br><span class="line">组合模式：用于整体与部分的结构</span><br><span class="line">外观模式：体现封装的思想</span><br><span class="line">享元模式：体现面向对象的可复用性</span><br><span class="line">代理模式：主要用于对某个对象加以控制</span><br></pre></td></tr></table></figure>

<p><strong>适配器模式</strong><br><strong>装饰器模式</strong><br><strong>代理模式</strong><br><strong>享元模式</strong>：享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p>
<p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。<br>一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p>
<p><strong>外观模式</strong><br><strong>桥接模式</strong><br><strong>组合模式</strong></p>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">行为型模式重点关注类与类之间的交互与协作。如同在工作中，每个人的行为都可能影响到其他同事，同时每个人也会受到别人的影响。我们一边接收上级的指令，一边派发任务给下级，在这样的协作中完成一项项伟大的工作。程序在运行时，每个对象都不是孤立的，他们可以通过通信与协作完成种种复杂的功能。</span><br><span class="line"></span><br><span class="line">责任链模式：处理职责相同，程度不同的对象，使其在一条链上传递</span><br><span class="line">命令模式：封装“方法调用”，将行为请求者和行为实现者解耦</span><br><span class="line">解释器模式：定义自己的语法规则</span><br><span class="line">迭代器模式：定义 next() 方法和 hasNext() 方法，让外部类使用这两个方法来遍历列表，以达到隐藏列表内部细节的目的</span><br><span class="line">中介者模式：通过引入中介者，将网状耦合结构变成星型结构</span><br><span class="line">备忘录模式：存储对象的状态，以便恢复</span><br><span class="line">观察者模式：处理一对多的依赖关系，被观察的对象改变时，多个观察者都能收到通知</span><br><span class="line">状态模式：关于多态的设计模式，每个状态类处理对象的一种状态</span><br><span class="line">策略模式：殊途同归，用多种方法做同一件事</span><br><span class="line">模板方法模式：关于继承的设计模式，父类是子类的模板</span><br><span class="line">访问者模式：将数据的结构和对数据的操作分离</span><br></pre></td></tr></table></figure>

<p><strong>责任链模式</strong>：责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止<br><strong>观察者模式</strong><br><strong>中介者模式</strong><br><strong>访问者模式</strong><br><strong>解释器模式</strong><br><strong>迭代器模式</strong><br><strong>命令模式</strong><br><strong>备忘录模式</strong></p>
<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><ol>
<li>面向对象的特点是什么？</li>
</ol>
<p>👉查看答案👈<br>可维护、可复用、可扩展、灵活性好。</p>
<ol start="2">
<li>让面向对象保持结构良好的秘诀是什么？</li>
</ol>
<p>👉查看答案👈<br>让面向对象保持结构良好的秘诀就是设计模式，面向对象结合设计模式，才能真正体会到程序变得可维护、可复用、可扩展、灵活性好。</p>
<ol start="3">
<li>六大设计原则是什么？</li>
</ol>
<p>👉查看答案👈<br>开闭原则、单一职责原则、里氏替换原则、依赖倒置原则、迪米特原则、接口隔离原则。</p>
<ol start="4">
<li>什么是里氏替换原则？</li>
</ol>
<p>👉查看答案👈<br>子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能。</p>
<ol start="5">
<li>工厂模式是用于达到什么目的的设计模式？</li>
</ol>
<p>👉查看答案👈<br>封装对象。</p>
<ol start="6">
<li>工厂模式有哪三种？</li>
</ol>
<p>👉查看答案👈<br>简单工厂模式、工厂方法模式、抽象工厂模式。</p>
<ol start="7">
<li>工厂方法模式解决了简单工厂模式的哪两个弊端？</li>
</ol>
<p>👉查看答案👈<br>当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。<br>当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。</p>
<ol start="8">
<li>抽象工厂模式是什么样的？</li>
</ol>
<p>在创建时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。这种经过抽象的工厂方法模式被称作抽象工厂模式。</p>
<ol>
<li>抽象工厂模式很好的发挥了哪些原则？</li>
</ol>
<p>开闭原则、依赖倒置原则。</p>
<ol>
<li>抽象工厂模式的缺点是什么？</li>
</ol>
<p>缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。</p>
<ol>
<li>抽象工厂模式适用于和不适用于哪些情况？</li>
</ol>
<p>适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。</p>
<ol>
<li>什么时候可以使用单例模式？</li>
</ol>
<p>某个对象全局只需要一个实例时即可。</p>
<ol>
<li>单例模式的优点是什么？</li>
</ol>
<p>• 它能够避免对象重复创建，节约空间并提升效率<br>• 避免由于操作不同实例导致的逻辑错误</p>
<ol>
<li>单例模式有哪两种实现方式？请分别简单解释。</li>
</ol>
<p>饿汉式和懒汉式。饿汉式指变量在声明时便初始化。懒汉式指先声明一个空变量，需要用时才初始化。</p>
<ol>
<li>饿汉式的弊端是什么？</li>
</ol>
<p>即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。</p>
<ol>
<li>静态内部类方式是怎么保证线程安全的？</li>
</ol>
<p>Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。</p>
<ol>
<li>建造者模式用于什么时候？</li>
</ol>
<p>创建过程稳定，但配置多变的对象。</p>
<ol>
<li>建造者模式是什么意思？</li>
</ol>
<p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<ol>
<li>现在建造者模式主要用来做什么？</li>
</ol>
<p>通过链式调用生成不同的配置。</p>
<ol>
<li>使用建造者模式的好处是什么？</li>
</ol>
<p>不用担心忘了指定某个配置，保证了构建过程是稳定的。</p>
<ol>
<li>原型模式是什么？</li>
</ol>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<ol>
<li>适配器模式适用于什么结构？</li>
</ol>
<p>有相关性但不兼容的结构。</p>
<ol>
<li>什么是适配？什么是适配器？</li>
</ol>
<p>源接口通过一个中间件转换后才可以适用于目标接口，这个转换过程就是适配，这个中间件就称之为适配器。</p>
<ol>
<li>需要绘制矩形、圆形、三角形这三种图案，按照桥接模式的思想会怎么做？</li>
</ol>
<p>将形状和颜色分离，根据需要对形状和颜色进行组合。</p>
<ol>
<li>什么是桥接模式？</li>
</ol>
<p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体模式或接口模式。</p>
<ol>
<li>组合模式适用于什么结构？</li>
</ol>
<p>组合模式用于整体与部分的结构，当整体与部分有相似的结构，在操作时可以被一致对待时，就可以使用组合模式。</p>
<ol>
<li>组合模式最主要的功能是什么？</li>
</ol>
<p>组合模式最主要的功能是让用户可以一致对待整体和部分结构，将两者都作为一个相同的组件。</p>
<ol>
<li>什么是组合模式中的透明方式？</li>
</ol>
<p>违背了接口隔离原则的组合模式。</p>
<ol>
<li>什么是安全方式？</li>
</ol>
<p>在 Component 中不声明 add 和 remove 等管理子对象的方法，这样叶节点就无需实现它，只需在枝节点中实现管理子对象的方法即可。</p>
<ol>
<li>什么是透明装饰模式？</li>
</ol>
<p>装饰器仅用于增强功能，并不会改变 Me 原有的功能，这种装饰模式称之为透明装饰模式。</p>
<ol>
<li>装饰模式的缺点是什么？</li>
</ol>
<p>容易造成程序中有大量相似的类。</p>
<ol>
<li>动态代理相对于静态代理的优势是什么？</li>
</ol>
<p>节省代码量。</p>
<ol>
<li>简述责任链模式的有优点有哪些？</li>
</ol>
<p>• 降低了对象之间的耦合度。<br>• 扩展性强，满足开闭原则。可以根据需要增加新的请求处理类。<br>• 灵活性强。可以动态地改变链内的成员或者改变链的次序来适应流程的变化。<br>• 简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用。</p>
<ol>
<li>什么是宏命令？</li>
</ol>
<p>宏命令是将多个命令合并起来组成的命令。</p>
<ol>
<li>请写出解释器模式的一个常见应用。</li>
</ol>
<p>在我们平时匹配字符串时，用到的正则表达式就是一个解释器。</p>
<ol>
<li>怎样使得外部类只能读取此列表中的数据，无法修改其中的任何数据，保证其安全性？</li>
</ol>
<p>• 提供一个 String next() 方法，使得外部类可以按照次序，一条一条的读取数据；<br>• 提供一个 boolean hasNext() 方法，告知外部类是否还有下一条数据。</p>

    

        <a href="/2023/01/05/面经设计模式/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UML/">UML</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-面经操作系统"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-01-04 00:00:00" datetime="2023-01-03T16:00:00.000Z"  itemprop="datePublished">2023-01-04</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/OS/">OS</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/01/04/面经操作系统/">Operating System</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li>线程安全（Thread Safety）：</li>
</ul>
<p>当多个线程访问某个类或者对象时，如果不需要额外的同步机制或者用户干预，这个类或者对象依然能够表现出正确的行为，那么它就被认为是线程安全的。<br>简而言之，线程安全意味着在多线程环境下，对象的状态不会发生不一致或者不正确的情况。</p>
<ul>
<li>线程不安全（Thread Unsafe）：</li>
</ul>
<p>相反，当多个线程访问某个类或者对象时，如果没有适当的同步措施，就可能导致对象的状态变得不可预测或者不正确，那么这个类或者对象就是线程不安全的。<br>在线程不安全的情况下，多个线程可能会在同一时间访问、修改相同的数据，这可能导致数据损坏或者不一致。</p>
<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul>
<li><p>进程是系统资源分配的基本单位，一个程序对应一个进程。每个进程都有自己独立的内存空间，相互之间不会共享。它包括了程序代码、内存空间、资源和文件等。</p>
</li>
<li><p>线程是进程中的<strong>执行单元</strong>，一个进程可以包含多个线程。线程共享了进程的内存空间和资源，可以同时执行不同的任务。</p>
</li>
</ul>
<h3 id="共享资源指的是哪些资源"><a href="#共享资源指的是哪些资源" class="headerlink" title="共享资源指的是哪些资源"></a>共享资源指的是哪些资源</h3><p>内存、全局变量、对象、文件等</p>
<h1 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h1><p>协程（goroutine）可以理解为轻量化的用户态线程的实现，区别是<br><strong>协程由goruntime进行调度，线程由操作系统内核调度</strong></p>
<h1 id="进程切换："><a href="#进程切换：" class="headerlink" title="进程切换："></a>进程切换：</h1><ul>
<li>保存当前进程上下文：当操作系统决定要切换到另一个进程时，首先会保存当前进程的上下文信息，包括寄存器的值、程序计数器（PC）等。</li>
<li>加载目标进程的上下文：接下来，操作系统会从进程调度队列中选择一个新的进程，将其保存的上下文信息加载到 CPU 寄存器中，以便开始执行该进程。</li>
<li>切换页表：在多进程的环境下，<strong>每个进程都有自己独立的地址空间</strong>（虚拟内存），因此在切换进程时，需要将当前进程的页表（用于地址映射）切换为目标进程的页表。</li>
<li>恢复执行：一旦目标进程的上下文信息被加载，CPU 会从目标进程的上次停止的位置继续执行。</li>
</ul>
<h2 id="与线程切换的区别："><a href="#与线程切换的区别：" class="headerlink" title="与线程切换的区别："></a>与线程切换的区别：</h2><ul>
<li>线程切换发生在用户态，进程切换发生在内核态。</li>
<li>线程切换相对于进程切换来说更加轻量级，因为线程共享了同一地址空间和其他资源，上下文切换的开销较小。</li>
</ul>
<h1 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h1><ul>
<li><strong>共享内存</strong> </li>
<li><strong>管道</strong> 半双工</li>
<li><strong>信号</strong> signal ，用于处理异步事件，如外部中断、错误、异常等情况</li>
<li><strong>信号量</strong> semaphore（mutex）实现进程间的互斥与同步，int计数器</li>
<li><strong>消息队列</strong> 保存在内核中的消息链表<h1 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h1></li>
<li><strong>互斥锁</strong></li>
<li><strong>读写锁</strong></li>
<li><strong>自旋锁</strong> 适用于锁被持有时间较短的情况：线程尝试获得锁时，如果锁已被占用，线程会一直忙等待直到锁被释放</li>
<li><strong>信号量</strong></li>
<li><strong>条件变量</strong></li>
<li><strong>原子操作</strong></li>
</ul>
<h1 id="fork子进程与父进程的区别"><a href="#fork子进程与父进程的区别" class="headerlink" title="fork子进程与父进程的区别"></a>fork子进程与父进程的区别</h1><p>在调用 fork() 函数时，操作系统会创建一个新的进程，这个新的进程称为子进程。子进程是父进程的一个复制，它将继承父进程的内存空间、文件描述符等资源。<br>fork之后，子进程和父进程之间是完全独立进行，互不干扰。</p>
<h1 id="死锁定义-amp-产生条件"><a href="#死锁定义-amp-产生条件" class="headerlink" title="死锁定义&amp; 产生条件"></a>死锁定义&amp; 产生条件</h1><p>定义：<br>死锁（Deadlock）是指在多个进程或线程之间，每个进程或线程都在等待一个事件，而这个事件只能由其他等待的进程或线程触发，从而导致所有进程或线程都无法继续执行的一种状态。</p>
<p>产生条件</p>
<ul>
<li>互斥（Mutual Exclusion）：资源只能被一个进程或线程占用，如果资源被占用，其他进程或线程必须等待。</li>
<li>持有和等待（Hold and Wait）：一个进程或线程可以在持有某个资源的同时等待其他资源，这时如果其他资源被占用，就会导致死锁。</li>
<li>不可剥夺（No Preemption）：资源不能被强制从一个进程或线程中抢占，只能由占用它的进程或线程显式释放。</li>
<li>循环等待（Circular Wait）：多个进程或线程之间形成一个环路。</li>
</ul>
<h1 id="进程调度策略"><a href="#进程调度策略" class="headerlink" title="进程调度策略"></a>进程调度策略</h1><ul>
<li>先来先服务</li>
<li>短进程优先</li>
<li>时间片轮转</li>
<li>优先级队列</li>
<li>多级反馈队列<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1></li>
<li>先进先出</li>
<li>最近最久未使用（手撕）</li>
</ul>
<h1 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h1><ul>
<li>先来先服务</li>
<li>最短寻道优先</li>
<li>扫描算法<h1 id="分页是什么，内存页面"><a href="#分页是什么，内存页面" class="headerlink" title="分页是什么，内存页面"></a>分页是什么，内存页面</h1>分页是操作系统中一种内存管理技术。</li>
</ul>
<p>优势 </p>
<ul>
<li>虚拟内存的实现：允许程序使用比实际物理内存更大的地址空间。</li>
<li>分页策略：可以实现页面置换算法，将不常用的页置换到磁盘上。</li>
<li>内存保护：可以将页设置为只读或只执行，从而保护程序的关键部分不被修改。</li>
<li>内存共享：多个进程可以共享相同的物理页，减少了内存的占用。</li>
</ul>
<h1 id="分段是什么，存在碎片问题"><a href="#分段是什么，存在碎片问题" class="headerlink" title="分段是什么，存在碎片问题"></a>分段是什么，存在碎片问题</h1><p>与分页不同，分段不将内存划分为固定大小的块，而是将其划分为逻辑上相关联的段，每个段的长度可以不同。</p>
<p>优势</p>
<ul>
<li>更灵活的内存管理：可以根据程序的需要分配不同大小的段，更好地利用内存。</li>
<li>更好的地址空间划分：可以将程序的不同部分（如代码、数据、堆栈等）放置在不同的段中，提高了程序的可读性和可维护性。</li>
<li>内存保护：可以通过设置段的权限（如只读、读写等）来保护程序的关键部分，防止非法访问。</li>
<li>共享和动态加载：不同程序可以共享相同的段，也可以在运行时动态加载和卸载段。</li>
</ul>
<p>使用场景</p>
<ul>
<li>动态链接库（DLL）：在操作系统中，动态链接库通常会以独立的段来存放，这样可以在运行时被加载和卸载。</li>
<li>程序的逻辑结构：将程序的不同部分（如代码段、数据段、堆栈段等）放置在不同的段中，可以使程序的逻辑结构更清晰，提高可读性和可维护性。</li>
<li>内存保护：可以通过设置段的权限来保护程序的关键部分，防止非法访问。例如，将代码段设置为只读，防止在运行时修改代码</li>
</ul>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><p>通过将程序的逻辑地址空间映射到物理内存或磁盘上的存储空间来实现。<br>实现技术：分页和分段技术</p>
<h1 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h1><p>时间局部性：如果一个数据项被访问，那么在不久的将来它很可能再次被访问。这意味着程序往往会重复使用相同的数据。</p>
<p>空间局部性：如果一个数据项被访问，那么在它附近的数据也很可能会被访问。这意味着程序往往会以块或连续区域的方式访问数据。</p>
<h1 id="交换空间（Swap分区）"><a href="#交换空间（Swap分区）" class="headerlink" title="交换空间（Swap分区）"></a>交换空间（Swap分区）</h1><p>当物理内存不足时，操作系统会将一部分不常用的数据（可能是程序的代码、数据等）从物理内存移动到磁盘上的交换文件（Swap File）或者交换分区（Swap Partition）中。这样，物理内存就会腾出空间来运行当前活动的程序。当需要访问被移到交换空间的数据时，操作系统会将其再次加载到物理内存中。</p>
<h1 id="缓冲区泄漏"><a href="#缓冲区泄漏" class="headerlink" title="缓冲区泄漏"></a>缓冲区泄漏</h1><p>当程序向缓冲区写入超过其容量的数据时，会覆盖相邻内存区域的数据或者控制程序的执行流程，从而可能导致程序崩溃或者执行意外的行为。</p>
<ul>
<li>程序崩溃：如果溢出的数据覆盖了程序关键的数据或者控制信息，可能会导致程序崩溃或异常终止。</li>
<li>提权漏洞：如果一个程序以特权用户或系统管理员的身份运行，并且存在缓冲区溢出漏洞，攻击者可以利用这个漏洞来提升自己的权限，获取对系统的控制权。</li>
<li>执行恶意代码：攻击者可以通过精心构造的输入数据来覆盖程序的返回地址或者函数指针，从而强行将程序执行流程转移到恶意代码所在的地址，实现远程代码执行攻击。</li>
<li>信息泄露：攻击者可以利用缓冲区溢出漏洞来读取程序内部的数据，可能包括敏感信息、密码等。</li>
</ul>
<h1 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h1><h2 id="僵尸进程：子进程结束，父进程不知道"><a href="#僵尸进程：子进程结束，父进程不知道" class="headerlink" title="僵尸进程：子进程结束，父进程不知道"></a>僵尸进程：子进程结束，父进程不知道</h2><p>定义：僵尸进程是已经结束执行的子进程，但其父进程尚未调用wait()或waitpid()系统调用来获取子进程的退出状态，因此子进程的资源（如进程表项、文件描述符等）尚未被完全释放。</p>
<p>状态：僵尸进程处于”Z”状态（在ps命令中以”Z”标识），找到Z状态kill掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -aux | grep Z</span><br><span class="line">kill -s SIGCHLD &lt;PID&gt; </span><br><span class="line">#SIGCHLD信号是一个用于通知父进程子进程状态变化的信号。通过向僵尸进程发送这个信号</span><br></pre></td></tr></table></figure>

<p>危害：僵尸进程占用了系统资源（如进程表项），如果大量的僵尸进程积累，可能会导致系统资源不足。</p>
<h2 id="孤儿进程：父进程结束，子进程还在执行，会被init进程接管"><a href="#孤儿进程：父进程结束，子进程还在执行，会被init进程接管" class="headerlink" title="孤儿进程：父进程结束，子进程还在执行，会被init进程接管"></a>孤儿进程：父进程结束，子进程还在执行，会被init进程接管</h2><p>定义：孤儿进程是指一个子进程的父进程提前结束了，而子进程还在继续运行。此时，子进程会被init进程（PID为1）接管，成为init的子进程。<br>状态：孤儿进程的状态正常，不会变成僵尸进程，因为init进程会负责回收孤儿进程的资源。<br>危害：一般情况下，孤儿进程并不会造成严重问题。但如果大量的孤儿进程在系统中运行，可能会占用系统资源，因此最好的做法是在父进程退出前，确保它的子进程已经正确地结束。</p>
<h1 id="重点：IO多路复用"><a href="#重点：IO多路复用" class="headerlink" title="重点：IO多路复用"></a>重点：IO多路复用</h1><p>IO Multiplexing是指通过一种机制<strong>同时监听多个文件描述符（sockets、文件、设备等）</strong>，当其中任意一个文件描述符就绪（可读、可写或异常）时，就可以对其进行相应的处理，从而提高了系统的性能和响应速度。</p>
<ul>
<li>select 轮训，在一个数组中注册多个文件描述符，数据量少时效果好</li>
<li>数据结构：数组</li>
<li>poll 轮训，数据量多时效果好</li>
<li>数据结构：链表</li>
<li>epoll 使用了事件驱动的方式来管理文件描述符，只有当文件描述符真正就绪时才会通知应用程序</li>
<li>数据结构：红黑树</li>
</ul>
<p>优点：相对于select和poll，epoll的性能更高，因为它采用了红黑树的数据结构来管理文件描述符，可以处理大量的文件描述符，并且在文件描述符就绪时会立即得到通知。</p>
<h1 id="硬连接-软连接"><a href="#硬连接-软连接" class="headerlink" title="硬连接 软连接"></a>硬连接 软连接</h1><p>硬连接</p>
<ul>
<li>硬链接与原文件共享同一个索引节点，具有相同的 Inode 号。</li>
<li>不能连接目录，防止形成环<br>软连接</li>
<li>软链接是一个单独的文件，其中包含了指向目标文件的路径信息。</li>
<li>能连接目录</li>
</ul>
<h1 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h1><ol>
<li>中断触发，事件可能包括定时器结束，系统调用，异常等</li>
<li>中断请求，向CPU发送通知，我要处理一个终端</li>
<li>中断控制器（Interrupt Controller）将中断请求映射到一个中断向量，对应了中断处理程序的入口地址，是映射关系，类似于函数指针。</li>
<li>根据中断向量表将中断向量映射到实际的中断处理程序的入口地址。</li>
<li>保存上下文</li>
<li>执行中断服务程序</li>
<li>关中断</li>
<li>恢复现场后，<strong>重新执行产生中断的那一句指令</strong></li>
</ol>
<h1 id="中断和轮训"><a href="#中断和轮训" class="headerlink" title="中断和轮训"></a>中断和轮训</h1><ol>
<li>触发条件不同，中断是被动条件触发（定时器结束、产生异常），轮训是主动查询资源状体啊</li>
<li>响应能力不同，中断实时发生，论文有延迟</li>
<li>轮训同步，中断异步</li>
</ol>
<h1 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h1><p>零拷贝是一种优化数据传输的技术，它通过<strong>减少或消除数据在内存之间的复制过程</strong>来提高传输效率，从而在高性能的数据传输场景中发挥重要作用。</p>
<ol>
<li>传递文件描述符</li>
<li>允许内核缓冲区直接访问</li>
<li>DMA</li>
<li>sendfile() 将一个文件描述符的内容发给另一个</li>
<li>mmap()文件映射到内存</li>
</ol>
<p><strong>Redis：</strong><br>Redis 通过使用 sendfile 系统调用，实现了零拷贝技术，可以在文件传输时避免数据在用户空间和内核空间之间的多次拷贝。</p>
<p><strong>Kafka：</strong><br>Kafka 在数据的生产者和消费者之间使用了零拷贝技术。生产者将数据<strong>直接写入内核缓冲区</strong>，消费者从内核缓冲区直接读取数据，避免了中间的数据拷贝过程。</p>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p><strong>分配管理</strong></p>
<ul>
<li>栈由编译器管理，自动分配和释放内存，函数调用时分配，并在函数返回时自动释放。</li>
<li>堆通常用于存储动态分配的数据，由程序员手动管理内存的分配和释放。<code>malloc()、calloc()、realloc()</code></li>
</ul>
<p><strong>存储内容</strong><br>栈用于存储函数的局部变量和控制信息<br>堆用于存储动态分配的数据，如动态数组、对象等。<br><strong>大小和位置</strong></p>
<ul>
<li>栈的大小是固定有限的，由系统在程序启动时分配，每个函数调用时，都会创建一个称为帧（Frame）的区域来存储这些信息</li>
<li>堆大小不固定，位置不固定</li>
</ul>
<h2 id="CPU占用率-使用率-负载"><a href="#CPU占用率-使用率-负载" class="headerlink" title="CPU占用率 使用率 负载"></a>CPU占用率 使用率 负载</h2><p>CPU占用率、使用率和负载是监控和评估计算机系统性能的三个不同方面。</p>
<p><strong>CPU占用率（CPU Usage）：</strong><br>CPU占用率是指计算机CPU处理任务的效率和利用率。它通常以百分比的形式表示，表示CPU正在执行任务的时间占总时间的比例。例如，一个CPU占用率为50%的系统表示CPU一半的时间用于处理任务，一半的时间处于空闲状态。</p>
<p><strong>CPU使用率（CPU Utilization）：</strong><br>CPU使用率是指实际用于处理计算任务的CPU时间与总时间的比例。它反映了CPU的工作效率，是一个反映计算机性能的重要指标。CPU使用率可以分为用户态使用率、内核态使用率等不同类型。</p>
<p><strong>负载（Load Average）：</strong><br>负载是一个相对于一段时间内系统CPU运算负荷的指标。通常以三个数值表示，分别表示系统在过去1分钟、5分钟和15分钟内的负载情况。例如，一个负载为1.0的系统表示在平均1分钟内，有一个任务在运行。</p>
<p><strong>区别总结：</strong></p>
<p>CPU占用率关注的是CPU执行任务的效率，以百分比表示。<br>CPU使用率关注的是实际用于处理任务的CPU时间占总时间的比例，也以百分比表示，但更偏向于反映CPU的工作效率。<br>负载关注的是系统的整体负担情况，包括CPU、内存、磁盘等资源的占用情况，以及等待队列中的任务数。</p>
<h2 id="Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）"><a href="#Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）" class="headerlink" title="Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）"></a>Linux进程间通信：管道（匿名管道和有名管道）、信号、消息队列、共享内存、信号量、套接字（socket）</h2><h2 id="Linus线程间通信：互斥量、信号量、条件变量"><a href="#Linus线程间通信：互斥量、信号量、条件变量" class="headerlink" title="Linus线程间通信：互斥量、信号量、条件变量"></a>Linus线程间通信：互斥量、信号量、条件变量</h2>
    

        <a href="/2023/01/04/面经操作系统/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OS/">OS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-面经计算机网络"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-01-04 00:00:00" datetime="2023-01-03T16:00:00.000Z"  itemprop="datePublished">2023-01-04</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Network/">Network</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/01/04/面经计算机网络/">NetWorking</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><p>MAC头部：6<br>IP头部：20<br>TCP头部：20到60字节<br>UDP头部：8<br>TCP最大长度 65535 - 头部</p>
<p>UDP最大长度 65535 - 头部</p>
<h2 id="TCP的字节序是大端还是小端【大端】为什么？"><a href="#TCP的字节序是大端还是小端【大端】为什么？" class="headerlink" title="TCP的字节序是大端还是小端【大端】为什么？"></a>TCP的字节序是大端还是小端【大端】为什么？</h2><p>小端字节序是将最低有效字节存储在内存的最低地址处，而大端字节序则是将最高有效字节存储在最低地址处。</p>
<ol>
<li>网络字节序是大端，arm64和x86主机采用主机字节序，是小端</li>
<li>如果两台主机的CPU架构或者字节序不同（比如一台是小端序，另一台是大端序），TCP协议会在传输过程中自动进行字节序的转换，以保证接收方能够正确地解析数据。</li>
</ol>
<ul>
<li>创建socket或bind时，要用htonl、htons等函数来将端口或ip地址从主机字节序转换成网络字节序</li>
<li>send，recv等函数传输的只是字节流，不关心大小端序<h2 id="TCP如何保证可靠的"><a href="#TCP如何保证可靠的" class="headerlink" title="TCP如何保证可靠的"></a>TCP如何保证可靠的</h2></li>
</ul>
<ol>
<li>确认号，序列号</li>
<li>三次握手和四次挥手</li>
<li>超时重传（TTS字段）</li>
<li>流量控制（滑动窗口）</li>
<li>拥塞控制（拥塞窗口）<h2 id="TCP半连接队列和全连接队列"><a href="#TCP半连接队列和全连接队列" class="headerlink" title="TCP半连接队列和全连接队列"></a>TCP半连接队列和全连接队列</h2>在TCP连接的建立过程中，会涉及到半连接队列（SYN队列）和全连接队列（ESTABLISHED队列）。</li>
</ol>
<ul>
<li>半连接队列中存放的是三次握手中的第一步（即SYN）发送的连接请求，还没有得到完全建立连接的确认</li>
<li>当TCP连接成功建立后，会被移动到全连接队列<h2 id="粘包和拆包"><a href="#粘包和拆包" class="headerlink" title="粘包和拆包"></a>粘包和拆包</h2>由于网络传输中的数据分片、路由器缓冲区大小限制、接收端缓冲区大小设置等因素造成的</li>
<li><strong>粘包</strong>：多个数据包被合并成一个大的数据块</li>
<li><strong>拆包</strong>：只收到了一个大包，被拆成了多个小块</li>
<li>TCP选项字段可以设置MTU，指网络通信中能够通过的最大数据包的大小。通过设置MTU，可以控制单个数据包的大小，但并不能解决粘包和拆包的问题。</li>
<li>粘包和拆包问题主要是因为TCP协议是流协议，它并没有记录消息的边界信息。因此，在数据传输过程中，可能会出现多个消息被合并成一个包（粘包）或一个消息被拆分成多个包（拆包）的情况。<h1 id="TCP最大长度为2的32次方-头部字段"><a href="#TCP最大长度为2的32次方-头部字段" class="headerlink" title="TCP最大长度为2的32次方-头部字段"></a>TCP最大长度为2的32次方-头部字段</h1><h3 id="解决办法【固定长度，消息边界，定时器，缓冲区】"><a href="#解决办法【固定长度，消息边界，定时器，缓冲区】" class="headerlink" title="解决办法【固定长度，消息边界，定时器，缓冲区】"></a>解决办法【固定长度，消息边界，定时器，缓冲区】</h3></li>
</ul>
<ol>
<li>头部字段，固定消息长度</li>
<li>帧数据字段加入边界信息，比如某个特定字符</li>
<li>使用定时器来等待足够长的时间以接收完整的消息，</li>
<li>可以通过合理设置缓冲区大小来保证完整接收消息<h2 id="TCP的TIMEWAIT状态过多会发生什么"><a href="#TCP的TIMEWAIT状态过多会发生什么" class="headerlink" title="TCP的TIMEWAIT状态过多会发生什么"></a>TCP的TIMEWAIT状态过多会发生什么</h2>TCP的TIME_WAIT状态发生在第四次挥手，是为了确保在网络中所有的数据包都被正确地接收和处理，以避免出现数据包混淆或丢失的情况</li>
<li>内存资源、端口资源大量被占用，新连接无法建立，被网络攻击，导致程序崩溃等情况</li>
<li>拒绝服务（DOS）攻击，端口扫描攻击<h3 id="【如何解决】"><a href="#【如何解决】" class="headerlink" title="【如何解决】"></a>【如何解决】</h3></li>
<li>在程序里设置一个等待参数，超时退出</li>
<li>使用连接池复用连接<h2 id="传输内容"><a href="#传输内容" class="headerlink" title="传输内容"></a>传输内容</h2>应用层 报文<br>传输层 报文段<br>网络层 数据包<br>链路层 数据帧<br>物理层 比特流<h2 id="网络层实现转发"><a href="#网络层实现转发" class="headerlink" title="网络层实现转发"></a>网络层实现转发</h2><h2 id="路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？"><a href="#路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？" class="headerlink" title="路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？"></a>路由表是使用什么数据结构查找的？路由表中没有要查找的IP怎么办？</h2>路由表通常使用前缀树（Trie）存储路由表项，存的是一个<strong>IP地址与下一跳路由器，即路由器的IP地址</strong>，的映射<br>没有要查找的IP，则跳到默认的下一跳，如果一直转发默认下一跳，则丢弃或者不可达信号</li>
</ol>
<h2 id="简述TCP的拥塞控制"><a href="#简述TCP的拥塞控制" class="headerlink" title="简述TCP的拥塞控制"></a>简述TCP的拥塞控制</h2><p>首先，通过<strong>慢启动</strong>机制，当建立新的TCP连接时，发送方会谨慎地开始发送数据，逐步增大发送量以避免过快发送引起网络拥塞，每次x2。其次，一旦拥塞窗口达到设定阈值，TCP进入<strong>拥塞避免</strong>状态，发送方将<strong>以线性方式增大拥塞窗口</strong>，以保持合理的数据传输速率。</p>
<ol>
<li>发现数据丢失时，用<strong>快速重传和快速恢复机制</strong>：1.计时器检测没有确认，超时重传发生，TCP会将拥塞窗口减半，再线性增加。<h2 id="简述TCP的流量控制【确保接收方能以自己的接收速度来处理】"><a href="#简述TCP的流量控制【确保接收方能以自己的接收速度来处理】" class="headerlink" title="简述TCP的流量控制【确保接收方能以自己的接收速度来处理】"></a>简述TCP的流量控制【确保接收方能以自己的接收速度来处理】</h2>通过接收方维护接收的窗口实现的。<br>发送方<h1 id="1-应用层"><a href="#1-应用层" class="headerlink" title="1. 应用层"></a>1. 应用层</h1><h2 id="HTTP的无状态、明文传输特性"><a href="#HTTP的无状态、明文传输特性" class="headerlink" title="HTTP的无状态、明文传输特性"></a>HTTP的无状态、明文传输特性</h2></li>
</ol>
<ul>
<li>无状态：在处理每个请求时都不会记住之前的请求，每个请求都是独立的，不依赖于之前的请求</li>
<li>状态码：状态码用来指示<strong>服务器对请求</strong>的处理状态<h2 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h2></li>
<li>强制缓存：浏览器判断缓存没有过期，则直接使用浏览器的本地缓存</li>
<li>协商缓存：通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存，响应状态码为304。</li>
<li>【TIP】只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。</li>
</ul>
<h2 id="HTTP-和HTTPs-的区别"><a href="#HTTP-和HTTPs-的区别" class="headerlink" title="HTTP 和HTTPs 的区别"></a>HTTP 和HTTPs 的区别</h2><ol>
<li>HTTP是明文传输，HTTPS使用了SSL证书来建立加密传输过程，HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
<li>HTTP是直接运行在TCP协议基础上的，HTTPS是运行在SSL协议上，其中SSL协议建立在TCP之上，使用加密和身份验证保证安全性</li>
<li>HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>CA证书放在服务器上，证书内容包含服务器的公钥、持有者信息、颁发者信息、有效期等等</li>
<li>CA证书验证：服务器向客户端发送证书时，客户端会使用相应的CA的公钥来验证证书的合法性。包括检查证书的数字签名是否正确、证书是否在有效期内等。</li>
<li>CA信任链验证：如果客户端信任该CA（通常是因为<strong>CA的根证书</strong>预装在操作系统或浏览器中），那么客户端将信任由该CA签发的证书。</li>
</ol>
<h2 id="HTTP状态码目录"><a href="#HTTP状态码目录" class="headerlink" title="HTTP状态码目录"></a>HTTP状态码目录</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status</a></p>
<ul>
<li>200：成功返回响应</li>
<li>301：永久重定向，客户端第一次访问此 url 时，告知客户端以后直接访问新的 url，该状态保存在浏览器缓存中。</li>
<li>302；临时重定向，客户端每次访问此 url 时，告知客户端重定向到新的 url ，后续访问依然访问当前的 url。</li>
<li>304：使用协商缓存</li>
<li>400：发送的请求错误，请求格式错误，或者没有服务器要求的数据。</li>
<li>401：没有权限访问，当前用户没有权限访问此资源。</li>
<li>403：请求被服务器禁止。</li>
<li>404：请求的 url 不存在，一般是 url 出错。</li>
<li>500：服务器处理请求出现错误。</li>
<li>501：服务器超出能力之外的方法，例如：请求的方法服务器不支持。</li>
<li>504：来自网关或者代理服务器，请求资源服务器时超时。</li>
</ul>
<h2 id="HTTP2：解决HTTP延迟高的问题"><a href="#HTTP2：解决HTTP延迟高的问题" class="headerlink" title="HTTP2：解决HTTP延迟高的问题"></a>HTTP2：解决HTTP延迟高的问题</h2><ul>
<li>延迟高的原因：请求-响应模型、头部巨大且重复、并发连接耗时、服务器不能主动推送等<h3 id="解决方法与针对的问题"><a href="#解决方法与针对的问题" class="headerlink" title="解决方法与针对的问题"></a>解决方法与针对的问题</h3></li>
<li>头部压缩：Cookie、User Agent、Accept 头部字段内容太大</li>
<li>二进制帧：字段传输速度，便于位运算</li>
<li>并发传输：缓解了队头阻塞问题（没有解决）</li>
<li>服务端主动推送资源<h3 id="方法细节"><a href="#方法细节" class="headerlink" title="方法细节"></a>方法细节</h3></li>
<li>头部压缩：使用Hpack算法，静态字典/动态字典/哈夫曼编码。客户端和服务器两端都会建立和维护「字典」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，可达到 50%~90% 的高压缩率。</li>
<li>二进制帧：响应报文划分成了两类帧，包括 首部 和 DATA（负载），也就是说一条 HTTP 响应，划分成了两类帧来传输，并且采用二进制来编码。</li>
<li>并发传输：使用 Stream 设计，多个 Stream 复用一条 TCP 连接，达到并发的效果</li>
</ul>
<p><img src="/images/http2stream.webp" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 1 个 TCP 连接包含一个或者多个 Stream，Stream 是 HTTP/2 并发的关键技术；</span><br><span class="line">- Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；</span><br><span class="line">- Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；</span><br><span class="line">- 一个 Frame 可以由多个 TCP 报文构成</span><br><span class="line">- 不同stream的帧可以乱序，帧头部可以带stream ID，接收端可以重组</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端推送资源：客户端发起的请求，必须使用的是奇数号 Stream，服务器主动的推送，使用的是偶数号 Stream。服务器在推送资源时，会通过 PUSH_PROMISE 帧传输 HTTP 头部，并通过帧中的 Promised Stream ID 字段告知客户端，接下来会在哪个偶数号 Stream 中发送包体。<h2 id="HTTP3-quic协议，使用HTTP2-TLS-UDP"><a href="#HTTP3-quic协议，使用HTTP2-TLS-UDP" class="headerlink" title="HTTP3: quic协议，使用HTTP2 + TLS + UDP"></a>HTTP3: quic协议，使用HTTP2 + TLS + UDP</h2>HTTP2存在问题：</li>
</ul>
<ol>
<li>TCP层的队头阻塞问题：HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。<ul>
<li><strong>TCP 是字节流协议</strong>。TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。</li>
</ul>
</li>
<li>TCP 与 TLS 的握手时延迟：TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生“减速”效果</li>
<li>网络迁移需要重新连接：<h3 id="quic协议"><a href="#quic协议" class="headerlink" title="quic协议"></a>quic协议</h3></li>
<li>无队头阻塞：传输层协议换成UDP，根本上避免了TCP的队头阻塞。<ul>
<li>quic协议会保证数据包的可靠性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。</li>
<li>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响。</li>
</ul>
</li>
<li>更快的连接建立：quic协议握手的方式：<ul>
<li>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</li>
</ul>
</li>
<li>连接迁移：没有用四元组的方式来“绑定”连接，而是通过连接 ID 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感。</li>
</ol>
<h2 id="网页解析HTTP请求："><a href="#网页解析HTTP请求：" class="headerlink" title="网页解析HTTP请求："></a>网页解析HTTP请求：</h2><ol>
<li><p>输入url</p>
</li>
<li><p>DNS解析，就近原则，如果本地DNS服务器的缓存中没有，就发到DNS根服务器，</p>
<ul>
<li>根DNS服务器返回的报文，告诉本地DNS，这个域名由哪个顶级DNS服务器负责，本地去这个顶级（比如.com）服务器去查询</li>
<li>顶级返回次级地址，次级返回次次级，最后返回目标IP，本地DNS缓存更新这个IP</li>
<li>其中用户使用的DNS服务器默认是运营商提供的本地域名解析器，检查自己的缓存</li>
</ul>
</li>
<li><p><strong>建立TCP连接，经过三次握手 <em>1.C-&gt;S发送握手请求，附带一个SEQ=x，2.S-&gt;C发送收到，福袋一个ACK=x+1，和另一个SEQ=y ，3. C-&gt;S发送一个ACK=y+1 ,SEQ =x+1，上一个ACK</em>，结束SYN-RECV阶段，并进入establish阶段/</strong></p>
</li>
<li><p>释放连接，<strong>经过四次挥手</strong> <em>1.</em></p>
<h2 id="网页解析HTTPS请求：先建立TCP，再建立SSL加密"><a href="#网页解析HTTPS请求：先建立TCP，再建立SSL加密" class="headerlink" title="网页解析HTTPS请求：先建立TCP，再建立SSL加密"></a>网页解析HTTPS请求：先建立TCP，再建立SSL加密</h2></li>
<li><p>输入url，三次握手完成TCP通信建立</p>
</li>
<li><p>客户端发送https请求到服务端</p>
</li>
<li><p>服务端发回SSL证书和公钥到客户端</p>
</li>
<li><p>客户端验证证书安全性，如果安全，生成对称密钥，把这个密钥用公钥发回服务端</p>
</li>
<li><p>服务端用自己的私钥解密，这样两者都有了session key，后面的传输都是通过这个对称加密进行的</p>
</li>
</ol>
<h2 id="HTTP1-1的长连接是怎样建立的"><a href="#HTTP1-1的长连接是怎样建立的" class="headerlink" title="HTTP1.1的长连接是怎样建立的"></a>HTTP1.1的长连接是怎样建立的</h2><p>响应头中包含了 Connection: keep-alive 字段，那么它表示愿意保持连接开启，后续的请求都会通过上一个连接发送</p>
<h2 id="HTTP方法：POST-GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有"><a href="#HTTP方法：POST-GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有" class="headerlink" title="HTTP方法：POST GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有"></a>HTTP方法：POST GET的区别：get提交数据在url后，post在body中；get具有幂等性，post不具有</h2><p>GET 方法具有<strong>幂等性</strong>，指同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。<br>POST不具有幂等性。</p>
<ol>
<li><p>get 提交的数据会放在 url 之后，post 提交的数据放在 body 上。<br>get请求参数会以 url 的形式完整的保留在浏览器的记录里，会存在安全问题。而 post 数据放在请求主体中，且数据不会被浏览器记录，相比 get 方法，post 方法更安全，主要用于修改服务器上的资源。</p>
<ul>
<li><p>post 可以进行复杂的加密，get 则不可以</p>
</li>
<li><p>get 只支持 ASCII 字符格式的参数，而 post 方法没有限制。</p>
</li>
<li><p>get 提交的数据大小有限制（这里所说的限制是针对浏览器而言的），而 post 方法提交的数据理论上没限制</p>
</li>
</ul>
</li>
<li><p>get 方法具有幂等性，post 方法不具有。<br>幂等性，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p>
</li>
<li><p>post方法有时会发送两个 tcp 数据包，与浏览器有关</p>
</li>
</ol>
<ul>
<li>使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li>
<li>而 GET 方法 Header 和 Data 会一起发送<br>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</li>
</ul>
<h2 id="长连接：减少-TCP-连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。"><a href="#长连接：减少-TCP-连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。" class="headerlink" title="长连接：减少 TCP 连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。"></a>长连接：减少 TCP 连接的重复建立和断开所造成的额外开销，减轻服务器端的负载。</h2><ul>
<li>管道传输【一般不使用】：在同一个 TCP 连接里面，客户端可以发起多个请求：只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</li>
<li>队头阻塞问题：当顺序发送的请求序列中的某个请求阻塞时，后面的请求也会一直被阻塞。<h1 id="2-传输层"><a href="#2-传输层" class="headerlink" title="2. 传输层"></a>2. 传输层</h1><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2>UDP头部包含8个字节64位</li>
</ul>
<p>UDP头部的格式如下：</p>
<p><strong>源端口 (16位)</strong>：用于标识发送方的端口号。<br><strong>目标端口 (16位)</strong>：用于标识接收方的端口号。<br><strong>长度 (16位)</strong>：指示UDP报文头部和数据的总长度，以字节为单位，最小值为8（只有头部）。<br><strong>校验和 (16位)</strong>：用于检测UDP报文是否在传输过程中发生了错误。</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP头部包含20个字节。握手挥手时，数据字段为空</p>
<h3 id="为什么要进行三次握手-？"><a href="#为什么要进行三次握手-？" class="headerlink" title="*为什么要进行三次握手 ？"></a>*为什么要进行三次握手 ？</h3><p>确认客户端和服务端都可以正常发送接收数据。</p>
<ul>
<li>第一次握手：确认客户端可以正常发送数据。</li>
<li>第二次握手：确认客户端可以正常发送数据，确认服务端可以正常接收数据。</li>
<li>第三次握手：确认客户端可以正常发送数据，确认服务端可以正常接收数据，确认服务端可以正常发送数据，客户端可以正常接收数据。<h3 id="三次握手过程中网络断开，会出现什么情况"><a href="#三次握手过程中网络断开，会出现什么情况" class="headerlink" title="三次握手过程中网络断开，会出现什么情况"></a>三次握手过程中网络断开，会出现什么情况</h3></li>
</ul>
<p>第一次握手丢失：客户端没收到第二次握手，触发超时重传机制，发送第一次握手<br>第二次握手丢失：客户端依然没收到第二次握手，触发超时重传，发送第一次握手；服务端没有收到第三次握手，超时重传，发送第二次握手<br>第三次握手丢失：客户端establish状态，服务端没有收到第三次握手，超时重传，仍然发送第二次握手</p>
<p>超时重传的限度：发送一定次数N，这个次数由内核限制，linux为5次。</p>
<h3 id="为什么要进行四次挥手-？"><a href="#为什么要进行四次挥手-？" class="headerlink" title="为什么要进行四次挥手 ？"></a>为什么要进行四次挥手 ？</h3><p>第一次挥手：客户端向服务端请求关闭连接。</p>
<ul>
<li>客户端：客户端无数据传输。</li>
<li>服务端：无感知。</li>
</ul>
<p>第二次挥手：服务端收到客户端的请求，并且告知客户端等我处理完毕数据。</p>
<ul>
<li>客户端：客户端无数据传输。</li>
<li>服务端：客户端无数据传输。</li>
</ul>
<p>第三次挥手：服务端处理完毕数据，告知客户端，服务端数据处理完毕。</p>
<ul>
<li>客户端：客户端无数据传输，服务端无数据传输。</li>
<li>服务端：客户端无数据传输，服务端无数据传输。</li>
</ul>
<p>第四次挥手：客户端得知服务端数据处理完毕，双方数据都处理完毕，可断开连接。</p>
<ul>
<li>客户端：客户端无数据传输，服务端无数据传输。</li>
<li>服务端：客户端无数据传输，服务端无数据传输，得知客户端知道服务端无数据传输。</li>
</ul>
<h3 id="TCP是如何保证可靠传输的"><a href="#TCP是如何保证可靠传输的" class="headerlink" title="*TCP是如何保证可靠传输的"></a>*TCP是如何保证可靠传输的</h3><p>1 数据分块<br>​ 应用数据被分割成 TCP 认为最适合发送的数据块。并且给每一个数据块进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，如果发送过程中，存在数据块丢失或者发送重复，接收方根据序列号整理数据块，删除重复的数据块，要求发送方重新发送丢失的数据块。</p>
<p>2 校验和<br>与UDP 校验和相同，监测数据传输过程中可能出现的差错。</p>
<p>3 流量控制<br>让发送方的发送速率不要太快，让接收方来得及接收，TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</p>
<p>4 ARQ协议<br>ARQ(Automatic Repeat-reQuest)自动重传协议：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
<p>5 超时重传<br>当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</p>
<p>6 拥塞控制<br>在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</p>
<p>慢开始：当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况。慢开始的慢指的是初始发送报文段的数量为 1，如果收到确认，则发送两个报文段，之后每收到一个确认报文，发送报文端的数量就翻倍，直到到达慢开始门限，当发送报文段的数据大于门限数量时，使用拥塞避免算法。<br>拥塞避免：当网络拥塞发生时，慢开始门限值减半，发送的报文段数量改变为 1 ,然后再次重复两种算法（慢开始和拥塞避免）。<br>快重传：接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。</p>
<p>快恢复</p>
<p>快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：</p>
<p>① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限值减半；</p>
<p>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，发送报文段的数量减半，然后执行拥塞避免算法，线性增加发送报文段的数量。</p>
<h2 id="quic协议-1"><a href="#quic协议-1" class="headerlink" title="quic协议"></a>quic协议</h2><p>QUIC(Quick UDP Internet Connections)，是一种基于 UDP 的传输层协议。QUIC = HTTP/2 + TLS + UDP.</p>
<h1 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. 网络层</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>A 类地址：10.0.0.0～10.255.255.255<br>B 类地址：172.16.0.0～172.31.255.255<br>C 类地址：192.168.0.0～192.168.255.255<br>解决IPv4不够用的两种技术：</p>
<ul>
<li>nat(network address translation)网络地址转换协议：将内网地址转为公网ip的协议，实现多层网络地址转换。</li>
<li>IPv6 128位，比IPv4的32位多了四倍<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2>arp(address resolution protocol) 地址解析协议：根据主机的ip 地址获取主机的mac 地址。每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</li>
</ul>
<p>A要发送B一个数据包，首先他有B的IP地址，为了发送成功还需要B的MAC地址。</p>
<ul>
<li>首先A查找本地ARP缓存，<strong>IP：MAC的映射</strong></li>
<li>如果找到MAC 地址，就可以发送消息。</li>
<li>如果没有，A就会发送一个局域网广播的ARP请求B的MAC的数据包，这个消息被局域网内所有的计算机接受，B返回一个包含自身MAC和IP地址的ARP响应消息。作为响应请求的一部分，B 可以将 A 的一个条目插入到它的 ARP 表中，以备将来使用。</li>
</ul>
<h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><ul>
<li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。</li>
<li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。<br>互联网中主机之间相互传递数据的逻辑是，先通过 ip 地址找到对应的局域网，然后再找到对应的主机。</li>
<li>如果只采用 ip 地址，不用mac 地址：不安全， 同一个ip 地址可能绑定多个主机，而无论何时mac 地址和主机是一一对应的。<br>  <strong>找不到主机号，IP本质上相当于逻辑地址，两个主机可能有一个IP</strong></li>
<li>如果只采用mac 地址，不用ip 地址：没有办法使用ip 通过网段寻找目标主机，需要在全网段内没有规律的找一个主机，效率太慢。<br>  <strong>一个是不够用，二是没有IP网段，全网查找，没有规律</strong></li>
</ul>
<h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><ul>
<li>使用最广泛的HTTP/1.1，也是基于TCP协议的，同一时间里，客户端和服务器只能有一方主动发数据，这就是所谓的半双工。</li>
<li></li>
</ul>

    

        <a href="/2023/01/04/面经计算机网络/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-面经Java基础"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-01-03 00:00:00" datetime="2023-01-02T16:00:00.000Z"  itemprop="datePublished">2023-01-03</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/01/03/面经Java基础/">Java base</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B extends A;</span><br><span class="line">B b = <span class="keyword">new</span> A(); <span class="comment">//错误</span></span><br><span class="line">A a = <span class="keyword">new</span> B(); <span class="comment">//合法，但是通过 a 只能访问 A 类中定义的方法和属性，除非 B 类重写了这些方法</span></span><br></pre></td></tr></table></figure>

<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><ul>
<li>boolean 1</li>
<li>byte 1</li>
<li>short 2</li>
<li>char 2</li>
<li>int 4 </li>
<li>float 4</li>
<li>long 4</li>
<li>double <h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2></li>
<li>Boolean</li>
<li>Byte</li>
<li>Short</li>
<li>Character</li>
<li>Integer</li>
<li>Long</li>
<li>Float（没有实现缓存机制）</li>
<li>Double（没有实现缓存机制）</li>
<li>BigDecimal（浮点精确运算的场景，传统浮点类型计算时，会出现位数不够的时候，计算机会给这个浮点表示进行截断），计算机x86一般用小端存储，高（位）存高（地址），低存低<ul>
<li>低地址：指的是内存中较小的地址值。在大多数系统中，低地址对应于内存中的起始位置，也就是地址为0的位置。</li>
<li>高地址：指的是内存中较大的地址值。它是相对于低地址而言的，表示内存的结束位置。</li>
</ul>
</li>
<li>BigInteger（存储超过64 位 long 整型的数字）BigInteger 内部使用 int[] 数组来存储任意大小的整形数据。</li>
</ul>
<p><a href="https://javaguide.cn/java/basis/bigdecimal.html" target="_blank" rel="noopener">https://javaguide.cn/java/basis/bigdecimal.html</a></p>
<p><strong>装箱</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Integer num1 = <span class="number">40</span>; <span class="comment">//发生装箱，相当于 Integer.valueOf(40);</span></span><br><span class="line">Integer num2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line"><span class="keyword">return</span> num1 == num2; | <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">解释：num1 直接使用的是缓存中的对象: num2 直接创建了新对象</span><br><span class="line"><span class="comment">// 自动装箱函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自动拆箱</span></span><br><span class="line">如果把第一句换成 <span class="keyword">int</span> num1 =<span class="number">40</span>;</span><br><span class="line">num1 == num2;| <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">//会对num2发生自动拆箱，会实现两个int类型的比较，返回true</span></span><br><span class="line"><span class="comment">// 如果要用num2.equals比较:</span></span><br><span class="line">num2.equals(Integer.valueOf(num1));</span><br></pre></td></tr></table></figure>

<ul>
<li>所有<strong>整型包装类对象之间值</strong>的比较，全部使用 equals 方法比较。</li>
<li>== 操作符会<strong>比较两个对象的引用是否相等</strong>，而不是它们的值。因为 num1 和 num2 都是通过自动装箱得到的，它们实际上是不同的对象，即使它们包装的值相同</li>
<li>自动拆箱与装箱的例子：<ul>
<li>Integer i = 10 等价于 Integer i = Integer.valueOf(10)</li>
<li>int n = i 等价于 int n = i.intValue();</li>
</ul>
</li>
<li>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该<strong>尽量避免不必要的拆装箱操作</strong>。<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2></li>
<li>private</li>
<li>protected    </li>
<li>public<h2 id="类，方法，变量修饰符"><a href="#类，方法，变量修饰符" class="headerlink" title="类，方法，变量修饰符"></a>类，方法，变量修饰符</h2></li>
<li>class</li>
<li>new</li>
<li>abstract </li>
<li>extends</li>
<li>static:</li>
<li>final </li>
<li>implements</li>
<li>interface</li>
<li>synchronized</li>
<li>enum</li>
<li>native</li>
<li>volatile</li>
</ul>
<ol>
<li><p>static:static 修饰的变量和方法可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。也就是说，静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p>
</li>
<li><p>静态方法只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。</p>
</li>
<li><p>【为什么不能调用非静态成员】：在类加载的时候就会分配内存，非静态成员需要实例化后才能有效访问</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2></li>
</ol>
<ul>
<li>try</li>
<li>catch</li>
<li>throw</li>
<li>throws</li>
<li>finally<ul>
<li>当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
</li>
</ul>
<h2 id="重写-override-和-重载-overload"><a href="#重写-override-和-重载-overload" class="headerlink" title="重写 override 和 重载 overload"></a>重写 override 和 重载 overload</h2><ul>
<li>override是子类重写父类方法，参数需要一样</li>
<li>overload是在一个类中重载的某个方法</li>
<li>构造方法可以背重载，不可以重写</li>
</ul>
<h2 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h2><p>共同点：都不能被实例化。都可以包含抽象方法。都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。</p>
<p>区别：接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。一个类只能继承一个类，但是可以实现多个接口。接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值</p>
<h2 id="深拷贝与浅拷贝-引用拷贝"><a href="#深拷贝与浅拷贝-引用拷贝" class="headerlink" title="深拷贝与浅拷贝/引用拷贝"></a>深拷贝与浅拷贝/引用拷贝</h2><ul>
<li>深拷贝：完整复制某个对象，包括这个对象中的内部对象，都是不同的对象</li>
<li>浅拷贝：在堆上创建一个新对象，这个新对象与原对象使用的是同一个内部对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Person person = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        person.setAddress(person.getAddress().clone());</span><br><span class="line">        <span class="comment">//加入这一行，内部的address对象也进行拷贝，本质上是堆上的另外一个对象。</span></span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Object：基类"><a href="#Object：基类" class="headerlink" title="Object：基类"></a>Object：基类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">//native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。获取哈希码（int 整数），也称为散列码，也可以比较两个对象是否相等。两个对象的hashCode 值相等并不代表两个对象就相等：可能发生冲突</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">//native 方法，用于创建并返回当前对象的一份拷贝。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="comment">//返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="String-StringBuffer-StringBuilder"><a href="#String-StringBuffer-StringBuilder" class="headerlink" title="String  StringBuffer StringBuilder"></a>String  StringBuffer StringBuilder</h2><ul>
<li>String类不可变：创建时，采用final的字符数组表示字符串了,final char [],(java9以后用的byte[])</li>
<li><strong>StringBuilder</strong> 与 <strong>StringBuffer</strong>都继承自 <strong>AbstractStringBuilder</strong> 类，也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。</li>
</ul>
<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了<strong>避免字符串的重复创建。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line">String aa = <span class="string">"ab"</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line">String bb = <span class="string">"ab"</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>【面试题】<code>String s1 = new String(&quot;abc&quot;);</code>这句话创建了几个字符串对象？</p>
<ul>
<li>一个或两个：</li>
<li>一个的情况，abc在字符串常量池里，仅需要abc的引用创建s1</li>
<li>两个的情况，abc不存在常量池里，要先创建abc，再将其引用创建s1</li>
</ul>
<p>【面试题】手动将某字符串加入字符串常量池用什么方法</p>
<ul>
<li>String.intern()</li>
<li>将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：<ul>
<li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”Java“</span></span><br><span class="line"><span class="comment">// 将字符串对象”Java“的引用保存在字符串常量池中</span></span><br><span class="line">String s1 = <span class="string">"Java"</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// 会在堆中在单独创建一个字符串对象</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"Java"</span>);</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”Java“对应的引用</span></span><br><span class="line">String s4 = s3.intern();</span><br><span class="line"><span class="comment">// s1 和 s2 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// s3 和 s4 指向的是堆中不同的对象</span></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// s1 和 s4 指向的是堆中的同一个对象</span></span><br><span class="line">System.out.println(s1 == s4); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>【面试题】字符串加号操作 str + str</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"str"</span>;<span class="comment">//创建了一个字符串常量 "str"，它会存储在常量池中</span></span><br><span class="line">String str2 = <span class="string">"ing"</span>;</span><br><span class="line">String str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;<span class="comment">//这里的 "str" 和 "ing" 都是字符串字面量，它们会在编译时就被合并成一个新的字符串常量 "string"，然后存储在常量池中。</span></span><br><span class="line">String str4 = str1 + str2;<span class="comment">//这里使用了变量 str1 和 str2 进行字符串拼接，这是在运行时进行的。因此，新的字符串对象 "string" 会在堆内存中创建，而不是常量池</span></span><br><span class="line">String str5 = <span class="string">"string"</span>;</span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="Exception-和-Error（两者继承Thorwable）"><a href="#Exception-和-Error（两者继承Thorwable）" class="headerlink" title="Exception 和 Error（两者继承Thorwable）"></a>Exception 和 Error（两者继承Thorwable）</h2><ul>
<li><strong>Exception</strong> ：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong>Error</strong>：Error 属于程序无法处理的错误 ，jvm一般会选择线程终止。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<h3 id="Checkable-Exception-受检查异常，必须用catch或者throw捕获"><a href="#Checkable-Exception-受检查异常，必须用catch或者throw捕获" class="headerlink" title="Checkable Exception 受检查异常，必须用catch或者throw捕获"></a>Checkable Exception 受检查异常，必须用catch或者throw捕获</h3><p>除了RuntimeException及其子类以外（下列），其他的Exception类及其子类都属于受检查异常</p>
<ul>
<li>NullPointerException(空指针错误)</li>
<li>IllegalArgumentException(参数错误比如方法入参类型错误)</li>
<li>NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类）</li>
<li>ArrayIndexOutOfBoundsException（数组越界错误）</li>
<li>ClassCastException（类型转换错误）</li>
<li>ArithmeticException（算术错误）</li>
<li>SecurityException （安全错误比如权限不够）</li>
<li>UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用throws关键字声明可能抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="comment">// 在方法内部发现异常情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* some condition */</span>) &#123;</span><br><span class="line">            <span class="comment">// 抛出自定义异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">"Something went wrong"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;<span class="keyword">catch</span>(MyException e)&#123;</span><br><span class="line">          e.printStackTrace(); <span class="comment">//在控制台上打印 Throwable 对象封装的异常信息</span></span><br><span class="line">          e.getMessage();<span class="comment">// 返回异常发生时的简要描述</span></span><br><span class="line">          e.toString();<span class="comment">// 返回异常发生时的详细信息</span></span><br><span class="line">          e.getLocalizedMessage();<span class="comment">//返回异常对象的本地化信息。</span></span><br><span class="line">      &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型-Generics-对比CPP的template"><a href="#泛型-Generics-对比CPP的template" class="headerlink" title="泛型 Generics //对比CPP的template"></a>泛型 Generics //对比CPP的template</h2><p>相同点：</p>
<ul>
<li><strong>参数化类型</strong>：两者都允许你定义可以接受不特定类型的数据结构或算法，从而提高代码的复用性和灵活性。</li>
<li><strong>类型安全</strong>：Java 的泛型和 C++ 的模板都<strong>在编译时进行类型检查</strong>，确保类型的一致性。</li>
<li><strong>支持容器类</strong>：在两者中，可以创建可以容纳任何类型的容器类（例如，List、Set、Map 等）。</li>
</ul>
<p>不同点：</p>
<ul>
<li><strong>实现方式</strong>：<ul>
<li>Java 泛型是通过擦除（type erasure）来实现的。在编译时，泛型类型信息会被擦除，编译器会将泛型代码转化成非泛型的代码。这意味着在运行时，不会保留关于泛型类型的信息。这也是为什么在 Java 中不能直接创建泛型数组的原因。</li>
<li>C++ 模板是通过编译器在编译时进行代码生成，每次使用模板时，都会根据模板参数生成对应的代码。这使得 C++ 模板可以实现更为复杂和灵活的类型推断。</li>
</ul>
</li>
<li><strong>语法</strong>：<br>Java 泛型使用<t>来表示泛型类型，可以在类、接口、方法等级别使用泛型。<br>C++ 模板使用<typename t>或者<class t>来声明模板参数，可以在类、函数等级别使用模板。</class></typename></t></li>
<li><strong>泛型的通配符</strong>：<br>Java 的泛型可以使用通配符（wildcards）来表示不确定的类型。例如：List&lt;?&gt;表示一个不确定类型的 List。<br>C++ 模板可以通过模板特化来处理特定的类型。</li>
<li><strong>模板元编程</strong>：<br>C++ 的模板系统支持模板元编程，这意味着可以在编译时进行计算和逻辑操作，从而实现更为复杂的类型处理。</li>
<li><strong>依赖</strong>：<br>Java 的泛型不依赖于运行时类型信息（RTTI）。<br>C++ 的模板依赖于编译时类型信息（CTTI）。</li>
</ul>
<h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><ul>
<li>代理机制</li>
</ul>
<p><strong>使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<ul>
<li>动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。</li>
<li>静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li>JVM 层面：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class alunbarClass = TargetObject.class; <span class="comment">//知道目的类名为TargetObject，直接获取</span></span><br><span class="line">Class alunbarClass1 = Class.forName(<span class="string">"cn.javaguide.TargetObject"</span>);<span class="comment">//通过类的全路径获取</span></span><br><span class="line">TargetObject instance = <span class="keyword">new</span> TargetObject();<span class="comment">//通过实例获取</span></span><br><span class="line">Class alunbarClass2 = instance.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类加载器进行全路径的loadclass</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">"cn.javaguide.TargetObject"</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>静态代理<br>可以在代理类中增加方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsServiceImpl</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsProxy</span> <span class="keyword">implements</span> <span class="title">SmsService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SmsService smsService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmsProxy</span><span class="params">(SmsService smsService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.smsService = smsService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SmsService smsService = <span class="keyword">new</span> SmsServiceImpl();</span><br><span class="line">SmsProxy smsProxy = <span class="keyword">new</span> SmsProxy(smsService);</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态代理：JDK 动态代理、CGLIB 动态代理</p>
<ul>
<li>InvocationHandler 接口和 Proxy 类</li>
<li>还必须需要实现InvocationHandler 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现InvocationHandler 接口类的 invoke 方法来调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当你使用代理对象调用方法的时候实际会调用到这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p>数据从外部存储和内存之间进出的过程就是IO。</p>
<h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时</p>
<h2 id="序列化-Protobuf，Hessian，Kyro"><a href="#序列化-Protobuf，Hessian，Kyro" class="headerlink" title="序列化 Protobuf，Hessian，Kyro"></a>序列化 Protobuf，Hessian，Kyro</h2><ul>
<li>transient 阻止实例中那些用此关键字修饰的的变量序列化；</li>
<li>当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。</li>
<li>transient 只能修饰变量，不能修饰类和方法。</li>
<li>static 变量因为不属于任何对象(Object)，所以无论有没有 transient 关键字修饰，均不会被序列化。</li>
</ul>
<h2 id="sun-misc-Unsafe类-并发工具类的组件，一个直接操作内存空间的类。"><a href="#sun-misc-Unsafe类-并发工具类的组件，一个直接操作内存空间的类。" class="headerlink" title="sun.misc.Unsafe类:并发工具类的组件，一个直接操作内存空间的类。"></a>sun.misc.Unsafe类:并发工具类的组件，一个直接操作内存空间的类。</h2><p>主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。</p>
<ul>
<li>Unsafe中提供的方法需要依赖native方法，Java 代码中只是声明方法头，具体的实现则交给本地代码</li>
</ul>
<h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配新的本地空间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//重新调整内存空间的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//将内存设置为指定值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object srcBase, <span class="keyword">long</span> srcOffset,Object destBase, <span class="keyword">long</span> destOffset,<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//清除内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这种方式分配<strong>堆外内存</strong>，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用freeMemory方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在try中执行对内存的操作，最终在finally块中进行内存释放。</p>
<h3 id="【面试题】为什么要用堆外内存"><a href="#【面试题】为什么要用堆外内存" class="headerlink" title="【面试题】为什么要用堆外内存"></a>【面试题】为什么要用堆外内存</h3><ul>
<li>对GC停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li>
<li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例模式的应用：</span></span><br><span class="line"><span class="comment">// 利用反射获得 Unsafe 类中已经实例化完成的单例对象 theUnsafe.</span></span><br><span class="line">Unsafe unsafe = Unsafe.reflectGetUnsafe();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="keyword">long</span> maddr = unsafe.allocateMemory(<span class="number">1024</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(OutOfMemoryError e)&#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">  <span class="keyword">throw</span> e;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  unsafe.freeMomory(maddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><ul>
<li>实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，在NIO中使用广泛。</li>
<li>对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现</li>
</ul>
<h3 id="内存屏障-Memory-Barrier-组织指令重排序"><a href="#内存屏障-Memory-Barrier-组织指令重排序" class="headerlink" title="内存屏障 Memory Barrier:组织指令重排序"></a>内存屏障 Memory Barrier:组织指令重排序</h3><p>阻止屏障两边的<strong>指令重排序</strong>从而避免编译器和硬件的不正确优化情况</p>
<ul>
<li>屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//内存屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。</p>

    

        <a href="/2023/01/03/面经Java基础/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-面经MySQL问题"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-01-03 00:00:00" datetime="2023-01-02T16:00:00.000Z"  itemprop="datePublished">2023-01-03</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Mysql/">Mysql</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/01/03/面经MySQL问题/">MySQL questions</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h2 id="其他数据库"><a href="#其他数据库" class="headerlink" title="其他数据库"></a>其他数据库</h2><p>mongodb(<a href="https://www.chaojimake.cn/question_8_88.html" target="_blank" rel="noopener">https://www.chaojimake.cn/question_8_88.html</a>)<br>hbase(<a href="https://www.chaojimake.cn/question_8_349.html" target="_blank" rel="noopener">https://www.chaojimake.cn/question_8_349.html</a>)</p>
<h2 id="为什么要分库"><a href="#为什么要分库" class="headerlink" title="为什么要分库"></a>为什么要分库</h2><p>如果业务量剧增，数据库可能会出现性能瓶颈，这时候我们就需要考虑拆分数据库。</p>
<ul>
<li><strong>磁盘存储</strong><br>业务量剧增，MySQL单机磁盘容量会撑爆，拆成多个数据库，磁盘使用率大大降低。</li>
<li><strong>并发连接支撑</strong><br>知道数据库连接数是有限的（150个？）。在高并发的场景下，大量请求访问数据库，MySQL单机是扛不住的！高并发场景下，会出现too many connections报错。</li>
</ul>
<p>当前非常火的微服务架构出现，就是为了应对高并发。它把订单、用户、商品等不同模块，拆分成多个应用，并且把单个数据库也拆分成多个不同功能模块的数据库（订单库、用户库、商品库），以分担读写压力。</p>
<h2 id="为什么要分表"><a href="#为什么要分表" class="headerlink" title="为什么要分表"></a>为什么要分表</h2><p>假如你的单表数据量非常大，存储和查询的性能就会遇到瓶颈了，如果你做了很多优化之后还是无法提升效率的时候，就需要考虑做分表了。一般千万级别数据量，就需要分表。<br>这是因为即使SQL命中了索引，如果表的数据量超过一千万的话，查询也是会明显变慢的。这是因为索引一般是B+树结构，数据千万级别的话，B+树的高度会增高，查询就变慢啦</p>
<h2 id="考虑分库分表的时机"><a href="#考虑分库分表的时机" class="headerlink" title="考虑分库分表的时机"></a>考虑分库分表的时机</h2><p>一般数据量千万级别，B+树索引高度就会到3层以上了，查询的时候会多查磁盘的次数，SQL就会变慢。</p>
<p>阿里巴巴的《Java开发手册》提出：<br><strong>单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表</strong>。<br>那我们是不是等到数据量到达五百万，才开始分库分表呢？<br>不是这样的，我们应该提前规划分库分表，如果估算3年后，你的表都不会到达这个五百万，则不需要分库分表。<br>MySQL服务器如果配置更好，是不是可以超过这个500万这个量级，才考虑分库分表？<br>虽然配置更好，可能数据量大之后，性能还是不错，但是如果持续发展的话，还是要考虑分库分表<br>一般什么类型业务表需要才分库分表？<br>通用是一些流水表、用户表等才考虑分库分表，如果是一些配置类的表，则完全不用考虑，因为不太可能到达这个量级。</p>
<h2 id="如何分库分表？原则有哪些"><a href="#如何分库分表？原则有哪些" class="headerlink" title="如何分库分表？原则有哪些"></a>如何分库分表？原则有哪些</h2><h2 id="数据库垂直切分"><a href="#数据库垂直切分" class="headerlink" title="数据库垂直切分"></a>数据库垂直切分</h2><h2 id="数据库水平切分"><a href="#数据库水平切分" class="headerlink" title="数据库水平切分"></a>数据库水平切分</h2><h2 id="一定规则"><a href="#一定规则" class="headerlink" title="一定规则"></a>一定规则</h2><h2 id="分库分表的取模算法"><a href="#分库分表的取模算法" class="headerlink" title="分库分表的取模算法"></a>分库分表的取模算法</h2><h2 id="分库分表的范围限定算法"><a href="#分库分表的范围限定算法" class="headerlink" title="分库分表的范围限定算法"></a>分库分表的范围限定算法</h2><h2 id="分库后，事务问题如何解决"><a href="#分库后，事务问题如何解决" class="headerlink" title="分库后，事务问题如何解决"></a>分库后，事务问题如何解决</h2><h2 id="分表后，跨节点的join和union问题"><a href="#分表后，跨节点的join和union问题" class="headerlink" title="分表后，跨节点的join和union问题"></a>分表后，跨节点的join和union问题</h2><h2 id="分库分表后，orderby-groupby等聚合函数如何处理"><a href="#分库分表后，orderby-groupby等聚合函数如何处理" class="headerlink" title="分库分表后，orderby groupby等聚合函数如何处理"></a>分库分表后，orderby groupby等聚合函数如何处理</h2><h2 id="分库分表后，分页的处理方案"><a href="#分库分表后，分页的处理方案" class="headerlink" title="分库分表后，分页的处理方案"></a>分库分表后，分页的处理方案</h2><h2 id="如何生成全局唯一的分布式ID"><a href="#如何生成全局唯一的分布式ID" class="headerlink" title="如何生成全局唯一的分布式ID"></a>如何生成全局唯一的分布式ID</h2><h2 id="主流分库分表中间件"><a href="#主流分库分表中间件" class="headerlink" title="主流分库分表中间件"></a>主流分库分表中间件</h2><h2 id="分表要停服吗，不停服怎么做"><a href="#分表要停服吗，不停服怎么做" class="headerlink" title="分表要停服吗，不停服怎么做"></a>分表要停服吗，不停服怎么做</h2><h2 id="为了避免数据热点问题如何选择分表策略"><a href="#为了避免数据热点问题如何选择分表策略" class="headerlink" title="为了避免数据热点问题如何选择分表策略"></a>为了避免数据热点问题如何选择分表策略</h2><h2 id="阐述常用的数据库中间件"><a href="#阐述常用的数据库中间件" class="headerlink" title="阐述常用的数据库中间件"></a>阐述常用的数据库中间件</h2><h1 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h1><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><ul>
<li>int：tinyint(1byte) smallint(2byte)  mediumint(3byte)  int(4byte)  bigint(8byte) </li>
<li>float,double</li>
<li>decimal</li>
</ul>
<p><strong>字符串类型：varchar,char,text,blob</strong> </p>
<ul>
<li>varchar(n):n代表字符个数，不是字节个数</li>
<li>char与varchar的区别<ul>
<li>char定长，var不定长，存储效率较高</li>
<li>varchar在开头两个字节存长度</li>
</ul>
</li>
<li>text 和blob会使用临时表，开销损失大<br>【Tips】经常变更的数据使用char，char不容易产生碎片</li>
</ul>
<p><strong>时间类型</strong></p>
<ul>
<li><p>date</p>
</li>
<li><p>timestamp（优先使用，空间开销小）</p>
<h2 id="3-数据库三大范式-，范式和反范式是什么"><a href="#3-数据库三大范式-，范式和反范式是什么" class="headerlink" title="3. 数据库三大范式 ，范式和反范式是什么"></a>3. 数据库三大范式 ，范式和反范式是什么</h2></li>
<li><p>第一范式（1NF）：每个列都不可以再拆分，强调的是列的原子性。第一范式要求数据库中的表都是二维表。</p>
</li>
<li><p>第二范式（2NF）：在第一范式的基础上，一个表必须有一个主键，非主键列 完全依赖 于主键，而不能是依赖于主键的一部分。</p>
</li>
<li><p>第三范式（3NF）：在第二范式的基础上，非主键列只依赖（直接依赖）于主键，不依赖于其他非主键。</p>
</li>
<li><p><strong>范式</strong>：范式化的表减少了数据冗余，数据表更新操作快、占用存储空间少。    </p>
</li>
<li><p>但是查询时通常需要多表关联查询，更难进行索引优化</p>
</li>
<li><p><strong>反范式</strong>：反范式的过程就是通过冗余数据来提高查询性能，可以减少表关联和更好进行索引优化</p>
</li>
<li><p>存在大量冗余数据，并且数据的维护成本更高</p>
</li>
</ul>
<h1 id="索引问题"><a href="#索引问题" class="headerlink" title="索引问题"></a>索引问题</h1><h2 id="1-索引的分类"><a href="#1-索引的分类" class="headerlink" title="1.索引的分类"></a>1.索引的分类</h2><h2 id="2-索引优缺点"><a href="#2-索引优缺点" class="headerlink" title="2.索引优缺点"></a>2.索引优缺点</h2><h2 id="3-索引设计原则"><a href="#3-索引设计原则" class="headerlink" title="3.索引设计原则"></a>3.索引设计原则</h2><ul>
<li><p>唯一性</p>
</li>
<li><p>选择常用的字段</p>
</li>
<li><p>选用经常排序、分组、联合的字段</p>
</li>
<li><p>小表不建议索引（几万这种不需要，，几十万这种看情况）</p>
<h2 id="4-索引的b-树"><a href="#4-索引的b-树" class="headerlink" title="4.索引的b+树"></a>4.索引的b+树</h2><h2 id="5-hash索引和b-索引的区别"><a href="#5-hash索引和b-索引的区别" class="headerlink" title="5.hash索引和b+索引的区别"></a>5.hash索引和b+索引的区别</h2><h2 id="6-为什么b-树打败了二叉查找树和b树"><a href="#6-为什么b-树打败了二叉查找树和b树" class="headerlink" title="6.为什么b+树打败了二叉查找树和b树"></a>6.为什么b+树打败了二叉查找树和b树</h2><h2 id="7-最左匹配原则"><a href="#7-最左匹配原则" class="headerlink" title="7.最左匹配原则"></a>7.最左匹配原则</h2><h2 id="8-覆盖索引"><a href="#8-覆盖索引" class="headerlink" title="8.覆盖索引"></a>8.覆盖索引</h2><h2 id="9-索引下推"><a href="#9-索引下推" class="headerlink" title="9.索引下推"></a>9.索引下推</h2><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>InnoDB 适用于？<br>MyISAM 适用以插入为主的程序，比如博客系统、新闻门户</p>
<h2 id="1-存储引擎InnoDB的四大特性"><a href="#1-存储引擎InnoDB的四大特性" class="headerlink" title="1.存储引擎InnoDB的四大特性"></a>1.存储引擎InnoDB的四大特性</h2><p>插入缓冲（insert buffer)<br>二次写(double write)<br>自适应哈希索引(ahi)<br>预读(read ahead)</p>
<h2 id="2-MyISAM和InnoDB的区别"><a href="#2-MyISAM和InnoDB的区别" class="headerlink" title="2.MyISAM和InnoDB的区别"></a>2.MyISAM和InnoDB的区别</h2></li>
<li><p>InnoDB 支持事务，而 MyISAM 不支持。</p>
</li>
<li><p>InnoDB 支持外键，而 MyISAM 不支持。因此将一个含有外键的 InnoDB 表 转为 MyISAM 表会失败。</p>
</li>
<li><p>InnoDB 和 MyISAM 均支持 B+ Tree 数据结构的索引。但 InnoDB 是聚集索引，而 MyISAM 是非聚集索引。</p>
</li>
<li><p>InnoDB 不保存表中数据行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量记录了整个表的行数，速度相当快（注意不能有 WHERE 子句）。</p>
</li>
</ul>
<p><strong>那为什么 InnoDB 没有使用这样的变量呢</strong> 因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的。</p>
<ul>
<li><p>InnoDB 支持表、行（默认）级锁，而 MyISAM 支持表级锁。<br>InnoDB 的行锁是基于索引实现的，而不是物理行记录上。即访问如果没有命中索引，则也无法使用行锁，将要退化为表锁。</p>
</li>
<li><p>InnoDB 必须有唯一索引（如主键），如果没有指定，就会自动寻找或生产一个隐藏列 Row_id 来充当默认主键，而 Myisam 可以没有主键。</p>
<h2 id="3-为何推荐使用自增主键"><a href="#3-为何推荐使用自增主键" class="headerlink" title="3.为何推荐使用自增主键"></a>3.为何推荐使用自增主键</h2><p>自增 ID 可以保证每次插入时 B+ 树索引是从右边扩展的，因此相比自定义 ID （如 UUID）可以避免 B+ 树的频繁合并和分裂。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p>
<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><h2 id="1-页Page，区Extend，段Segment"><a href="#1-页Page，区Extend，段Segment" class="headerlink" title="1.页Page，区Extend，段Segment"></a>1.页Page，区Extend，段Segment</h2></li>
</ul>
<p><strong>页（数据页）：InnoDB中每个页16KB，Myisam是1KB</strong></p>
<h3 id="一行数据大于16kb，会发生什么，怎么解决【行溢出问题】"><a href="#一行数据大于16kb，会发生什么，怎么解决【行溢出问题】" class="headerlink" title="一行数据大于16kb，会发生什么，怎么解决【行溢出问题】"></a>一行数据大于16kb，会发生什么，怎么解决【行溢出问题】</h3><p>内置的解决方式：将溢出的数据存到新页里，然后原始页里存放一个指针，需要额外一次IO去读取</p>
<p>聚簇索引情况：</p>
<ul>
<li>如果表使用了聚簇索引（InnoDB的主键索引就是一个聚簇索引），那么数据行实际上是存储在聚簇索引的叶子节点中的。如果一行数据超出了页的大小，那么会发生行溢出，溢出部分会存储在一个溢出页中，而叶子节点中仍然包含原始行的数据和指向溢出页的指针。</li>
</ul>
<p>非聚簇索引情况：</p>
<ul>
<li>如果表使用了非聚簇索引（如普通索引），那么数据行是单独存储在聚簇索引的叶子节点之外的，这种情况下，如果一行数据超出了页的大小，会直接发生行溢出，溢出部分会存储在溢出页中，同时非聚簇索引中也会保留指向溢出页的指针。</li>
</ul>
<p><strong>区Extent：一个区默认是 64 个连续的页组成的，也就是 1MB</strong></p>
<p><strong>段Segment：一段相邻的区的集合，逻辑上的组织，存放b+树</strong></p>
<h2 id="2-页由哪些数据组成"><a href="#2-页由哪些数据组成" class="headerlink" title="2.页由哪些数据组成"></a>2.页由哪些数据组成</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/mysqlpagestructure.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>file header:用于描述数据页的外部信息，比如属于哪一个表空间、前后页的页号等</li>
<li>page header:用来描述数据页中的具体信息，比如存在多少条纪录，第一条纪录的位置等。</li>
<li>infimum 和 supremum 纪录:是系统生成的纪录，分别为最小和最大纪录值，infimum 的下一条是用户纪录中键值最小的纪录，supremum 的上一条是用户纪录中键值最大的纪录，通过 next_record 字段来相连。</li>
<li>user records:据库表中对应的数据(Compact行格式)</li>
<li>free space 可插入的空闲区域</li>
<li>page dictionary：类似于字典的目录结构，根据主键大小，每隔 4-8 个纪录设置一个槽，用来纪录其位置，当根据主键查找数据时，首先一步到位找到数据所在的槽，然后在槽中线性搜素。这种方法比从前到后遍历页的链表的效率更快。</li>
<li>File Header：存储刷盘前内存的校验和，Page Tailer储存刷盘后的校验和。当刷盘的时候，出现异常，Page Tailer和File Header中的校验和不一致，则说明出现刷盘错误。</li>
</ul>
<h2 id="3-页插入记录的过程"><a href="#3-页插入记录的过程" class="headerlink" title="3.页插入记录的过程"></a>3.页插入记录的过程</h2><p>1）如果 Free Space 的空间足够的话，直接分配空间来添加纪录，并将插入前最后一条纪录的 next_record 指向当前插入的纪录，将当前插入纪录的 next_record 指向 supremum 纪录。</p>
<p>2）如果 Free Space的 空间不够的话，则首先将之前删除造成的碎片重新整理之后，按照上述步骤插入纪录。</p>
<p>3）如果当前页空间整理碎片之后仍然不足的话，则重新申请一个页，将页初始化之后，按照上述步骤插入纪录</p>
<h2 id="4-bufferPool"><a href="#4-bufferPool" class="headerlink" title="4.bufferPool"></a>4.bufferPool</h2><p>Buffer Pool 是 InnoDB 存储引擎层的缓冲池，不属于 MySQL 的 Server 层，注意跟 8.0 删掉的“查询缓存”功能区分。</p>
<p>内存中以页（page）为单位缓存磁盘数据，减少磁盘IO，提升访问速度。缓冲池大小默认 128M，独立的 MySQL 服务器推荐设置缓冲池大小为总内存的 80%。主要存储数据页、索引页更新缓冲（change buffer）等。</p>
<h2 id="5-change-buffer"><a href="#5-change-buffer" class="headerlink" title="5.change buffer"></a>5.change buffer</h2><p>​如果每次写操作，数据库都直接更新磁盘中的数据，会很占磁盘IO。为了减少磁盘IO，InnoDB在Buffer Pool中开辟了一块内存，用来存储变更记录，为了防止异常宕机丢失缓存，当事务提交时会将变更记录持久化到磁盘（redo log），等待时机更新磁盘的数据文件（刷脏），用来缓存写操作的内存，就是Change Buffer</p>
<p>Change Buffer默认占Buffer Pool的25%，最大设置占用50%。</p>
<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h2 id="1-架构设计【内存、线程】"><a href="#1-架构设计【内存、线程】" class="headerlink" title="1.架构设计【内存、线程】"></a>1.架构设计【内存、线程】</h2><ul>
<li>内存数据区域划分<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/Innodbmem.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure></li>
<li>四大线程<ul>
<li>Master thread</li>
<li>IO thread</li>
<li>Purge thread</li>
<li>Page Cleaner Thread</li>
</ul>
</li>
</ul>
<p>1）负责刷新内存池中的数据，保证缓冲池的内存缓冲的是最近的数据</p>
<p>2）已修改的数据文件刷新到磁盘文件</p>
<p>3）保证数据库发生异常的情况下InnoDB能恢复到正常状态</p>
<h2 id="2-InnoDB有哪些线程"><a href="#2-InnoDB有哪些线程" class="headerlink" title="2.InnoDB有哪些线程"></a>2.InnoDB有哪些线程</h2><ul>
<li>Master Thread</li>
</ul>
<p>负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲（INSERT BUFFER），UNDO页的回收等。</p>
<ul>
<li>IO Thread</li>
</ul>
<p>负责 AIO 请求的回调处理。</p>
<ul>
<li>Purge Thread</li>
</ul>
<p>事务提交后，undo log 可能不再需要，由 Purge Thread 负责回收并重新分配的这些已经使用的 undo 页。</p>
<ul>
<li>Page Cleaner Thread</li>
</ul>
<p>将Master Threader中刷新脏页的工作移至该线程，如上面说的FLUSH LRU LIST Checkpoint以及Async/Sync Flush Checkpoint。</p>
<h2 id="3-double-writer是什么"><a href="#3-double-writer是什么" class="headerlink" title="3.double writer是什么"></a>3.double writer是什么</h2><h2 id="4-自适应hash是什么"><a href="#4-自适应hash是什么" class="headerlink" title="4. 自适应hash是什么"></a>4. 自适应hash是什么</h2><p>InnoDB 会监控对表上各索引页的查询执行情况，如发现建立哈希索引可以提升速度，则建立哈希索引，这是过程不需要用户干预。（默认开启）</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1.什么是事务"></a>1.什么是事务</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p>
<h2 id="2-什么是事务的四大特性ACID"><a href="#2-什么是事务的四大特性ACID" class="headerlink" title="2.什么是事务的四大特性ACID"></a>2.什么是事务的四大特性ACID</h2><h2 id="3-事务的并发问题【带来脏读、不可重复度、幻读问题】"><a href="#3-事务的并发问题【带来脏读、不可重复度、幻读问题】" class="headerlink" title="3.事务的并发问题【带来脏读、不可重复度、幻读问题】"></a>3.事务的并发问题【带来脏读、不可重复度、幻读问题】</h2><h2 id="5-事务的隔离级别"><a href="#5-事务的隔离级别" class="headerlink" title="5.事务的隔离级别"></a>5.事务的隔离级别</h2><p>串行化<br>可重复度（Innodb默认）<br>读已提交<br>读未提交</p>
<h2 id="6-ACID的特性如何实现"><a href="#6-ACID的特性如何实现" class="headerlink" title="6.ACID的特性如何实现"></a>6.ACID的特性如何实现</h2><p>原子性是 undo 日志<br>持久性是 redo 日志</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="1-数据库锁的特性，有哪些锁"><a href="#1-数据库锁的特性，有哪些锁" class="headerlink" title="1.数据库锁的特性，有哪些锁"></a>1.数据库锁的特性，有哪些锁</h2><ul>
<li>行锁，表锁，页锁</li>
<li>共享锁=读锁S，排他锁=写锁X，更新锁U锁</li>
<li>乐观锁，悲观锁<h2 id="2-隔离级别和锁的关系"><a href="#2-隔离级别和锁的关系" class="headerlink" title="2.隔离级别和锁的关系"></a>2.隔离级别和锁的关系</h2></li>
<li><h2 id="3-InnoDB的锁算法"><a href="#3-InnoDB的锁算法" class="headerlink" title="3.InnoDB的锁算法"></a>3.InnoDB的锁算法</h2><h2 id="4-快照读和当前读"><a href="#4-快照读和当前读" class="headerlink" title="4.快照读和当前读"></a>4.快照读和当前读</h2><h2 id="5-innodb的可重复度如何实现"><a href="#5-innodb的可重复度如何实现" class="headerlink" title="5.innodb的可重复度如何实现"></a>5.innodb的可重复度如何实现</h2>通过MVCC实现，为每个事务维护一个独立版本视图，执行期间保持一致性。<h2 id="6-MVCC以及实现（乐观锁）"><a href="#6-MVCC以及实现（乐观锁）" class="headerlink" title="6.MVCC以及实现（乐观锁）"></a>6.MVCC以及实现（乐观锁）</h2>MVCC 的基本思想是为每个事务创建一个独立的版本视图，以便在事务执行期间保持数据的一致性。它通过在修改数据时不覆盖原有的数据，而是为每个事务创建一个新的版本来实现。</li>
</ul>
<ol>
<li>每行数据保存一个版本号/时间戳</li>
<li>当一个事务对某行数据进行修改时，不会直接修改原始数据，而是会在数据库中创建一个新的版本，并将原始版本的数据保留下来</li>
<li>查询时，根据版本号<h2 id="7-mysql优化手段有哪些"><a href="#7-mysql优化手段有哪些" class="headerlink" title="7. mysql优化手段有哪些"></a>7. mysql优化手段有哪些</h2></li>
<li>给常用字段索引</li>
<li>避免使用select *，避免全表扫描</li>
<li>分表，分区，拆分子表</li>
<li>使用覆盖索引：索引覆盖是指查询的列都包含在索引中，而无需再去访问表本身，可以减少IO和提高查询性能。<strong>不适合频繁变更的表和列</strong></li>
<li>redis缓存分担压力</li>
<li>连接池等<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="1-mysql的常见日志"><a href="#1-mysql的常见日志" class="headerlink" title="1.mysql的常见日志"></a>1.mysql的常见日志</h2></li>
</ol>
<h2 id="2-主从复制的作用"><a href="#2-主从复制的作用" class="headerlink" title="2.主从复制的作用"></a>2.主从复制的作用</h2><h2 id="3-主从复制的架构"><a href="#3-主从复制的架构" class="headerlink" title="3.主从复制的架构"></a>3.主从复制的架构</h2><h2 id="4-主从复制的原理"><a href="#4-主从复制的原理" class="headerlink" title="4.主从复制的原理"></a>4.主从复制的原理</h2><h2 id="5-主从复制的异步复制和半同步"><a href="#5-主从复制的异步复制和半同步" class="headerlink" title="5.主从复制的异步复制和半同步"></a>5.主从复制的异步复制和半同步</h2><h2 id="6-主从的常见问题和解决方式"><a href="#6-主从的常见问题和解决方式" class="headerlink" title="6.主从的常见问题和解决方式"></a>6.主从的常见问题和解决方式</h2><p>主从延迟问题，不一致性问题<br><a href="https://zhuanlan.zhihu.com/p/642614348" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/642614348</a></p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="1-Where和Having的区别"><a href="#1-Where和Having的区别" class="headerlink" title="1.Where和Having的区别"></a>1.Where和Having的区别</h2><h2 id="2-In-和-Exists的区别"><a href="#2-In-和-Exists的区别" class="headerlink" title="2.In 和 Exists的区别"></a>2.In 和 Exists的区别</h2><h2 id="3-Union和Union-ALL的区别"><a href="#3-Union和Union-ALL的区别" class="headerlink" title="3. Union和Union ALL的区别"></a>3. Union和Union ALL的区别</h2><h2 id="4-Drop-Delete-Truncate的区别"><a href="#4-Drop-Delete-Truncate的区别" class="headerlink" title="4. Drop Delete Truncate的区别"></a>4. Drop Delete Truncate的区别</h2><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="1-如何判断是否走了索引"><a href="#1-如何判断是否走了索引" class="headerlink" title="1. 如何判断是否走了索引"></a>1. 如何判断是否走了索引</h2><h2 id="2-索引失效的几种情况"><a href="#2-索引失效的几种情况" class="headerlink" title="2. 索引失效的几种情况"></a>2. 索引失效的几种情况</h2><h2 id="3-where子句如何优化"><a href="#3-where子句如何优化" class="headerlink" title="3. where子句如何优化"></a>3. where子句如何优化</h2><h2 id="4-超大分页和深度分页"><a href="#4-超大分页和深度分页" class="headerlink" title="4. 超大分页和深度分页"></a>4. 超大分页和深度分页</h2><h2 id="5-大表查询如何优化"><a href="#5-大表查询如何优化" class="headerlink" title="5. 大表查询如何优化"></a>5. 大表查询如何优化</h2><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="1-存储过程（procedure）和函数的区别"><a href="#1-存储过程（procedure）和函数的区别" class="headerlink" title="1.存储过程（procedure）和函数的区别"></a>1.存储过程（procedure）和函数的区别</h2><h2 id="2-视图是什么"><a href="#2-视图是什么" class="headerlink" title="2.视图是什么"></a>2.视图是什么</h2><h2 id="3-Trigger是什么"><a href="#3-Trigger是什么" class="headerlink" title="3.Trigger是什么"></a>3.Trigger是什么</h2><h2 id="sql优化的经验"><a href="#sql优化的经验" class="headerlink" title="sql优化的经验"></a>sql优化的经验</h2><ol>
<li>查询字段不使用函数或者大于等于表达式</li>
<li>避免where中的不等于，大于小于，null等</li>
<li>使用between and 替代in</li>
<li>当操作字段规模大的时候，拆分delete和insert语句</li>
<li>查询时使用索引的最左前缀原则</li>
</ol>
<h2 id="使用-union-和-union-all-时需要注意些什么"><a href="#使用-union-和-union-all-时需要注意些什么" class="headerlink" title="使用 union 和 union all 时需要注意些什么?"></a>使用 union 和 union all 时需要注意些什么?</h2><p>通过 union 连接的 SQL 分别单独取出的列数必须相同。 使用 union 时，多个相等的行将会被合并，由<br>于合升比较耗时，一般不直接使 用 union 进行合并，而是通常采用 union all 进行合并。</p>

    

        <a href="/2023/01/03/面经MySQL问题/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-面经MySQL"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-01-03 00:00:00" datetime="2023-01-02T16:00:00.000Z"  itemprop="datePublished">2023-01-03</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Mysql/">Mysql</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/01/03/面经MySQL/">MySQL</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="mysql分为哪些层，各用来干嘛的"><a href="#mysql分为哪些层，各用来干嘛的" class="headerlink" title="mysql分为哪些层，各用来干嘛的"></a>mysql分为哪些层，各用来干嘛的</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/mysql查询流程.png.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>mysql架构共分为两层：Server 层和存储引擎层</li>
<li>Server 层负责建立连接、分析和执行 SQL</li>
<li>存储引擎层负责数据的存储和提取<h2 id="mysql基于什么协议传输"><a href="#mysql基于什么协议传输" class="headerlink" title="mysql基于什么协议传输"></a>mysql基于什么协议传输</h2>TCP。<br>三次握手建立后，连接器验证用户名和密码。</li>
</ul>
<p><strong>连接器作用</strong></p>
<ul>
<li>TCP三次握手</li>
<li>校检用户名密码，返回用户权限</li>
</ul>
<p><strong>查询缓存作用</strong></p>
<ul>
<li>select语句输入，执行，先去查询缓存中找，查询缓存中存的是之前执行过的sql语句，以key-value保存的，底层数据结构为哈希表。</li>
<li>8.0.3后移除了这一层，在一些问题，包括性能问题、锁的竞争问题以及难以扩展。</li>
</ul>
<p><strong>解析器作用</strong></p>
<ul>
<li><code>词法分析-语法分析-语法树</code>结构</li>
<li>词法分析（Lexical Analysis）</li>
<li>语法分析（Syntax Analysis）语法分析器会将其转化为一个抽象语法树（<strong>AST</strong>）</li>
<li><strong>AST</strong>的作用：编译器或解释器用来理解代码含义的数据结构，它可以被后续的步骤用来进行语义分析、优化和生成目标代码等。</li>
<li>【查询优化】：对AST进行查询优化，选择合适的索引和决定连接顺序</li>
</ul>
<h2 id="【面试题】执行一条-SQL-查询语句，期间发生了什么？"><a href="#【面试题】执行一条-SQL-查询语句，期间发生了什么？" class="headerlink" title="【面试题】执行一条 SQL 查询语句，期间发生了什么？"></a>【面试题】执行一条 SQL 查询语句，期间发生了什么？</h2><ul>
<li>连接器：建立连接，管理连接、校验用户身份；</li>
<li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li>
<li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li>
<li>执行 SQL：执行 SQL 共有三个阶段：</li>
<li>prepare 预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li>
<li>optimize 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>execute 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
<h2 id="如何查看我的sql被几个客户端链接了"><a href="#如何查看我的sql被几个客户端链接了" class="headerlink" title="如何查看我的sql被几个客户端链接了"></a>如何查看我的sql被几个客户端链接了</h2><p>show processlist;会有ID user host等字段</p>
<h2 id="mysql推荐使用长链接，但会产生的问题："><a href="#mysql推荐使用长链接，但会产生的问题：" class="headerlink" title="mysql推荐使用长链接，但会产生的问题："></a>mysql推荐使用长链接，但会产生的问题：</h2><p>随着长连接一直不释放，内存占用大。【解决方式】定期释放，主动重置连接mysql_reset_connection()</p>
<h2 id="MYSQL的数据存储方式"><a href="#MYSQL的数据存储方式" class="headerlink" title="MYSQL的数据存储方式"></a>MYSQL的数据存储方式</h2><ol>
<li>show variable like ‘datadir’; 可以查找mysql的文件在哪<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.opt  用来存储当前数据库的默认字符集和字符校验规则。</span><br><span class="line">t_order.frm  存放表结构，在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</span><br><span class="line">t_order.ibd  存放表数据。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="表空间文件的结构"><a href="#表空间文件的结构" class="headerlink" title="表空间文件的结构"></a>表空间文件的结构</h3><p>表空间由段（segment）、区（extent）、页（page）、行（row）组成</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/mysqltablestructure.drawio.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>表中的数据在Page里，数据是按「页」为单位来读写的，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。</li>
<li>默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间</li>
</ul>
<p><strong>按区分配空间的情况</strong></p>
<ul>
<li>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了。</li>
</ul>
<p><strong>段一般分为数据段、索引段和回滚段等。</strong></p>
<ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合，之前讲事务隔离 (opens new window)的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。<h2 id="Innodb的行格式"><a href="#Innodb的行格式" class="headerlink" title="Innodb的行格式"></a>Innodb的行格式</h2>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</li>
</ul>
<p><strong>COMPACT 行格式</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/COMPACT.drawio.png.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li><p>数据类型：char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p>
</li>
<li><p>row_id：<br>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p>
</li>
<li><p>trx_id：<br>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p>
</li>
<li><p>roll_pointer：<br>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节</p>
</li>
<li><p>NULL值列表：用位图存储的。压缩行存储通过一种称为”Dynamic Prefix”的技术，动态地存储每一行的前缀信息和 NULL 列的位图。这使得它可以更加高效地存储具有大量 NULL 列的行。</p>
<h1 id="mysql读取时的几个情况"><a href="#mysql读取时的几个情况" class="headerlink" title="mysql读取时的几个情况"></a>mysql读取时的几个情况</h1></li>
<li><p>脏读：读到其他事务未提交的数据；</p>
</li>
<li><p>不可重复读：前后读取的数据不一致；</p>
</li>
<li><p>幻读：前后读取的记录数量不一致。</p>
</li>
</ul>
<p><strong>脏读</strong>: A事务读取到了B事务未提交的内容,而B事务后面进行了回滚. </p>
<p><strong>不可重复读</strong>: 当设置A事务只能读取B事务已经提交的部分,会造成在A事务内的两次查询,结果竟然不一样,因为在此期间B事务进行了提交操作. </p>
<p><strong>幻读</strong>: A事务读取了一个范围的内容,而同时B事务在此期间插入了一条数据.造成”幻觉”. </p>
<h1 id="MySQL什么情况下索引会失效"><a href="#MySQL什么情况下索引会失效" class="headerlink" title="MySQL什么情况下索引会失效"></a>MySQL什么情况下索引会失效</h1><ol>
<li>组合索引时，如果查询条件没有使用最左边的字段，就不会使用索引</li>
<li>like进行匹配时，如果字符串前面含有%百分号，就会全表扫描时，不使用索引，</li>
<li>还有一种情况，是如果查询条件中类型是字符串，没有引号，发生了隐式转换就不会使用索引</li>
<li>对索引列进行运算</li>
<li>判断索引列是否不等于某个值时</li>
<li>查询条件使用or连接，也会导致索引失效</li>
</ol>
<h1 id="mysql四种隔离级别"><a href="#mysql四种隔离级别" class="headerlink" title="mysql四种隔离级别"></a>mysql四种隔离级别</h1><ol>
<li>Serializable (串行化) :可避免脏读、不可重复读、幻读的发生。 </li>
<li>Repeatable read (可重复读) :可避免脏读、不可重复读的发生。 </li>
<li>Read committed (读已提交) :可避免脏读的发生。</li>
<li>Read uncommitted (读未提交) :最低级别，任何情况都无法保证。 </li>
</ol>
<p>SQL查看隔离级别：</p>
<figure class="highlight plain"><figcaption><span>@@transaction_isolation;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">设置隔离级别：</span><br><span class="line">```set session transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure>

<h2 id="生产环境数据库一般用的什么隔离级别呢？"><a href="#生产环境数据库一般用的什么隔离级别呢？" class="headerlink" title="生产环境数据库一般用的什么隔离级别呢？"></a>生产环境数据库一般用的什么隔离级别呢？</h2><p>生产环境大多使用RC(读已提交)，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">缘由一：在可重复读RR隔离级别下，存在**间隙锁**，导致出现死锁的几率比RC大的多！ </span><br><span class="line">缘由二：在RR隔离级别下，条件列未命中索引会锁表！而在RC隔离级别下，只锁行!</span><br></pre></td></tr></table></figure>

<p>InnoDB的默认隔离级别：可重复读，不能避免幻读<br>多版本并发控制协议MVCC(Multi- Version Concurrency Control) </p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h2><p>索引是存储引擎用于提高数据库表的访问速度的一种数据结构。它可以比作一本字典的目录，可以帮你快速找到对应的记录。<br>索引一般存储在磁盘的文件中，它是占用物理空间的。</p>
<h2 id="索引的分类（按字段特性）"><a href="#索引的分类（按字段特性）" class="headerlink" title="索引的分类（按字段特性）"></a>索引的分类（按字段特性）</h2><ol>
<li>主键索引：primary key，在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A(</span><br><span class="line">    x <span class="built_in">int</span> primary <span class="keyword">key</span>, </span><br><span class="line">    //或</span><br><span class="line">    x <span class="built_in">int</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(x) <span class="keyword">using</span> BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>建表后，创建主键索引<br><code>CREATE INDEX a ON tableA(a);</code><br>再将其添加主键约束<br><code>ALTER TABLE tableA ADD CONTRAINT id PRIMARY KEY</code></p>
<p>如果仅改一个主键<code>ALTER TABLE tableA ADD PRIMARY KEY(a)</code></p>
<ol start="2">
<li>唯一索引：unique key建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，<strong>索引列的值必须唯一，但是允许有空值</strong>。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> A&#123;</span><br><span class="line">    x <span class="built_in">int</span> <span class="keyword">unique</span> <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">key</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>建表后，创建唯一索引<code>create UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...);</code></li>
</ul>
<ol start="3">
<li><p>普通索引/二级索引:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx <span class="keyword">on</span> tableA(a,b,x,y);</span><br></pre></td></tr></table></figure>
</li>
<li><p>前缀索引: 对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tableA(</span><br><span class="line">    a <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">INDEX</span>(a(<span class="number">10</span>))//字符串前<span class="number">10</span>个字符匹配。</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="【面试考点】联合索引如何使用的"><a href="#【面试考点】联合索引如何使用的" class="headerlink" title="【面试考点】联合索引如何使用的"></a>【面试考点】联合索引如何使用的</h3><ol>
<li>联合索引范围查询</li>
</ol>
<p>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。</p>
<p>【例子】</p>
<figure class="highlight plain"><figcaption><span>* from  tableA where a> 10 and b</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">```select * from  tableA where a&gt;= 10 and b=2;```的区别：</span><br><span class="line">a都用了索引，一个没用，一个用了。因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序</span><br><span class="line">   </span><br><span class="line">## 索引的优缺点？</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line">- 加快数据查找的速度</span><br><span class="line">- 为用来排序或者是分组的字段添加索引，可以加快分组和排序的速度</span><br><span class="line">- 加快表与表之间的连接</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line">- 建立索引需要占用物理空间</span><br><span class="line">- 会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行动态维护索引，导致增删改时间变长</span><br><span class="line">## 什么情况下需要建索引？</span><br><span class="line"></span><br><span class="line">- 经常**用于查询**的字段</span><br><span class="line">- 经常**用于连接**的字段建立索引，可以加快连接的速度</span><br><span class="line">- 经常**需要排序**的字段建立索引，因为索引已经排好序，可以加快排序查询速度</span><br><span class="line"></span><br><span class="line">## 什么情况下不建索引？</span><br><span class="line"></span><br><span class="line">- where条件中用不到的字段不适合建立索引</span><br><span class="line">- 表记录较少。比如只有几百条数据，没必要加索引。</span><br><span class="line">- 需要经常增删改。需要评估是否适合加索引</span><br><span class="line">- 参与列计算的列不适合建索引</span><br><span class="line">- 区分度不高的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。</span><br><span class="line"></span><br><span class="line">## 哈希索引</span><br><span class="line">哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是O(1)，一般多用于精确查找。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 【面试题】InnoDB为什么用B+树做索引</span><br><span class="line">从数据结构和考虑磁盘 I/O 操作次数回答</span><br><span class="line">![](/images/innodbb%2Btree.webp)</span><br><span class="line">因为B+树可以实现**有序存放**和**减少磁盘IO**</span><br><span class="line">知识点：</span><br><span class="line">1. 适合范围查找：普通二分查找树</span><br><span class="line">   由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（假设一个节点的大小「小于」操作系统的最小读写单位块的大小），也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。</span><br><span class="line">2.  在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</span><br><span class="line"></span><br><span class="line">### 【再问】为什么不用B树</span><br><span class="line">B树和B+的时间复杂度查找都是O(logN)，但是B 树可能会因为树的分支过多，导致需要进行多次磁盘访问。并且B+支持多级索引，很容易扩展。</span><br><span class="line">- 更适合磁盘存储：</span><br></pre></td></tr></table></figure>

<p>B+ 树的叶子节点形成了一个有序链表，这使得范围查询的效率非常高，因为相邻的元素会被存储在相邻的位置，可以在一个或者很少几个相邻的节点中找到所有需要的数据。<br>B+ 树的叶子节点包含了所有的数据记录，这意味着每次查找都可以直接定位到具体的数据行，而不需要额外的中间层节点来获取实际数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 支持多级索引</span><br><span class="line"></span><br><span class="line">B+ 树可以很容易地扩展为多级索引。在多级索引中，每一层都是一个独立的 B+ 树，它们之间通过指针进行连接。这样的设计使得在大量数据的情况下也可以保持高效的检索速度。</span><br></pre></td></tr></table></figure>

<p>举例来说，假设我们有一个三级索引 (a, b, c)，那么：<br>第一级索引以 a 为键构建一颗 B+ 树，每个节点中存储 b 的值以及指向第二级索引的指针。<br>第二级索引以 b 为键构建一颗 B+ 树，每个节点中存储 c 的值以及指向第三级索引的指针。<br>第三级索引以 c 为键构建一颗 B+ 树，叶子节点中存储了对应的数据记录。<br>这样的设计使得在多级索引中，每一层都能帮助缩小搜索范围，从而提高查询效</p>
<p>其中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">## 为什么B+ 和 B树</span><br><span class="line">- 从存储情况来说，B+只有叶子村数据，B树所有节点都有数据，这样就增加了磁盘IO次数</span><br><span class="line">- B+ 的非叶子结点仅有关键字，适合搜索</span><br><span class="line"></span><br><span class="line">B 树的内部节点既包含关键字也包含指向实际数据的指针，而 B+ 树的内部节点仅包含关键字，实际数据只存储在叶子节点中。这使得 B+ 树在磁盘存储和范围查询等方面具有优势，适合作为数据库索引的数据结构</span><br><span class="line"></span><br><span class="line">## 【面试】 索引失效的情况</span><br><span class="line">- 左/左右模糊匹配`like %a`</span><br><span class="line">- 使用函数，但是8.0之后出现了函数索引</span><br><span class="line">- 表达式计算</span><br><span class="line">- 隐式类型转换，比如name是varchar，查询时使用`select 8 from A where name=11111;`</span><br><span class="line">- 联合索引的非**最左匹配**：</span><br><span class="line">- WHERE 里面的 OR操作，导致全表扫描：OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，解决办法将其都加上索引。</span><br><span class="line">## 【面试题】索引下推是什么，回表是什么</span><br><span class="line">- **explain会显示Extra字段为using index condition，表示使用了索引下推**</span><br><span class="line">- 回表也叫二次查询，指在数据库中执行一个查询，如果查询的字段不在查询的索引中，数据库可能需要通过索引定位到相应的行，然后再去实际的数据页中获取所需的字段值，这个过程就被称为回表。</span><br><span class="line">以索引举例，查了两个索引，那么就是先根据第一个索引找到符合要求的值，然后在这些行里用第二个索引进行过滤。</span><br><span class="line"></span><br><span class="line">截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 (a, b, c) 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</span><br><span class="line"></span><br><span class="line">## 【面试】最左匹配的一个问题：当where a=1 and c=3时，符合最左匹配吗</span><br><span class="line">答案：符合最左，只有a用了索引，c字段没使用</span><br><span class="line">严格意义上来说是属于索引截断。</span><br><span class="line"></span><br><span class="line">- MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。</span><br><span class="line">- 从 MySQL 5.6 之后，有一个索引下推功能，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</span><br><span class="line">## 【面试】讲一下回表和索引下推的区别</span><br><span class="line">- **表是先通过索引查询行，再访问数据行涉及到两次磁盘访问**</span><br><span class="line">- **先在索引上执行一部分或全部的查询条件，大大减少磁盘访问次数**</span><br><span class="line"></span><br><span class="line">**表（Lookup）：**</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">回表是指在使用索引定位到符合查询条件的行后，再次访问实际的数据行，从中获取所需的字段值的过程。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">使用索引定位到符合查询条件的行的位置。</span><br><span class="line">从定位到的位置中读取行的指针或主键。</span><br><span class="line">使用指针或主键再次访问实际的数据行，从中获取所需的字段值。</span><br><span class="line"></span><br><span class="line">代价：</span><br><span class="line">回表的代价相对较高，因为它涉及了两次磁盘/内存访问。</span><br><span class="line"></span><br><span class="line">**索引下推（Index Pushdown）：**</span><br><span class="line"></span><br><span class="line">定义：</span><br><span class="line">索引下推是指在查询执行过程中，数据库管理系统会尝试在索引上执行部分或全部的查询条件，从而减少需要访问实际数据行的次数。</span><br><span class="line"></span><br><span class="line">过程：</span><br><span class="line">当查询中的条件可以在索引中找到匹配项时，数据库会尝试在索引上执行这部分查询条件，以过滤掉不符合条件的行。 只有符合索引条件的行才会被返回给用户。</span><br><span class="line"></span><br><span class="line">优势：</span><br><span class="line">减少了回表的次数，降低了查询的代价，提高了查询的性能。</span><br><span class="line">减少了磁盘/内存访问次数，尤其在大型数据集中，效果显著。</span><br><span class="line"></span><br><span class="line">适用情况：</span><br><span class="line">索引下推通常在涉及到范围查询、排序、聚合等操作时可以发挥较大的优化作用。</span><br><span class="line"></span><br><span class="line">## Hash索引和B+树索引的区别？</span><br><span class="line"></span><br><span class="line">哈希索引**不支持排序**，因为哈希表是无序的。</span><br><span class="line">哈希索引**不支持范围查找**。</span><br><span class="line">哈希索引**不支持模糊查询**及组合索引的最左前缀匹配。</span><br><span class="line">因为哈希表中会存在哈希冲突，所以哈希索引的性能是**不稳定**的，</span><br><span class="line">而B+树索引的性能是**相对稳定的**，每次查询都是从根节点到叶子节点。</span><br><span class="line"></span><br><span class="line">## 为什么B+树比B树更适合实现数据库索引？</span><br><span class="line"></span><br><span class="line">- 由于B+树的数据都存储在叶子结点中，叶子结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，而在数据库中基于范围的查询是非常频繁的，所以通常B+树用于数据库索引。</span><br><span class="line"></span><br><span class="line">B+树的节点只存储索引key值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的I/O支出。</span><br><span class="line"></span><br><span class="line">B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当</span><br><span class="line"></span><br><span class="line">## 什么是覆盖索引？</span><br><span class="line"></span><br><span class="line">select的数据列只用从索引中就能够取得，不需要回表进行二次查询，也就是说查询列要被所使用的索引覆盖。对于innodb表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。</span><br><span class="line"></span><br><span class="line">不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。</span><br><span class="line"></span><br><span class="line">对于使用了覆盖索引的查询，在查询前面使用explain，输出的extra列会显示为using index。</span><br><span class="line"></span><br><span class="line">比如user_like 用户点赞表，组合索引为(user_id, blog_id)，user_id和blog_id都不为null。</span><br><span class="line"></span><br><span class="line">```explain select blog_id from user_like where user_id = 13;</span><br></pre></td></tr></table></figure>

<p>explain结果的Extra列为Using index，查询的列被索引覆盖，并且where筛选条件符合最左前缀原则，通过索引查找就能直接找到符合条件的数据，不需要回表查询数据。</p>
<figure class="highlight plain"><figcaption><span>select user_id from user_like where blog_id </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">explain结果的Extra列为Using where; Using index， 查询的列被索引覆盖，where筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过索引扫描找到符合条件的数据，也不需要回表查询数据。</span><br><span class="line"></span><br><span class="line"># 数据库引擎</span><br><span class="line">## InnoDB存储引擎</span><br><span class="line"></span><br><span class="line">InnoDB是MySQL默认的事务型存储引擎，使用最广泛，基于**聚簇索引**建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。</span><br><span class="line"></span><br><span class="line">**优点**：支持事务和崩溃修复能力；引入了行级锁和外键约束。</span><br><span class="line"></span><br><span class="line">**缺点**：占用的数据空间相对较大。</span><br><span class="line"></span><br><span class="line">**适用场景**：需要事务支持，并且有较高的并发读写频率。</span><br><span class="line">### 什么是聚集索引？</span><br><span class="line"></span><br><span class="line">InnoDB使用**表的主键构造主键索引树**，同时叶子节点中存放的即为整张表的记录数据。聚集索引叶子节点的存储是逻辑上连续的，使用双向链表连接，叶子节点按照主键的顺序排序，因此对于主键的排序查找和范围查找速度比较快。</span><br><span class="line"></span><br><span class="line">聚集索引的叶子节点就是整张表的行记录。InnoDB 主键使用的是聚簇索引。聚集索引要比非聚集索引查询效率高很多。</span><br><span class="line"></span><br><span class="line">对于InnoDB来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为NULL的唯一索引。如果没有主键也没有合适的唯一索引，那么InnoDB内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为6个字节，它的值会随着数据的插入自增。</span><br><span class="line"></span><br><span class="line">## MyISAM存储引擎</span><br><span class="line"></span><br><span class="line">数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件.MYD和索引文件.MYI。</span><br><span class="line"></span><br><span class="line">**优点**: 访问速度快。</span><br><span class="line"></span><br><span class="line">**缺点**：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。</span><br><span class="line"></span><br><span class="line">**适用场景**：对事务完整性没有要求；表的数据都会只读的。</span><br><span class="line"></span><br><span class="line">## InnoDB和MyISAM的区别</span><br><span class="line">1. myisam支持表锁，Innodb支持行锁，解决脏读和不可重复度</span><br><span class="line">2. myisam没有事务日志，innodb有binlog可以恢复数据库</span><br><span class="line">3. myisam数据存储是直接查到内存地址，innodb是有数据缓存，myisam更快一些</span><br><span class="line">4. 使用场景myisam适合读场景多，crud场景少的场景，比如博客这些；innodb适合事务支持，高并发等情况</span><br><span class="line">## 两者索引的区别【非聚簇索引myisam，看3.】</span><br><span class="line">1. myisam使用非聚簇索引，B树，innodb使用聚簇索引，B+树</span><br><span class="line">2. myisam的索引和数据存储是分开的，聚簇索引是将数据和索引存储在一起</span><br><span class="line">3. 将数据存储于索引分开结构，索引结构的叶子节点指向了数 据的对应行，myisam 通 过 key_buffer 把索引先缓存到内存中，当需要访问 数据时(通过索引访问数据)，在内存中直接 搜索索引，然后通过索引找 到磁盘相应数据，这也就是为什么索引不在 key buffer 命中时，速度慢 的 原因。</span><br><span class="line">## 【面试】为什么innodb用b+而不用b树</span><br><span class="line">b+树在范围查询和顺序访问上有优势：</span><br><span class="line">b+树叶子节点形成了一个有序链表，有利于范围查询和顺序访问，不需遍历整棵树</span><br><span class="line">## 【重点】为什么innodb比myisam慢了点</span><br><span class="line">- myisam是非聚簇，索引和数据是分开的，在查询时，可以直接访问到索引文件，而不需要额外的查找操作。</span><br><span class="line">- 而在 InnoDB 中，由于使用了聚簇索引，查询时可能需要在索引中定位到主键，再根据主键访问数据行</span><br><span class="line"># 事务Transaction</span><br><span class="line">## InnoDB 引擎通过什么技术来保证事务的这ACID特性的？</span><br><span class="line"></span><br><span class="line">- 持久性Durability是通过 redo log（重做日志）来保证的；</span><br><span class="line">- 原子性Atomicity 是通过 undo log（回滚日志）来保证的；</span><br><span class="line">- 隔离性Isolation是通过 MVCC（多版本并发控制） 或锁机制来保证的；</span><br><span class="line">- 一致性Consistency则是通过持久性+原子性+隔离性来保证；</span><br><span class="line"></span><br><span class="line">*MySQL 并不会使用「串行化」隔离级别来避免幻读现象的发生，因为使用「串行化」隔离级别会影响性能*</span><br><span class="line">https://xiaolincoding.com/mysql/transaction/phantom.html#什么是幻读</span><br><span class="line">## 可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View。</span><br><span class="line"></span><br><span class="line">## 【面试题】为什么事务要有隔离性，我们就要知道并发事务时会引发什么问题。</span><br><span class="line">数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</span><br><span class="line"></span><br><span class="line">## 多事务的并发进行一般会造成以下几个问题: </span><br><span class="line"></span><br><span class="line">锁：共享锁和排他锁（读写锁）</span><br><span class="line"></span><br><span class="line"># 【面试重点】锁</span><br><span class="line">锁分为全局锁，表锁，行锁，下面介绍各锁的使用和场景</span><br><span class="line">## 全局锁</span><br><span class="line">**应用场景**：全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</span><br><span class="line"></span><br><span class="line">**缺点**：意味着整个数据库都是只读状态，备份花时间长，无法执行其他操作。</span><br><span class="line">但是MYSQL解决了这个问题，通过**可重复度**，使用ReadView，事务操作时用ReadView，MVCC支持备份与事务同时进行。</span><br><span class="line"></span><br><span class="line">- 上锁1`flush tables with READ lock;`锁定所有的表，防止其他会话对这些表进行写操作，但允许读操作</span><br><span class="line">- 上锁2`lock tables [tablename] READ/WRITE`</span><br><span class="line">- `unlock tables;`</span><br><span class="line"></span><br><span class="line">## 表级锁</span><br><span class="line">### 表锁</span><br><span class="line">**应用场景**:表级别的共享锁=读锁,独占锁=写锁</span><br><span class="line">- 尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能</span><br><span class="line">- `lock tables [tablename] read/write;` </span><br><span class="line">### 元数据锁</span><br><span class="line">**应用场景**不需要显式使用，在CRUD/alter中自动创建，select执行完才可以执行其他操作，</span><br><span class="line">- MDL 是在事务提交后才会释放，这意味着事务执行期间，MDL 是一直持有的。</span><br><span class="line">  </span><br><span class="line">【引申问题】</span><br><span class="line">那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），</span><br><span class="line">首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</span><br><span class="line"></span><br><span class="line">然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</span><br><span class="line"></span><br><span class="line">接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</span><br><span class="line"></span><br><span class="line">那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</span><br><span class="line"></span><br><span class="line">**那么为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？**</span><br><span class="line"></span><br><span class="line">因为申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</span><br><span class="line"></span><br><span class="line">### 意向锁</span><br><span class="line">**用于快速判断表是否加了锁**。因为：</span><br><span class="line"></span><br><span class="line">如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</span><br><span class="line"></span><br><span class="line">### 自增锁</span><br><span class="line">```java</span><br><span class="line">@Id</span><br><span class="line">@GeneratedValue(strategy = GenerationType.IDENTITY) // 指定自动生成主键的策略</span><br><span class="line">@Column(name = &quot;id&quot;)</span><br><span class="line">private int id;</span><br></pre></td></tr></table></figure>

<p>在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。</p>
<p><strong>应用场景</strong></p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p><strong>记录锁 Record Lock</strong>，仅仅把一条记录锁上；</p>
<p><strong>间隙锁 Gap Lock</strong>，锁定一个范围，但是不包含记录本身；间隙锁的意义只在于阻止区间被插入</p>
<p><strong>临键锁 Next-Key Lock</strong>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
<ul>
<li>【普通的select没有行锁】普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。<h3 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁 Record Lock"></a>记录锁 Record Lock</h3>记录锁分为S锁和X锁。</li>
<li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
<li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。<h3 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁 Gap Lock"></a>间隙锁 Gap Lock</h3>只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</li>
<li>对间隙加锁是为了防止插入/删除的时候出现幻读</li>
<li>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。<h3 id="临键锁-Next-key-Lock"><a href="#临键锁-Next-key-Lock" class="headerlink" title="临键锁 Next-key Lock"></a>临键锁 Next-key Lock</h3>理解为一个范围的间隙锁</li>
</ul>
<h2 id="【面试题】MYSQL怎么加锁"><a href="#【面试题】MYSQL怎么加锁" class="headerlink" title="【面试题】MYSQL怎么加锁"></a>【面试题】MYSQL怎么加锁</h2><ol>
<li>【加行锁】在查询时对记录加行级锁，这两种查询会加锁的语句称为锁定读。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//对读取的记录加共享锁(S型锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"></span><br><span class="line">//对读取的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">//对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> .... <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">//对操作的记录加独占锁(X型锁)</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。</p>
<h3 id="普通查询，没有使用索引的话，会导致什么情况？"><a href="#普通查询，没有使用索引的话，会导致什么情况？" class="headerlink" title="普通查询，没有使用索引的话，会导致什么情况？"></a>普通查询，没有使用索引的话，会导致什么情况？</h3><p>没有使用索引字段作查询条件的话，导致扫描是全表扫描。那么，每一条记录的索引上都会加 临键（NK）锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.xiaolincoding.com//mysql/other/3c3af16e7a948833ccb6409e8b51daf8.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<ul>
<li>如果在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了。<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.xiaolincoding.com//mysql/other/1aa886fe95e7bc791c296e2d342fa435.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
这条 update 语句产生了 4 个记录锁（有几条记录就有几个Record锁）和 5 个间隙锁（范围+1），相当于锁住了全表。</li>
</ul>
<h3 id="那-update-语句的-where-带上索引就能避免全表记录加锁了吗？"><a href="#那-update-语句的-where-带上索引就能避免全表记录加锁了吗？" class="headerlink" title="那 update 语句的 where 带上索引就能避免全表记录加锁了吗？"></a>那 update 语句的 where 带上索引就能避免全表记录加锁了吗？</h3><p>关键还得看这条语句在执行过程种，优化器最终选择的是索引扫描，还是全表扫描，如果走了全表扫描，就会对全表的记录加锁了。</p>
<h3 id="update-没加索引，加的是表锁还是行锁"><a href="#update-没加索引，加的是表锁还是行锁" class="headerlink" title="update 没加索引，加的是表锁还是行锁"></a>update 没加索引，加的是表锁还是行锁</h3><p>对每一行都加了NK锁，就锁了整张表。</p>
<h3 id="避免全表锁定"><a href="#避免全表锁定" class="headerlink" title="避免全表锁定"></a>避免全表锁定</h3><p>将 MySQL 里的 <strong>sql_safe_updates 参数设置为 1</strong>，开启安全更新模式。</p>
<ul>
<li><p>update 语句必须满足如下条件之一才能执行成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">使用 where，并且 where 条件中必须有索引列；</span><br><span class="line">使用 limit；</span><br><span class="line">同时使用 where 和 limit，此时 where 条件中可以没有索引列；</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete 语句必须满足以下条件能执行成功：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">同时使用 where 和 limit，此时 where 条件中可以没有索引列；</span><br><span class="line"></span><br><span class="line">另外：如果 where 条件带上了索引列，但是优化器最终扫描选择的是全表，而不是索引的话，我们可以使用 FORCE INDEX([index_name]) 可以告诉优化器使用哪个索引，以此避免有几率锁全表带来的隐患。</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？【可以】"><a href="#MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？【可以】" class="headerlink" title="MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？【可以】"></a>MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？【可以】</h2><h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁的生成时机：</p>
<p>每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁），现象就是 Insert 语句会被阻塞。<br>#</p>

    

        <a href="/2023/01/03/面经MySQL/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-面经Redis"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-01-03 00:00:00" datetime="2023-01-02T16:00:00.000Z"  itemprop="datePublished">2023-01-03</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Redis/">Redis</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/01/03/面经Redis/">Redis</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/八股文/五种数据类型.png" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>

<table>
<thead>
<tr>
<th>String</th>
<th>List</th>
<th>Hash</th>
<th>Set</th>
<th>Zset</th>
</tr>
</thead>
<tbody><tr>
<td>SDS</td>
<td>LinkedList/ZipList/QuickList</td>
<td>Dict、ZipList</td>
<td>Dict、Intset</td>
<td>ZipList、SkipList</td>
</tr>
<tr>
<td># redis内存模型？</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>hashtable</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h1><ul>
<li>BitMap：签到、行为统计（点赞）</li>
<li>hyperloglog：不太了解</li>
<li>Geospatial：基于sort set，GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。<h2 id="【重点】一致性问题：Redis和数据库的一致性"><a href="#【重点】一致性问题：Redis和数据库的一致性" class="headerlink" title="【重点】一致性问题：Redis和数据库的一致性"></a>【重点】一致性问题：Redis和数据库的一致性</h2><a href="https://juejin.cn/post/7287026079066800168#heading-1" target="_blank" rel="noopener">https://juejin.cn/post/7287026079066800168#heading-1</a></li>
</ul>
<h1 id="三种缓存读写策略"><a href="#三种缓存读写策略" class="headerlink" title="三种缓存读写策略"></a>三种缓存读写策略</h1><h2 id="1-Cache-Aside-Pattern（旁路缓存模式）"><a href="#1-Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="1. Cache Aside Pattern（旁路缓存模式）"></a>1. <strong>Cache Aside Pattern（旁路缓存模式）</strong></h2><ul>
<li>写：先更新DB，再删除cache</li>
<li>读：先从cache读，读到就返回；读不到就读db，将数据写到cache<h3 id="【问题】可以先删cache，再更新db吗？"><a href="#【问题】可以先删cache，再更新db吗？" class="headerlink" title="【问题】可以先删cache，再更新db吗？"></a>【问题】可以先删cache，再更新db吗？</h3>不能，因为写的时间远大于读，出现数据不一致（和缓存击穿？）的可能性更高<h3 id="缺陷有哪些"><a href="#缺陷有哪些" class="headerlink" title="缺陷有哪些"></a>缺陷有哪些</h3><ol>
<li>数据不在cache，导致缓存击穿（大量数据访问db）</li>
<li>不适合写操作频繁的操作<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3>解决办法：</li>
</ol>
<ul>
<li>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小</li>
</ul>
</li>
</ul>
<h2 id="2-Read-Write-Through-Pattern（读写穿透）"><a href="#2-Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="2. Read/Write Through Pattern（读写穿透）"></a>2. <strong>Read/Write Through Pattern（读写穿透）</strong></h2><ul>
<li>写：先查cache，没有就直接更新db；有的话， 先更新cache，cache服务自己更新db</li>
<li>读：先从cache读，读到就返回；读不到就读db，写入到cache<h2 id="3-Write-Behind-Pattern（异步缓存写入）"><a href="#3-Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="3. Write Behind Pattern（异步缓存写入）"></a>3. <strong>Write Behind Pattern（异步缓存写入）</strong></h2></li>
<li>写：先查cache，没有直接更新db；有的话，只更新缓存，异步批量写db</li>
<li>读：先从cache读，读到就返回；读不到就读db，写入到cache<br><strong>与读写穿透的区别：</strong>：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1></li>
</ul>
<h2 id="Redis持久化的方式"><a href="#Redis持久化的方式" class="headerlink" title="Redis持久化的方式"></a>Redis持久化的方式</h2><p>Redis 共有三种数据持久化的方式：</p>
<ul>
<li>AOF（Append Only File）日志：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li>
<li>RDB（Redis Database Backup file） 快照：将某一时刻的内存数据，以二进制的方式写入磁盘；</li>
<li>混合持久化方式：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点<h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3>提供两个命令实现快照</li>
<li>save：在主线程实现，可能会导致阻塞</li>
<li>bgsave：background save，在后台的子进程生成RDB快照</li>
</ul>
<p><strong>RDB 在执行快照的时候，数据能修改吗？</strong></p>
<p>执行 bgsave 过程中，Redis 依然可以继续处理操作命令的，也就是数据是能被修改的，关键的技术就在于【写时复制技术】（Copy-On-Write, COW）。</p>
<p>技术原理：bgsave会通过 fork() 创建子进程，此时子进程和父进程是共享同一片内存数据的，因为创建子进程的时候，会复制父进程的页表，但是页表指向的物理内存还是一个，此时如果主线程执行读操作，则主线程和 bgsave 子进程互相不影响。</p>
<h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>在执行完一条写操作命令后，就会把该命令以追加的方式写入到一个文件里，然后 Redis 重启时，会读取该文件记录的命令，然后逐一执行命令的方式来进行数据恢复。<br><strong>它们的区别是什么</strong><br>AOF：三种写回方式</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/redisAOF.webp" alt title>
                </div>
                <div class="image-caption"></div>
            </figure>
<p>所以，RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p>
<p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p>
<p><strong>AOF 日志过大，会触发什么机制</strong></p>
<p>【AOF 重写机制】，压缩AOF文件：<br>【压缩方式】：在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。但是对KV的记录就保持最新的那一条</p>
<h1 id="redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】"><a href="#redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】" class="headerlink" title="redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】"></a>redis事务【不建议开发时使用，和mysql不一致的时候会造成缓存读写的限制问题】</h1><p><strong>不支持回滚</strong></p>
<ol>
<li>ULTI/EXEC 命令：<br>在 Redis 中，事务的开始由 MULTI 命令表示，结束由 EXEC 命令表示。在 MULTI 和 EXEC 之间的所有命令会被添加到事务队列中，但不会立即执行。</li>
<li>WATCH 命令：<br>Redis 提供了 WATCH 命令，可以用于在事务执行之前监视一个或多个键。如果在事务执行过程中，被监视的键被其他客户端修改了，事务将会被打断。</li>
</ol>
<h1 id="数据类型实现"><a href="#数据类型实现" class="headerlink" title="数据类型实现"></a>数据类型实现</h1><h3 id="String-字符串-应用场景-缓存对象、常规计数、分布式锁、共享-session-信息等。"><a href="#String-字符串-应用场景-缓存对象、常规计数、分布式锁、共享-session-信息等。" class="headerlink" title="String(字符串) 应用场景:缓存对象、常规计数、分布式锁、共享 session 信息等。"></a>String(字符串) 应用场景:缓存对象、常规计数、分布式锁、共享 session 信息等。</h3><ul>
<li><strong>底层数据结构是SDS（Simple Dynamic String）简单动态字符串</strong>，保存文本数据，还可以保存二进制数据 。因为 SDS 使用 len 属性 的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li>
<li>Redis 的 SDS API 是安全的，<strong>拼接字符串不会造成缓冲区溢出</strong> ：因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果<strong>空间不够会自动扩容</strong>，所以不会导致缓冲区溢出的问题。</li>
</ul>
<p><strong>使用 String 来缓存对象有两种方式</strong>：</p>
<p>直接缓存整个对象的 JSON，命令例子： <figure class="highlight plain"><figcaption><span>user:1 '&#123;"name":"xiaolin", "age":18&#125;'```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20**</span><br><span class="line">### List(列表)</span><br><span class="line">- **数据结构**：quicklist（双向链表+压缩列表）</span><br><span class="line">- **类型的应用场景**:消息队列(但是有两个问题:1. 生产者需要自行实现全局唯一ID;2. 不能以消费组形式消费数据)等</span><br><span class="line"></span><br><span class="line">**List 可以使用 LPUSH + RPOP （或者反过来，RPUSH+LPOP）命令实现消息队列。**</span><br><span class="line"></span><br><span class="line">- 生产者使用 LPUSH key value[value...] 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</span><br><span class="line">  </span><br><span class="line">- 消费者使用 RPOP key 依次读取队列的消息，先进先出。</span><br><span class="line"></span><br><span class="line">### Set(集合) 类型:聚合计算(并集、交集、差集)场景，比如点赞、共同关注、抽奖活动等。</span><br><span class="line">- **数据结构**：是由哈希表或整数集合实现的</span><br><span class="line">- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用整数集合作为 Set 类型的底层数据结构；</span><br><span class="line">- 如果集合中的元素不满足上面条件，则 Redis 使用哈希表作为 Set 类型的底层数据结构。</span><br><span class="line">### Zset(有序集合) 类型:排序场景，比如排行榜、电话和姓名排序等</span><br><span class="line">- **数据结构** ：7.0以后，使用 **listpack** 数据结构</span><br><span class="line">### Hash(哈希) 类型:缓存对象、购物车等。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### BitMap(2.2 版新增):二值状态统计的场景，比如签到、判断用户登陆状态、 连续签到用户总数等;</span><br><span class="line">### HyperLogLog(2.8 版新增):海量数据基数统计的场景，比如百万级网页 UV 计数等;</span><br><span class="line">### GEO</span><br><span class="line">### Stream</span><br><span class="line"># Redis 的线程模型</span><br><span class="line"></span><br><span class="line">**首先**，是单线程模型，它指的是```「接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端」```这个过程是由一个线程（主线程）来完成的，这也是我们常说 Redis 是单线程的原因。</span><br><span class="line"></span><br><span class="line">但是，Redis 程序并不是单线程的，Redis 在启动的时候，是会启动后台线程（BIO）</span><br><span class="line"></span><br><span class="line">### Redis 6.0 之后为什么引入了多线程？</span><br><span class="line">回答：网络IO出现瓶颈，对网络IO引入了多线程处理，命令执行仍然是主线程完成。</span><br><span class="line"></span><br><span class="line">虽然 Redis 的主要工作（网络 I/O 和执行命令）一直是单线程模型，但是在 Redis 6.0 版本之后，也采用了多个 I/O 线程来处理网络请求，这是因为```随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在网络 I/O 的处理上```。</span><br><span class="line"></span><br><span class="line">所以为了提高网络 I/O 的并行度，Redis 6.0 **对于网络 I/O 采用多线程来处理**。但是对于命令的执行，Redis 仍然使用单线程来处理，所以大家不要误解 Redis 有多线程同时执行命令。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Redis的零拷贝技术是什么</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Redis集群</span><br><span class="line"></span><br><span class="line"> 主从复制，主节点故障时要手动恢复</span><br><span class="line">### 主从模式</span><br><span class="line">读写分离，主节点负责写，从节点负责读。</span><br><span class="line">### 哨兵模式</span><br><span class="line">多个哨兵监控主节点服务器，提供故障转移功能：</span><br><span class="line">【故障转移】：主节点挂了之后，在从节点中选取一个作为主节点</span><br><span class="line"></span><br><span class="line">### 切片集群模式</span><br><span class="line">缓存数据量大到一台服务器无法缓存时，就需要使用 Redis 切片集群。</span><br><span class="line">将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。</span><br><span class="line">- 切片就是一个redis实例分成多个hash slot，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。</span><br><span class="line">- 默认部署的slot个数有16384个，平均分配到各节点上，如果有n个redis实例，那么每个节点有16384/n个slot。</span><br><span class="line"></span><br><span class="line">### 可能出现的问题：</span><br><span class="line">**集群脑裂是什么**：</span><br><span class="line"></span><br><span class="line">由于网络问题，导致主节点与哨兵失联后，哨兵多选举出来一个主节点，当旧节点恢复正常时，降级从节点后，向新master请求同步复制时，清空了自己的缓冲区，产生了之前客户端写入的数据丢失的问题。</span><br><span class="line"></span><br><span class="line">- 如果旧节点又好了，就把旧主节点降级为普通节点，作为从节点向新master进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</span><br><span class="line"></span><br><span class="line">【解决方案】</span><br><span class="line">当主节点发现从节点下线或者通信超时的总数量小于阈值时，那么禁止主节点进行写数据，直接把错误返回给客户端。</span><br><span class="line"></span><br><span class="line">【配置文件】</span><br><span class="line">- min-slaves-to-write x，主节点必须要有至少 x 个从节点连接，如果小于这个数，主节点会禁止写数据。</span><br><span class="line">- min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒，如果超过，主节点会禁止写数据。</span><br><span class="line">### Redis过期删除与内存淘汰</span><br><span class="line"></span><br><span class="line">【过期删除：惰性删除+定期删除】当我们对一个 key 设置了过期时间时，Redis 会把该 key 带上过期时间存储到一个过期字典（expires dict）中，也就是说「过期字典」保存了数据库中所有 key 的过期时间。</span><br><span class="line"></span><br><span class="line">- 惰性删除：惰性删除策略的做法是，不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。</span><br><span class="line">- 每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。</span><br><span class="line">【内存淘汰：不进行数据淘汰的策略/进行数据淘汰的策略】</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 集群与哨兵模式的区别</span><br><span class="line">- 主从集群模式适合对读写性能要求高，且可以容忍一定程度的数据同步延迟的场景</span><br><span class="line">- 哨兵模式适用于对高可用性要求较高的场景，能够实现自动故障切换</span><br><span class="line">## Redis的lua支持</span><br><span class="line">如果你想在 Redis 中定时执行 Lua 脚本，可以考虑使用 Redis 的定时任务功能，例如使用 Redis 的BGSAVE和MONITOR命令配合实现。</span><br><span class="line"></span><br><span class="line">1. 编写 Lua 脚本</span><br><span class="line">首先，你需要编写一个 Lua 脚本，命名为 a.lua 或其他你喜欢的名字。在该脚本中编写你想要定时执行的逻辑。</span><br><span class="line">2. 使用 BGSAVE</span><br><span class="line">Redis 的 BGSAVE 命令用于在后台执行持久化操作（将数据写入磁盘），这会创建一个快照文件。你可以利用这个特性来触发 Lua 脚本的执行。</span><br><span class="line">客户端执行```BGSAVE</span><br></pre></td></tr></table></figure></p>
<p>请注意，BGSAVE 不会阻塞 Redis 的主线程，因此可以在 Redis 运行时执行。</p>
<ol start="3">
<li>使用 MONITOR<br>Redis 的 MONITOR 命令可以用于实时监控 Redis 的命令执行情况。你可以通过监控 Redis 的命令来捕捉 BGSAVE 命令的执行，一旦发现 BGSAVE 命令执行完毕，就可以在 Lua 脚本中调用 EVAL 来执行你的逻辑。</li>
</ol>
<h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><h2 id="介绍缓存雪崩，缓存击穿，缓存穿透"><a href="#介绍缓存雪崩，缓存击穿，缓存穿透" class="headerlink" title="介绍缓存雪崩，缓存击穿，缓存穿透"></a>介绍缓存雪崩，缓存击穿，缓存穿透</h2><ul>
<li><strong>缓存雪崩</strong> 指大量缓存数据在同一时间过期时，大量的用户请求全部直接访问数据库，从而导致数据库崩溃的问题，从而形成一系列连锁反应，造成整个系统崩溃。</li>
<li><strong>缓存击穿</strong> 指某个数据过期时，大量用户请求直接访问该数据，导致高并发的数据库请求</li>
<li><strong>缓存穿透</strong> 当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，没办法构建缓存数据，来服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是缓存穿透的问题。</li>
</ul>
<p>【缓存雪崩解决方法】</p>
<ol>
<li>设置缓存失效时间随机打乱</li>
<li>设置缓存不过期，使用后台接口进行操作redis</li>
</ol>
<p>【缓存击穿解决方法】</p>
<ol>
<li>互斥锁方案（Redis 中使用 setNX 方法设置一个状态位，表示这是一种锁定状态），保证同一时间只有一个业务线程请求缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。</li>
<li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间；</li>
</ol>
<p>【缓存穿透解决方法】</p>
<ol>
<li><p><strong>布隆过滤器</strong>：快速判断数据是否存在，避免通过查询数据库来判断数据是否存在：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，业务线程确认缓存失效后，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询数据库来判断数据是否存在，即使发生了缓存穿透，大量请求只会查询 Redis 和布隆过滤器，而不会查询数据库，保证了数据库能正常运行，Redis 自身也是支持布隆过滤器的。</p>
</li>
<li><p>设置空值或者默认值</p>
</li>
<li><p>在API入口处判断请求参数有没有非法值/是否存在</p>
</li>
</ol>
<h2 id="热点数据缓存策略"><a href="#热点数据缓存策略" class="headerlink" title="热点数据缓存策略"></a>热点数据缓存策略</h2><p>热点数据动态缓存的策略总体思路：通过数据最新访问时间来做排名，并过滤掉不常访问的数据，只留下经常访问的数据。</p>
<h2 id="【面试题】缓存更新策略"><a href="#【面试题】缓存更新策略" class="headerlink" title="【面试题】缓存更新策略"></a>【面试题】缓存更新策略</h2><ul>
<li>Cache Aside（旁路缓存）策略；</li>
<li>Read/Write Through（读穿 / 写穿）策略；</li>
<li>Write Back（写回）策略；</li>
</ul>
<h2 id="【面试题】数据库和缓存如何保证一致性"><a href="#【面试题】数据库和缓存如何保证一致性" class="headerlink" title="【面试题】数据库和缓存如何保证一致性"></a>【面试题】数据库和缓存如何保证一致性</h2><h2 id="【面试题】常见性能问题和解决方案"><a href="#【面试题】常见性能问题和解决方案" class="headerlink" title="【面试题】常见性能问题和解决方案"></a>【面试题】常见性能问题和解决方案</h2><ol>
<li>Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大 的，会间断性暂停服务</li>
<li>如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次</li>
<li>为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局 域网</li>
<li>尽量避免在压力很大的主库上增加从</li>
<li>主从复制不要用图状结构，用单向链表结构更为稳定，即:Master &lt;- Slave1&lt;- Slave2 &lt;- Slave3… 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了，可以立刻启 用 Slave1 做 Master，其他不变。</li>
</ol>
<h2 id="过期key的删除策略"><a href="#过期key的删除策略" class="headerlink" title="过期key的删除策略"></a>过期key的删除策略</h2><ul>
<li>定时删除单key：一个是添加的key的时候， expire指定时间</li>
<li>惰性删除：每次查找key时，都会判断是否过期</li>
<li>定期批量删除：每隔一段时间扫库，删除过期key<h2 id="Redis回收-淘汰策略"><a href="#Redis回收-淘汰策略" class="headerlink" title="Redis回收/淘汰策略"></a>Redis回收/淘汰策略</h2></li>
</ul>
<ol>
<li>volatile-lru:从已设置过期时间的数据集(server.db[i].expires)中挑选 最近最少使用的数据淘汰</li>
<li>volatile-ttl:从已设置过期时间的数据集(server.db[i].expires)中挑选 将要过期的数据淘汰</li>
<li>volatile-random:从已设置过期时间的数据集(server.db[i].expires)中任 意选择数据淘汰</li>
<li>allkeys-lru:从数据集(server.db[i].dict)中挑选最近最少使用的数据淘 汰</li>
<li>allkeys-random:从数据集(server.db[i].dict)中任意选择数据淘汰</li>
<li>no-enviction(驱逐):禁止驱逐数据 注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置 过期时间的数 据集淘汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是 三种不同 的淘汰策略，再加上一种no-enviction 永不回收的策略。<h2 id="如何选取上述策略？"><a href="#如何选取上述策略？" class="headerlink" title="如何选取上述策略？"></a>如何选取上述策略？</h2></li>
<li>如果数据分布的差不多，使用allkeys random</li>
<li>如果数据分布差别大，使用allkeys lru<h2 id="redis的同步机制是什么【全量复制和部分复制】"><a href="#redis的同步机制是什么【全量复制和部分复制】" class="headerlink" title="redis的同步机制是什么【全量复制和部分复制】"></a>redis的同步机制是什么【全量复制和部分复制】</h2></li>
</ol>
<ul>
<li>salve 发送sync请求到master，开始第一次同步</li>
<li>第一次同步时使用bgsave做rdb快照，同时将后续修改记录加到内存缓冲区，完成后将rdb文件同步到从节点，复制完后由从节点加载到内存</li>
<li>加载完成后通知master，master将缓冲区的写操作记录发给slave，slave再执行剩余的这些写操作，与master保持一致<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3></li>
<li>slave发送psync请求到master，开始第一次同步</li>
<li>slave再发一个偏移量，master从这个偏移量开始同步数据<h2 id="redis集群的原理"><a href="#redis集群的原理" class="headerlink" title="redis集群的原理"></a>redis集群的原理</h2></li>
</ul>
<ol>
<li><p>哨兵模式，高可用性，在master宕机时自动将slave提升为master</p>
</li>
<li><p>集群模式，扩展性，单个redis内存不足时，使用cluster进行分片存储</p>
<ul>
<li>集群没用一致性hash，而是用了hash槽，有16384个hash槽，每个节点负责一部分槽</li>
<li>主从复制模型，每个节点都是其他节点的副本<h2 id="集群会有写操作丢失吗【会】为什么？"><a href="#集群会有写操作丢失吗【会】为什么？" class="headerlink" title="集群会有写操作丢失吗【会】为什么？"></a>集群会有写操作丢失吗【会】为什么？</h2></li>
</ul>
</li>
<li><p>当发生故障转移（failover）时，在连接丢失的情况下，部分写操作无法完成</p>
</li>
<li><p>另外如果用了RDB，主节点写操作存在buffer里，转移主节点时，这部分不进行复制，导致写操作丢失，所以可以使用混合方式，写操作使用AOF持久化一下，转移主节点后重放AOF日志</p>
<h2 id="redis事务了解吗"><a href="#redis事务了解吗" class="headerlink" title="redis事务了解吗"></a>redis事务了解吗</h2><p>multi exec discard watch</p>
<h2 id="如何优化redis内存占用和性能【内存优化】"><a href="#如何优化redis内存占用和性能【内存优化】" class="headerlink" title="如何优化redis内存占用和性能【内存优化】"></a>如何优化redis内存占用和性能【内存优化】</h2></li>
<li><p>对小数据合并到一个对象中，用hash存储</p>
</li>
<li><p>设置合理的过期策略，和内存淘汰策略等</p>
</li>
<li><p>使用持久化保证高可用性</p>
</li>
<li><p>使用布隆过滤器，防止缓存穿透和击穿问题，查看一个元素是否存在于一个集合中</p>
</li>
<li><p>删除key后的碎片整理：Redis 会在删除键值对后，释放内存并且尝试整理内存碎片。可以通过配置文件中的 activerehashing 参数来控制内存碎片整理的行为。</p>
<h2 id="假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某-个固定的已知的前缀开头的，如果将它们全部找出来"><a href="#假如-Redis-里面有-1-亿个-key，其中有-10w-个-key-是以某-个固定的已知的前缀开头的，如果将它们全部找出来" class="headerlink" title="假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某 个固定的已知的前缀开头的，如果将它们全部找出来?"></a>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某 个固定的已知的前缀开头的，如果将它们全部找出来?</h2></li>
</ol>
<ul>
<li>使用scan无阻塞地去提取正则字符串，然后在客户端用一个set去重</li>
<li>keys也可以扫，但是会导致阻塞，线上服务会停<h2 id="redis队列和延时队列"><a href="#redis队列和延时队列" class="headerlink" title="redis队列和延时队列"></a>redis队列和延时队列</h2></li>
<li>队列使用list，当队列为空，rpush生产消息，使用blpop消费消息。</li>
<li>延时队列使用zset，每个消息对应的时间戳作为score，消息内容当key，<strong>zadd生产消息</strong>，消费者用 <strong>zrangebyscore 指令获取 N 秒之前的数据轮询进行处理</strong></li>
</ul>
<h2 id="redis内存回收进程"><a href="#redis内存回收进程" class="headerlink" title="redis内存回收进程"></a>redis内存回收进程</h2><p><a href="https://cloud.tencent.com/developer/article/2315748" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/2315748</a><br>Redis回收进程指对那些已过期但是尚未被删除的 keys 进行标记，这样它们就可以在之后被立即释放并回收所占用的内存</p>
<ol>
<li>基本原理是周期性地扫描存储数据库中所有的键<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Redis 提供了三个与内存回收相关的命令：</span><br><span class="line"></span><br><span class="line">MEMORY USAGE key：</span><br><span class="line">用于返回指定键所占用的内存字节数。可以通过传递键的名称作为参数来获取相应键的内存使用情况。</span><br><span class="line">MEMORY PURGE：</span><br><span class="line">该命令用于在 Redis Enterprise 中手动触发内存回收。</span><br><span class="line">MEMORY DOCTOR：</span><br><span class="line">该命令用于诊断 Redis 内存分配和使用情况，帮助识别内存泄漏或者不正常的内存使用情况。</span><br><span class="line">需要注意的是，MEMORY PURGE 和 MEMORY DOCTOR 是 Redis Enterprise 特有的命令，而 MEMORY USAGE 是 Redis 通用的命令。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="如何使用redis实现一个分布式锁"><a href="#如何使用redis实现一个分布式锁" class="headerlink" title="如何使用redis实现一个分布式锁"></a>如何使用redis实现一个分布式锁</h2><ul>
<li>setnx拿锁，拿到之后expire给锁加一个过期时间，</li>
</ul>
<h2 id="Redis内存耗尽会怎样"><a href="#Redis内存耗尽会怎样" class="headerlink" title="Redis内存耗尽会怎样"></a>Redis内存耗尽会怎样</h2><p>崩溃，可能导致缓存失效，命中率下降，虚拟内存<br><a href="https://juejin.cn/post/6932711444404256781" target="_blank" rel="noopener">https://juejin.cn/post/6932711444404256781</a></p>
<ol>
<li>会使用LRU和LFU的内存淘汰策略<h2 id="LRU-最近最长时间未被使用"><a href="#LRU-最近最长时间未被使用" class="headerlink" title="LRU 最近最长时间未被使用"></a>LRU 最近最长时间未被使用</h2><h2 id="LFU-最近最少频率使用"><a href="#LFU-最近最少频率使用" class="headerlink" title="LFU 最近最少频率使用"></a>LFU 最近最少频率使用</h2></li>
</ol>
<h2 id="stream数据结构"><a href="#stream数据结构" class="headerlink" title="stream数据结构"></a>stream数据结构</h2><ol>
<li>基于基数树</li>
</ol>
<h2 id="缓存穿透miss-和击穿breakdown-怎么解决"><a href="#缓存穿透miss-和击穿breakdown-怎么解决" class="headerlink" title="缓存穿透miss 和击穿breakdown 怎么解决"></a>缓存穿透miss 和击穿breakdown 怎么解决</h2><ul>
<li>击穿是breakdown，要查找的热点缓存突然过期，导致大量请求向mysql涌入，导致崩溃等问题</li>
<li>穿透是缓存中没有这些key，没有方法满足这些请求<h2 id="穿透的解决方式"><a href="#穿透的解决方式" class="headerlink" title="穿透的解决方式"></a>穿透的解决方式</h2></li>
</ul>
<ol>
<li>在缓存之前再加一层布隆过滤器，在查询的时候先去布隆过滤器查询 key 是否存在，如果不存在就直接返回</li>
<li>简单处理，存无效key，value设为null</li>
</ol>
<h2 id="如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题"><a href="#如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题" class="headerlink" title="如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题"></a>如果有大量的key需要同一时间过期，要如何解决缓存雪崩问题</h2><ul>
<li>设置过期时间时加上随机值，使得缓存失效的时间点尽量均匀分布。</li>
<li>使用 Redis 集群，将缓存数据分散到多个节点上，避免单点故障。</li>
<li>在缓存失效后采用加锁或者队列来控制<strong>读数据库写缓存</strong>的线程数量，避免大量线程同时读数据库。</li>
<li>针对热点数据可以设置永不过期，或者使用手动过期的方式来控制缓存的使用时间</li>
<li>高并发时，使用限流和熔断机制控制请求访问量</li>
<li>本地和分布式缓存结合，服务器本地当二级缓存</li>
</ul>
<h2 id="热key问题怎么解决"><a href="#热key问题怎么解决" class="headerlink" title="热key问题怎么解决"></a>热key问题怎么解决</h2><p>热key问题是由于某部分热点key分布在不同的节点上，导致负载不均衡</p>
<ul>
<li>解决方法，1使用分布式缓存，读写分离架构 2 数据分片策略 3 缓存失效策略避免一直是热key</li>
<li>如果热Key的产生<strong>来自于读请求</strong>使用读写分离架构<br>您可以将实例改造成读写分离架构来降低每个数据分片的读请求压力，甚至可以不断地增加从节点。但是读写分离架构在增加业务代码复杂度的同时，也会增加Redis集群架构复杂度。不仅要为多个从节点提供转发层（如Proxy，LVS等）来实现负载均衡，还要考虑从节点数量显著增加后带来故障率增加的问题。<h2 id="单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】"><a href="#单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】" class="headerlink" title="单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】"></a>单例的redis能承载多少个连接？【默认1w个，可以用maxclients修改】</h2></li>
</ul>
<h2 id="redis-6-0-前后不支持与支持多线程的理由"><a href="#redis-6-0-前后不支持与支持多线程的理由" class="headerlink" title="redis 6.0 前后不支持与支持多线程的理由"></a>redis 6.0 前后不支持与支持多线程的理由</h2><ol>
<li>6.0前，避免竞态条件，上下文切换的开销，充分利用CPU</li>
<li>6.0后的多线程主要引入的是IO和AOF和RDB备份</li>
</ol>
<h2 id="提高命中率的方式"><a href="#提高命中率的方式" class="headerlink" title="提高命中率的方式"></a>提高命中率的方式</h2><ol>
<li>缓存过期时间</li>
<li>缓存预热</li>
<li>LRU LFU分别基于访问时间和频率来确定缓存中的数据</li>
<li>使用分布式缓存，将缓存数据分布到多节点上<!-- 5. 使用分布式锁，布隆过滤器等手段去提高可用性，提供维护时间长 -->


</li>
</ol>
<h2 id="redis-如何解决key冲突"><a href="#redis-如何解决key冲突" class="headerlink" title="redis 如何解决key冲突"></a>redis 如何解决key冲突</h2><ol>
<li><p>命名时注意不冲突，比如加前缀后缀</p>
</li>
<li><p>不同数据存合适的数据结构</p>
</li>
<li><p>分布式锁来保证并发冲突</p>
</li>
<li><p>单线程下使用mutex方法<br>内存模型是hashtable，解决key冲突可能就链地址 开地址哪些吧</p>
</li>
</ol>
<h2 id="redis-如何解决大key问题【key的value过大】"><a href="#redis-如何解决大key问题【key的value过大】" class="headerlink" title="redis 如何解决大key问题【key的value过大】"></a>redis 如何解决大key问题【key的value过大】</h2><p><a href="https://help.aliyun.com/zh/redis/user-guide/identify-and-handle-large-keys-and-hotkeys" target="_blank" rel="noopener">bigkey solution</a></p>
<h3 id="大key产生的问题"><a href="#大key产生的问题" class="headerlink" title="大key产生的问题"></a>大key产生的问题</h3><ol>
<li>执行变慢，删除时产生阻塞，内存溢出</li>
</ol>
<h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a>处理方式</h3><ol>
<li>如果已经发现了一个大key，就遍历把它插成大key1 key2 key3，限制长度</li>
<li>不要这个大key时，使用UNLINK删除</li>
<li><strong>使用redis分片技术</strong>：</li>
</ol>
<ul>
<li><p>一致性hash:<br>将哈希值映射到一个固定大小的环形空间中。客户端根据键的哈希值定位到环上的某个位置，然后找到离该位置最近的节点，将数据存储在该节点上。</p>
<ul>
<li><strong>优点</strong>：在节点的增减时，只有少量的数据需要重新映射，保持了相对的稳定性。</li>
<li><strong>缺点</strong>：可能会出现不均匀的数据分布，导致节点负载不均</li>
</ul>
</li>
<li><p>CRC16:<br>循环冗余校验来生成哈希值</p>
<ul>
<li><strong>优点</strong>：计算速度快，适用于一些简单的分布式场景。</li>
<li><strong>缺点</strong>：可能会导致节点负载不均衡。</li>
</ul>
</li>
<li><p>RedisCluster<br>它将数据分片到多个节点上，同时提供了节点间的数据复制和故障恢复机制</p>
<ul>
<li><strong>优点</strong>自动进行数据分片和复制，实现了高可用性。</li>
<li><strong>缺点</strong>好用但是复杂 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Key本身的数据量过大：一个String类型的Key，它的值为5 MB。</span><br><span class="line">Key中的成员数过多：一个ZSET类型的Key，它的成员数量为10,000个。</span><br><span class="line">Key中成员的数据量过大：一个Hash类型的Key，它的成员数量虽然只有1,000个但这些成员的Value（值）总大小为100 MB。</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="redis慢查询如何排查"><a href="#redis慢查询如何排查" class="headerlink" title="redis慢查询如何排查"></a>redis慢查询如何排查</h2><p>命令：</p>
<ol>
<li>慢查询日志：SHOWLOG GET</li>
<li>redis-cli的INFO</li>
<li>redis有一个时延监控命令，–latency查询命令</li>
</ol>

    

        <a href="/2023/01/03/面经Redis/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </div>
    
</article>

        </li>
    
        <li class="post-list-item fade">
            <article id="post-面经Redis问题"
  class="article-card article-type-post" itemprop="blogPost">

    <div class="post-meta">
        <time class="post-time" title="2023-01-03 00:00:00" datetime="2023-01-02T16:00:00.000Z"  itemprop="datePublished">2023-01-03</time>

        
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Redis/">Redis</a></li></ul>



    </div>

    


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2023/01/03/面经Redis问题/">Redis questions</a>
    </h3>
  




    <div class="post-content" id="post-content" itemprop="postContent">

    
        <h2 id="1-memcached和redis区别有哪些，优势劣势？"><a href="#1-memcached和redis区别有哪些，优势劣势？" class="headerlink" title="1.memcached和redis区别有哪些，优势劣势？"></a>1.memcached和redis区别有哪些，优势劣势？</h2><p>redis支持多种数据类型，并且支持持久化策略，</p>
<h2 id="2-实现本地缓存，有哪些方案？go本地，redis"><a href="#2-实现本地缓存，有哪些方案？go本地，redis" class="headerlink" title="2.实现本地缓存，有哪些方案？go本地，redis"></a>2.实现本地缓存，有哪些方案？go本地，redis</h2><h2 id="3-redis通讯协议？特点是什么"><a href="#3-redis通讯协议？特点是什么" class="headerlink" title="3.redis通讯协议？特点是什么"></a>3.redis通讯协议？特点是什么</h2><h2 id="4-字符串最大长度是多少？512MB"><a href="#4-字符串最大长度是多少？512MB" class="headerlink" title="4.字符串最大长度是多少？512MB"></a>4.字符串最大长度是多少？512MB</h2><h2 id="5-介绍一下zset及底层实现机制"><a href="#5-介绍一下zset及底层实现机制" class="headerlink" title="5.介绍一下zset及底层实现机制"></a>5.介绍一下zset及底层实现机制</h2><h2 id="6-redis事务？原理是什么"><a href="#6-redis事务？原理是什么" class="headerlink" title="6.redis事务？原理是什么"></a>6.redis事务？原理是什么</h2><h2 id="7-事务相关命令？支持回滚吗"><a href="#7-事务相关命令？支持回滚吗" class="headerlink" title="7.事务相关命令？支持回滚吗"></a>7.事务相关命令？支持回滚吗</h2><h2 id="8-介绍一下pipeline和使用场景：批量读取写入"><a href="#8-介绍一下pipeline和使用场景：批量读取写入" class="headerlink" title="8.介绍一下pipeline和使用场景：批量读取写入"></a>8.介绍一下pipeline和使用场景：批量读取写入</h2><p>批量执行Redis命令的机制，它可以在客户端发送多个命令后，一次性将它们发送到服务器，然后一次性接收服务器的响应</p>
<h3 id="和批量命令有什么不同"><a href="#和批量命令有什么不同" class="headerlink" title="和批量命令有什么不同"></a>和批量命令有什么不同</h3><ol>
<li>pipeline是同时发送/执行不同命令的机制，批量是都需要执行相似的</li>
<li>pipeline是顺序执行所有命令，执行一个一个状态，而批量需要等待所有的返回<h2 id="9-设置生存时间和过期时间用什么命令"><a href="#9-设置生存时间和过期时间用什么命令" class="headerlink" title="9.设置生存时间和过期时间用什么命令"></a>9.设置生存时间和过期时间用什么命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE key n_seconds</span><br><span class="line">PEXPIRE mykey n_milseconds</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="10-介绍下redis的发布订阅功能"><a href="#10-介绍下redis的发布订阅功能" class="headerlink" title="10.介绍下redis的发布订阅功能"></a>10.介绍下redis的发布订阅功能</h2><ul>
<li>允许多个客户端之间通过消息中间件来发送和接收消息。在这种模式下，消息的发送者称为发布者（Publisher），而消息的接收者称为订阅者（Subscriber）</li>
<li>Redis的发布订阅功能是异步的，消息的发送和接收是非阻塞的，因此在订阅者接收消息时需要特别注意处理并发和同步的问题。<h2 id="11-redis单线程为什么那么快"><a href="#11-redis单线程为什么那么快" class="headerlink" title="11.redis单线程为什么那么快"></a>11.redis单线程为什么那么快</h2>单线程没有锁，主线程异步处理IO，避免多线程上下文切换<h2 id="12-分布式缓存要注意哪些问题"><a href="#12-分布式缓存要注意哪些问题" class="headerlink" title="12. 分布式缓存要注意哪些问题"></a>12. 分布式缓存要注意哪些问题</h2></li>
</ul>
<ol>
<li>缓存一致性 </li>
<li>缓存击穿 </li>
<li>缓存雪崩</li>
</ol>
<h2 id="13-redis的key删除策略"><a href="#13-redis的key删除策略" class="headerlink" title="13. redis的key删除策略"></a>13. redis的key删除策略</h2><ol>
<li>定期删除，每 100 毫秒检查 20 个随机选择的过期 key，如果发现有过期的 key，就会将其删除。</li>
<li>惰性删除，<br>设置过期时间+一个随机的时间，防止缓存雪崩</li>
</ol>

    

        <a href="/2023/01/03/面经Redis问题/" class="post-more waves-effect waves-button">
            Continue reading...
        </a>
    </div>
    
    <div class="post-footer">
        
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </div>
    
</article>

        </li>
    
    </ul>

    
<nav id="page-nav">
    <div class="inner">
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
    </div>
</nav>


</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>waynamigo &copy; 2018 - 2023</span>
            <span>
                
                <a href="http://www.miitbeian.gov.cn/" target="_blank">鲁ICP备18055379号</a><br>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://waynamigo.github.io/page/2/&title=waynamigo's blog&pic=http://waynamigo.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://waynamigo.github.io/page/2/&title=waynamigo's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://waynamigo.github.io/page/2/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=waynamigo's blog&url=http://waynamigo.github.io/page/2/&via=http://waynamigo.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://waynamigo.github.io/page/2/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAACuCAAAAACKZ2kyAAAB1UlEQVR42u3auY7CQBAFQP7/p1lpIxKG14cNQU1kWZZdELT6ejzi8/w/r9evd8733z1zfnJ0cHFxx9zn8byjvLs+3zm/4WzAxcW9n5sEr/z5PBaV34mLi/tj3CTYnUELfwEuLu7Pc3sB62uBDBcXt8jNg9QkcUmKq7VaDRcXd8DtNUx3ry/v7+Li4i5NJaqh7ZymzA8uLu493KTIScao5zvV8cyHYIeLi3sjN0cnzYte4Iu+i4uL+yVu3vjojU5zXBTIcHFxV7n5Mlby4Tzd6ZVGuLi493CTtYlq07NX5BRGubi4uBdz8zFnL1mZFD9RvMTFxb2A2ytCJkVOdQQbbYvg4uKucvNUo9fi7A1LoloNFxf3Mu5koarXYK02UKJaDRcXd5VbbXBUVy17xc/odbi4uGNub0SaD12qK1kLOyO4uLhjbtIenVzn4Slp3eLi4t7DzU9vUFotlvL0CBcX9zrus3iqI9J55lVIcXBxcZe4V0fB3oLXKLnBxcVd4uYl0O7eR3VAi4uLez+32qrIE5FqBI06u7i4uD/GnYxe8p+6FshwcXEv5vZapb3WyUIgw8XFHXPz4idvfFRbKstLGLi4uANur/WZFzblxsdgNIuLizvm/gHRVHadIzxNDQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>






<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = 'mole';
            clearTimeout(titleTime);
        } else {
            document.title = 'mole';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
